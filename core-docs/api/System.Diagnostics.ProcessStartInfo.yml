items:
- uid: System.Diagnostics.ProcessStartInfo
  commentId: T:System.Diagnostics.ProcessStartInfo
  id: ProcessStartInfo
  parent: System.Diagnostics
  children:
  - System.Diagnostics.ProcessStartInfo.#ctor
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  - System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  - System.Diagnostics.ProcessStartInfo.Arguments
  - System.Diagnostics.ProcessStartInfo.CreateNoWindow
  - System.Diagnostics.ProcessStartInfo.Environment
  - System.Diagnostics.ProcessStartInfo.FileName
  - System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  - System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  - System.Diagnostics.ProcessStartInfo.UseShellExecute
  - System.Diagnostics.ProcessStartInfo.WorkingDirectory
  langs:
  - csharp
  - vb
  name: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
  type: Class
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ProcessStartInfo
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 16
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Specifies a set of values that are used when you start a process.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> is used together with the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. When you start a process using the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> class, you have access to process information in addition to that available when attaching to a running process.</p>\n<p>You can use the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class for better control over the process you start. You must at least set the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property, either manually or using the constructor. The file name is any application or document. Here a document is defined to be any file type that has an open or default action associated with it. You can view registered file types and their associated applications for your computer by using the Folder Options dialog box, which is available through the operating system. The Advanced button leads to a dialog box that shows whether there is an open action associated with a specific registered file type.</p>\n<p>In addition, you can set other properties that define actions to take with that file. You can specify a value specific to the type of the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property for the <xref href=\"System.Diagnostics.ProcessStartInfo.Verb\" data-throw-if-not-resolved=\"false\"></xref> property. For example, you can specify \"print\" for a document type. Additionally, you can specify <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> property values to be command-line arguments to pass to the file's open procedure. For example, if you specify a text editor application in the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property, you can use the <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> property to specify a text file to be opened by the editor.</p>\n<p>Standard input is usually the keyboard, and standard output and standard error are usually the monitor screen. However, you can use the <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> properties to cause the process to get input from or return output to a file or other device. If you use the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> properties on the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, you must first set the corresponding value on the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> property. Otherwise, the system throws an exception when you read or write to the stream.</p>\n<p>Set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to specify whether to start the process by using the operating system shell.</p>\n<p>You can change the value of any <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> property up to the time that the process starts. After you start the process, changing these values has no effect.</p>\n<p>This class contains a link demand at the class level that applies to all members. A <xref href=\"System.Security.SecurityException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when the immediate caller does not have full-trust permission. For details about security demands, see Link Demands.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to use the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class to start Internet Explorer, providing the destination URLs as <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> arguments.</p>Process.Start_static#1"
  syntax:
    content: public sealed class ProcessStartInfo
    content.vb: Public NotInheritable Class ProcessStartInfo
  seealso:
  - type: System.Diagnostics.Process
    commentId: T:System.Diagnostics.Process
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - sealed
  - class
  modifiers.vb:
  - Public
  - NotInheritable
  - Class
- uid: System.Diagnostics.ProcessStartInfo.#ctor
  commentId: M:System.Diagnostics.ProcessStartInfo.#ctor
  id: '#ctor'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: ProcessStartInfo()
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo()
  type: Constructor
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 34
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class without specifying a file name with which to start the process.</p>\n"
  remarks: "\n<p>You must set at least the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property before you start the process. The file name is any application or document. In this case, a document is defined to be any file type that has an open or default action associated with it. You can view registered file types and their associated applications for your computer by using the Folder Options dialog box, which is available through the operating system. The Advanced button leads to a dialog box that shows whether there is an open action associated with a specific registered file type.</p>\n<p>Optionally, you can also set other properties before you start the process. The <xref href=\"System.Diagnostics.ProcessStartInfo.Verb\" data-throw-if-not-resolved=\"false\"></xref> property supplies actions to take, such as \"print\", with the file indicated in the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property. The <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> property supplies a way to pass command-line arguments to the file when the system opens it.</p>\n"
  syntax:
    content: public ProcessStartInfo()
    content.vb: Public Sub New
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  commentId: M:System.Diagnostics.ProcessStartInfo.#ctor(System.String)
  id: '#ctor(System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: ProcessStartInfo(String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(System.String)
  type: Constructor
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 41
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class and specifies a file name such as an application or document with which to start the process.</p>\n"
  remarks: "\n<p>The file name is any application or document. In this case, a document is defined to be any file type that has an open or default action associated with it. You can view registered file types and their associated applications for your computer by using the Folder Options dialog box, which is available through the operating system. The Advanced button leads to a dialog box that shows whether there is an open action associated with a specific registered file type.</p>\n<p>You can change the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property after you call this constructor, up to the time that the process starts. After you start the process, changing these values has no effect.</p>\n"
  syntax:
    content: public ProcessStartInfo(string fileName)
    content.vb: Public Sub New(fileName As String)
    parameters:
    - id: fileName
      type: System.String
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  commentId: M:System.Diagnostics.ProcessStartInfo.#ctor(System.String,System.String)
  id: '#ctor(System.String,System.String)'
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: ProcessStartInfo(String, String)
  fullName: System.Diagnostics.ProcessStartInfo.ProcessStartInfo(System.String, System.String)
  type: Constructor
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 50
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class, specifies an application file name with which to start the process, and specifies a set of command-line arguments to pass to the application.</p>\n"
  remarks: "\n<p>The file name is any application or document. In this case, a document is defined to be any file type that has an open or default action associated with it. You can view registered file types and their associated applications for your computer by using the Folder Options dialog box, which is available through the operating system. The Advanced button leads to a dialog box that shows whether there is an open action associated with a specific registered file type.</p>\n<p>You can change the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> properties after you call this constructor, up to the time that the process starts. After you start the process, changing these values has no effect.</p>\n"
  syntax:
    content: public ProcessStartInfo(string fileName, string arguments)
    content.vb: Public Sub New(fileName As String, arguments As String)
    parameters:
    - id: fileName
      type: System.String
    - id: arguments
      type: System.String
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.Arguments
  commentId: P:System.Diagnostics.ProcessStartInfo.Arguments
  id: Arguments
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: Arguments
  fullName: System.Diagnostics.ProcessStartInfo.Arguments
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Arguments
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 59
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the set of command-line arguments to use when starting the application.</p>\n"
  example:
  - "\n<p>The first example below creates a small application (argsecho.exe) that echos its arguments to the console. The second example creates an application that invokes argsecho.exe to demonstrate different variations for the Arguments property.</p>Process.Start_static#3Process.Start_static#2"
  syntax:
    content: public string Arguments { get; set; }
    content.vb: Public Property Arguments As String
    parameters: []
    return:
      type: System.String
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  commentId: P:System.Diagnostics.ProcessStartInfo.CreateNoWindow
  id: CreateNoWindow
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: CreateNoWindow
  fullName: System.Diagnostics.ProcessStartInfo.CreateNoWindow
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateNoWindow
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 75
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value indicating whether to start the process in a new window.</p>\n"
  remarks: "\n<p>If the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong> or the <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.ProcessStartInfo.Password\" data-throw-if-not-resolved=\"false\"></xref> properties are not <strong>null</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.CreateNoWindow\" data-throw-if-not-resolved=\"false\"></xref> property value is ignored and a new window is created.</p>\n"
  example:
  - Process.Start_instance#1
  syntax:
    content: public bool CreateNoWindow { get; set; }
    content.vb: Public Property CreateNoWindow As Boolean
    parameters: []
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.Environment
  commentId: P:System.Diagnostics.ProcessStartInfo.Environment
  id: Environment
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: Environment
  fullName: System.Diagnostics.ProcessStartInfo.Environment
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Environment
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 81
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the environment variables that apply to this process and its child processes.</p>\n"
  remarks: "\n<p>The environment variables contain search paths for files, directories for temporary files, application-specific options, and other similar information. Although you cannot directly set the <xref href=\"System.Diagnostics.ProcessStartInfo.Environment\" data-throw-if-not-resolved=\"false\"></xref> property, you can modify the generic dictionary returned by the property. For example, the following code adds a TempPath environment variable: <code>myProcess.StartInfo.Environment.Add(\"TempPath\", \"C:\\\\Temp\")</code>.  You must set the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> to start the process after changing the <xref href=\"System.Diagnostics.ProcessStartInfo.Environment\" data-throw-if-not-resolved=\"false\"></xref> property. If <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n<p>On .NET Framework applications, using the <xref href=\"System.Diagnostics.ProcessStartInfo.Environment\" data-throw-if-not-resolved=\"false\"></xref> property is the same as using the <xref href=\"System.Diagnostics.ProcessStartInfo.EnvironmentVariables\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  syntax:
    content: public IDictionary<string, string> Environment { get; }
    content.vb: Public ReadOnly Property Environment As IDictionary(Of String, String)
    parameters: []
    return:
      type: System.Collections.Generic.IDictionary{System.String,System.String}
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.EnvironmentVariables
    commentId: P:System.Diagnostics.ProcessStartInfo.EnvironmentVariables
  - type: System.Diagnostics.ProcessStartInfo.UseShellExecute
    commentId: P:System.Diagnostics.ProcessStartInfo.UseShellExecute
  - type: System.Diagnostics.Process.Start
    commentId: M:System.Diagnostics.Process.Start
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.ProcessStartInfo.FileName
  commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  id: FileName
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: FileName
  fullName: System.Diagnostics.ProcessStartInfo.FileName
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FileName
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 159
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the application or document to start.</p>\n"
  remarks: "\n<p>You must set at least the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property before you start the process. The file name is any application or document. A document is defined to be any file type that has an open or default action associated with it. You can view registered file types and their associated applications for your computer by using the Folder Options dialog box, which is available through the operating system. The Advanced button leads to a dialog box that shows whether there is an open action associated with a specific registered file type.</p>\n<p>The set of file types available to you depends in part on the value of the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property. If <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, you can start any document and perform operations on the file, such as printing, with the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, you can start only executables with the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component.</p>\n<p>You can start a ClickOnce application by setting the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard disk.</p>\n"
  example:
  - Process.Start_instance#1
  syntax:
    content: public string FileName { get; set; }
    content.vb: Public Property FileName As String
    parameters: []
    return:
      type: System.String
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  id: RedirectStandardError
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: RedirectStandardError
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardError
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RedirectStandardError
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 135
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value that indicates whether the error output of an application is written to the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  remarks: "\n<p>When a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes text to its standard error stream, that text is typically displayed on the console. By redirecting the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, you can manipulate or suppress the error output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</p>\n<p>You must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> if you want to set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, reading from the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n<p>The redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the error output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>The application that is processing the asynchronous output should call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> method to ensure that the output buffer has been flushed.</p>\n<p>Synchronous read operations introduce a dependency between the caller reading from the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream and the child process writing to that stream. These dependencies can cause deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits for the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits for the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait for each other to complete an operation, and neither can continue. You can avoid deadlocks by evaluating dependencies between the caller and child process.</p>\n<p>For example, the following C# code shows how to read from a redirected stream and wait for the child process to exit.</p>\n<pre><code>// Start the child process.\nProcess p = new Process();\n// Redirect the error stream of the child process.\np.StartInfo.UseShellExecute = false;\np.StartInfo.RedirectStandardError = true;\np.StartInfo.FileName = \"Write500Lines.exe\";\np.Start();\n// Do not wait for the child process to exit before\n// reading to the end of its redirected error stream.\n// p.WaitForExit();\n// Read the error stream first and then wait.\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids a deadlock condition by calling <code>p.StandardError.ReadToEnd</code> before <code>p.WaitForExit</code>. A deadlock condition can result if the parent process calls <code>p.WaitForExit</code> before <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>There is a similar issue when you read all text from both the standard output and standard error streams. For example, the following C# code performs a read operation on both streams.</p>\n<pre><code> // Do not perform a synchronous read to the end of both\n// redirected streams.\n// string output = p.StandardOutput.ReadToEnd();\n// string error = p.StandardError.ReadToEnd();\n// p.WaitForExit();\n// Use asynchronous read operations on at least one of the streams.\np.BeginOutputReadLine();\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids the deadlock condition by performing asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. A deadlock condition results if the parent process calls <code>p.StandardOutput.ReadToEnd</code> followed by <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</p>\n"
  example:
  - "\n<p>The following example uses the <strong>net use</strong> command together with a user-supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.</p>Process_StandardError#1"
  syntax:
    content: public bool RedirectStandardError { get; set; }
    content.vb: Public Property RedirectStandardError As Boolean
    parameters: []
    return:
      type: System.Boolean
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.UseShellExecute
    commentId: P:System.Diagnostics.ProcessStartInfo.UseShellExecute
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  id: RedirectStandardInput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: RedirectStandardInput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RedirectStandardInput
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 117
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value indicating whether the input for an application is read from the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> can read input text from its standard input stream, typically the keyboard. By redirecting the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream, you can programmatically specify the input of a process. For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</p>\n<p>You must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> if you want to set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, writing to the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n"
  example:
  - "\n<p>The following example illustrates how to redirect the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream of a process. The <strong>sort</strong> command is a console application that reads and sorts text input.</p>\n<p>The example starts the <strong>sort</strong> command with redirected input. It then prompts the user for text, and passes the text to the <strong>sort</strong> process through the redirected <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream. The <strong>sort</strong> results are displayed to the user on the console.</p>Process_StandardInput#1"
  syntax:
    content: public bool RedirectStandardInput { get; set; }
    content.vb: Public Property RedirectStandardInput As Boolean
    parameters: []
    return:
      type: System.Boolean
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.UseShellExecute
    commentId: P:System.Diagnostics.ProcessStartInfo.UseShellExecute
  - type: System.Diagnostics.Process.StandardInput
    commentId: P:System.Diagnostics.Process.StandardInput
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  id: RedirectStandardOutput
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: RedirectStandardOutput
  fullName: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RedirectStandardOutput
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 126
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value that indicates whether the textual output of an application is written to the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  remarks: "\n<p>When a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes text to its standard stream, that text is typically displayed on the console. By setting <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong> to redirect the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, you can manipulate or suppress the output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</p>\n<p>You must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> if you want to set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, reading from the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n<p>The redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables a designated event handler (see <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref>) for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>The application that is processing the asynchronous output should call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> method to ensure that the output buffer has been flushed.</p>\n<p>Synchronous read operations introduce a dependency between the caller reading from the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream and the child process writing to that stream. These dependencies can cause deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits for the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits for the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait for each other to complete an operation, and neither can continue. You can avoid deadlocks by evaluating dependencies between the caller and child process.</p>\n<p>For example, the following C# code shows how to read from a redirected stream and wait for the child process to exit.</p>\n<pre><code> Process p = new Process();\np.StartInfo.UseShellExecute = false;\np.StartInfo.RedirectStandardOutput = true;\np.StartInfo.FileName = \"Write500Lines.exe\";\np.Start();\n\n// To avoid deadlocks, always read the output stream first and then wait.\nstring output = p.StandardOutput.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids a deadlock condition by calling <code>p.StandardOutput.ReadToEnd</code> before <code>p.WaitForExit</code>. A deadlock condition can result if the parent process calls <code>p.WaitForExit</code> before <code>p.StandardOutput.ReadToEnd</code> and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>There is a similar issue when you read all text from both the standard output and standard error streams. For example, the following C# code performs a read operation on both streams.</p>\n<pre><code> // To avoid deadlocks, use asynchronous read operations on at least one of the streams.\n// Do not perform a synchronous read to the end of both redirected streams.\np.BeginOutputReadLine();\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids the deadlock condition by performing asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. A deadlock condition results if the parent process calls <code>p.StandardOutput.ReadToEnd</code> followed by <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</p>\n"
  example:
  - ProcessOneStream#1
  syntax:
    content: public bool RedirectStandardOutput { get; set; }
    content.vb: Public Property RedirectStandardOutput As Boolean
    parameters: []
    return:
      type: System.Boolean
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.UseShellExecute
    commentId: P:System.Diagnostics.ProcessStartInfo.UseShellExecute
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  commentId: P:System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  id: StandardErrorEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: StandardErrorEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardErrorEncoding
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StandardErrorEncoding
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 142
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the preferred encoding for error output.</p>\n"
  remarks: "\n<p>If the value of the <xref href=\"System.Diagnostics.ProcessStartInfo.StandardErrorEncoding\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>null</strong>, the process uses the default standard error encoding for error output. The <xref href=\"System.Diagnostics.ProcessStartInfo.StandardErrorEncoding\" data-throw-if-not-resolved=\"false\"></xref> property must be set before the process is started. Setting this property does not guarantee that the process will use the specified encoding; the process will use only those encodings that it supports. The application should be tested to determine which encodings are supported.</p>\n"
  syntax:
    content: public Encoding StandardErrorEncoding { get; set; }
    content.vb: Public Property StandardErrorEncoding As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  commentId: P:System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  id: StandardOutputEncoding
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: StandardOutputEncoding
  fullName: System.Diagnostics.ProcessStartInfo.StandardOutputEncoding
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StandardOutputEncoding
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 148
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the preferred encoding for standard output.</p>\n"
  remarks: "\n<p>If the value of the <xref href=\"System.Diagnostics.ProcessStartInfo.StandardOutputEncoding\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>null</strong>, the process uses the default standard output encoding for the standard output. The <xref href=\"System.Diagnostics.ProcessStartInfo.StandardOutputEncoding\" data-throw-if-not-resolved=\"false\"></xref> property must be set before the process is started. Setting this property does not guarantee that the process will use the specified encoding. The application should be tested to determine which encodings the process supports.</p>\n"
  syntax:
    content: public Encoding StandardOutputEncoding { get; set; }
    content.vb: Public Property StandardOutputEncoding As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.UseShellExecute
  commentId: P:System.Diagnostics.ProcessStartInfo.UseShellExecute
  id: UseShellExecute
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: UseShellExecute
  fullName: System.Diagnostics.ProcessStartInfo.UseShellExecute
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UseShellExecute
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 131
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value indicating whether to use the operating system shell to start the process.</p>\n"
  remarks: "\n<p>Setting this property to <strong>false</strong> enables you to redirect input, output, and error streams.</p>\n<p>   <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> must be <strong>false</strong> if the <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> property is not <strong>null</strong> or an empty string, or an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> will be thrown when the <xref href=\"System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n<p>When you use the operating system shell to start processes, you can start any document (which is any registered file type associated with an executable that has a default open action) and perform operations on the file, such as printing, by using the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, you can start only executables by using the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>\n<xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> must be <strong>true</strong> if you set the <xref href=\"System.Diagnostics.ProcessStartInfo.ErrorDialog\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>true</strong>.</p>\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property behaves differently depending on the value of the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property specifies the location of the executable. If <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> is an empty string, it is assumed that the current directory contains the executable.</p>\n<p>When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property is not used to find the executable. Instead, it is used only by the process that is started and has meaning only within the context of the new process. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property can be either a fully qualified path to the executable, or a simple executable name that the system will attempt to find within folders specified by the PATH environment variable.</p>\n"
  example:
  - ProcessOneStream#1
  syntax:
    content: public bool UseShellExecute { get; set; }
    content.vb: Public Property UseShellExecute As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the shell should be used when starting the process; <strong>false</strong> if the process should be created directly from the executable file. The default is <strong>true</strong>.</p>\n"
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardError
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  commentId: P:System.Diagnostics.ProcessStartInfo.WorkingDirectory
  id: WorkingDirectory
  parent: System.Diagnostics.ProcessStartInfo
  langs:
  - csharp
  - vb
  name: WorkingDirectory
  fullName: System.Diagnostics.ProcessStartInfo.WorkingDirectory
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WorkingDirectory
    path: src/System.Diagnostics.Process/src/System/Diagnostics/ProcessStartInfo.cs
    startLine: 169
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>When the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>, gets or sets the working directory for the process to be started. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, gets or sets the directory that contains the process to be started.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property must be set if <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.ProcessStartInfo.Password\" data-throw-if-not-resolved=\"false\"></xref> are provided. If the property is not set, the default working directory is %SYSTEMROOT%\\system32.</p>\n<p>If the directory is already part of the system path variable, you do not have to repeat the directory's location in this property.</p>\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property behaves differently when <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong> than when <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property specifies the location of the executable. If <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> is an empty string, the current directory is understood to contain the executable.</p>\n<p>When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the working directory of the application that starts the executable is also the working directory of the executable.</p>\n<p>When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, the <xref href=\"System.Diagnostics.ProcessStartInfo.WorkingDirectory\" data-throw-if-not-resolved=\"false\"></xref> property is not used to find the executable. Instead, its value applies to the process that is started and only has meaning within the context of the new process.</p>\n"
  syntax:
    content: public string WorkingDirectory { get; set; }
    content.vb: Public Property WorkingDirectory As String
    parameters: []
    return:
      type: System.String
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
references:
- uid: System.Diagnostics
  isExternal: false
  name: System.Diagnostics
  fullName: System.Diagnostics
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Collections.Generic.IDictionary{System.String,System.String}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IDictionary`2
  name: IDictionary<String, String>
  fullName: System.Collections.Generic.IDictionary<System.String, System.String>
  fullname.vb: System.Collections.Generic.IDictionary(Of System.String, System.String)
  name.vb: IDictionary(Of String, String)
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    fullName: System.Collections.Generic.IDictionary
    isExternal: true
  - name: <
    fullName: <
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    fullName: System.Collections.Generic.IDictionary
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.Generic.IDictionary`2
  parent: System.Collections.Generic
  isExternal: false
  name: IDictionary<TKey, TValue>
  fullName: System.Collections.Generic.IDictionary<TKey, TValue>
  fullname.vb: System.Collections.Generic.IDictionary(Of TKey, TValue)
  name.vb: IDictionary(Of TKey, TValue)
  spec.csharp:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    fullName: System.Collections.Generic.IDictionary
  - name: <
    fullName: <
  - name: TKey
    fullName: TKey
  - name: ', '
    fullName: ', '
  - name: TValue
    fullName: TValue
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IDictionary`2
    name: IDictionary
    fullName: System.Collections.Generic.IDictionary
  - name: '(Of '
    fullName: '(Of '
  - name: TKey
    fullName: TKey
  - name: ', '
    fullName: ', '
  - name: TValue
    fullName: TValue
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: false
  name: Encoding
  fullName: System.Text.Encoding
- uid: System.Text
  isExternal: false
  name: System.Text
  fullName: System.Text
