items:
- uid: System.Threading.Interlocked
  commentId: T:System.Threading.Interlocked
  id: Interlocked
  parent: System.Threading
  children:
  - System.Threading.Interlocked.Add(System.Int32@,System.Int32)
  - System.Threading.Interlocked.Add(System.Int64@,System.Int64)
  - System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)
  - System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)
  - System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)
  - System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)
  - System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)
  - System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)
  - System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)
  - System.Threading.Interlocked.Decrement(System.Int32@)
  - System.Threading.Interlocked.Decrement(System.Int64@)
  - System.Threading.Interlocked.Exchange(System.Double@,System.Double)
  - System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)
  - System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)
  - System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)
  - System.Threading.Interlocked.Exchange(System.Object@,System.Object)
  - System.Threading.Interlocked.Exchange(System.Single@,System.Single)
  - System.Threading.Interlocked.Exchange``1(``0@,``0)
  - System.Threading.Interlocked.Increment(System.Int32@)
  - System.Threading.Interlocked.Increment(System.Int64@)
  - System.Threading.Interlocked.MemoryBarrier
  - System.Threading.Interlocked.Read(System.Int64@)
  langs:
  - csharp
  - vb
  name: Interlocked
  fullName: System.Threading.Interlocked
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Interlocked
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 19
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Provides atomic operations for variables that are shared by multiple threads. </p>\n"
  remarks: "\n<p>The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Increment(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.Interlocked.Decrement(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps: </p>\n<ol><li>\n<p>Load a value from an instance variable into a register.</p>\n</li><li>\n<p>Increment or decrement the value.</p>\n</li><li>\n<p>Store the value in the instance variable.</p>\n</li></ol>\n<p>If you do not use <xref href=\"System.Threading.Interlocked.Increment(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.Interlocked.Decrement(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method atomically exchanges the values of the specified variables. The <xref href=\"System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.</p>\n"
  example:
  - "\n<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1"
  syntax:
    content: public class Interlocked
    content.vb: Public Class Interlocked
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Threading.Interlocked.Add(System.Int32@,System.Int32)
  commentId: M:System.Threading.Interlocked.Add(System.Int32@,System.Int32)
  id: Add(System.Int32@,System.Int32)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Add(ref Int32, Int32)
  fullName: System.Threading.Interlocked.Add(ref System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Add
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 206
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> and <em>value</em> is 1, the result is <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref>; if <em>value</em> is 2, the result is (<xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref> + 1); and so on. No exception is thrown.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static int Add(ref int location1, int value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Function Add(ByRef location1 As Integer, value As Integer) As Integer
    parameters:
    - id: location1
      type: System.Int32
    - id: value
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Add(ByRef System.Int32, System.Int32)
  name.vb: Add(ByRef Int32, Int32)
- uid: System.Threading.Interlocked.Add(System.Int64@,System.Int64)
  commentId: M:System.Threading.Interlocked.Add(System.Int64@,System.Int64)
  id: Add(System.Int64@,System.Int64)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Add(ref Int64, Int64)
  fullName: System.Threading.Interlocked.Add(ref System.Int64, System.Int64)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Add
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 212
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: if the value at <em>location1</em> is <xref href=\"System.Int64.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> and <em>value</em> is 1, the result is <xref href=\"System.Int64.MinValue\" data-throw-if-not-resolved=\"false\"></xref>; if <em>value</em> is 2, the result is (<xref href=\"System.Int64.MinValue\" data-throw-if-not-resolved=\"false\"></xref> + 1); and so on. No exception is thrown.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref> method and the 64-bit overloads of the <see cref=\"Overload:System.Threading.Interlocked.Increment\"></see>, <see cref=\"Overload:System.Threading.Interlocked.Decrement\"></see>, and <see cref=\"Overload:System.Threading.Interlocked.Add\"></see> methods are truly atomic only on systems where a <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref href=\"System.Threading.Interlocked\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static long Add(ref long location1, long value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Function Add(ByRef location1 As Long, value As Long) As Long
    parameters:
    - id: location1
      type: System.Int64
    - id: value
      type: System.Int64
    return:
      type: System.Int64
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  seealso:
  - type: System.Threading.Interlocked.Read(System.Int64@)
    commentId: M:System.Threading.Interlocked.Read(System.Int64@)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Add(ByRef System.Int64, System.Int64)
  name.vb: Add(ByRef Int64, Int64)
- uid: System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)
  id: CompareExchange(System.Double@,System.Double,System.Double)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref Double, Double, Double)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.Double, System.Double, System.Double)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n"
  example:
  - "\n<p>The following code example demonstrates a thread-safe method that accumulates a running total of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> values. Two threads add a series of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals. </p>\n<p>In the thread-safe method, the initial value of the running total is saved, and then the <xref href=\"System.Threading.Interlocked.CompareExchange(System.Double@,System.Double,System.Double)\" data-throw-if-not-resolved=\"false\"></xref> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>System.Threading.Interlocked CompareExchange Double#1"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static double CompareExchange(ref double location1, double value, double comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As Double, value As Double, comparand As Double) As Double
    parameters:
    - id: location1
      type: System.Double
    - id: value
      type: System.Double
    - id: comparand
      type: System.Double
    return:
      type: System.Double
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.Double, System.Double, System.Double)
  name.vb: CompareExchange(ByRef Double, Double, Double)
- uid: System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)
  id: CompareExchange(System.Int32@,System.Int32,System.Int32)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref Int32, Int32, Int32)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.Int32, System.Int32, System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n"
  example:
  - "\n<p>The following code example demonstrates a thread-safe method that accumulates a running total. The initial value of the running total is saved, and then the <xref href=\"System.Threading.Interlocked.CompareExchange(System.Int32@,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>\n<p>The <see cref=\"Overload:System.Threading.Interlocked.Add\"></see> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.</p>System.Threading.Interlocked CompareExchange0#1"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static int CompareExchange(ref int location1, int value, int comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As Integer, value As Integer, comparand As Integer) As Integer
    parameters:
    - id: location1
      type: System.Int32
    - id: value
      type: System.Int32
    - id: comparand
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.Int32, System.Int32, System.Int32)
  name.vb: CompareExchange(ByRef Int32, Int32, Int32)
- uid: System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.Int64@,System.Int64,System.Int64)
  id: CompareExchange(System.Int64@,System.Int64,System.Int64)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref Int64, Int64, Int64)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.Int64, System.Int64, System.Int64)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static long CompareExchange(ref long location1, long value, long comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As Long, value As Long, comparand As Long) As Long
    parameters:
    - id: location1
      type: System.Int64
    - id: value
      type: System.Int64
    - id: comparand
      type: System.Int64
    return:
      type: System.Int64
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.Int64, System.Int64, System.Int64)
  name.vb: CompareExchange(ByRef Int64, Int64, Int64)
- uid: System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)
  id: CompareExchange(System.IntPtr@,System.IntPtr,System.IntPtr)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref IntPtr, IntPtr, IntPtr)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.IntPtr, System.IntPtr, System.IntPtr)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n<p>\n<xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is a platform-specific type.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static IntPtr CompareExchange(ref IntPtr location1, IntPtr value, IntPtr comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As IntPtr, value As IntPtr, comparand As IntPtr) As IntPtr
    parameters:
    - id: location1
      type: System.IntPtr
    - id: value
      type: System.IntPtr
    - id: comparand
      type: System.IntPtr
    return:
      type: System.IntPtr
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.IntPtr, System.IntPtr, System.IntPtr)
  name.vb: CompareExchange(ByRef IntPtr, IntPtr, IntPtr)
- uid: System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)
  id: CompareExchange(System.Object@,System.Object,System.Object)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref Object, Object, Object)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.Object, System.Object, System.Object)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two objects for reference equality and, if they are equal, replaces the first object.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the object in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n<p>Beginning with .NET Framework version 2.0, the <xref href=\"System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload provides a type-safe alternative for reference types.</p>\n<p>The objects are compared for reference equality, rather than <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static object CompareExchange(ref object location1, object value, object comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As Object, value As Object, comparand As Object) As Object
    parameters:
    - id: location1
      type: System.Object
    - id: value
      type: System.Object
    - id: comparand
      type: System.Object
    return:
      type: System.Object
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.Object, System.Object, System.Object)
  name.vb: CompareExchange(ByRef Object, Object, Object)
- uid: System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)
  commentId: M:System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)
  id: CompareExchange(System.Single@,System.Single,System.Single)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange(ref Single, Single, Single)
  fullName: System.Threading.Interlocked.CompareExchange(ref System.Single, System.Single, System.Single)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n"
  example:
  - "\n<p>The following code example demonstrates a thread-safe method that accumulates a running total of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> values. Two threads add a series of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals. </p>\n<p>In the thread-safe method, the initial value of the running total is saved, and then the <xref href=\"System.Threading.Interlocked.CompareExchange(System.Single@,System.Single,System.Single)\" data-throw-if-not-resolved=\"false\"></xref> method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.</p>System.Threading.Interlocked CompareExchange Single#1"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static float CompareExchange(ref float location1, float value, float comparand)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(ByRef location1 As Single, value As Single, comparand As Single) As Single
    parameters:
    - id: location1
      type: System.Single
    - id: value
      type: System.Single
    - id: comparand
      type: System.Single
    return:
      type: System.Single
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(ByRef System.Single, System.Single, System.Single)
  name.vb: CompareExchange(ByRef Single, Single, Single)
- uid: System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)
  commentId: M:System.Threading.Interlocked.CompareExchange``1(``0@,``0,``0)
  id: CompareExchange``1(``0@,``0,``0)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: CompareExchange<T>(ref T, T, T)
  fullName: System.Threading.Interlocked.CompareExchange<T>(ref T, T, T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CompareExchange
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 172
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Compares two instances of the specified reference type <em>T</em> for equality and, if they are equal, replaces the first one.</p>\n"
  remarks: "\n<p>If <em>comparand</em> and the value in <em>location1</em> are equal, then <em>value</em> is stored in <em>location1</em>. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in <em>location1</em>, whether or not the exchange takes place.</p>\n<p>This method only supports reference types. There are overloads of the <see cref=\"Overload:System.Threading.Interlocked.CompareExchange\"></see> method for the value types <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>, but there is no support for other value types.</p>\n<p>This method overload is preferable to the <xref href=\"System.Threading.Interlocked.CompareExchange(System.Object@,System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method overload, because the latter requires the destination object to be accessed late-bound.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [ComVisible(false)]

      [SecuritySafeCritical]

      public static T CompareExchange<T>(ref T location1, T value, T comparand)where T : class
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <ComVisible(False)>

      <SecuritySafeCritical>

      Public Shared Function CompareExchange(Of T As Class)(ByRef location1 As T, value As T, comparand As T) As T
    parameters:
    - id: location1
      type: '{T}'
    - id: value
      type: '{T}'
    - id: comparand
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: '{T}'
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.CompareExchange(Of T)(ByRef T, T, T)
  name.vb: CompareExchange(Of T)(ByRef T, T, T)
- uid: System.Threading.Interlocked.Decrement(System.Int32@)
  commentId: M:System.Threading.Interlocked.Decrement(System.Int32@)
  id: Decrement(System.Int32@)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Decrement(ref Int32)
  fullName: System.Threading.Interlocked.Decrement(ref System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Decrement
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 45
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Decrements a specified variable and stores the result, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: If <em>location</em> = <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref>, <em>location</em> - 1 = <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. No exception is thrown.</p>\n"
  example:
  - "\n<p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value. Because three threads generate the random numbers, the <xref href=\"System.Threading.Interlocked.Decrement(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref> method is called to ensure that multiple threads don't update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <xref href=\"System.Threading.CountdownEvent\" data-throw-if-not-resolved=\"false\"></xref> object is used to ensure that the <code>Main</code> method doesn't finish execution before the three threads. </p>System.Threading.Interlocked.Decrement#1"
  - "\n<p>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <xref href=\"System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])\" data-throw-if-not-resolved=\"false\"></xref> method eliminates the need for the <xref href=\"System.Threading.CountdownEvent\" data-throw-if-not-resolved=\"false\"></xref> object.  </p>System.Threading.Interlocked.Decrement#2"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static int Decrement(ref int location)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Function Decrement(ByRef location As Integer) As Integer
    parameters:
    - id: location
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The address of <em>location</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Decrement(ByRef System.Int32)
  name.vb: Decrement(ByRef Int32)
- uid: System.Threading.Interlocked.Decrement(System.Int64@)
  commentId: M:System.Threading.Interlocked.Decrement(System.Int64@)
  id: Decrement(System.Int64@)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Decrement(ref Int64)
  fullName: System.Threading.Interlocked.Decrement(ref System.Int64)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Decrement
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 51
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Decrements the specified variable and stores the result, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: if <em>location</em> = <xref href=\"System.Int64.MinValue\" data-throw-if-not-resolved=\"false\"></xref>, <em>location</em> - 1 = <xref href=\"System.Int64.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. No exception is thrown.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref> method and the 64-bit overloads of the <see cref=\"Overload:System.Threading.Interlocked.Increment\"></see>, <see cref=\"Overload:System.Threading.Interlocked.Decrement\"></see>, and <see cref=\"Overload:System.Threading.Interlocked.Add\"></see> methods are truly atomic only on systems where a <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref href=\"System.Threading.Interlocked\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: public static long Decrement(ref long location)
    content.vb: Public Shared Function Decrement(ByRef location As Long) As Long
    parameters:
    - id: location
      type: System.Int64
    return:
      type: System.Int64
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The address of <em>location</em> is a null pointer. </p>\n"
  seealso:
  - type: System.Threading.Interlocked.Read(System.Int64@)
    commentId: M:System.Threading.Interlocked.Read(System.Int64@)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Decrement(ByRef System.Int64)
  name.vb: Decrement(ByRef Int64)
- uid: System.Threading.Interlocked.Exchange(System.Double@,System.Double)
  commentId: M:System.Threading.Interlocked.Exchange(System.Double@,System.Double)
  id: Exchange(System.Double@,System.Double)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref Double, Double)
  fullName: System.Threading.Interlocked.Exchange(ref System.Double, System.Double)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static double Exchange(ref double location1, double value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As Double, value As Double) As Double
    parameters:
    - id: location1
      type: System.Double
    - id: value
      type: System.Double
    return:
      type: System.Double
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.Double, System.Double)
  name.vb: Exchange(ByRef Double, Double)
- uid: System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)
  commentId: M:System.Threading.Interlocked.Exchange(System.Int32@,System.Int32)
  id: Exchange(System.Int32@,System.Int32)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref Int32, Int32)
  fullName: System.Threading.Interlocked.Exchange(ref System.Int32, System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n"
  example:
  - "\n<p>The following code example shows a thread-safe resource locking mechanism.</p>System.Threading.Interlocked.Exchange Int32 Example#1"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static int Exchange(ref int location1, int value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As Integer, value As Integer) As Integer
    parameters:
    - id: location1
      type: System.Int32
    - id: value
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.Int32, System.Int32)
  name.vb: Exchange(ByRef Int32, Int32)
- uid: System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)
  commentId: M:System.Threading.Interlocked.Exchange(System.Int64@,System.Int64)
  id: Exchange(System.Int64@,System.Int64)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref Int64, Int64)
  fullName: System.Threading.Interlocked.Exchange(ref System.Int64, System.Int64)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static long Exchange(ref long location1, long value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As Long, value As Long) As Long
    parameters:
    - id: location1
      type: System.Int64
    - id: value
      type: System.Int64
    return:
      type: System.Int64
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.Int64, System.Int64)
  name.vb: Exchange(ByRef Int64, Int64)
- uid: System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)
  commentId: M:System.Threading.Interlocked.Exchange(System.IntPtr@,System.IntPtr)
  id: Exchange(System.IntPtr@,System.IntPtr)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref IntPtr, IntPtr)
  fullName: System.Threading.Interlocked.Exchange(ref System.IntPtr, System.IntPtr)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static IntPtr Exchange(ref IntPtr location1, IntPtr value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As IntPtr, value As IntPtr) As IntPtr
    parameters:
    - id: location1
      type: System.IntPtr
    - id: value
      type: System.IntPtr
    return:
      type: System.IntPtr
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.IntPtr, System.IntPtr)
  name.vb: Exchange(ByRef IntPtr, IntPtr)
- uid: System.Threading.Interlocked.Exchange(System.Object@,System.Object)
  commentId: M:System.Threading.Interlocked.Exchange(System.Object@,System.Object)
  id: Exchange(System.Object@,System.Object)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref Object, Object)
  fullName: System.Threading.Interlocked.Exchange(ref System.Object, System.Object)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</p>\n"
  remarks: "\n<p>Beginning with .NET Framework version 2.0, the <xref href=\"System.Threading.Interlocked.Exchange``1(``0@,``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload provides a type-safe alternative for reference types.</p>\n"
  example:
  - "\n<p>The following code example shows the syntax for using <strong>Exchange</strong> with any reference type object.</p>System.Threading.Interlocked.Exchange#1"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [SecuritySafeCritical]

      public static object Exchange(ref object location1, object value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As Object, value As Object) As Object
    parameters:
    - id: location1
      type: System.Object
    - id: value
      type: System.Object
    return:
      type: System.Object
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.Object, System.Object)
  name.vb: Exchange(ByRef Object, Object)
- uid: System.Threading.Interlocked.Exchange(System.Single@,System.Single)
  commentId: M:System.Threading.Interlocked.Exchange(System.Single@,System.Single)
  id: Exchange(System.Single@,System.Single)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange(ref Single, Single)
  fullName: System.Threading.Interlocked.Exchange(ref System.Single, System.Single)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n"
  syntax:
    content: >-
      [MethodImpl(MethodImplOptions.InternalCall)]

      [SecuritySafeCritical]

      public static float Exchange(ref float location1, float value)
    content.vb: >-
      <MethodImpl(MethodImplOptions.InternalCall)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(ByRef location1 As Single, value As Single) As Single
    parameters:
    - id: location1
      type: System.Single
    - id: value
      type: System.Single
    return:
      type: System.Single
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(ByRef System.Single, System.Single)
  name.vb: Exchange(ByRef Single, Single)
- uid: System.Threading.Interlocked.Exchange``1(``0@,``0)
  commentId: M:System.Threading.Interlocked.Exchange``1(``0@,``0)
  id: Exchange``1(``0@,``0)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Exchange<T>(ref T, T)
  fullName: System.Threading.Interlocked.Exchange<T>(ref T, T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Exchange
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 93
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets a variable of the specified type <em>T</em> to a specified value and returns the original value, as an atomic operation.</p>\n"
  remarks: "\n<p>This method only supports reference types. There are overloads of the <see cref=\"Overload:System.Threading.Interlocked.Exchange\"></see> method for the <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> value types, but there is no support for other value types.</p>\n<p>This method overload is preferable to the <xref href=\"System.Threading.Interlocked.Exchange(System.Object@,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method overload, because the latter requires late-bound access to the destination object .  </p>\n"
  example:
  - "\n<p>The following example launches ten tasks, each of which generates  100 ten-character part numbers. It then the part number that is first alphabetically. </p>System.Threading.Interlocked.Exchange#2<p>The example uses the <code>firstWidget</code> variable to store the ID that occurs first in the sort order. It compares each ID that it generates with the <code>firstWidget</code> value.  If the new value precedes the current value of <code>firstWidget</code> in the sort order, the example calls the <xref href=\"System.Threading.Interlocked.Exchange``1(``0@,``0)\" data-throw-if-not-resolved=\"false\"></xref> method to assign the new value to <code>firstWidget</code>. </p>"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [ComVisible(false)]

      [SecuritySafeCritical]

      public static T Exchange<T>(ref T location1, T value)where T : class
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <ComVisible(False)>

      <SecuritySafeCritical>

      Public Shared Function Exchange(Of T As Class)(ByRef location1 As T, value As T) As T
    parameters:
    - id: location1
      type: '{T}'
    - id: value
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: '{T}'
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location1</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Exchange(Of T)(ByRef T, T)
  name.vb: Exchange(Of T)(ByRef T, T)
- uid: System.Threading.Interlocked.Increment(System.Int32@)
  commentId: M:System.Threading.Interlocked.Increment(System.Int32@)
  id: Increment(System.Int32@)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Increment(ref Int32)
  fullName: System.Threading.Interlocked.Increment(ref System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Increment
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 27
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Increments a specified variable and stores the result, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: if <em>location</em> = <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, <em>location</em> + 1 = <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref>. No exception is thrown.</p>\n"
  example:
  - "\n<p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000. Because three threads generate the random numbers, the <xref href=\"System.Threading.Interlocked.Increment(System.Int32@)\" data-throw-if-not-resolved=\"false\"></xref> method is called to ensure that multiple threads don't update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <xref href=\"System.Threading.CountdownEvent\" data-throw-if-not-resolved=\"false\"></xref> object is used to ensure that the <code>Main</code> method doesn't finish execution before the three threads. </p>System.Threading.Interlocked.Increment2#3"
  - "\n<p>The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <xref href=\"System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])\" data-throw-if-not-resolved=\"false\"></xref> method eliminates the need for the <xref href=\"System.Threading.CountdownEvent\" data-throw-if-not-resolved=\"false\"></xref> object. </p>System.Threading.Interlocked.Increment2#4"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static int Increment(ref int location)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Function Increment(ByRef location As Integer) As Integer
    parameters:
    - id: location
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location</em> is a null pointer. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Increment(ByRef System.Int32)
  name.vb: Increment(ByRef Int32)
- uid: System.Threading.Interlocked.Increment(System.Int64@)
  commentId: M:System.Threading.Interlocked.Increment(System.Int64@)
  id: Increment(System.Int64@)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Increment(ref Int64)
  fullName: System.Threading.Interlocked.Increment(ref System.Int64)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Increment
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 33
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Increments a specified variable and stores the result, as an atomic operation.</p>\n"
  remarks: "\n<p>This method handles an overflow condition by wrapping: if <em>location</em> = <xref href=\"System.Int64.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, <em>location</em> + 1 = <xref href=\"System.Int64.MinValue\" data-throw-if-not-resolved=\"false\"></xref>. No exception is thrown.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref> method and the 64-bit overloads of the <see cref=\"Overload:System.Threading.Interlocked.Increment\"></see>, <see cref=\"Overload:System.Threading.Interlocked.Decrement\"></see>, and <see cref=\"Overload:System.Threading.Interlocked.Add\"></see> methods are truly atomic only on systems where a <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref href=\"System.Threading.Interlocked\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static long Increment(ref long location)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Function Increment(ByRef location As Long) As Long
    parameters:
    - id: location
      type: System.Int64
    return:
      type: System.Int64
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The address of <em>location</em> is a null pointer. </p>\n"
  seealso:
  - type: System.Threading.Interlocked.Read(System.Int64@)
    commentId: M:System.Threading.Interlocked.Read(System.Int64@)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Increment(ByRef System.Int64)
  name.vb: Increment(ByRef Int64)
- uid: System.Threading.Interlocked.MemoryBarrier
  commentId: M:System.Threading.Interlocked.MemoryBarrier
  id: MemoryBarrier
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: MemoryBarrier()
  fullName: System.Threading.Interlocked.MemoryBarrier()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: MemoryBarrier
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 227
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\" data-throw-if-not-resolved=\"false\"></xref> execute after memory accesses that follow the call to <xref href=\"System.Threading.Interlocked.MemoryBarrier\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method was added to the <xref href=\"System.Threading.Interlocked\" data-throw-if-not-resolved=\"false\"></xref> class in the .NET Framework 4.5 as a convenience; it's a wrapper for the <xref href=\"System.Threading.Thread.MemoryBarrier\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>\n<xref href=\"System.Threading.Interlocked.MemoryBarrier\" data-throw-if-not-resolved=\"false\"></xref> is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).</p>\n<p>For most purposes, the C# <strong>lock</strong> statement, the Visual Basic <strong>SyncLock</strong> statement, or the <xref href=\"System.Threading.Monitor\" data-throw-if-not-resolved=\"false\"></xref> class provide easier ways to synchronize data.</p>\n"
  syntax:
    content: public static void MemoryBarrier()
    content.vb: Public Shared Sub MemoryBarrier
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Interlocked.Read(System.Int64@)
  commentId: M:System.Threading.Interlocked.Read(System.Int64@)
  id: Read(System.Int64@)
  parent: System.Threading.Interlocked
  langs:
  - csharp
  - vb
  name: Read(ref Int64)
  fullName: System.Threading.Interlocked.Read(ref System.Int64)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Interlocked.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Read
    path: src/mscorlib/src/System/Threading/Interlocked.cs
    startLine: 221
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Returns a 64-bit value, loaded as an atomic operation.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref> method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Threading.Interlocked.Read(System.Int64@)\" data-throw-if-not-resolved=\"false\"></xref> method and the 64-bit overloads of the <see cref=\"Overload:System.Threading.Interlocked.Increment\"></see>, <see cref=\"Overload:System.Threading.Interlocked.Decrement\"></see>, and <see cref=\"Overload:System.Threading.Interlocked.Add\"></see> methods are truly atomic only on systems where a <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <xref href=\"System.Threading.Interlocked\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n<p>\n<xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> is a platform-specific type.</p>\n"
  example:
  - 
  syntax:
    content: public static long Read(ref long location)
    content.vb: Public Shared Function Read(ByRef location As Long) As Long
    parameters:
    - id: location
      type: System.Int64
    return:
      type: System.Int64
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Interlocked.Read(ByRef System.Int64)
  name.vb: Read(ByRef Int64)
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Double
  parent: System
  isExternal: false
  name: Double
  fullName: System.Double
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Single
  parent: System
  isExternal: false
  name: Single
  fullName: System.Single
- uid: '{T}'
  isExternal: false
  name: T
  fullName: T
- uid: System.NullReferenceException
  isExternal: false
  name: NullReferenceException
  fullName: System.NullReferenceException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
