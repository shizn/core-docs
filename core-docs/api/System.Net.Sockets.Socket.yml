items:
- uid: System.Net.Sockets.Socket
  commentId: T:System.Net.Sockets.Socket
  id: Socket
  parent: System.Net.Sockets
  children:
  - System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  - System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  - System.Net.Sockets.Socket.Accept
  - System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.AddressFamily
  - System.Net.Sockets.Socket.Available
  - System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - System.Net.Sockets.Socket.Blocking
  - System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)
  - System.Net.Sockets.Socket.Connect(System.String,System.Int32)
  - System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.Connected
  - System.Net.Sockets.Socket.Dispose
  - System.Net.Sockets.Socket.Dispose(System.Boolean)
  - System.Net.Sockets.Socket.DontFragment
  - System.Net.Sockets.Socket.DualMode
  - System.Net.Sockets.Socket.EnableBroadcast
  - System.Net.Sockets.Socket.ExclusiveAddressUse
  - System.Net.Sockets.Socket.Finalize
  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])
  - System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])
  - System.Net.Sockets.Socket.IsBound
  - System.Net.Sockets.Socket.LingerState
  - System.Net.Sockets.Socket.Listen(System.Int32)
  - System.Net.Sockets.Socket.LocalEndPoint
  - System.Net.Sockets.Socket.MulticastLoopback
  - System.Net.Sockets.Socket.NoDelay
  - System.Net.Sockets.Socket.OSSupportsIPv4
  - System.Net.Sockets.Socket.OSSupportsIPv6
  - System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  - System.Net.Sockets.Socket.ProtocolType
  - System.Net.Sockets.Socket.Receive(System.Byte[])
  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  - System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.ReceiveBufferSize
  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)
  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
  - System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.ReceiveTimeout
  - System.Net.Sockets.Socket.RemoteEndPoint
  - System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
  - System.Net.Sockets.Socket.Send(System.Byte[])
  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  - System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.SendBufferSize
  - System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.SendTimeout
  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)
  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)
  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)
  - System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - System.Net.Sockets.Socket.SocketType
  - System.Net.Sockets.Socket.Ttl
  langs:
  - csharp
  - vb
  name: Socket
  fullName: System.Net.Sockets.Socket
  type: Class
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Socket
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 158
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Implements the Berkeley sockets interface.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class provides a rich set of methods and properties for network communications. The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> enumeration. </p>\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method corresponds to the asynchronous <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n<p>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</p>\n<ul><li>\n<p>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method processes any incoming connection requests and returns a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> that you can use to communicate data with the remote host. Use this returned <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. Call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling the <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. To communicate data, call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n</li><li>\n<p>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method to accept any incoming datagrams. Use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to send datagrams to a remote host.</p>\n</li></ul>\n<p>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</p>\n<ul><li>\n<p>If you are using a connection-oriented protocol such as TCP, use the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> methods to connect with a listening host. Use the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> methods to communicate data asynchronously. Incoming connection requests can be processed using <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>If you are using a connectionless protocol such as UDP, you can use <xref href=\"System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> to send datagrams, and <xref href=\"System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>and<xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> to receive datagrams.</p>\n</li></ul>\n<p>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</p>\n<p>When you are finished sending and receiving data, use the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method to disable the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. After calling <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref>, call the <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method to release all resources associated with the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class allows you to configure your <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. Retrieve these settings using the <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are writing a relatively simple application and do not require maximum performance, consider using <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.UdpClient\" data-throw-if-not-resolved=\"false\"></xref>. These classes provide a simpler and more user-friendly interface to <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> communications.</p>\n"
  example:
  - "\n<p>The following code example shows how the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class can be used to send data to an HTTP server and receive the response. This example blocks until the entire page is received.</p>System.Net.Sockets.Socket#1"
  syntax:
    content: 'public class Socket : IDisposable'
    content.vb: >-
      Public Class Socket
          Implements IDisposable
  seealso:
  - type: System.Net
    commentId: N:System.Net
  - type: System.Net.Cache
    commentId: N:System.Net.Cache
  - type: System.Net.Security
    commentId: N:System.Net.Security
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  commentId: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  id: '#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)'
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Socket(AddressFamily, SocketType, ProtocolType)
  fullName: System.Net.Sockets.Socket.Socket(System.Net.Sockets.AddressFamily, System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 160
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class using the specified address family, socket type and protocol.</p>\n"
  remarks: "\n<p>The <em>addressFamily</em> parameter specifies the addressing scheme that the<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class uses, the <em>socketType</em> parameter specifies the type of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class, and the <em>protocolType</em> parameter specifies the protocol used by <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. The three parameters are not independent. Some address families restrict which protocols can be used with them, and often the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> type is implicit in the protocol. If the combination of address family, <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> type, and protocol type results in an invalid <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, this constructor throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If this constructor throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to create an instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Socket_Send_Recieve#1"
  syntax:
    content: public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType)
    content.vb: Public Sub New(addressFamily As AddressFamily, socketType As SocketType, protocolType As ProtocolType)
    parameters:
    - id: addressFamily
      type: System.Net.Sockets.AddressFamily
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: socketType
      type: System.Net.Sockets.SocketType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: protocolType
      type: System.Net.Sockets.ProtocolType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>The combination of <em>addressFamily</em>, <em>socketType</em>, and <em>protocolType</em> results in an invalid socket. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
  - type: System.Net.Sockets.AddressFamily
    commentId: T:System.Net.Sockets.AddressFamily
  - type: System.Net.Sockets.ProtocolType
    commentId: T:System.Net.Sockets.ProtocolType
  - type: System.Net.Sockets.SocketType
    commentId: T:System.Net.Sockets.SocketType
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  commentId: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)
  id: '#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)'
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Socket(SocketType, ProtocolType)
  fullName: System.Net.Sockets.Socket.Socket(System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 161
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class using the specified socket type and protocol.</p>\n"
  remarks: "\n<p>The <em>socketType</em> parameter specifies the type of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class and the <em>protocolType</em> parameter specifies the protocol used by <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. The two parameters are not independent. Often the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> type is implicit in the protocol. If the combination of <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> type and protocol type results in an invalid <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, this constructor throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If this constructor throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Socket(SocketType socketType, ProtocolType protocolType)
    content.vb: Public Sub New(socketType As SocketType, protocolType As ProtocolType)
    parameters:
    - id: socketType
      type: System.Net.Sockets.SocketType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: protocolType
      type: System.Net.Sockets.ProtocolType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>The combination of  <em>socketType</em> and <em>protocolType</em> results in an invalid socket. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.AddressFamily
  commentId: P:System.Net.Sockets.Socket.AddressFamily
  id: AddressFamily
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: AddressFamily
  fullName: System.Net.Sockets.Socket.AddressFamily
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddressFamily
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 162
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the address family of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> specifies the addressing scheme that an instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class can use. This property is read-only and is set when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is created.</p>\n"
  example:
  - "\n<p>The following code example displays the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> to the console.</p>Socket_Socket_Options#3"
  syntax:
    content: public AddressFamily AddressFamily { get; }
    content.vb: Public ReadOnly Property AddressFamily As AddressFamily
    parameters: []
    return:
      type: System.Net.Sockets.AddressFamily
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  seealso:
  - type: System.Net.Sockets.AddressFamily
    commentId: T:System.Net.Sockets.AddressFamily
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.Available
  commentId: P:System.Net.Sockets.Socket.Available
  id: Available
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Available
  fullName: System.Net.Sockets.Socket.Available
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Available
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 163
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the amount of data that has been received from the network and is available to be read.</p>\n"
  remarks: "\n<p>If you are using a non-blocking <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is a good way to determine whether data is queued for reading, before calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> returns 0.</p>\n<p>If the remote host shuts down or closes the connection, <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> can throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</p>NCLSocketIoControl#1"
  syntax:
    content: public int Available { get; }
    content.vb: Public ReadOnly Property Available As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The number of bytes of data received from the network and available to be read.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.IO.Stream
    commentId: T:System.IO.Stream
  - type: System.Net.Sockets.SocketType.Dgram
    commentId: F:System.Net.Sockets.SocketType.Dgram
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.Blocking
  commentId: P:System.Net.Sockets.Socket.Blocking
  id: Blocking
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Blocking
  fullName: System.Net.Sockets.Socket.Blocking
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Blocking
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 164
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is in blocking mode.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property indicates whether a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is in blocking mode.</p>\n<p>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes. If you want execution to continue even though the requested operation is not complete, change the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong>. The <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property has no effect on asynchronous methods. If you are sending and receiving data asynchronously and want to block execution, use the <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public bool Blocking { get; set; }
    content.vb: Public Property Blocking As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> will block; otherwise, <strong>false</strong>. The default is <strong>true</strong>.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Connected
  commentId: P:System.Net.Sockets.Socket.Connected
  id: Connected
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Connected
  fullName: System.Net.Sockets.Socket.Connected
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connected
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 165
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets a value that indicates whether a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is connected to a remote host as of the last <see cref=\"Overload:System.Net.Sockets.Socket.Send\"></see> or <see cref=\"Overload:System.Net.Sockets.Socket.Receive\"></see> operation.</p>\n"
  remarks: "\n<p>The <strong>Connected</strong> property gets the connection state of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> as of the last I/O operation. When it returns <strong>false</strong>, the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> was either never connected, or is no longer connected.</p>\n<p>The value of the <xref href=\"System.Net.Sockets.Socket.Connected\" data-throw-if-not-resolved=\"false\"></xref> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</p>\n<p>If you call <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see> on a User Datagram Protocol (UDP) socket, the <xref href=\"System.Net.Sockets.Socket.Connected\" data-throw-if-not-resolved=\"false\"></xref> property always returns <strong>true</strong>; however, this action does not change the inherent connectionless nature of UDP.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint, checks the <xref href=\"System.Net.Sockets.Socket.Connected\" data-throw-if-not-resolved=\"false\"></xref> property, and checks the current state of the connection.</p>Classic Socket.Connect Example#1"
  syntax:
    content: public bool Connected { get; }
    content.vb: Public ReadOnly Property Connected As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> was connected to a remote resource as of the most recent operation; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.DontFragment
  commentId: P:System.Net.Sockets.Socket.DontFragment
  id: DontFragment
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: DontFragment
  fullName: System.Net.Sockets.Socket.DontFragment
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DontFragment
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 166
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> allows Internet Protocol (IP) datagrams to be fragmented.</p>\n"
  remarks: "\n<p>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <xref href=\"System.Net.Sockets.Socket.DontFragment\" data-throw-if-not-resolved=\"false\"></xref> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</p>\n<p>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.DontFragment\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#2"
  syntax:
    content: public bool DontFragment { get; set; }
    content.vb: Public Property DontFragment As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> allows datagram fragmentation; otherwise, <strong>false</strong>. The default is <strong>true</strong>.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> families. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.DualMode
  commentId: P:System.Net.Sockets.Socket.DualMode
  id: DualMode
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: DualMode
  fullName: System.Net.Sockets.Socket.DualMode
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DualMode
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 167
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is a dual-mode socket used for both IPv4 and IPv6.</p>\n"
  syntax:
    content: public bool DualMode { get; set; }
    content.vb: Public Property DualMode As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is a  dual-mode socket; otherwise, <strong>false</strong>. The default is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.EnableBroadcast
  commentId: P:System.Net.Sockets.Socket.EnableBroadcast
  id: EnableBroadcast
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: EnableBroadcast
  fullName: System.Net.Sockets.Socket.EnableBroadcast
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnableBroadcast
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 168
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> can send or receive broadcast packets.</p>\n"
  remarks: "\n<p>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</p>\n<p>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.EnableBroadcast\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#2"
  syntax:
    content: public bool EnableBroadcast { get; set; }
    content.vb: Public Property EnableBroadcast As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> allows broadcast packets; otherwise, <strong>false</strong>. The default is <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>This option is valid for a datagram socket only. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ExclusiveAddressUse
  commentId: P:System.Net.Sockets.Socket.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ExclusiveAddressUse
  fullName: System.Net.Sockets.Socket.ExclusiveAddressUse
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExclusiveAddressUse
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 169
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> allows only one process to bind to a port.</p>\n"
  remarks: "\n<p>If <xref href=\"System.Net.Sockets.Socket.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, multiple sockets can use the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port. If more than one socket attempts to use the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port. </p>\n<p>If <xref href=\"System.Net.Sockets.Socket.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the first use of the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to attempt to bind to that port will fail until the original bound socket is destroyed. </p>\n<p>This property must be set before <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> is called; otherwise an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> will be thrown.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    content.vb: Public Property ExclusiveAddressUse As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> allows only one socket to bind to a specific port; otherwise, <strong>false</strong>. The default is <strong>true</strong> for Windows Server 2003 and Windows XP Service Pack 2, and <strong>false</strong> for all other versions.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> has been called for this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.IsBound
  commentId: P:System.Net.Sockets.Socket.IsBound
  id: IsBound
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: IsBound
  fullName: System.Net.Sockets.Socket.IsBound
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsBound
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 170
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is bound to a specific local port.</p>\n"
  remarks: "\n<p>A socket is considered bound to a local port if it is explicitly bound by calling the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, or implicitly bound by calling members like <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method to bind to a well-known port so that clients may connect to them.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.IsBound\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public bool IsBound { get; }
    content.vb: Public ReadOnly Property IsBound As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is bound to a local port; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.LingerState
  commentId: P:System.Net.Sockets.Socket.LingerState
  id: LingerState
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: LingerState
  fullName: System.Net.Sockets.Socket.LingerState
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LingerState
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 171
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies whether the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> will delay closing a socket in an attempt to send all pending data.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property changes the way <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior. </p>\n<p>This property controls the length of time that a connection-oriented connection will remain open after a call to <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> when data remains to be sent.</p>\n<p>When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref href=\"System.Net.Sockets.TcpClient.Close\" data-throw-if-not-resolved=\"false\"></xref> method drops the connection.</p>\n<p>To enable lingering, create a <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> instance containing the desired values, and set the <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property to this instance.</p>\n<p>The following table describes the behavior of the <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method for the possible values of the <xref href=\"System.Net.Sockets.LingerOption.Enabled\" data-throw-if-not-resolved=\"false\"></xref> property and the <xref href=\"System.Net.Sockets.LingerOption.LingerTime\" data-throw-if-not-resolved=\"false\"></xref> property stored in the <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>LingerState.Enabled</p>\n<p>LingerState.LingerTime</p>\n<p>Behavior</p>\n<p>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property is not set.</p>\n<p>When the <xref href=\"System.Net.Sockets.LingerOption.LingerTime\" data-throw-if-not-resolved=\"false\"></xref> property stored in the <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override. </p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public LingerOption LingerState { get; set; }
    content.vb: Public Property LingerState As LingerOption
    parameters: []
    return:
      type: System.Net.Sockets.LingerOption
      description: "\n<p>A <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> that specifies how to linger while closing a socket.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.LocalEndPoint
  commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  id: LocalEndPoint
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: LocalEndPoint
  fullName: System.Net.Sockets.Socket.LocalEndPoint
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LocalEndPoint
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 172
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the local endpoint.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property gets an <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that contains the local IP address and port number to which your <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is bound. You must cast this <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> before retrieving any information. You can then call the <xref href=\"System.Net.IPEndPoint.Address\" data-throw-if-not-resolved=\"false\"></xref> method to retrieve the local <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref>, and the <xref href=\"System.Net.IPEndPoint.Port\" data-throw-if-not-resolved=\"false\"></xref> method to retrieve the local port number.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property is usually set after you make a call to the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you allow the system to assign your socket's local IP address and port number, the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example retrieves and displays the local and remote endpoints.</p>Socket_Socket_Options#4"
  syntax:
    content: public EndPoint LocalEndPoint { get; }
    content.vb: Public ReadOnly Property LocalEndPoint As EndPoint
    parameters: []
    return:
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is using for communications.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.EndPoint
    commentId: T:System.Net.EndPoint
  - type: System.Net.IPEndPoint
    commentId: T:System.Net.IPEndPoint
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.MulticastLoopback
  commentId: P:System.Net.Sockets.Socket.MulticastLoopback
  id: MulticastLoopback
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: MulticastLoopback
  fullName: System.Net.Sockets.Socket.MulticastLoopback
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MulticastLoopback
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 173
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</p>\n"
  remarks: "\n<p>Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address. </p>\n<p>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.MulticastLoopback\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#2"
  syntax:
    content: public bool MulticastLoopback { get; set; }
    content.vb: Public Property MulticastLoopback As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> receives outgoing multicast packets; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.NoDelay
  commentId: P:System.Net.Sockets.Socket.NoDelay
  id: NoDelay
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: NoDelay
  fullName: System.Net.Sockets.Socket.NoDelay
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NoDelay
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 174
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the stream <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is using the Nagle algorithm.</p>\n"
  remarks: "\n<p>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</p>\n<p>The majority of network applications should use the Nagle algorithm.</p>\n<p>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.NoDelay\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public bool NoDelay { get; set; }
    content.vb: Public Property NoDelay As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>false</strong> if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> uses the Nagle algorithm; otherwise, <strong>true</strong>. The default is <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.OSSupportsIPv4
  commentId: P:System.Net.Sockets.Socket.OSSupportsIPv4
  id: OSSupportsIPv4
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: OSSupportsIPv4
  fullName: System.Net.Sockets.Socket.OSSupportsIPv4
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OSSupportsIPv4
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 175
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</p>\n"
  remarks: "\n<p>The operating system may support both IPv4 and IPv6 protocols.</p>\n"
  example:
  - 
  syntax:
    content: public static bool OSSupportsIPv4 { get; }
    content.vb: Public Shared ReadOnly Property OSSupportsIPv4 As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the operating system and network adaptors support the IPv4 protocol; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.OSSupportsIPv6
    commentId: P:System.Net.Sockets.Socket.OSSupportsIPv6
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Net.Sockets.Socket.OSSupportsIPv6
  commentId: P:System.Net.Sockets.Socket.OSSupportsIPv6
  id: OSSupportsIPv6
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: OSSupportsIPv6
  fullName: System.Net.Sockets.Socket.OSSupportsIPv6
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OSSupportsIPv6
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 176
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</p>\n"
  remarks: "\n<p>The operating system may support both IPv4 and IPv6 protocols.</p>\n"
  example:
  - 
  syntax:
    content: public static bool OSSupportsIPv6 { get; }
    content.vb: Public Shared ReadOnly Property OSSupportsIPv6 As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the operating system and network adaptors support the IPv6 protocol; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.OSSupportsIPv4
    commentId: P:System.Net.Sockets.Socket.OSSupportsIPv4
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Net.Sockets.Socket.ProtocolType
  commentId: P:System.Net.Sockets.Socket.ProtocolType
  id: ProtocolType
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ProtocolType
  fullName: System.Net.Sockets.Socket.ProtocolType
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ProtocolType
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 177
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the protocol type of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> property is set when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is created, and specifies the protocol used by that <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example displays the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> to the console.</p>Socket_Socket_Options#3"
  syntax:
    content: public ProtocolType ProtocolType { get; }
    content.vb: Public ReadOnly Property ProtocolType As ProtocolType
    parameters: []
    return:
      type: System.Net.Sockets.ProtocolType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.ReceiveBufferSize
  commentId: P:System.Net.Sockets.Socket.ReceiveBufferSize
  id: ReceiveBufferSize
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveBufferSize
  fullName: System.Net.Sockets.Socket.ReceiveBufferSize
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveBufferSize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 178
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies the size of the receive buffer of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.ReceiveBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public int ReceiveBufferSize { get; set; }
    content.vb: Public Property ReceiveBufferSize As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>An <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that contains the size, in bytes, of the receive buffer. The default is 8192.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value specified for a set operation is less than 0.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ReceiveTimeout
  commentId: P:System.Net.Sockets.Socket.ReceiveTimeout
  id: ReceiveTimeout
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveTimeout
  fullName: System.Net.Sockets.Socket.ReceiveTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveTimeout
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 179
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies the amount of time after which a synchronous <see cref=\"Overload:System.Net.Sockets.Socket.Receive\"></see> call will time out.</p>\n"
  remarks: "\n<p>This option applies to synchronous <see cref=\"Overload:System.Net.Sockets.Socket.Receive\"></see> calls only. If the time-out period is exceeded, the <see cref=\"Overload:System.Net.Sockets.Socket.Receive\"></see> method will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public int ReceiveTimeout { get; set; }
    content.vb: Public Property ReceiveTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value specified for a set operation is less than -1.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.RemoteEndPoint
  commentId: P:System.Net.Sockets.Socket.RemoteEndPoint
  id: RemoteEndPoint
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: RemoteEndPoint
  fullName: System.Net.Sockets.Socket.RemoteEndPoint
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RemoteEndPoint
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 180
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the remote endpoint.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol, the <xref href=\"System.Net.Sockets.Socket.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property gets the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that contains the remote IP address and port number to which the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is connected. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> contains the default remote IP address and port number with which the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> will communicate. You must cast this <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> before retrieving any information. You can then call the <xref href=\"System.Net.IPEndPoint.Address\" data-throw-if-not-resolved=\"false\"></xref> method to retrieve the remote <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref>, and the <xref href=\"System.Net.IPEndPoint.Port\" data-throw-if-not-resolved=\"false\"></xref> method to retrieve the remote port number.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> is set after a call to either <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. If you try to access this property earlier, <xref href=\"System.Net.Sockets.Socket.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example retrieves and displays the local and remote endpoints.</p>Socket_Socket_Options#4"
  syntax:
    content: public EndPoint RemoteEndPoint { get; }
    content.vb: Public ReadOnly Property RemoteEndPoint As EndPoint
    parameters: []
    return:
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> with which the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is communicating.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.EndPoint
    commentId: T:System.Net.EndPoint
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Accept
    commentId: M:System.Net.Sockets.Socket.Accept
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.SendBufferSize
  commentId: P:System.Net.Sockets.Socket.SendBufferSize
  id: SendBufferSize
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendBufferSize
  fullName: System.Net.Sockets.Socket.SendBufferSize
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendBufferSize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 181
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies the size of the send buffer of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.SendBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1<p></p>"
  syntax:
    content: public int SendBufferSize { get; set; }
    content.vb: Public Property SendBufferSize As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>An <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that contains the size, in bytes, of the send buffer. The default is 8192.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value specified for a set operation is less than 0.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SendTimeout
  commentId: P:System.Net.Sockets.Socket.SendTimeout
  id: SendTimeout
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendTimeout
  fullName: System.Net.Sockets.Socket.SendTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTimeout
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 182
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies the amount of time after which a synchronous <see cref=\"Overload:System.Net.Sockets.Socket.Send\"></see> call will time out.</p>\n"
  remarks: "\n<p>This option applies to synchronous <see cref=\"Overload:System.Net.Sockets.Socket.Send\"></see> calls only. If the time-out period is exceeded, the <see cref=\"Overload:System.Net.Sockets.Socket.Send\"></see> method will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public int SendTimeout { get; set; }
    content.vb: Public Property SendTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value specified for a set operation is less than -1.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SocketType
  commentId: P:System.Net.Sockets.Socket.SocketType
  id: SocketType
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SocketType
  fullName: System.Net.Sockets.Socket.SocketType
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SocketType
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 183
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the type of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.SocketType\" data-throw-if-not-resolved=\"false\"></xref> is read-only and is set when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is created.</p>\n"
  example:
  - "\n<p>The following code example displays the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> to the console.</p>Socket_Socket_Options#3"
  syntax:
    content: public SocketType SocketType { get; }
    content.vb: Public ReadOnly Property SocketType As SocketType
    parameters: []
    return:
      type: System.Net.Sockets.SocketType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  seealso:
  - type: System.Net.Sockets.SocketType
    commentId: T:System.Net.Sockets.SocketType
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.Socket.Ttl
  commentId: P:System.Net.Sockets.Socket.Ttl
  id: Ttl
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Ttl
  fullName: System.Net.Sockets.Socket.Ttl
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ttl
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 184
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) \"TTL exceeded\" error message is returned to the sender.</p>\n<p>The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32. </p>\n<p>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.Socket.Ttl\" data-throw-if-not-resolved=\"false\"></xref> property.</p>SocketPropertyTester#1"
  syntax:
    content: public short Ttl { get; set; }
    content.vb: Public Property Ttl As Short
    parameters: []
    return:
      type: System.Int16
      description: "\n<p>The TTL value.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The TTL value can't be set to a negative number.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> families.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Accept
  commentId: M:System.Net.Sockets.Socket.Accept
  id: Accept
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Accept()
  fullName: System.Net.Sockets.Socket.Accept()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Accept
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 185
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Creates a new <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for a newly created connection.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. You cannot use this returned <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to accept any additional connections from the connection queue. However, you can call the <xref href=\"System.Net.Sockets.Socket.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> method of the returned <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to identify the remote host's network address and port number.</p>\n<p>In blocking mode, <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> continues queuing incoming connection requests until you close it.</p>\n<p>If you call this method using a non-blocking <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, and no connection requests are queued, <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>Before calling the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method, you must first call the <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to listen for and queue incoming connection requests.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example accepts a simple <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection.</p>Classic Socket.Accept Example#1"
  syntax:
    content: public Socket Accept()
    content.vb: Public Function Accept As Socket
    return:
      type: System.Net.Sockets.Socket
      description: "\n<p>A <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for a newly created connection.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Listen(System.Int32)
    commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  - type: System.Net.Sockets.Socket.RemoteEndPoint
    commentId: P:System.Net.Sockets.Socket.RemoteEndPoint
  - type: System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)
    commentId: M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: AcceptAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AcceptAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 186
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins an asynchronous operation to accept an incoming connection attempt.</p>\n"
  remarks: "\n<p>Connection-oriented protocols can use the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, you must call the <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to listen for and queue incoming connection requests.</p>\n<p>To be notified of completion, you must create a callback method that implements the EventHandler<SocketAsyncEventArgs> delegate and hook it to the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller can optionally specify an existing <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to use for the incoming connection by specifying the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to use with the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>If the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> property is null, a new <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is constructed with the same <xref href=\"System.Net.Sockets.Socket.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.SocketType\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.Socket.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> as the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> and set as the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method succeeds. In this case, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the buffer containing the data to receive and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <see cref=\"Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer\"></see> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> property on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</p>\n<p>The completion callback method should examine the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketError\" data-throw-if-not-resolved=\"false\"></xref> property to determine if the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> operation was successful.</p>\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event can occur in some cases when no connection has been accepted and cause the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketError\" data-throw-if-not-resolved=\"false\"></xref> property to be set to <xref href=\"System.Net.Sockets.SocketError.ConnectionReset\" data-throw-if-not-resolved=\"false\"></xref>. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence). Applications using the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method should be prepared to handle this condition. </p>\n"
  example:
  - 
  syntax:
    content: public bool AcceptAsync(SocketAsyncEventArgs e)
    content.vb: Public Function AcceptAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation.</p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes. </p>\n<p>This exception also occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref> property is not null.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>An argument is out of range. The exception occurs if the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> is less than 0.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>An invalid operation was requested. This exception occurs if the accepting <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is not listening for connections or the accepted socket is bound. </p>\n<p>You must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method before calling the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <em>e</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  id: Bind(System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Bind(EndPoint)
  fullName: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bind
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 187
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Associates a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> with a local endpoint.</p>\n"
  remarks: "\n<p>Use the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method if you need to use a specific local endpoint. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before you can call the <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. You do not need to call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before using the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method unless you need to use a specific local endpoint. You can use the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method on both connectionless and connection-oriented protocols.</p>\n<p>Before calling <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, you must first create the local <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> using <xref href=\"System.Net.IPAddress.Any\" data-throw-if-not-resolved=\"false\"></xref> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.</p>\n<p>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> will not return the locally assigned network address until after you have made a call to the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</p>\n<p>If a UDP socket wants to receive interface information on received packets,  the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method should be explicitly called with the socket option set to <xref href=\"System.Net.Sockets.SocketOptionName.PacketInformation\" data-throw-if-not-resolved=\"false\"></xref> immediately after calling the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you intend to receive multicast datagrams, you must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method with a multicast port number.</p>\n<p>You must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method if you intend to receive connectionless datagrams using the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> when calling the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example binds a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> using the specified local endpoint.</p>Classic Socket.Bind Example#1"
  syntax:
    content: public void Bind(EndPoint localEP)
    content.vb: Public Sub Bind(localEP As EndPoint)
    parameters:
    - id: localEP
      type: System.Net.EndPoint
      description: "\n<p>The local <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> to associate with the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>localEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation. </p>\n"
  seealso:
  - type: System.Net.IPEndPoint
    commentId: T:System.Net.IPEndPoint
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Listen(System.Int32)
    commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  - type: System.Net.IPAddress
    commentId: T:System.Net.IPAddress
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: CancelConnectAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CancelConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 188
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Cancels an asynchronous request for a remote host connection.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method cancels an asynchronous request for a remote host connection. </p>\n"
  example:
  - 
  syntax:
    content: public static void CancelConnectAsync(SocketAsyncEventArgs e)
    content.vb: Public Shared Sub CancelConnectAsync(e As SocketAsyncEventArgs)
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object used to request the connection to the remote host by calling one of the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>e</em> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  id: Connect(System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Connect(EndPoint)
  fullName: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connect
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 189
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Establishes a connection to a remote host.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol such as TCP, the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method synchronously establishes a network connection between <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> and the specified remote endpoint. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host. After you call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, you can send data to the remote device with the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method, or receive data from the remote device with the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> to synchronously communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method will block, unless you specifically set the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> prior to calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, but has not yet completed successfully. Use the <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method to determine when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is finished connecting.</p>\n<p>If you are using a connection-oriented protocol and did not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> again with the desired endpoint.</p>\n<p>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see> methods to reconnect. This is a limitation of the underlying provider.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint and then verifies the connection.</p>Classic Socket.Connect Example#1"
  syntax:
    content: public void Connect(EndPoint remoteEP)
    content.vb: Public Sub Connect(remoteEP As EndPoint)
    parameters:
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the remote device. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>ing.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.Socket.Blocking
    commentId: P:System.Net.Sockets.Socket.Blocking
  - type: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
    commentId: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)
  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)
  id: Connect(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Connect(IPAddress, Int32)
  fullName: System.Net.Sockets.Socket.Connect(System.Net.IPAddress, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connect
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 190
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Establishes a connection to a remote host. The host is specified by an IP address and a port number.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol such as TCP, the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method synchronously establishes a network connection between <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> and the specified remote endpoint. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host. After you call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> you can send data to the remote device with the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method, or receive data from the remote device with the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> to synchronously communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>\n<xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method will block, unless you specifically set the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> prior to calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, but has not yet completed successfully. Use the <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method to determine when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is finished connecting.</p>\n<p>If you are using a connection-oriented protocol and did not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> again with the desired endpoint.</p>\n<p>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see> methods to reconnect. This is a limitation of the underlying provider.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint and then verifies the connection.</p>System.Net.Sockets.Socket.BeginConnect#4"
  syntax:
    content: public void Connect(IPAddress address, int port)
    content.vb: Public Sub Connect(address As IPAddress, port As Integer)
    parameters:
    - id: address
      type: System.Net.IPAddress
      description: "\n<p>The IP address of the remote host.</p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number of the remote host.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>address</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The port number is not valid.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> families.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>address</em> is zero.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>ing.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)
  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)
  id: Connect(System.Net.IPAddress[],System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Connect(IPAddress[], Int32)
  fullName: System.Net.Sockets.Socket.Connect(System.Net.IPAddress[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connect
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 191
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.</p>\n"
  remarks: "\n<p>This method is typically used immediately after a call to <xref href=\"System.Net.Dns.GetHostAddresses(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method synchronously establishes a network connection between <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> and the specified remote endpoint. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host. After you call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> you can send data to the remote device with the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method, or receive data from the remote device with the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> to synchronously communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>\n<xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method will block, unless you specifically set the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> prior to calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, but has not yet completed successfully. Use the <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method to determine when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is finished connecting.</p>\n<p>If you are using a connection-oriented protocol and did not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> again with the desired endpoint.</p>\n<p>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see> methods to reconnect. This is a limitation of the underlying provider.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint and then verifies the connection.</p>System.Net.Sockets.Socket.BeginConnect#5"
  syntax:
    content: public void Connect(IPAddress[] addresses, int port)
    content.vb: Public Sub Connect(addresses As IPAddress(), port As Integer)
    parameters:
    - id: addresses
      type: System.Net.IPAddress[]
      description: "\n<p>The IP addresses of the remote host.</p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number of the remote host.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>addresses</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The port number is not valid.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> families.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>address</em> is zero.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>ing.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Connect(System.Net.IPAddress(), System.Int32)
  name.vb: Connect(IPAddress(), Int32)
- uid: System.Net.Sockets.Socket.Connect(System.String,System.Int32)
  commentId: M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)
  id: Connect(System.String,System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Connect(String, Int32)
  fullName: System.Net.Sockets.Socket.Connect(System.String, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connect
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 192
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Establishes a connection to a remote host. The host is specified by a host name and a port number.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol such as TCP, the <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method synchronously establishes a network connection between <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> and the specified remote host. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host. After you call <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> you can send data to the remote device with the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method, or receive data from the remote device with the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> to synchronously communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>\n<xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method will block, unless you specifically set the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> prior to calling <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, but has not yet completed successfully. Use the <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method to determine when the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is finished connecting.</p>\n<p>If IPv6 is enabled and the <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</p>\n<p>If you are using a connection-oriented protocol and did not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref href=\"System.Net.Sockets.Socket.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> again with the desired endpoint.</p>\n<p>If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see> methods to reconnect. This is a limitation of the underlying provider.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint and then verifies the connection.</p>System.Net.Sockets.Socket.BeginConnect#6"
  syntax:
    content: public void Connect(string host, int port)
    content.vb: Public Sub Connect(host As String, port As Integer)
    parameters:
    - id: host
      type: System.String
      description: "\n<p>The name of the remote host.</p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number of the remote host.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>host</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The port number is not valid.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> families.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>ing.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ConnectAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 193
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins an asynchronous request for a connection to a remote host.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol, the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host. </p>\n<p>To be notified of completion, you must create a callback method that implements the EventHandler<SocketAsyncEventArgs> delegate and attach the callback to the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>The caller must set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property to the <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> of the remote host to connect to.</p>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> to communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method again with the desired endpoint. </p>\n<p>If you wish to set the default remote host to a broadcast address, you must first call <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> and set Broadcast to <strong>true</strong>. If this is not done, the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method succeeds. In this case, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the buffer containing the data to send and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.</p>\n<p>If you are using a connection-oriented protocol and do not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the most appropriate local network address and port number. </p>\n<p>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method throws <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> if the address family of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> are not the same address family. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> when calling this method, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - 
  syntax:
    content: public bool ConnectAsync(SocketAsyncEventArgs e)
    content.vb: Public Function ConnectAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref> property is not null. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>e</em> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> are not the same address family.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation.</p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)
  id: ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType, System.Net.Sockets.ProtocolType, System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 194
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins an asynchronous request for a connection to a remote host.</p>\n"
  remarks: "\n<p>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> establishes a default remote host specified by the <em>socketType</em> and <em>protocolType</em> parameters. </p>\n<p>To be notified of completion, you must create a callback method that implements the EventHandler<SocketAsyncEventArgs> delegate and attach the callback to the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>The caller must set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property to the <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> of the remote host to connect to.</p>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>If you are using a connectionless protocol such as UDP, you do not have to call <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> before sending and receiving data. You can use <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> to communicate with a remote host. If you do call <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method again with the desired endpoint. </p>\n<p>If you wish to set the default remote host to a broadcast address, you must first call <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> and set Broadcast to <strong>true</strong>. If this is not done, the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method succeeds. In this case, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the buffer containing the data to send and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.</p>\n<p>If you are using a connection-oriented protocol and do not call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, the underlying service provider will assign the most appropriate local network address and port number. </p>\n<p>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method throws <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> if the address family of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> are not the same address family. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> when calling this method, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - 
  syntax:
    content: public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e)
    content.vb: Public Shared Function ConnectAsync(socketType As SocketType, protocolType As ProtocolType, e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: socketType
      type: System.Net.Sockets.SocketType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: protocolType
      type: System.Net.Sockets.ProtocolType
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref> property is not null. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>e</em> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> are not the same address family.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Net.Sockets.Socket.Dispose
  commentId: M:System.Net.Sockets.Socket.Dispose
  id: Dispose
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Net.Sockets.Socket.Dispose()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 195
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Releases all resources used by the current instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Call <strong>Dispose</strong> when you are finished using the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. The <strong>Dispose</strong> method leaves the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> in an unusable state. After calling <strong>Dispose</strong>, you must release all references to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> so the garbage collector can reclaim the memory that the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> was occupying.</p>\n<p>For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>\n<p>Always call <strong>Dispose</strong> before you release your last reference to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> object's <strong>Finalize</strong> method.</p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Dispose(System.Boolean)
  commentId: M:System.Net.Sockets.Socket.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Net.Sockets.Socket.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 196
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, and optionally disposes of the managed resources.</p>\n"
  remarks: "\n<p>This method is called by the public <strong>Dispose()</strong> method and the <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method. <strong>Dispose()</strong> invokes the protected <strong>Dispose(Boolean)</strong> method with the <em>disposing</em> parameter set to <strong>true</strong>. <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> invokes <strong>Dispose</strong> with <em>disposing</em> set to <strong>false</strong>.</p>\n<p>When the <em>disposing</em> parameter is <strong>true</strong>, this method releases all resources held by any managed objects that this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> references. This method invokes the <strong>Dispose()</strong> method of each referenced object.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: protected virtual void Dispose(bool disposing)
    content.vb: Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to release both managed and unmanaged resources; <strong>false</strong> to releases only unmanaged resources. </p>\n"
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Net.Sockets.Socket.Finalize
  commentId: M:System.Net.Sockets.Socket.Finalize
  id: Finalize
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Finalize()
  fullName: System.Net.Sockets.Socket.Finalize()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Finalize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 197
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Frees resources used by the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class finalizer calls the <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method to close the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> and free resources associated with the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: protected void Finalize()
    content.vb: Protected Sub Finalize
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: GetSocketOption(SocketOptionLevel, SocketOptionName)
  fullName: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 198
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Returns the value of a specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option, represented as an object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Use this overload to get the <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\" data-throw-if-not-resolved=\"false\"></xref><xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options. For the <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref> option, use <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for the <em>optionLevel</em> parameter. For <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketOptionLevel.IP\" data-throw-if-not-resolved=\"false\"></xref>. If you want to set the value of any of the options listed above, use the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example retrieves the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time-out values and displays them to the console.</p>Socket_Socket_Options#2"
  syntax:
    content: public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName)
    content.vb: Public Function GetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Object
      description: "\n<p>An object that represents the value of the option. When the <em>optionName</em> parameter is set to <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref> the return value is an instance of the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> class. When <em>optionName</em> is set to <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\" data-throw-if-not-resolved=\"false\"></xref>, the return value is an instance of the <xref href=\"System.Net.Sockets.MulticastOption\" data-throw-if-not-resolved=\"false\"></xref> class. When <em>optionName</em> is any other value, the return value is an integer.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information.</p>\n<p>-or-</p>\n<p>\n<em>optionName</em> was set to the unsupported value <xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])
  fullName: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 199
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Returns the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option setting, represented as a byte array.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Upon successful completion of this method, the array specified by the <em>optionValue</em> parameter contains the value of the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option.</p>\n<p>When the length of the <em>optionValue</em> array is smaller than the number of bytes required to store the value of the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option, <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use this overload for any sockets that are represented by Boolean values or integers.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example retrieves the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time-out values and displays them to the console.</p>Socket_Socket_Options#2"
  syntax:
    content: public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue)
    content.vb: Public Sub GetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionValue
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is to receive the option setting. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n<p>- or -</p>\n<p>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <see cref=\"Overload:System.Net.Sockets.Socket.SetSocketOption\"></see>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte())
  name.vb: GetSocketOption(SocketOptionLevel, SocketOptionName, Byte())
- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)
  fullName: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 200
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Returns the value of the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option in an array.</p>\n"
  remarks: "\n<p>The <em>optionLength</em> parameter sets the maximum size of the returned byte array. If the option value requires fewer bytes, the array will contain only that many bytes. If the option value requires more bytes, <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. Use this overload for any sockets that are represented by Boolean values or integers.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example retrieves the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time-out values and displays them to the console.</p>Socket_Socket_Options#2"
  syntax:
    content: public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength)
    content.vb: Public Function GetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionLength
      type: System.Int32
      description: "\n<p>The length, in bytes, of the expected return value. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the value of the socket option.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n<p>- or -</p>\n<p>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <see cref=\"Overload:System.Net.Sockets.Socket.SetSocketOption\"></see>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])
  commentId: M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])
  id: IOControl(System.Int32,System.Byte[],System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: IOControl(Int32, Byte[], Byte[])
  fullName: System.Net.Sockets.Socket.IOControl(System.Int32, System.Byte[], System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IOControl
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 201
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> using numerical control codes.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method provides low-level access to the operating system <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> underlying the current instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class. For more information, see the WSAIoctl documentation in the MSDN library.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example compares the results of FIONREAD and the Available property.</p>NCLSocketIoControl#1"
  syntax:
    content: public int IOControl(int ioControlCode, byte[] optionInValue, byte[] optionOutValue)
    content.vb: Public Function IOControl(ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer
    parameters:
    - id: ioControlCode
      type: System.Int32
      description: "\n<p>An <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> value that specifies the control code of the operation to perform. </p>\n"
    - id: optionInValue
      type: System.Byte[]
      description: "\n<p>A <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> array that contains the input data required by the operation. </p>\n"
    - id: optionOutValue
      type: System.Byte[]
      description: "\n<p>A <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> array that contains the output data returned by the operation. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes in the <em>optionOutValue</em> parameter.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.IOControl(System.Int32, System.Byte(), System.Byte())
  name.vb: IOControl(Int32, Byte(), Byte())
- uid: System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])
  commentId: M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])
  id: IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: IOControl(IOControlCode, Byte[], Byte[])
  fullName: System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode, System.Byte[], System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IOControl
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 202
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.Net.Sockets.IOControlCode\" data-throw-if-not-resolved=\"false\"></xref> enumeration to specify control codes.</p>\n"
  remarks: "\n<p>This method provides low-level access to the operating system <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> underlying the current instance of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class. For more, see the WSAIoctl documentation in the MSDN library.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example compares the results of calling <xref href=\"System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> with <xref href=\"System.Net.Sockets.IOControlCode.DataToRead\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property.</p>NCLSocketIoControl1#1"
  syntax:
    content: public int IOControl(IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue)
    content.vb: Public Function IOControl(ioControlCode As IOControlCode, optionInValue As Byte(), optionOutValue As Byte()) As Integer
    parameters:
    - id: ioControlCode
      type: System.Net.Sockets.IOControlCode
      description: "\n<p>A <xref href=\"System.Net.Sockets.IOControlCode\" data-throw-if-not-resolved=\"false\"></xref> value that specifies the control code of the operation to perform. </p>\n"
    - id: optionInValue
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the input data required by the operation. </p>\n"
    - id: optionOutValue
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the output data returned by the operation. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes in the <em>optionOutValue</em> parameter.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode, System.Byte(), System.Byte())
  name.vb: IOControl(IOControlCode, Byte(), Byte())
- uid: System.Net.Sockets.Socket.Listen(System.Int32)
  commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  id: Listen(System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Listen(Int32)
  fullName: System.Net.Sockets.Socket.Listen(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Listen
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 203
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Places a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> in a listening state.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> causes a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to listen for incoming connection attempts. The <em>backlog</em> parameter specifies the number of incoming connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\" data-throw-if-not-resolved=\"false\"></xref> value. <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> does not block.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to accept a connection from the queue.</p>\n<p>You must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method before calling <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n<p>The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.</p>\n"
  example:
  - "\n<p>The following code example uses <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to listen for incoming connections.</p>Classic Socket.Listen Example#1"
  syntax:
    content: public void Listen(int backlog)
    content.vb: Public Sub Listen(backlog As Integer)
    parameters:
    - id: backlog
      type: System.Int32
      description: "\n<p>The maximum length of the pending connections queue. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketOptionName.MaxConnections
    commentId: F:System.Net.Sockets.SocketOptionName.MaxConnections
  - type: System.Net.Sockets.Socket.Accept
    commentId: M:System.Net.Sockets.Socket.Accept
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  commentId: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  id: Poll(System.Int32,System.Net.Sockets.SelectMode)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Poll(Int32, SelectMode)
  fullName: System.Net.Sockets.Socket.Poll(System.Int32, System.Net.Sockets.SelectMode)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Poll
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 204
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Determines the status of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method will check the state of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Specify <xref href=\"System.Net.Sockets.SelectMode.SelectRead\" data-throw-if-not-resolved=\"false\"></xref> for the <em>selectMode</em> parameter to determine if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is readable. Specify <xref href=\"System.Net.Sockets.SelectMode.SelectWrite\" data-throw-if-not-resolved=\"false\"></xref> to determine if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is writable. Use <xref href=\"System.Net.Sockets.SelectMode.SelectError\" data-throw-if-not-resolved=\"false\"></xref> to detect an error condition. <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> will block execution until the specified time period, measured in <em>microseconds</em>, elapses. Set the <em>microSeconds</em> parameter to a negative integer if you would like to wait indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the <xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example creates a socket, connects to a server, and uses <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> to check the status of the socket.</p>SelectModeExample#1"
  syntax:
    content: public bool Poll(int microSeconds, SelectMode mode)
    content.vb: Public Function Poll(microSeconds As Integer, mode As SelectMode) As Boolean
    parameters:
    - id: microSeconds
      type: System.Int32
      description: "\n<p>The time to wait for a response, in microseconds. </p>\n"
    - id: mode
      type: System.Net.Sockets.SelectMode
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SelectMode\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>The status of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> based on the polling mode value passed in the <em>mode</em> parameter.</p>\n<p>Mode </p>\n<p>Return Value </p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Net.Sockets.SelectMode.SelectRead\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<strong>true</strong> if <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has been called and a connection is pending; </p>\n<p>-or- </p>\n<p>\n<strong>true</strong> if data is available for reading; </p>\n<p>-or- </p>\n<p>\n<strong>true</strong> if the connection has been closed, reset, or terminated; </p>\n<p>otherwise, returns <strong>false</strong>. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Net.Sockets.SelectMode.SelectWrite\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<strong>true</strong>, if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, and the connection has succeeded; </p>\n<p>-or- </p>\n<p>\n<strong>true</strong> if data can be sent; </p>\n<p>otherwise, returns <strong>false</strong>. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Net.Sockets.SelectMode.SelectError\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<strong>true</strong> if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> that does not block, and the connection has failed; </p>\n<p>-or- </p>\n<p>\n<strong>true</strong> if <xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\" data-throw-if-not-resolved=\"false\"></xref> is not set and out-of-band data is available; </p>\n<p>otherwise, returns <strong>false</strong>. </p>\n</td></tr></tbody></table>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <em>mode</em> parameter is not one of the <xref href=\"System.Net.Sockets.SelectMode\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See remarks below. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SelectMode
    commentId: T:System.Net.Sockets.SelectMode
  - type: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
    commentId: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Receive(System.Byte[])
  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[])
  id: Receive(System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(Byte[])
  fullName: System.Net.Sockets.Socket.Receive(System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 205
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into a receive buffer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> from both connection-oriented and connectionless sockets.</p>\n<p>This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> will read the first queued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffer</em> parameter, <em>buffer</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example receives data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#1"
  syntax:
    content: public int Receive(byte[] buffer)
    content.vb: Public Function Receive(buffer As Byte()) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for the received data. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Byte())
  name.vb: Receive(Byte())
- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  id: Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(Byte[], Int32, Int32, SocketFlags)
  fullName: System.Net.Sockets.Socket.Receive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 206
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives the specified number of bytes from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into the specified offset position of the receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> from both connection-oriented and connectionless sockets.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first queued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffer</em> parameter, <em>buffer</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#4"
  syntax:
    content: public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags)
    content.vb: Public Function Receive(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for received data. </p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The location in <em>buffer</em> to store the received data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em> minus the value of the <em>offset</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property was not set.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
  name.vb: Receive(Byte(), Int32, Int32, SocketFlags)
- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  id: Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(Byte[], Int32, Int32, SocketFlags, out SocketError)
  fullName: System.Net.Sockets.Socket.Receive(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, out System.Net.Sockets.SocketError)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 207
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> from both connection-oriented and connectionless sockets.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first queued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffer</em> parameter, <em>buffer</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode)
    content.vb: Public Function Receive(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for the received data.</p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the <em>buffer</em> parameter to store the received data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: errorCode
      type: System.Net.Sockets.SocketError
      description: "\n<p>A <xref href=\"System.Net.Sockets.SocketError\" data-throw-if-not-resolved=\"false\"></xref> object that stores the socket error.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em> minus the value of the <em>offset</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property is not set.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ByRef System.Net.Sockets.SocketError)
  name.vb: Receive(Byte(), Int32, Int32, SocketFlags, ByRef SocketError)
- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  id: Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(Byte[], Int32, SocketFlags)
  fullName: System.Net.Sockets.Socket.Receive(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 208
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives the specified number of bytes of data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter and returns the number of bytes successfully read. You can call <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> from both connection-oriented and connectionless sockets.</p>\n<p>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry your receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the number of bytes specified by the <em>size</em> parameter. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first queued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffer</em> parameter, <em>buffer</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following receives the data found into <em>buffer</em>, and specifies <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref> for <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Send_Recieve#4"
  syntax:
    content: public int Receive(byte[] buffer, int size, SocketFlags socketFlags)
    content.vb: Public Function Receive(buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for the received data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>size</em> exceeds the size of <em>buffer</em>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Byte(), System.Int32, System.Net.Sockets.SocketFlags)
  name.vb: Receive(Byte(), Int32, SocketFlags)
- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)
  id: Receive(System.Byte[],System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(Byte[], SocketFlags)
  fullName: System.Net.Sockets.Socket.Receive(System.Byte[], System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 209
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> from both connection-oriented and connectionless sockets.</p>\n<p>This overload only requires you to provide a receive buffer and the necessary <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry your receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffer</em> parameter, <em>buffer</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example specifies a data buffer, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> for receiving data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#2"
  syntax:
    content: public int Receive(byte[] buffer, SocketFlags socketFlags)
    content.vb: Public Function Receive(buffer As Byte(), socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for the received data. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Byte(), System.Net.Sockets.SocketFlags)
  name.vb: Receive(Byte(), SocketFlags)
- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(IList<ArraySegment<Byte>>)
  fullName: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 210
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into the list of receive buffers.</p>\n"
  remarks: "\n<p>This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.</p>\n<p>This overload requires you to provide one or more receive buffers.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host connection established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffers</em> parameter, <em>buffers</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>Note   This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Receive(IList<ArraySegment<byte>> buffers)
    content.vb: Public Function Receive(buffers As IList(Of ArraySegment(Of Byte))) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the received data.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>buffer</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred while attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)))
  name.vb: Receive(IList(Of ArraySegment(Of Byte)))
- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(IList<ArraySegment<Byte>>, SocketFlags)
  fullName: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 211
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method reads data into the <em>buffers</em> parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.</p>\n<p>This overload requires you to provide one or more receive buffers. The <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host connection established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffers</em> parameter, <em>buffers</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to receive data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Net.Sockets.Socketgenerics#2"
  syntax:
    content: public int Receive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags)
    content.vb: Public Function Receive(buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the received data.</p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffers</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>buffers</em>.Count is zero.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred while attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)), System.Net.Sockets.SocketFlags)
  name.vb: Receive(IList(Of ArraySegment(Of Byte)), SocketFlags)
- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Receive(IList<ArraySegment<Byte>>, SocketFlags, out SocketError)
  fullName: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, out System.Net.Sockets.SocketError)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Receive
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 212
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives data from a bound <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method reads data into the <em>buffers</em> parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.</p>\n<p>This overload requires you to provide one or more receive buffers. The <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, you must either call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection prior to calling <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref> method will only read data that arrives from the remote host connection established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you are using a connectionless protocol, you can also use the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will allow you to receive data arriving from any host.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available, unless a time-out value was set by using <xref href=\"System.Net.Sockets.Socket.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>If you are using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>,<xref href=\"System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\" data-throw-if-not-resolved=\"false\"></xref> will read the first queued datagram from the destination address you specify in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If the datagram you receive is larger than the size of the <em>buffers</em> parameter, <em>buffers</em> gets filled with the first part of the message, the excess data is lost and a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Receive(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode)
    content.vb: Public Function Receive(buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the received data.</p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: errorCode
      type: System.Net.Sockets.SocketError
      description: "\n<p>A <xref href=\"System.Net.Sockets.SocketError\" data-throw-if-not-resolved=\"false\"></xref> object that stores the socket error.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffers</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>buffers</em>.Count is zero.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred while attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)), System.Net.Sockets.SocketFlags, ByRef System.Net.Sockets.SocketError)
  name.vb: Receive(IList(Of ArraySegment(Of Byte)), SocketFlags, ByRef SocketError)
- uid: System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 213
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins an asynchronous request to receive data from a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.</p>\n<p>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.</p>\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> property on the <em>e</em> parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref></p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> if <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> is set</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref> if <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> is set</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. </p>\n<p>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <em>e</em> parameter. If the message is larger than the buffer, the buffer is filled with the first part of the message.</p>\n<p>For connection-oriented sockets, the <xref href=\"System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketError\" data-throw-if-not-resolved=\"false\"></xref> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketError\" data-throw-if-not-resolved=\"false\"></xref> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</p>\n"
  example:
  - 
  syntax:
    content: public bool ReceiveAsync(SocketAsyncEventArgs e)
    content.vb: Public Function ReceiveAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>An argument was invalid. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref> properties on the <em>e</em> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.BufferList
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.BufferList
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.Offset
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Offset
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  id: ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveFrom(Byte[], Int32, Int32, SocketFlags, ref EndPoint)
  fullName: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveFrom
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 214
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and stores the endpoint.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</p>\n<p>With connectionless protocols, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of <em>buffer</em>, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will fill <em>buffer</em> with as much of the message as is possible, and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method with a large enough buffer.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>Although <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a connection before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method, you will get a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will ignore the <em>remoteEP</em> parameter and only receive data from the connected or default remote host.</p>\n<p>With connection-oriented sockets, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read as much data as is available up to the amount of bytes specified by the <em>size</em> parameter. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been Received, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>Before calling <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref>, you must explicitly bind the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.ReceiveFrom\"></see> needs to match the<xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.SendTo\"></see>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example receives a connectionless datagram from a remote host. The offset, buffer size, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#12"
  syntax:
    content: public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP)
    content.vb: Public Function ReceiveFrom(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for received data. </p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the <em>buffer</em> parameter to store the received data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref>, passed by reference, that represents the remote server. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of the <em>buffer</em> minus the value of the offset parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property was not set.</p>\n<p>-or- </p>\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.ReceiveFrom(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ByRef System.Net.EndPoint)
  name.vb: ReceiveFrom(Byte(), Int32, Int32, SocketFlags, ByRef EndPoint)
- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  id: ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveFrom(Byte[], Int32, SocketFlags, ref EndPoint)
  fullName: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveFrom
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 215
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives the specified number of bytes into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and stores the endpoint.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</p>\n<p>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and an <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the remote host. The buffer offset defaults to 0.</p>\n<p>With connectionless protocols, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of <em>buffer</em>, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will fill <em>buffer</em> with as much of the message as is possible, and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method with a large enough buffer.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>Although <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a connection before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method, you will get a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will ignore the <em>remoteEP</em> parameter and only receive data from the connected or default remote host.</p>\n<p>With connection-oriented sockets, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read as much data as is available up to the number of bytes specified by the <em>size</em> parameter. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>Before calling <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref>, you must explicitly bind the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.ReceiveFrom\"></see> needs to match the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.SendTo\"></see>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example receives a connectionless datagram from a remote host. The buffer size, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#11"
  syntax:
    content: public int ReceiveFrom(byte[] buffer, int size, SocketFlags socketFlags, ref EndPoint remoteEP)
    content.vb: Public Function ReceiveFrom(buffer As Byte(), size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for received data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref>, passed by reference, that represents the remote server. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property was not set.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.ReceiveFrom(System.Byte(), System.Int32, System.Net.Sockets.SocketFlags, ByRef System.Net.EndPoint)
  name.vb: ReceiveFrom(Byte(), Int32, SocketFlags, ByRef EndPoint)
- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)
  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)
  id: ReceiveFrom(System.Byte[],System.Net.EndPoint@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveFrom(Byte[], ref EndPoint)
  fullName: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[], ref System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveFrom
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 216
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives a datagram into the data buffer and stores the endpoint.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</p>\n<p>This overload only requires you to provide a receive <em>buffer</em>, and an <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the remote host. The buffer offset defaults to 0. The size defaults to the length of the <em>buffer</em> parameter and the <em>socketFlags</em> value defaults to <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Before calling <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref>, you must explicitly bind the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>With connectionless protocols, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of <em>buffer</em>, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will fill <em>buffer</em> with as much of the message as is possible, and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method with a large enough buffer.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>Although <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a connection before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method, you will get a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will ignore the <em>remoteEP</em> parameter and only receive data from the connected or default remote host.</p>\n<p>With connection-oriented sockets, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read as much data as is available up to the size of <em>buffer</em>. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been received, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.ReceiveFrom\"></see> needs to match the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.SendTo\"></see>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example receives a connectionless datagram from a remote host.</p>Socket_Sync_Send_Receive#9"
  syntax:
    content: public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP)
    content.vb: Public Function ReceiveFrom(buffer As Byte(), ByRef remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for received data. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref>, passed by reference, that represents the remote server. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.ReceiveFrom(System.Byte(), ByRef System.Net.EndPoint)
  name.vb: ReceiveFrom(Byte(), ByRef EndPoint)
- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  id: ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveFrom(Byte[], SocketFlags, ref EndPoint)
  fullName: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[], System.Net.Sockets.SocketFlags, ref System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveFrom
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 217
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives a datagram into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and stores the endpoint.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</p>\n<p>This overload only requires you to provide a receive buffer, the necessary <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and an <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the remote host. The offset defaults to 0 and the size defaults to the length of the buffer parameter.</p>\n<p>Before calling <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref>, you must explicitly bind the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>With connectionless protocols, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of <em>buffer</em>, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will fill <em>buffer</em> with as much of the message as is possible, and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method with a large enough buffer.</p>\n<p>If no data is available for reading, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can use the <xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> property to determine if data is available for reading. When<xref href=\"System.Net.Sockets.Socket.Available\" data-throw-if-not-resolved=\"false\"></xref> is non-zero, retry the receive operation.</p>\n<p>Although <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a connection before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method, you will get a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will ignore the <em>remoteEP</em> parameter and only receive data from the connected or default remote host.</p>\n<p>With connection-oriented sockets, <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> will read as much data as is available up to the size of <em>buffer</em>. If the remote host shuts down the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> connection with the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, and all available data has been Received, the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method will complete immediately and return zero bytes.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.ReceiveFrom\"></see> needs to match the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.SendTo\"></see>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example receives a connectionless datagram from a remote host. <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the <xref href=\"System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#10"
  syntax:
    content: public int ReceiveFrom(byte[] buffer, SocketFlags socketFlags, ref EndPoint remoteEP)
    content.vb: Public Function ReceiveFrom(buffer As Byte(), socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for the received data. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref>, passed by reference, that represents the remote server. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.ReceiveFrom(System.Byte(), System.Net.Sockets.SocketFlags, ByRef System.Net.EndPoint)
  name.vb: ReceiveFrom(Byte(), SocketFlags, ByRef EndPoint)
- uid: System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveFromAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveFromAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 218
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins to asynchronously receive data from a specified network device.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.</p>\n<p>The caller must set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property to the <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> of the remote host from which the data is to be received. </p>\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> property on the <em>e</em> parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref> properties determine where in the buffer the data is placed and the amount of data.</p>\n<p>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref> properties determine where in the buffer the data is placed and the amount of data.</p>\n"
  example:
  - 
  syntax:
    content: public bool ReceiveFromAsync(SocketAsyncEventArgs e)
    content.vb: Public Function ReceiveFromAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.Offset
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Offset
  - type: System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
  commentId: M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
  id: ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveMessageFrom(Byte[], Int32, Int32, ref SocketFlags, ref EndPoint, out IPPacketInformation)
  fullName: System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[], System.Int32, System.Int32, ref System.Net.Sockets.SocketFlags, ref System.Net.EndPoint, out System.Net.Sockets.IPPacketInformation)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveMessageFrom
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 219
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and stores the endpoint and packet information.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method reads data into the <em>buffer</em> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet. </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref href=\"System.Net.Sockets.SocketType.Dgram\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketType.Raw\" data-throw-if-not-resolved=\"false\"></xref> before calling this method. This can be done when the socket is constructed using <xref href=\"System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>For message-oriented sockets, an incoming message is placed into the <em>buffer</em> parameter up to the total size specified in the <em>size</em> parameter. The <em>offset</em> parameter determines where in the <em>buffer</em> the data is placed. The actual amount of data placed into the <em>buffer</em> is returned by the <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method automatically method sets the <xref href=\"System.Net.Sockets.SocketOptionName.PacketInformation\" data-throw-if-not-resolved=\"false\"></xref> socket option to <strong>true</strong> the first time it is called for a given <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. However, the returned <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or implicitly by one of the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods) and its first call to the <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method, calls to <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\" data-throw-if-not-resolved=\"false\"></xref> method will return invalid <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> objects for these packets.</p>\n<p>To ensure that all <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> objects are valid, an application should set the <xref href=\"System.Net.Sockets.SocketOptionName.PacketInformation\" data-throw-if-not-resolved=\"false\"></xref> socket option to <strong>true</strong> before it is bound to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>An application can examine the <em>ipPacketInformation</em> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</p>\n<p>The <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.ReceiveFrom\"></see> needs to match the <xref href=\"System.Net.Sockets.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> used in <see cref=\"Overload:System.Net.Sockets.Socket.SendTo\"></see>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - 
  syntax:
    content: public int ReceiveMessageFrom(byte[] buffer, int offset, int size, ref SocketFlags socketFlags, ref EndPoint remoteEP, out IPPacketInformation ipPacketInformation)
    content.vb: Public Function ReceiveMessageFrom(buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that is the storage location for received data.</p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the <em>buffer</em> parameter to store the received data.</p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to receive.</p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>An <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref>, passed by reference, that represents the remote server.</p>\n"
    - id: ipPacketInformation
      type: System.Net.Sockets.IPPacketInformation
      description: "\n<p>An <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> holding address and interface information.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes received.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>- or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of the <em>buffer</em> minus the value of the offset parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property was not set.</p>\n<p>-or- </p>\n<p>The .NET Framework is running on an AMD 64-bit processor.</p>\n<p>-or- </p>\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
    commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
  - type: System.Net.Sockets.Socket.Available
    commentId: P:System.Net.Sockets.Socket.Available
  - type: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
    commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte(), System.Int32, System.Int32, ByRef System.Net.Sockets.SocketFlags, ByRef System.Net.EndPoint, ByRef System.Net.Sockets.IPPacketInformation)
  name.vb: ReceiveMessageFrom(Byte(), Int32, Int32, ByRef SocketFlags, ByRef EndPoint, ByRef IPPacketInformation)
- uid: System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: ReceiveMessageFromAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveMessageFromAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 220
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>, and stores the endpoint and packet information.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref href=\"System.Net.Sockets.SocketType.Dgram\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketType.Raw\" data-throw-if-not-resolved=\"false\"></xref> before calling this method. This can be done when the socket is constructed using <xref href=\"System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>The caller must set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property to the <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> of the remote host from which the data is to be received. </p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref> properties determine where in the buffer the data is placed and the amount of data.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method automatically sets the <xref href=\"System.Net.Sockets.SocketOptionName.PacketInformation\" data-throw-if-not-resolved=\"false\"></xref> socket option to <strong>true</strong> the first time it is called for a given <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. However, the <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or implicitly by one of the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods) and the first call to the <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, calls to <xref href=\"System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method will result in invalid <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> objects for these packets.</p>\n<p>To ensure that all <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> objects are valid, an application should set the <xref href=\"System.Net.Sockets.SocketOptionName.PacketInformation\" data-throw-if-not-resolved=\"false\"></xref> socket option to<strong>true</strong> before it is bound to a local endpoint using the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>An application can examine the resulting <xref href=\"System.Net.Sockets.IPPacketInformation\" data-throw-if-not-resolved=\"false\"></xref> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</p>\n"
  example:
  - 
  syntax:
    content: public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e)
    content.vb: Public Function ReceiveMessageFromAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.Offset
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Offset
  - type: System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
  commentId: M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
  id: Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Select(IList, IList, IList, Int32)
  fullName: System.Net.Sockets.Socket.Select(System.Collections.IList, System.Collections.IList, System.Collections.IList, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Select
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 221
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Determines the status of one or more sockets.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is a static method that determines the status of one or more <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> instances. You must place one or more sockets into an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> before you can use the <xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. Check for readability by calling <xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> as the <em>checkRead</em> parameter. To check your sockets for writability, use the <em>checkWrite</em> parameter. For detecting error conditions, use <em>checkError</em>. After calling <xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> will be filled with only those sockets that satisfy the conditions.</p>\n<p>If you are in a listening state, readability means that a call to <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has shut down the connection; in that case a call to <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will return immediately, with zero bytes returned.</p>\n<p>\n<xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns when at least one of the sockets of interest (the sockets in the <em>checkRead</em>, <em>checkWrite</em>, and <em>checkError</em> lists) meets its specified criteria, or the <em>microSeconds</em> parameter is exceeded, whichever comes first. Setting <em>microSeconds</em> to -1 specifies an infinite time-out.</p>\n<p>If you make a nonblocking call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.</p>\n<p>If you have made a non-blocking call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the <em>checkerror</em> parameter identifies sockets that have not connected successfully.</p>\n<p>Use the <xref href=\"System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\" data-throw-if-not-resolved=\"false\"></xref> method if you only want to determine the status of a single <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - "\n<p>The following code example uses <xref href=\"System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to determine which listening sockets have a connection request.</p>Socket_Select#1"
  syntax:
    content: public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds)
    content.vb: Public Shared Sub Select(checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)
    parameters:
    - id: checkRead
      type: System.Collections.IList
      description: "\n<p>An <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> instances to check for readability. </p>\n"
    - id: checkWrite
      type: System.Collections.IList
      description: "\n<p>An <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> instances to check for writability. </p>\n"
    - id: checkError
      type: System.Collections.IList
      description: "\n<p>An <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> instances to check for errors. </p>\n"
    - id: microSeconds
      type: System.Int32
      description: "\n<p>The time-out value, in microseconds. A -1 value indicates an infinite time-out.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>checkRead</em> parameter is <strong>null</strong> or empty.</p>\n<p>-and- </p>\n<p>The <em>checkWrite</em> parameter is <strong>null</strong> or empty </p>\n<p>-and- </p>\n<p>The <em>checkError</em> parameter is <strong>null</strong> or empty. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  seealso:
  - type: System.Collections.IList
    commentId: T:System.Collections.IList
  - type: System.Net.Sockets.Socket.Accept
    commentId: M:System.Net.Sockets.Socket.Accept
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
    commentId: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Net.Sockets.Socket.Send(System.Byte[])
  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[])
  id: Send(System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(Byte[])
  fullName: System.Net.Sockets.Socket.Send(System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 222
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> synchronously sends data to the remote host specified in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method and returns the number of bytes successfully sent. <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> can be used for both connection-oriented and connectionless protocols.</p>\n<p>This overload requires a buffer that contains the data you want to send. The <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates sending data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#1"
  syntax:
    content: public int Send(byte[] buffer)
    content.vb: Public Function Send(buffer As Byte()) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Byte())
  name.vb: Send(Byte())
- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  id: Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(Byte[], Int32, Int32, SocketFlags)
  fullName: System.Net.Sockets.Socket.Send(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 223
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> synchronously sends data to the remote host specified in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method and returns the number of bytes successfully sent. <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> can be used for both connection-oriented and connectionless protocols.</p>\n<p>In this overload, if you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method or <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. If you do not use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. It is okay to use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until the requested number of bytes are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example specifies the data buffer, an offset, a size, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> for sending data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#4"
  syntax:
    content: public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags)
    content.vb: Public Function Send(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the data buffer at which to begin sending data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to send. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em> minus the value of the <em>offset</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags)
  name.vb: Send(Byte(), Int32, Int32, SocketFlags)
- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  id: Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(Byte[], Int32, Int32, SocketFlags, out SocketError)
  fullName: System.Net.Sockets.Socket.Send(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, out System.Net.Sockets.SocketError)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 224
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> synchronously sends data to the remote host specified in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method and returns the number of bytes successfully sent. <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> can be used for both connection-oriented and connectionless protocols.</p>\n<p>In this overload, if you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method or <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a<xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. If you do not use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. It is okay to use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until the requested number of bytes are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, seeNetwork Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example specifies the data buffer, an offset, a size, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> for sending data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#4"
  syntax:
    content: public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags, out SocketError errorCode)
    content.vb: Public Function Send(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the data buffer at which to begin sending data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to send. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: errorCode
      type: System.Net.Sockets.SocketError
      description: "\n<p>A <xref href=\"System.Net.Sockets.SocketError\" data-throw-if-not-resolved=\"false\"></xref> object that stores the socket error.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em> minus the value of the <em>offset</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags, ByRef System.Net.Sockets.SocketError)
  name.vb: Send(Byte(), Int32, Int32, SocketFlags, ByRef SocketError)
- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  id: Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(Byte[], Int32, SocketFlags)
  fullName: System.Net.Sockets.Socket.Send(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 225
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> synchronously sends data to the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method and returns the number of bytes successfully sent. <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> can be used for both connection-oriented and connectionless protocols.</p>\n<p>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method before each call to the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>With a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until the requested number of bytes are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sends the data found in buffer, and specifies <xref href=\"System.Net.Sockets.SocketFlags.None\" data-throw-if-not-resolved=\"false\"></xref> for <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#3"
  syntax:
    content: public int Send(byte[] buffer, int size, SocketFlags socketFlags)
    content.vb: Public Function Send(buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to send. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>size</em> is less than 0 or exceeds the size of the buffer. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Byte(), System.Int32, System.Net.Sockets.SocketFlags)
  name.vb: Send(Byte(), Int32, SocketFlags)
- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)
  id: Send(System.Byte[],System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(Byte[], SocketFlags)
  fullName: System.Net.Sockets.Socket.Send(System.Byte[], System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 226
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> synchronously sends data to the remote host established in the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method and returns the number of bytes successfully sent. The <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method can be used for both connection-oriented and connectionless protocols.</p>\n<p>This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>. The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter value, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, seeNetwork Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates sending data on a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Socket_Sync_Send_Receive#2"
  syntax:
    content: public int Send(byte[] buffer, SocketFlags socketFlags)
    content.vb: Public Function Send(buffer As Byte(), socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.SocketFlags
    commentId: T:System.Net.Sockets.SocketFlags
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Byte(), System.Net.Sockets.SocketFlags)
  name.vb: Send(Byte(), SocketFlags)
- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(IList<ArraySegment<Byte>>)
  fullName: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 227
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\" data-throw-if-not-resolved=\"false\"></xref> can be used for both connection-oriented and connectionless protocols.</p>\n<p>This overload requires at least one buffer that contains the data you want to send.</p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In nonblocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Send(IList<ArraySegment<byte>> buffers)
    content.vb: Public Function Send(buffers As IList(Of ArraySegment(Of Byte))) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffers</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>buffers</em> is empty.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See remarks section below. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)))
  name.vb: Send(IList(Of ArraySegment(Of Byte)))
- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(IList<ArraySegment<Byte>>, SocketFlags)
  fullName: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 228
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This overload requires at least one buffer that contains the data you want to send. The <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to 0. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketFlags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In non-blocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Send(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags)
    content.vb: Public Function Send(buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent.</p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffers</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>buffers</em> is empty.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)), System.Net.Sockets.SocketFlags)
  name.vb: Send(IList(Of ArraySegment(Of Byte)), SocketFlags)
- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Send(IList<ArraySegment<Byte>>, SocketFlags, out SocketError)
  fullName: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList<System.ArraySegment<System.Byte>>, System.Net.Sockets.SocketFlags, out System.Net.Sockets.SocketError)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Send
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 229
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This overload requires at least one buffer that contains the data you want to send. The <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to 0. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketFlags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you must call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before calling this method, or <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you are using a connection-oriented protocol, you must either use <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> to establish a remote host connection, or use <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> to accept an incoming connection.</p>\n<p>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not use the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, you will have to call <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> before each call to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref>. You can use <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> even after you have established a default remote host with <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You can also change the default remote host prior to calling <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> by making another call to <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you are using a connection-oriented protocol, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref href=\"System.Net.Sockets.Socket.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>. If the time-out value was exceeded, the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> call will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. In non-blocking mode, <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public int Send(IList<ArraySegment<byte>> buffers, SocketFlags socketFlags, out SocketError errorCode)
    content.vb: Public Function Send(buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer
    parameters:
    - id: buffers
      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
      description: "\n<p>A list of <xref href=\"System.ArraySegment`1\" data-throw-if-not-resolved=\"false\"></xref>s of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent.</p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
    - id: errorCode
      type: System.Net.Sockets.SocketError
      description: "\n<p>A <xref href=\"System.Net.Sockets.SocketError\" data-throw-if-not-resolved=\"false\"></xref> object that stores the socket error.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffers</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>buffers</em> is empty.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte)), System.Net.Sockets.SocketFlags, ByRef System.Net.Sockets.SocketError)
  name.vb: Send(IList(Of ArraySegment(Of Byte)), SocketFlags, ByRef SocketError)
- uid: System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 230
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation. </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method starts an asynchronous send operation to the remote host established in the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginAccept\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref></p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref> if <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> is set</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref> if <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> is set</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>The <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method will throw an exception if you do not first call <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginAccept\"></see><see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>Calling the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method gives you the ability to send data within a separate execution thread.</p>\n<p>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketError\" data-throw-if-not-resolved=\"false\"></xref> set to the native Winsock WSAEMSGSIZE error code (10040).</p>\n<p>Note that the successful completion of the <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method does not indicate that the data was successfully delivered.</p>\n"
  example:
  - 
  syntax:
    content: public bool SendAsync(SocketAsyncEventArgs e)
    content.vb: Public Function SendAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\" data-throw-if-not-resolved=\"false\"></xref> properties on the <em>e</em> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is not yet connected or was not obtained via an <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>,or <see cref=\"Overload:System.Net.Sockets.Socket.BeginAccept\"></see>, method.</p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.BufferList
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.BufferList
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.Offset
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Offset
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendPacketsAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendPacketsAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 231
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends a collection of files or in memory data buffers asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is used to send a collection of files or in memory data buffers to remote host. The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> must already be connected to the remote host.</p>\n<p>If a <xref href=\"System.Net.Sockets.SendPacketsElement\" data-throw-if-not-resolved=\"false\"></xref> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <xref href=\"System.IO.FileNotFoundException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>To be notified of completion, you must create a callback method that implements the EventHandler<SocketAsyncEventArgs> delegate and attach the callback to the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags\" data-throw-if-not-resolved=\"false\"></xref> property on the <em>e</em> parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref href=\"System.Net.Sockets.TransmitFileOptions\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</p>\n<p>Although intended for connection-oriented protocols, the <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method also works for connectionless protocols, provided that you first call the <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> throws a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> exception.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is optimized according to the operating system on which it is used. On Windows server editions, the <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is optimized for high performance. </p>\n<p>On Windows client editions, the <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method is optimized for minimum memory and resource utilization.</p>\n<p>Use of the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseKernelApc\" data-throw-if-not-resolved=\"false\"></xref> flag in the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags\" data-throw-if-not-resolved=\"false\"></xref> property on the <em>e</em> parameter can deliver significant performance benefits. If the thread initiating the <xref href=\"System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Note that there is a difference between kernel and user-mode APCs. Kernel APCs launch when a thread is in a wait state. User-mode APCs launch when a thread is in an alertable wait state</p>\n"
  example:
  - 
  syntax:
    content: public bool SendPacketsAsync(SocketAsyncEventArgs e)
    content.vb: Public Function SendPacketsAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "\n<p>The file specified in the <xref href=\"System.Net.Sockets.SendPacketsElement.FilePath\" data-throw-if-not-resolved=\"false\"></xref> property was not found. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method. This exception also occurs if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is not connected to a remote host. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>A connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements
  - type: System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  id: SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)
  fullName: System.Net.Sockets.Socket.SendTo(System.Byte[], System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTo
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 232
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>In this overload, if you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You only need to do this if you intend to call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the <em>remoteEP</em> parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property after the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method successfully completes.</p>\n<p>Although intended for connectionless protocols, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming connection request using the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a remote host connection, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will ignore the <em>remoteEP</em> parameter and only send data to the connected or default remote host.</p>\n<p>Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you are using a connectionless protocol in blocking mode, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sends a connectionless datagram to the specified remote host. The offset, size, and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#8"
  syntax:
    content: public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP)
    content.vb: Public Function SendTo(buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>The position in the data buffer at which to begin sending data. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to send. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the destination location for the data. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>offset</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than 0.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is greater than the length of <em>buffer</em> minus the value of the <em>offset</em> parameter. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>\n<em>socketFlags</em> is not a valid combination of values.</p>\n<p>-or- </p>\n<p>An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller in the call stack does not have the required permissions. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.SendTo(System.Byte(), System.Int32, System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  name.vb: SendTo(Byte(), Int32, Int32, SocketFlags, EndPoint)
- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  id: SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendTo(Byte[], Int32, SocketFlags, EndPoint)
  fullName: System.Net.Sockets.Socket.SendTo(System.Byte[], System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTo
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 233
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends the specified number of bytes of data to the specified endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>In this overload, the buffer offset defaults to 0. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You only need to do this if you intend to call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the <em>remoteEP</em> parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property after the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method successfully completes.</p>\n<p>Although intended for connectionless protocols, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming connection request using the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a remote host connection, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will ignore the <em>remoteEP</em> parameter and only send data to the connected or default remote host.</p>\n<p>Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you are using a connectionless protocol in blocking mode, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sends a connectionless datagram to the specified remote host. The size and <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#7"
  syntax:
    content: public int SendTo(byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP)
    content.vb: Public Function SendTo(buffer As Byte(), size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The number of bytes to send. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the destination location for the data. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The specified <em>size</em> exceeds the size of <em>buffer</em>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.SendTo(System.Byte(), System.Int32, System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  name.vb: SendTo(Byte(), Int32, SocketFlags, EndPoint)
- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)
  id: SendTo(System.Byte[],System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendTo(Byte[], EndPoint)
  fullName: System.Net.Sockets.Socket.SendTo(System.Byte[], System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTo
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 234
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data to the specified endpoint.</p>\n"
  remarks: "\n<p>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <em>buffer</em> parameter, and the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> value defaults to 0.</p>\n<p>If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You only need to do this if you intend to call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the <em>remoteEP</em> parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property after the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method successfully completes.</p>\n<p>Although intended for connectionless protocols, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming connection request using the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a remote host connection, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will ignore the <em>remoteEP</em> parameter and only send data to the connected or default remote host.</p>\n<p>Blocking sockets will block until the all of the bytes in the buffer are sent. Since a nonblocking<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> completes immediately, it might not send all of the bytes in the <em>buffer</em>. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <em>buffer</em>. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you are using a connectionless protocol in blocking mode, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sends a connectionless datagram to the specified remote host.</p>Socket_Sync_Send_Receive#5"
  syntax:
    content: public int SendTo(byte[] buffer, EndPoint remoteEP)
    content.vb: Public Function SendTo(buffer As Byte(), remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the destination for the data. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.SendTo(System.Byte(), System.Net.EndPoint)
  name.vb: SendTo(Byte(), EndPoint)
- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  id: SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendTo(Byte[], SocketFlags, EndPoint)
  fullName: System.Net.Sockets.Socket.SendTo(System.Byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTo
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 235
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data to a specific endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <em>buffer</em>. If you specify the <xref href=\"System.Net.Sockets.SocketFlags.DontRoute\" data-throw-if-not-resolved=\"false\"></xref> flag as the <em>socketflags</em> parameter, the data you are sending will not be routed. </p>\n<p>If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>. You only need to do this if you intend to call the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method. If you do call the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, the <em>remoteEP</em> parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property after the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method successfully completes.</p>\n<p>Although intended for connectionless protocols, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method or accept an incoming connection request using the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref> method. If you do not establish or accept a remote host connection, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. In either of these cases, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will ignore the <em>remoteEP</em> parameter and only send data to the connected or default remote host.</p>\n<p>Blocking sockets will block until the requested all of the bytes in the <em>buffer</em> are sent. Since a nonblocking<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> completes immediately, it might not send all of the bytes in the <em>buffer</em>. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <em>buffer</em>. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method means that the underlying system has had room to buffer your data for a network send. </p>\n<p>If you are using a connectionless protocol in blocking mode, <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option to <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sends a connectionless datagram to the specified remote host. <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> are passed to the<xref href=\"System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Socket_Sync_Send_Receive#6"
  syntax:
    content: public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP)
    content.vb: Public Function SendTo(buffer As Byte(), socketFlags As SocketFlags, remoteEP As EndPoint) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that contains the data to be sent. </p>\n"
    - id: socketFlags
      type: System.Net.Sockets.SocketFlags
      description: "\n<p>A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: remoteEP
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the destination location for the data. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes sent.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>remoteEP</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
    commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
  - type: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
  - type: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
    commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  - type: System.Net.Sockets.Socket.LocalEndPoint
    commentId: P:System.Net.Sockets.Socket.LocalEndPoint
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.SendTo(System.Byte(), System.Net.Sockets.SocketFlags, System.Net.EndPoint)
  name.vb: SendTo(Byte(), SocketFlags, EndPoint)
- uid: System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
  commentId: M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
  id: SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SendToAsync(SocketAsyncEventArgs)
  fullName: System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendToAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 236
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sends data asynchronously to a specific remote host.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method starts an asynchronous send operation to the remote host specified in the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property of the <em>e</em> parameter. Calling the <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method gives you the ability to send data within a separate execution thread. Although this method is intended for connectionless protocols, <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> works with both connectionless and connection-oriented protocols.</p>\n<p>To be notified of completion, you must create a callback method that implements the EventHandler<SocketAsyncEventArgs> delegate and attach the callback to the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>The following properties and events on the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object are required to successfully call this method:</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Offset\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>The caller may set the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.UserToken\" data-throw-if-not-resolved=\"false\"></xref> property to any user state object desired before calling the <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members. </p>\n<p>If you are using a connection-oriented protocol, you must first call the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginAccept\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method. Otherwise <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. When using a connection-oriented protocol, the <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method will ignore the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property and send data to the <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> established in the <xref href=\"System.Net.Sockets.Socket.Accept\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginAccept\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using a connectionless protocol, you do not need to establish a default remote host with the <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>. You only need to do this if you intend to call the <see cref=\"Overload:System.Net.Sockets.Socket.BeginSend\"></see> or <xref href=\"System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> methods. If you do call the <see cref=\"Overload:System.Net.Sockets.Socket.BeginConnect\"></see>, <see cref=\"Overload:System.Net.Sockets.Socket.Connect\"></see>, or <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method prior to calling <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property will override the specified default remote host for that send operation only. You are also not required to call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\" data-throw-if-not-resolved=\"false\"></xref> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\" data-throw-if-not-resolved=\"false\"></xref> property after the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event is signaled and the associated delegates are called.</p>\n<p>If you want to send data to a broadcast address, you must first call the <xref href=\"System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method and set the socket option for <xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you specify the DontRoute flag in the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\" data-throw-if-not-resolved=\"false\"></xref> property, the data you are sending will not be routed.</p>\n<p>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. The successful completion of a <xref href=\"System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\" data-throw-if-not-resolved=\"false\"></xref> method does not indicate that the data was successfully delivered.</p>\n"
  example:
  - 
  syntax:
    content: public bool SendToAsync(SocketAsyncEventArgs e)
    content.vb: Public Function SendToAsync(e As SocketAsyncEventArgs) As Boolean
    parameters:
    - id: e
      type: System.Net.Sockets.SocketAsyncEventArgs
      description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object to use for this asynchronous socket operation.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>Returns <strong>true</strong> if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will be raised upon completion of the operation. </p>\n<p>Returns <strong>false</strong> if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\" data-throw-if-not-resolved=\"false\"></xref> event on the <em>e</em> parameter will not be raised and the <em>e</em> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\" data-throw-if-not-resolved=\"false\"></xref> cannot be null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\" data-throw-if-not-resolved=\"false\"></xref> object specified in the <em>e</em> parameter.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows XP or later is required for this method.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>The protocol specified is connection-oriented, but the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is not yet connected.</p>\n"
  seealso:
  - type: System.Net.Sockets.SocketAsyncEventArgs
    commentId: T:System.Net.Sockets.SocketAsyncEventArgs
  - type: System.Net.Sockets.SocketAsyncEventArgs.Buffer
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Buffer
  - type: System.Net.Sockets.SocketAsyncEventArgs.Completed
    commentId: E:System.Net.Sockets.SocketAsyncEventArgs.Completed
  - type: System.Net.Sockets.SocketAsyncEventArgs.Count
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Count
  - type: System.Net.Sockets.SocketAsyncEventArgs.Offset
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.Offset
  - type: System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint
  - type: System.Net.Sockets.SocketAsyncEventArgs.UserToken
    commentId: P:System.Net.Sockets.SocketAsyncEventArgs.UserToken
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)
  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)
  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)
  fullName: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 237
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option to the specified <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Set <em>optionValue</em> to <strong>true</strong> to enable the option, or to <strong>false</strong> to disable the option.</p>\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options are grouped by level of protocol support.</p>\n<p>Listed below are the various <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload. These options are grouped by the appropriate <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> value. If you intend to set any of these options, be sure to use the appropriate <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> value for the <em>optionLevel</em> parameter. The option you choose to set must be specified in the <em>optionName</em> parameter. If you want to get the current value of any of the options listed, use the <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Socket\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.AcceptConnection\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.DontLinger\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Debug\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.KeepAlive\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.ReuseAddress\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.IP\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.HeaderIncluded\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.MulticastLoopback\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.UseLoopback\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Tcp\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.BsdUrgent\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Expedited\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.NoDelay\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Udp\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.NoChecksum\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>For more information on these options, refer to the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> enumeration.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> exception, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - "\n<p>The following code example opens a socket and enables the <strong>DontLinger</strong> and the <strong>OutOfBandInline</strong> socket options.</p>NCLSocketEnhancements#5"
  syntax:
    content: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue)
    content.vb: Public Sub SetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionValue
      type: System.Boolean
      description: "\n<p>The value of the option, represented as a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> object has been closed. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])
  fullName: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 238
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option to the specified value, represented as a byte array.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Use this overload to set those <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options that require a byte array as an option value.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sets the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time-out values.</p>Socket_Socket_Options#1"
  syntax:
    content: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue)
    content.vb: Public Sub SetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionValue
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> that represents the value of the option. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  - type: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
    commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Byte())
  name.vb: SetSocketOption(SocketOptionLevel, SocketOptionName, Byte())
- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)
  fullName: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 239
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option to the specified integer value.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. For an option with a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options are grouped by level of protocol support.</p>\n<p>Listed below are the various <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload. These options are grouped by the appropriate <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref>. If you intend to set any of these options, be sure to use the appropriate <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> for the <em>optionLevel</em> parameter. The option you choose to set must be specified in the <em>optionName</em> parameter. If you want to get the current value of any of the options listed, use the <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Socket\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Broadcast\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.DontLinger\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Debug\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Error\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.KeepAlive\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.ReceiveBuffer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.ReuseAddress\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.SendBuffer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Type\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.IP\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.HeaderIncluded\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.IPOptions\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.IpTimeToLive\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.MulticastInterface\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.MulticastLoopback\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.MulticastTimeToLive\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.TypeOfService\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.UseLoopback\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Tcp\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.BsdUrgent\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.Expedited\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.NoDelay\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.Udp\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.ChecksumCoverage\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.NoChecksum\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionLevel.IPv6\" data-throw-if-not-resolved=\"false\"></xref> options that can be set using this overload.</p>\n<ul><li>\n<p>\n<xref href=\"System.Net.Sockets.SocketOptionName.HopLimit\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>For more information about these options, refer to the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> enumeration.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example sets the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time-out values.</p>Socket_Socket_Options#1"
  syntax:
    content: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue)
    content.vb: Public Sub SetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionValue
      type: System.Int32
      description: "\n<p>A value of the option. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  - type: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
    commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)
  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)
  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Object)
  fullName: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetSocketOption
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 240
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Sets the specified <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option to the specified value, represented as an object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options determine the behavior of the current <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Use this overload to set the <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\" data-throw-if-not-resolved=\"false\"></xref><xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> options. For the <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref> option, use <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for the <em>optionLevel</em> parameter. For <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketOptionLevel.IP\" data-throw-if-not-resolved=\"false\"></xref>. If you want to get the current value of any of the options listed above, use the <xref href=\"System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n"
  example:
  - "\n<p>The following code example sets the <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> time out values.</p>Socket_Socket_Options#1"
  syntax:
    content: public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue)
    content.vb: Public Sub SetSocketOption(optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)
    parameters:
    - id: optionLevel
      type: System.Net.Sockets.SocketOptionLevel
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionName
      type: System.Net.Sockets.SocketOptionName
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketOptionName\" data-throw-if-not-resolved=\"false\"></xref> values. </p>\n"
    - id: optionValue
      type: System.Object
      description: "\n<p>A <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.MulticastOption\" data-throw-if-not-resolved=\"false\"></xref> that contains the value of the option. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>optionValue</em> is <strong>null</strong>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.SocketOptionName
    commentId: T:System.Net.Sockets.SocketOptionName
  - type: System.Net.Sockets.SocketOptionLevel
    commentId: T:System.Net.Sockets.SocketOptionLevel
  - type: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
    commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  id: Shutdown(System.Net.Sockets.SocketShutdown)
  parent: System.Net.Sockets.Socket
  langs:
  - csharp
  - vb
  name: Shutdown(SocketShutdown)
  fullName: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Shutdown
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 241
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Disables sends and receives on a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>When using a connection-oriented <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, always call the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method before closing the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. This ensures that all data is sent and received on the connected socket before it is closed.</p>\n<p>Call the <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method to free all managed and unmanaged resources associated with the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Do not attempt to reuse the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> after closing.</p>\n<p>The following table shows the <xref href=\"System.Net.Sockets.SocketShutdown\" data-throw-if-not-resolved=\"false\"></xref> enumeration values that are valid for the <em>how</em> parameter.</p>\n<p>Value </p>\n<p>Description </p>\n<table><tbody><tr><td>\n<p>Send </p>\n</td><td>\n<p>Disable sending on this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</td></tr><tr><td>\n<p>Receive </p>\n</td><td>\n<p>Disable receiving on this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</td></tr><tr><td>\n<p>Both </p>\n</td><td>\n<p>Disable both sending and receiving on this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</td></tr></tbody></table>\n<p>Setting <em>how</em> to <xref href=\"System.Net.Sockets.SocketShutdown.Send\" data-throw-if-not-resolved=\"false\"></xref> specifies that subsequent calls to <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> are not allowed. If you are using a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, specifying <xref href=\"System.Net.Sockets.SocketShutdown.Send\" data-throw-if-not-resolved=\"false\"></xref> will have no effect.</p>\n<p>Setting <em>how</em> to <xref href=\"System.Net.Sockets.SocketShutdown.Receive\" data-throw-if-not-resolved=\"false\"></xref> specifies that subsequent calls to <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> are not allowed. This has no effect on lower protocol layers. If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> : </p>\n<ul><li>\n<p>Data is in the incoming network buffer waiting to be received.</p>\n</li><li>\n<p>More data has arrived.</p>\n</li></ul>\n<p>If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> on a connectionless <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is not recommended.</p>\n<p>Setting <em>how</em> to <xref href=\"System.Net.Sockets.SocketShutdown.Both\" data-throw-if-not-resolved=\"false\"></xref> disables both sends and receives as described above.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> when calling the <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> method, use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example uses <xref href=\"System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\" data-throw-if-not-resolved=\"false\"></xref> to disable the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Socket.Close Example#1"
  syntax:
    content: public void Shutdown(SocketShutdown how)
    content.vb: Public Sub Shutdown(how As SocketShutdown)
    parameters:
    - id: how
      type: System.Net.Sockets.SocketShutdown
      description: "\n<p>One of the <xref href=\"System.Net.Sockets.SocketShutdown\" data-throw-if-not-resolved=\"false\"></xref> values that specifies the operation that will no longer be allowed. </p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  - type: System.Net.Sockets.SocketShutdown
    commentId: T:System.Net.Sockets.SocketShutdown
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Net.Sockets
  isExternal: false
  name: System.Net.Sockets
  fullName: System.Net.Sockets
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Net.Sockets.AddressFamily
  parent: System.Net.Sockets
  isExternal: false
  name: AddressFamily
  fullName: System.Net.Sockets.AddressFamily
- uid: System.Net.Sockets.SocketType
  parent: System.Net.Sockets
  isExternal: false
  name: SocketType
  fullName: System.Net.Sockets.SocketType
- uid: System.Net.Sockets.ProtocolType
  parent: System.Net.Sockets
  isExternal: false
  name: ProtocolType
  fullName: System.Net.Sockets.ProtocolType
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Net.Sockets.LingerOption
  parent: System.Net.Sockets
  isExternal: false
  name: LingerOption
  fullName: System.Net.Sockets.LingerOption
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: false
  name: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net
  isExternal: false
  name: System.Net
  fullName: System.Net
- uid: System.Int16
  parent: System
  isExternal: false
  name: Int16
  fullName: System.Int16
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: false
  name: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.SocketAsyncEventArgs
  parent: System.Net.Sockets
  isExternal: false
  name: SocketAsyncEventArgs
  fullName: System.Net.Sockets.SocketAsyncEventArgs
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: false
  name: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Net.IPAddress[]
  isExternal: false
  name: IPAddress[]
  fullName: System.Net.IPAddress[]
  fullname.vb: System.Net.IPAddress()
  name.vb: IPAddress()
  spec.csharp:
  - uid: System.Net.IPAddress
    name: IPAddress
    fullName: System.Net.IPAddress
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Net.IPAddress
    name: IPAddress
    fullName: System.Net.IPAddress
  - name: ()
    fullName: ()
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Net.Sockets.SocketOptionLevel
  parent: System.Net.Sockets
  isExternal: false
  name: SocketOptionLevel
  fullName: System.Net.Sockets.SocketOptionLevel
- uid: System.Net.Sockets.SocketOptionName
  parent: System.Net.Sockets
  isExternal: false
  name: SocketOptionName
  fullName: System.Net.Sockets.SocketOptionName
- uid: System.Byte[]
  isExternal: true
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Net.Sockets.IOControlCode
  parent: System.Net.Sockets
  isExternal: false
  name: IOControlCode
  fullName: System.Net.Sockets.IOControlCode
- uid: System.Net.Sockets.SelectMode
  parent: System.Net.Sockets
  isExternal: false
  name: SelectMode
  fullName: System.Net.Sockets.SelectMode
- uid: System.Net.Sockets.SocketFlags
  parent: System.Net.Sockets
  isExternal: false
  name: SocketFlags
  fullName: System.Net.Sockets.SocketFlags
- uid: System.Net.Sockets.SocketError
  parent: System.Net.Sockets
  isExternal: false
  name: SocketError
  fullName: System.Net.Sockets.SocketError
- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IList`1
  name: IList<ArraySegment<Byte>>
  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>
  fullname.vb: System.Collections.Generic.IList(Of System.ArraySegment(Of System.Byte))
  name.vb: IList(Of ArraySegment(Of Byte))
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: <
    fullName: <
  - uid: System.ArraySegment`1
    name: ArraySegment
    fullName: System.ArraySegment
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: '>'
    fullName: '>'
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IList`1
    name: IList
    fullName: System.Collections.Generic.IList
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.ArraySegment`1
    name: ArraySegment
    fullName: System.ArraySegment
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: )
    fullName: )
  - name: )
    fullName: )
- uid: System.Collections.Generic.IList`1
  parent: System.Collections.Generic
  isExternal: false
  name: IList<T>
  fullName: System.Collections.Generic.IList<T>
  fullname.vb: System.Collections.Generic.IList(Of T)
  name.vb: IList(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IList`1
    name: IList
    fullName: System.Collections.Generic.IList
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IList`1
    name: IList
    fullName: System.Collections.Generic.IList
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Net.Sockets.IPPacketInformation
  parent: System.Net.Sockets
  isExternal: false
  name: IPPacketInformation
  fullName: System.Net.Sockets.IPPacketInformation
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: false
  name: IList
  fullName: System.Collections.IList
- uid: System.Collections
  isExternal: false
  name: System.Collections
  fullName: System.Collections
- uid: System.Net.Sockets.SocketShutdown
  parent: System.Net.Sockets
  isExternal: false
  name: SocketShutdown
  fullName: System.Net.Sockets.SocketShutdown
- uid: System.Net.Sockets.SocketException
  isExternal: false
  name: SocketException
  fullName: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.Security.SecurityException
  isExternal: false
  name: SecurityException
  fullName: System.Security.SecurityException
- uid: System.IO.FileNotFoundException
  isExternal: false
  name: FileNotFoundException
  fullName: System.IO.FileNotFoundException
