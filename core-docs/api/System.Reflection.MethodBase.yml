items:
- uid: System.Reflection.MethodBase
  commentId: T:System.Reflection.MethodBase
  id: MethodBase
  parent: System.Reflection
  children:
  - System.Reflection.MethodBase.Attributes
  - System.Reflection.MethodBase.CallingConvention
  - System.Reflection.MethodBase.ContainsGenericParameters
  - System.Reflection.MethodBase.Equals(System.Object)
  - System.Reflection.MethodBase.GetGenericArguments
  - System.Reflection.MethodBase.GetHashCode
  - System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)
  - System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  - System.Reflection.MethodBase.GetParameters
  - System.Reflection.MethodBase.Invoke(System.Object,System.Object[])
  - System.Reflection.MethodBase.IsAbstract
  - System.Reflection.MethodBase.IsAssembly
  - System.Reflection.MethodBase.IsConstructor
  - System.Reflection.MethodBase.IsFamily
  - System.Reflection.MethodBase.IsFamilyAndAssembly
  - System.Reflection.MethodBase.IsFamilyOrAssembly
  - System.Reflection.MethodBase.IsFinal
  - System.Reflection.MethodBase.IsGenericMethod
  - System.Reflection.MethodBase.IsGenericMethodDefinition
  - System.Reflection.MethodBase.IsHideBySig
  - System.Reflection.MethodBase.IsPrivate
  - System.Reflection.MethodBase.IsPublic
  - System.Reflection.MethodBase.IsSpecialName
  - System.Reflection.MethodBase.IsStatic
  - System.Reflection.MethodBase.IsVirtual
  - System.Reflection.MethodBase.MethodImplementationFlags
  langs:
  - csharp
  - vb
  name: MethodBase
  fullName: System.Reflection.MethodBase
  type: Class
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MethodBase
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 157
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Provides information about methods and constructors. </p>\n"
  remarks: "\n<p>\n<strong>MethodBase</strong> is the base class of <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: 'public abstract class MethodBase : MemberInfo'
    content.vb: >-
      Public MustInherit Class MethodBase
          Inherits MemberInfo
  see:
  - type: System.Security.Permissions.SecurityAction.InheritanceDemand
    commentId: F:System.Security.Permissions.SecurityAction.InheritanceDemand
  inheritance:
  - System.Object
  - System.Reflection.MemberInfo
  inheritedMembers:
  - System.Reflection.MemberInfo.CustomAttributes
  - System.Reflection.MemberInfo.DeclaringType
  - System.Reflection.MemberInfo.Module
  - System.Reflection.MemberInfo.Name
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Reflection.MethodBase.Attributes
  commentId: P:System.Reflection.MethodBase.Attributes
  id: Attributes
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: Attributes
  fullName: System.Reflection.MethodBase.Attributes
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Attributes
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 160
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets the attributes associated with this method.</p>\n"
  remarks: "\n<p>All members have a set of attributes, which are defined in relation to the specific type of member.</p>\n<p>To get the <xref href=\"System.Reflection.MethodAttributes\" data-throw-if-not-resolved=\"false\"></xref>, first get the type. From the type, get the method. From the method, get the <xref href=\"System.Reflection.MethodAttributes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example displays the attributes of the user-defined method Mymethod.</p>Classic MethodBase.Attributes Example#1<p>This code produces the following output: </p><p>Reflection.MethodBase.Attributes Sample </p><p>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef) </p><p>PrivateScope </p><p>FamANDAssem </p><p>Family </p><p>Public </p><p>HideBySig </p><p>ReuseSlot </p>"
  syntax:
    content: public abstract MethodAttributes Attributes { get; }
    content.vb: Public MustOverride ReadOnly Property Attributes As MethodAttributes
    parameters: []
    return:
      type: System.Reflection.MethodAttributes
      description: "\n<p>One of the <xref href=\"System.Reflection.MethodAttributes\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  seealso:
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  modifiers.csharp:
  - public
  - abstract
  - get
  modifiers.vb:
  - Public
  - MustOverride
  - ReadOnly
- uid: System.Reflection.MethodBase.CallingConvention
  commentId: P:System.Reflection.MethodBase.CallingConvention
  id: CallingConvention
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: CallingConvention
  fullName: System.Reflection.MethodBase.CallingConvention
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CallingConvention
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 161
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating the calling conventions for this method.</p>\n"
  syntax:
    content: public virtual CallingConventions CallingConvention { get; }
    content.vb: Public Overridable ReadOnly Property CallingConvention As CallingConventions
    parameters: []
    return:
      type: System.Reflection.CallingConventions
      description: "\n<p>The <xref href=\"System.Reflection.CallingConventions\" data-throw-if-not-resolved=\"false\"></xref> for this method.</p>\n"
  seealso:
  - type: System.Reflection.CallingConventions
    commentId: T:System.Reflection.CallingConventions
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Reflection.MethodBase.ContainsGenericParameters
  commentId: P:System.Reflection.MethodBase.ContainsGenericParameters
  id: ContainsGenericParameters
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: ContainsGenericParameters
  fullName: System.Reflection.MethodBase.ContainsGenericParameters
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ContainsGenericParameters
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 162
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the generic method contains unassigned generic type parameters.</p>\n"
  remarks: "\n<p>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types. Because types can be arbitrarily complex, making this recursive determination is difficult. For convenience, and to reduce the chance of error, the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot. If the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>, the method cannot be invoked.</p>\n<p>The <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property searches recursively for type parameters. For example, it returns <strong>true</strong> for any method in an open type <code>A<T></code> (<code>A(Of T)</code> in Visual Basic), even though the method itself is not generic. Contrast this with the behavior of the <xref href=\"System.Reflection.MethodBase.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property, which returns <strong>false</strong> for such a method. </p>\n<p>Similarly, the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property parameter returns <strong>true</strong> for any constructor in an open type, even though constructors cannot have type parameters of their own.</p>\n<p>For a list of the invariant conditions for terms specific to generic methods, see the <xref href=\"System.Reflection.MethodInfo.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public virtual bool ContainsGenericParameters { get; }
    content.vb: Public Overridable ReadOnly Property ContainsGenericParameters As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic method that contains unassigned generic type parameters; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodBase.IsGenericMethod
    commentId: P:System.Reflection.MethodBase.IsGenericMethod
  - type: System.Reflection.MethodBase.IsGenericMethodDefinition
    commentId: P:System.Reflection.MethodBase.IsGenericMethodDefinition
  - type: System.Reflection.MethodInfo.ContainsGenericParameters
    commentId: P:System.Reflection.MethodInfo.ContainsGenericParameters
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Reflection.MethodBase.IsAbstract
  commentId: P:System.Reflection.MethodBase.IsAbstract
  id: IsAbstract
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsAbstract
  fullName: System.Reflection.MethodBase.IsAbstract
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAbstract
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 163
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is abstract.</p>\n"
  remarks: "\n<p>An abstract member is declared on a base class and has no implementation supplied.</p>\n<p>To get the <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref>, first get the type. From the type, get the method. From the method, get the <strong>MethodBase</strong>. If the <strong>MethodBase</strong> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <xref href=\"System.Reflection.BindingFlags\" data-throw-if-not-resolved=\"false\"></xref> mask to <strong>NonPublic</strong> in <strong>GetMethod</strong>.</p>\n"
  example:
  - "\n<p>The following example determines whether specified the method is abstract and displays the result.</p>Classic MethodBase.IsAbstract Example#1"
  syntax:
    content: public bool IsAbstract { get; }
    content.vb: Public ReadOnly Property IsAbstract As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the method is abstract; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  - type: System.Reflection.BindingFlags
    commentId: T:System.Reflection.BindingFlags
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsAssembly
  commentId: P:System.Reflection.MethodBase.IsAssembly
  id: IsAssembly
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsAssembly
  fullName: System.Reflection.MethodBase.IsAssembly
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAssembly
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 164
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the potential visibility of this method or constructor is described by <xref href=\"System.Reflection.MethodAttributes.Assembly\" data-throw-if-not-resolved=\"false\"></xref>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</p>\n"
  remarks: "\n<p>The actual visibility of a method is limited by the visibility of its type. The <xref href=\"System.Reflection.MethodBase.IsAssembly\" data-throw-if-not-resolved=\"false\"></xref> property might be <strong>true</strong> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</p>\n<p>The visibility of a method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.Assembly\" data-throw-if-not-resolved=\"false\"></xref> if the only visibility modifier is <strong>internal</strong> (<strong>Friend</strong> in Visual Basic). This property is <strong>false</strong> for methods that are <strong>protected internal</strong> in C# (<strong>Protected Friend</strong> in Visual Basic, <strong>protected public</strong> in C++); use the <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref> property to identify such methods. </p>\n"
  example:
  - "\n<p>The following code example defines methods with varying levels of visibility, and displays the values of their <xref href=\"System.Reflection.MethodBase.IsAssembly\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.MethodBase.IsFamilyAndAssembly\" data-throw-if-not-resolved=\"false\"></xref> properties.</p>\n<p>The Visual Basic and C# languages cannot define methods with <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref> visibility; that access level appears only in the C++ example.</p>Classic MethodBase.IsAssembly Example#1"
  syntax:
    content: public bool IsAssembly { get; }
    content.vb: Public ReadOnly Property IsAssembly As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the visibility of this method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.Assembly\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  - type: System.Reflection.MethodBase.IsFamily
    commentId: P:System.Reflection.MethodBase.IsFamily
  - type: System.Reflection.MethodBase.IsFamilyOrAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyOrAssembly
  - type: System.Reflection.MethodBase.IsFamilyAndAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyAndAssembly
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsConstructor
  commentId: P:System.Reflection.MethodBase.IsConstructor
  id: IsConstructor
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsConstructor
  fullName: System.Reflection.MethodBase.IsConstructor
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsConstructor
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 165
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is a constructor.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.MethodBase.IsConstructor\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>false</strong> for a <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> object in a dynamic type, unless the <xref href=\"System.Reflection.MethodAttributes.RTSpecialName\" data-throw-if-not-resolved=\"false\"></xref> flag was included in the <em>attributes</em> parameter when the constructor was defined. Omitting the <xref href=\"System.Reflection.MethodAttributes.RTSpecialName\" data-throw-if-not-resolved=\"false\"></xref> flag does not affect the correctness of the emitted constructor.</p>\n"
  syntax:
    content: public bool IsConstructor { get; }
    content.vb: Public ReadOnly Property IsConstructor As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method is a constructor represented by a <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> object (see note in Remarks about <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> objects); otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsFamily
  commentId: P:System.Reflection.MethodBase.IsFamily
  id: IsFamily
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsFamily
  fullName: System.Reflection.MethodBase.IsFamily
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsFamily
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 166
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the visibility of this method or constructor is described by <xref href=\"System.Reflection.MethodAttributes.Family\" data-throw-if-not-resolved=\"false\"></xref>; that is, the method or constructor is visible only within its class and derived classes.</p>\n"
  remarks: "\n<p>The visibility of a method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.Family\" data-throw-if-not-resolved=\"false\"></xref> if the only visibility modifier is <strong>protected</strong>. This property is <strong>false</strong> for methods that are <strong>protected internal</strong> in C# (<strong>Protected Friend</strong> in Visual Basic, <strong>protected public</strong> in C++); use the <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref> property to identify such methods.</p>\n"
  example:
  - "\n<p>The following code example defines methods with varying levels of visibility, and displays the values of their <xref href=\"System.Reflection.MethodBase.IsAssembly\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.MethodBase.IsFamilyAndAssembly\" data-throw-if-not-resolved=\"false\"></xref> properties.</p>\n<p>The Visual Basic and C# languages cannot define methods with <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref> visibility; that access level appears only in the C++ example.</p>Classic MethodBase.IsAssembly Example#1"
  syntax:
    content: public bool IsFamily { get; }
    content.vb: Public ReadOnly Property IsFamily As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if access to this method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.Family\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  - type: System.Reflection.MethodBase.IsAssembly
    commentId: P:System.Reflection.MethodBase.IsAssembly
  - type: System.Reflection.MethodBase.IsFamilyOrAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyOrAssembly
  - type: System.Reflection.MethodBase.IsFamilyAndAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyAndAssembly
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsFamilyAndAssembly
  commentId: P:System.Reflection.MethodBase.IsFamilyAndAssembly
  id: IsFamilyAndAssembly
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsFamilyAndAssembly
  fullName: System.Reflection.MethodBase.IsFamilyAndAssembly
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsFamilyAndAssembly
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 167
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the visibility of this method or constructor is described by <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</p>\n"
  remarks: "\n<p>The visibility of a method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref> if the visibility modifier is <strong>protected private</strong> in C++. Methods with this visibility cannot be defined in Visual Basic or C#.</p>\n"
  example:
  - "\n<p>The following code example defines methods with varying levels of visibility, and displays the values of their <xref href=\"System.Reflection.MethodBase.IsAssembly\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.MethodBase.IsFamilyAndAssembly\" data-throw-if-not-resolved=\"false\"></xref> properties.</p>\n<p>The Visual Basic and C# languages cannot define methods with <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref> visibility; that access level appears only in the C++ example.</p>Classic MethodBase.IsAssembly Example#1"
  syntax:
    content: public bool IsFamilyAndAssembly { get; }
    content.vb: Public ReadOnly Property IsFamilyAndAssembly As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if access to this method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  - type: System.Reflection.MethodBase.IsAssembly
    commentId: P:System.Reflection.MethodBase.IsAssembly
  - type: System.Reflection.MethodBase.IsFamilyOrAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyOrAssembly
  - type: System.Reflection.MethodBase.IsFamily
    commentId: P:System.Reflection.MethodBase.IsFamily
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsFamilyOrAssembly
  commentId: P:System.Reflection.MethodBase.IsFamilyOrAssembly
  id: IsFamilyOrAssembly
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsFamilyOrAssembly
  fullName: System.Reflection.MethodBase.IsFamilyOrAssembly
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsFamilyOrAssembly
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 168
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the potential visibility of this method or constructor is described by <xref href=\"System.Reflection.MethodAttributes.FamORAssem\" data-throw-if-not-resolved=\"false\"></xref>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</p>\n"
  remarks: "\n<p>If a type member has <xref href=\"System.Reflection.MethodAttributes.FamORAssem\" data-throw-if-not-resolved=\"false\"></xref><strong></strong>visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</p>\n<p>The actual visibility of a method is limited by the visibility of its type. The <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref> property might be <strong>true</strong> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</p>\n<p>The visibility of a method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.FamORAssem\" data-throw-if-not-resolved=\"false\"></xref> if the visibility modifier is <strong>protected internal</strong> in C# (<strong>Protected Friend</strong> in Visual Basic, <strong>protected public</strong> in C++). </p>\n"
  example:
  - "\n<p>The following code example defines methods with varying levels of visibility, and displays the values of their <xref href=\"System.Reflection.MethodBase.IsAssembly\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamily\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodBase.IsFamilyOrAssembly\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.MethodBase.IsFamilyAndAssembly\" data-throw-if-not-resolved=\"false\"></xref> properties.</p>\n<p>The Visual Basic and C# languages cannot define methods with <xref href=\"System.Reflection.MethodAttributes.FamANDAssem\" data-throw-if-not-resolved=\"false\"></xref> visibility; that access level appears only in the C++ example.</p>Classic MethodBase.IsAssembly Example#1"
  syntax:
    content: public bool IsFamilyOrAssembly { get; }
    content.vb: Public ReadOnly Property IsFamilyOrAssembly As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if access to this method or constructor is exactly described by <xref href=\"System.Reflection.MethodAttributes.FamORAssem\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  - type: System.Reflection.MethodBase.IsAssembly
    commentId: P:System.Reflection.MethodBase.IsAssembly
  - type: System.Reflection.MethodBase.IsFamily
    commentId: P:System.Reflection.MethodBase.IsFamily
  - type: System.Reflection.MethodBase.IsFamilyAndAssembly
    commentId: P:System.Reflection.MethodBase.IsFamilyAndAssembly
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsFinal
  commentId: P:System.Reflection.MethodBase.IsFinal
  id: IsFinal
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsFinal
  fullName: System.Reflection.MethodBase.IsFinal
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsFinal
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 169
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether this method is <strong>final</strong>.</p>\n"
  remarks: "\n<p>To determine if a method is overridable, it is not sufficient to check that <xref href=\"System.Reflection.MethodBase.IsVirtual\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>. For a method to be overridable, <strong>IsVirtual</strong> must be <strong>true</strong> and <strong>IsFinal</strong> must be <strong>false</strong>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <strong>virtual</strong>; therefore, the compiler marks the method <strong>virtual final</strong>. So there are cases where a method is marked as <strong>virtual</strong> but is still not overridable.</p>\n<p>To establish with certainty whether a method is overridable, use code such as this: </p>\n<p>\n<code>if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)</code>\n</p>\n<p>If <strong>IsVirtual</strong> is <strong>false</strong> or <strong>IsFinal</strong> is <strong>true</strong>, then the method cannot be overridden.</p>\n"
  example:
  - "\n<p>The following example displays <strong>false</strong> for <strong>IsFinal</strong>, which might lead you to think that MyMethod is overridable. The code prints <strong>false</strong> even though MyMethod is not marked <strong>virtual</strong> and thus cannot be overridden.</p>Classic MethodBase.IsVirtual Example#1"
  syntax:
    content: public bool IsFinal { get; }
    content.vb: Public ReadOnly Property IsFinal As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method is <strong>final</strong>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsGenericMethod
  commentId: P:System.Reflection.MethodBase.IsGenericMethod
  id: IsGenericMethod
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsGenericMethod
  fullName: System.Reflection.MethodBase.IsGenericMethod
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsGenericMethod
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 170
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is generic.</p>\n"
  remarks: "\n<p>Use the <xref href=\"System.Reflection.MethodBase.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic method. Use the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object represents an open constructed method or a closed constructed method.</p>\n<p>Generics are not supported by default; this property returns <strong>false</strong> if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <strong>false</strong> if the current instance is of type <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>For a list of the invariant conditions for terms specific to generic methods, see the <xref href=\"System.Reflection.MethodInfo.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public virtual bool IsGenericMethod { get; }
    content.vb: Public Overridable ReadOnly Property IsGenericMethod As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> represents a generic method; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodBase.ContainsGenericParameters
    commentId: P:System.Reflection.MethodBase.ContainsGenericParameters
  - type: System.Reflection.MethodBase.IsGenericMethodDefinition
    commentId: P:System.Reflection.MethodBase.IsGenericMethodDefinition
  - type: System.Reflection.MethodInfo.IsGenericMethod
    commentId: P:System.Reflection.MethodInfo.IsGenericMethod
  - type: System.Type.IsGenericType
    commentId: P:System.Type.IsGenericType
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Reflection.MethodBase.IsGenericMethodDefinition
  commentId: P:System.Reflection.MethodBase.IsGenericMethodDefinition
  id: IsGenericMethodDefinition
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsGenericMethodDefinition
  fullName: System.Reflection.MethodBase.IsGenericMethodDefinition
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsGenericMethodDefinition
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 171
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is a generic method definition.</p>\n"
  remarks: "\n<p>If the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> represents a generic method definition, then:</p>\n<ul><li>\n<p>The <xref href=\"System.Reflection.MethodBase.IsGenericMethodDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>.</p>\n</li><li>\n<p>For each <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object in the array returned by the <xref href=\"System.Reflection.MethodBase.GetGenericArguments\" data-throw-if-not-resolved=\"false\"></xref> method:</p>\n<ul><li>\n<p>The <xref href=\"System.Type.IsGenericParameter\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>.</p>\n</li><li>\n<p>The <xref href=\"System.Type.DeclaringMethod\" data-throw-if-not-resolved=\"false\"></xref> property returns the current instance.</p>\n</li><li>\n<p>The <xref href=\"System.Type.GenericParameterPosition\" data-throw-if-not-resolved=\"false\"></xref> property is the same as the position of the <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object in the array.</p>\n</li></ul>\n</li></ul>\n<p>Generics are not supported by default; this property returns <strong>false</strong> if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <strong>false</strong> if the current instance is of type <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>For a list of the invariant conditions for terms specific to generic methods, see the <xref href=\"System.Reflection.MethodInfo.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public virtual bool IsGenericMethodDefinition { get; }
    content.vb: Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object represents the definition of a generic method; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.MethodInfo.IsGenericMethodDefinition
    commentId: P:System.Reflection.MethodInfo.IsGenericMethodDefinition
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Reflection.MethodBase.IsHideBySig
  commentId: P:System.Reflection.MethodBase.IsHideBySig
  id: IsHideBySig
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsHideBySig
  fullName: System.Reflection.MethodBase.IsHideBySig
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsHideBySig
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 172
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</p>\n"
  remarks: "\n<p>When a member in a derived class is declared with the C# <strong>new</strong> modifier or the Visual Basic <strong>Shadows</strong> modifier, it can hide a member of the same name in the base class. C# hides base class members by signature. That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature. By contrast, Visual Basic hides all the base class overloads. Thus, <xref href=\"System.Reflection.MethodBase.IsHideBySig\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong> on a member declared with the Visual Basic <strong>Shadows</strong> modifier, and <strong>true</strong> on a member declared with the C# <strong>new</strong> modifier. </p>\n<p>This property does not determine whether a method has the <xref href=\"System.Reflection.MethodAttributes.NewSlot\" data-throw-if-not-resolved=\"false\"></xref> attribute. A method that is declared with either the <strong>new</strong> or the <strong>Shadows</strong> modifier will have the <xref href=\"System.Reflection.MethodAttributes.NewSlot\" data-throw-if-not-resolved=\"false\"></xref> attribute, but only methods declared with <strong>new</strong> (that is, only C# methods) will have the <xref href=\"System.Reflection.MethodBase.IsHideBySig\" data-throw-if-not-resolved=\"false\"></xref> property set to <strong>true</strong>.  To determine whether a method has the <xref href=\"System.Reflection.MethodAttributes.NewSlot\" data-throw-if-not-resolved=\"false\"></xref> attribute, use code similar to the following: <code>if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)</code> in C# or <code>If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot</code> in Visual Basic. Note, however, that although all methods declared with <strong>new</strong> or <strong>Shadows</strong> have the <xref href=\"System.Reflection.MethodAttributes.NewSlot\" data-throw-if-not-resolved=\"false\"></xref> attribute, not all methods that have the <xref href=\"System.Reflection.MethodAttributes.NewSlot\" data-throw-if-not-resolved=\"false\"></xref> attribute are declared with <strong>new</strong> or <strong>Shadows</strong>.</p>\n"
  example:
  - "\n<p>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads. In the Visual Basic version of the code example, the <xref href=\"System.Reflection.MethodBase.IsHideBySig\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>false</strong> for the member in the derived class. In the C# version of the code sample, the property returns <strong>true</strong> for the member in the derived class.</p>System.Reflection.MethodBase.IsHideBySig#1"
  syntax:
    content: public bool IsHideBySig { get; }
    content.vb: Public ReadOnly Property IsHideBySig As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the member is hidden by signature; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsPrivate
  commentId: P:System.Reflection.MethodBase.IsPrivate
  id: IsPrivate
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsPrivate
  fullName: System.Reflection.MethodBase.IsPrivate
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsPrivate
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 173
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether this member is private.</p>\n"
  remarks: "\n<p>If a type member has <strong>Private</strong> level visibility, it can be called from any member in the same class and no others.</p>\n"
  syntax:
    content: public bool IsPrivate { get; }
    content.vb: Public ReadOnly Property IsPrivate As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if access to this method is restricted to other members of the class itself; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsPublic
  commentId: P:System.Reflection.MethodBase.IsPublic
  id: IsPublic
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsPublic
  fullName: System.Reflection.MethodBase.IsPublic
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsPublic
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 174
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether this is a public method.</p>\n"
  remarks: "\n<p>To get the <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref>, first get the type. From the type, get the method. From the method, get the <strong>MethodBase</strong>. If the <strong>MethodBase</strong> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <xref href=\"System.Reflection.BindingFlags\" data-throw-if-not-resolved=\"false\"></xref> mask to <strong>NonPublic</strong> in <strong>GetMethod</strong>.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Reflection.MethodBase.IsPublic\" data-throw-if-not-resolved=\"false\"></xref> property to display a message that indicates whether the specified method is public.</p>Classic MethodBase.IsPublic Example#1"
  syntax:
    content: public bool IsPublic { get; }
    content.vb: Public ReadOnly Property IsPublic As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method is public; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  - type: System.Reflection.BindingFlags
    commentId: T:System.Reflection.BindingFlags
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsSpecialName
  commentId: P:System.Reflection.MethodBase.IsSpecialName
  id: IsSpecialName
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsSpecialName
  fullName: System.Reflection.MethodBase.IsSpecialName
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsSpecialName
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 175
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether this method has a special name.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.MethodAttributes.SpecialName\" data-throw-if-not-resolved=\"false\"></xref> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</p>\n"
  example:
  - "\n<p>This example shows a use of <xref href=\"System.Reflection.MethodBase.IsSpecialName\" data-throw-if-not-resolved=\"false\"></xref> to filter internal or private members out of a list.</p>Classic Type.IsSpecialName Example#1"
  syntax:
    content: public bool IsSpecialName { get; }
    content.vb: Public ReadOnly Property IsSpecialName As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method has a special name; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsStatic
  commentId: P:System.Reflection.MethodBase.IsStatic
  id: IsStatic
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsStatic
  fullName: System.Reflection.MethodBase.IsStatic
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsStatic
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 176
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is <strong>static</strong>.</p>\n"
  remarks: "\n<p>A static member cannot implicitly reference instance data in a class.</p>\n"
  syntax:
    content: public bool IsStatic { get; }
    content.vb: Public ReadOnly Property IsStatic As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method is <strong>static</strong>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Boolean
    commentId: T:System.Boolean
  - type: System.Reflection.MethodAttributes
    commentId: T:System.Reflection.MethodAttributes
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.IsVirtual
  commentId: P:System.Reflection.MethodBase.IsVirtual
  id: IsVirtual
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: IsVirtual
  fullName: System.Reflection.MethodBase.IsVirtual
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsVirtual
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 177
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a value indicating whether the method is <strong>virtual</strong>.</p>\n"
  remarks: "\n<p>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</p>\n<p>To determine if a method is overridable, it is not sufficient to check that <strong>IsVirtual</strong> is <strong>true</strong>. For a method to be overridable, <strong>IsVirtual</strong> must be <strong>true</strong> and <xref href=\"System.Reflection.MethodBase.IsFinal\" data-throw-if-not-resolved=\"false\"></xref> must be <strong>false</strong>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <strong>virtual</strong>; therefore, the compiler marks the method <strong>virtual final</strong>. So there are cases where a method is marked as <strong>virtual</strong> but is still not overridable.</p>\n<p>To establish with certainty whether a method is overridable, use code such as this: </p>\n<pre><code class=\"c#\">if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)</code></pre>\n<pre><code class=\"vb\">If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then</code></pre>\n<p>If <strong>IsVirtual</strong> is <strong>false</strong> or <strong>IsFinal</strong> is <strong>true</strong>, then the method cannot be overridden.</p>\n<p>You can determine whether the current method overrides a method in a base class by calling the <xref href=\"System.Reflection.MethodInfo.GetBaseDefinition\" data-throw-if-not-resolved=\"false\"></xref> method. The following example implements an <code>IsOverride</code> method that does this.</p>system.reflection.methodinfo.getbasedefinition#2"
  example:
  - "\n<p>The following example displays <strong>false</strong> for <strong>IsFinal</strong>, which might lead you to think that <code>MyMethod</code> is overridable. The code prints <strong>false</strong> even though <code>MyMethod</code> is not marked <strong>virtual</strong> and thus cannot be overridden.</p>Classic MethodBase.IsVirtual Example#1"
  syntax:
    content: public bool IsVirtual { get; }
    content.vb: Public ReadOnly Property IsVirtual As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this method is <strong>virtual</strong>; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.MethodBase.MethodImplementationFlags
  commentId: P:System.Reflection.MethodBase.MethodImplementationFlags
  id: MethodImplementationFlags
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: MethodImplementationFlags
  fullName: System.Reflection.MethodBase.MethodImplementationFlags
  type: Property
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MethodImplementationFlags
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 178
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets the <xref href=\"System.Reflection.MethodImplAttributes\" data-throw-if-not-resolved=\"false\"></xref> flags that specify the attributes of a method implementation.</p>\n"
  remarks: "\n<p>See the <xref href=\"System.Reflection.MethodBase.GetMethodImplementationFlags\" data-throw-if-not-resolved=\"false\"></xref> method for more information.</p>\n"
  syntax:
    content: public abstract MethodImplAttributes MethodImplementationFlags { get; }
    content.vb: Public MustOverride ReadOnly Property MethodImplementationFlags As MethodImplAttributes
    parameters: []
    return:
      type: System.Reflection.MethodImplAttributes
      description: "\n<p>The method implementation flags.</p>\n"
  modifiers.csharp:
  - public
  - abstract
  - get
  modifiers.vb:
  - Public
  - MustOverride
  - ReadOnly
- uid: System.Reflection.MethodBase.Equals(System.Object)
  commentId: M:System.Reflection.MethodBase.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.Reflection.MethodBase.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Equals
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 179
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Returns a value that indicates whether this instance is equal to a specified object.</p>\n"
  syntax:
    content: public override bool Equals(object obj)
    content.vb: Public Overrides Function Equals(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>An object to compare with this instance, or <strong>null</strong>.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>obj</em> equals the type and value of this instance; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Reflection.MemberInfo.Equals(System.Object)
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.MethodBase.GetGenericArguments
  commentId: M:System.Reflection.MethodBase.GetGenericArguments
  id: GetGenericArguments
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: GetGenericArguments()
  fullName: System.Reflection.MethodBase.GetGenericArguments()
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetGenericArguments
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 180
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Returns an array of <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</p>\n"
  remarks: "\n<p>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</p>\n<ul><li>\n<p>If the current method is a closed constructed method (that is, the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>false</strong>), the array returned by the <xref href=\"System.Reflection.MethodBase.GetGenericArguments\" data-throw-if-not-resolved=\"false\"></xref> method contains the types that have been assigned to the generic type parameters of the generic method definition. </p>\n</li><li>\n<p>If the current method is a generic method definition, the array contains the type parameters. </p>\n</li><li>\n<p>If the current method is an open constructed method (that is, the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters. Use the <xref href=\"System.Type.IsGenericParameter\" data-throw-if-not-resolved=\"false\"></xref> property to tell them apart. For a demonstration of this scenario, see the code example provided for the <xref href=\"System.Reflection.MethodBase.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li></ul>\n<p>Generic constructors are not supported in the .NET Framework version 2.0. This property throws <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>For a list of the invariant conditions for terms specific to generic methods, see the <xref href=\"System.Reflection.MethodInfo.IsGenericMethod\" data-throw-if-not-resolved=\"false\"></xref> property. For a list of the invariant conditions for other terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public virtual Type[] GetGenericArguments()
    content.vb: Public Overridable Function GetGenericArguments As Type()
    return:
      type: System.Type[]
      description: "\n<p>An array of <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The current object is a <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref>. Generic constructors are not supported in the .NET Framework version 2.0. This exception is the default behavior if this method is not overridden in a derived class.</p>\n"
  seealso:
  - type: System.Reflection.MethodBase.IsGenericMethod
    commentId: P:System.Reflection.MethodBase.IsGenericMethod
  - type: System.Reflection.MethodBase.IsGenericMethodDefinition
    commentId: P:System.Reflection.MethodBase.IsGenericMethodDefinition
  - type: System.Reflection.MethodInfo.GetGenericArguments
    commentId: M:System.Reflection.MethodInfo.GetGenericArguments
  - type: System.Reflection.MethodInfo.IsGenericMethod
    commentId: P:System.Reflection.MethodInfo.IsGenericMethod
  - type: System.Type.IsGenericType
    commentId: P:System.Type.IsGenericType
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Reflection.MethodBase.GetHashCode
  commentId: M:System.Reflection.MethodBase.GetHashCode
  id: GetHashCode
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.Reflection.MethodBase.GetHashCode()
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHashCode
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 181
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Returns the hash code for this instance.</p>\n"
  syntax:
    content: public override int GetHashCode()
    content.vb: Public Overrides Function GetHashCode As Integer
    return:
      type: System.Int32
      description: "\n<p>A 32-bit signed integer hash code.</p>\n"
  overridden: System.Reflection.MemberInfo.GetHashCode
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)
  commentId: M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)
  id: GetMethodFromHandle(System.RuntimeMethodHandle)
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: GetMethodFromHandle(RuntimeMethodHandle)
  fullName: System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetMethodFromHandle
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 182
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets method information by using the method's internal metadata representation (handle).</p>\n"
  remarks: "\n<p>Handles are valid only in the application domain in which they were obtained.</p>\n"
  syntax:
    content: public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle)
    content.vb: Public Shared Function GetMethodFromHandle(handle As RuntimeMethodHandle) As MethodBase
    parameters:
    - id: handle
      type: System.RuntimeMethodHandle
      description: "\n<p>The method's handle. </p>\n"
    return:
      type: System.Reflection.MethodBase
      description: "\n<p>A <strong>MethodBase</strong> containing information about the method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>handle</em> is invalid.</p>\n"
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  commentId: M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  id: GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: GetMethodFromHandle(RuntimeMethodHandle, RuntimeTypeHandle)
  fullName: System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle, System.RuntimeTypeHandle)
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetMethodFromHandle
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 183
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Gets a <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object for the constructor or method represented by the specified handle, for the specified generic type.</p>\n"
  remarks: "\n<p>Handles are valid only in the application domain in which they were obtained.</p>\n<p>A <xref href=\"System.RuntimeMethodHandle\" data-throw-if-not-resolved=\"false\"></xref> structure for a constructor or method of a generic type can represent different <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> objects, depending on the types specified for the type parameters of the generic type. For example, if <code>class G<T></code> (<code>class G(Of T)</code> in Visual Basic, <code>generic <T> ref class G</code> in C++) has a method that returns type <code>T</code>, the <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object for that method in a constructed class such as <code>G<int></code> is different from the <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object for that method in the generic type definition.</p>\n"
  syntax:
    content: public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType)
    content.vb: Public Shared Function GetMethodFromHandle(handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase
    parameters:
    - id: handle
      type: System.RuntimeMethodHandle
      description: "\n<p>A handle to the internal metadata representation of a constructor or method.</p>\n"
    - id: declaringType
      type: System.RuntimeTypeHandle
      description: "\n<p>A handle to the generic type that defines the constructor or method.</p>\n"
    return:
      type: System.Reflection.MethodBase
      description: "\n<p>A <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> object representing the method or constructor specified by <em>handle</em>, in the generic type specified by <em>declaringType</em>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>handle</em> is invalid.</p>\n"
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Reflection.MethodBase.GetParameters
  commentId: M:System.Reflection.MethodBase.GetParameters
  id: GetParameters
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: GetParameters()
  fullName: System.Reflection.MethodBase.GetParameters()
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetParameters
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 184
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>When overridden in a derived class, gets the parameters of the specified method or constructor.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Reflection.MethodBase.GetParameters\" data-throw-if-not-resolved=\"false\"></xref> method to retrieve the parameters of the <strong>Invoke</strong> method of a delegate.</p>\n<p>The example defines a delegate named <code>MyDelegate</code> and an event named <code>ev</code> of type <code>MyDelegate</code>. The code in the <code>Main</code> method discovers the event signature by getting the delegate type of the event, getting the <strong>Invoke</strong> method of the delegate type, and then retrieving and displaying the parameters.</p>eventarg#1"
  syntax:
    content: public abstract ParameterInfo[] GetParameters()
    content.vb: Public MustOverride Function GetParameters As ParameterInfo()
    return:
      type: System.Reflection.ParameterInfo[]
      description: "\n<p>An array of type <strong>ParameterInfo</strong> containing information that matches the signature of the method (or constructor) reflected by this <strong>MethodBase</strong> instance.</p>\n"
  seealso:
  - type: System.Reflection.ParameterInfo
    commentId: T:System.Reflection.ParameterInfo
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
- uid: System.Reflection.MethodBase.Invoke(System.Object,System.Object[])
  commentId: M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])
  id: Invoke(System.Object,System.Object[])
  parent: System.Reflection.MethodBase
  langs:
  - csharp
  - vb
  name: Invoke(Object, Object[])
  fullName: System.Reflection.MethodBase.Invoke(System.Object, System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Reflection/ref/4.0/System.Reflection.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Invoke
    path: src/System.Reflection/ref/4.0/System.Reflection.cs
    startLine: 185
  assemblies:
  - System.Reflection
  namespace: System.Reflection
  summary: "\n<p>Invokes the method or constructor represented by the current instance, using the specified parameters.</p>\n"
  remarks: "\n<p>This is a convenience method that calls the <xref href=\"System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)\" data-throw-if-not-resolved=\"false\"></xref> method overload, passing <xref href=\"System.Reflection.BindingFlags.Default\" data-throw-if-not-resolved=\"false\"></xref> for <em>invokeAttr</em> and <strong>null</strong> for <em>binder</em> and <em>culture</em>. </p>\n<p>If the invoked method throws an exception, the <xref href=\"System.Exception.GetBaseException\" data-throw-if-not-resolved=\"false\"></xref> method returns the exception.</p>\n<p>To invoke a static method using its <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object, pass <strong>null</strong> for <em>obj</em>. </p>\n<p>If this method overload is used to invoke an instance constructor, the object supplied for <em>obj</em> is reinitialized; that is, all instance initializers are executed. The return value is <strong>null</strong>. If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is <strong>null</strong>.</p>\n<p>Starting with the .NET Framework 2.0 Service Pack 1, this method can be used to access non-public members if the caller has been granted <xref href=\"System.Security.Permissions.ReflectionPermission\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess\" data-throw-if-not-resolved=\"false\"></xref> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See Security Considerations for Reflection.) </p>\n<p>To use this functionality, your application should target the .NET Framework 3.5 or later.</p>\n<p>If a parameter of the current method is a value type, and the corresponding argument in <em>parameters</em> is <strong>null</strong>, the runtime passes a zero-initialized instance of the value type. </p>\n"
  example:
  - "\n<p>The following code example demonstrates dynamic method lookup using reflection. Note that you cannot use the <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</p>Classic MethodBase.Invoke1 Example#1"
  syntax:
    content: public virtual object Invoke(object obj, object[] parameters)
    content.vb: Public Overridable Function Invoke(obj As Object, parameters As Object()) As Object
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be <strong>null</strong> or an instance of the class that defines the constructor.</p>\n"
    - id: parameters
      type: System.Object[]
      description: "\n<p>An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, <em>parameters</em> should be <strong>null</strong>.</p>\n<p>If the method or constructor represented by this instance takes a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <strong>null</strong>. For value-type elements, this value is 0, 0.0, or <strong>false</strong>, depending on the specific element type. </p>\n"
    return:
      type: System.Object
      description: "\n<p>An object containing the return value of the invoked method, or <strong>null</strong> in the case of a constructor.</p>\n<p>Elements of the <em>parameters</em> array that represent parameters declared with the <strong>ref</strong> or <strong>out</strong> keyword may also be modified.</p>\n"
  exceptions:
  - type: System.Reflection.TargetException
    commentId: T:System.Reflection.TargetException
    description: "\n<p>In the <see href=\"http://go.microsoft.com/fwlink/?LinkID=247912\">.NET for Windows Store apps</see> or the Portable Class Library, catch <xref href=\"System.Exception\" data-throw-if-not-resolved=\"false\"></xref> instead.</p>\n<p>The <em>obj</em> parameter is <strong>null</strong> and the method is not static.</p>\n<p>-or- </p>\n<p>The method is not declared or inherited by the class of <em>obj</em>. </p>\n<p>-or-</p>\n<p>A static constructor is invoked, and <em>obj</em> is neither <strong>null</strong> nor an instance of the class that declared the constructor.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The elements of the <em>parameters</em>array do not match the signature of the method or constructor reflected by this instance. </p>\n"
  - type: System.Reflection.TargetInvocationException
    commentId: T:System.Reflection.TargetInvocationException
    description: "\n<p>The invoked method or constructor throws an exception. </p>\n<p>-or-</p>\n<p>The current instance is a <xref href=\"System.Reflection.Emit.DynamicMethod\" data-throw-if-not-resolved=\"false\"></xref> that contains unverifiable code. See the \"Verification\" section in Remarks for <xref href=\"System.Reflection.Emit.DynamicMethod\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Reflection.TargetParameterCountException
    commentId: T:System.Reflection.TargetParameterCountException
    description: "\n<p>The <em>parameters</em> array does not have the correct number of arguments. </p>\n"
  - type: System.MethodAccessException
    commentId: T:System.MethodAccessException
    description: "\n<p>In the <see href=\"http://go.microsoft.com/fwlink/?LinkID=247912\">.NET for Windows Store apps</see> or the Portable Class Library, catch the base class exception, <xref href=\"System.MemberAccessException\" data-throw-if-not-resolved=\"false\"></xref>, instead.</p>\n<p>The caller does not have permission to execute the method or constructor that is represented by the current instance. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type that declares the method is an open generic type. That is, the <xref href=\"System.Type.ContainsGenericParameters\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong> for the declaring type.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The current instance is a <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Reflection.BindingFlags
    commentId: T:System.Reflection.BindingFlags
  - type: System.Reflection.Missing
    commentId: T:System.Reflection.Missing
  - type: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
    commentId: M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Reflection.MethodBase.Invoke(System.Object, System.Object())
  name.vb: Invoke(Object, Object())
references:
- uid: System.Reflection
  isExternal: false
  name: System.Reflection
  fullName: System.Reflection
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Reflection.MemberInfo
  parent: System.Reflection
  isExternal: false
  name: Reflection.MemberInfo
  fullName: System.Reflection.MemberInfo
- uid: System.Reflection.MemberInfo.CustomAttributes
  parent: System.Reflection.MemberInfo
  isExternal: false
  name: CustomAttributes
  fullName: System.Reflection.MemberInfo.CustomAttributes
- uid: System.Reflection.MemberInfo.DeclaringType
  parent: System.Reflection.MemberInfo
  isExternal: false
  name: DeclaringType
  fullName: System.Reflection.MemberInfo.DeclaringType
- uid: System.Reflection.MemberInfo.Module
  parent: System.Reflection.MemberInfo
  isExternal: false
  name: Module
  fullName: System.Reflection.MemberInfo.Module
- uid: System.Reflection.MemberInfo.Name
  parent: System.Reflection.MemberInfo
  isExternal: false
  name: Name
  fullName: System.Reflection.MemberInfo.Name
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Reflection.MethodAttributes
  parent: System.Reflection
  isExternal: false
  name: MethodAttributes
  fullName: System.Reflection.MethodAttributes
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: false
  name: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Reflection.MethodImplAttributes
  parent: System.Reflection
  isExternal: false
  name: MethodImplAttributes
  fullName: System.Reflection.MethodImplAttributes
- uid: System.Reflection.MemberInfo.Equals(System.Object)
  parent: System.Reflection.MemberInfo
  isExternal: true
  name: Equals(Object)
  fullName: System.Reflection.MemberInfo.Equals(System.Object)
  spec.csharp:
  - uid: System.Reflection.MemberInfo.Equals(System.Object)
    name: Equals
    fullName: System.Reflection.MemberInfo.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Reflection.MemberInfo.Equals(System.Object)
    name: Equals
    fullName: System.Reflection.MemberInfo.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Type[]
  isExternal: false
  name: Type[]
  fullName: System.Type[]
  fullname.vb: System.Type()
  name.vb: Type()
  spec.csharp:
  - uid: System.Type
    name: Type
    fullName: System.Type
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Type
    name: Type
    fullName: System.Type
  - name: ()
    fullName: ()
- uid: System.Reflection.MemberInfo.GetHashCode
  parent: System.Reflection.MemberInfo
  isExternal: false
  name: GetHashCode()
  fullName: System.Reflection.MemberInfo.GetHashCode()
  spec.csharp:
  - uid: System.Reflection.MemberInfo.GetHashCode
    name: GetHashCode
    fullName: System.Reflection.MemberInfo.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Reflection.MemberInfo.GetHashCode
    name: GetHashCode
    fullName: System.Reflection.MemberInfo.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.RuntimeMethodHandle
  parent: System
  isExternal: false
  name: RuntimeMethodHandle
  fullName: System.RuntimeMethodHandle
- uid: System.Reflection.MethodBase
  parent: System.Reflection
  isExternal: false
  name: MethodBase
  fullName: System.Reflection.MethodBase
- uid: System.RuntimeTypeHandle
  parent: System
  isExternal: false
  name: RuntimeTypeHandle
  fullName: System.RuntimeTypeHandle
- uid: System.Reflection.ParameterInfo[]
  isExternal: false
  name: ParameterInfo[]
  fullName: System.Reflection.ParameterInfo[]
  fullname.vb: System.Reflection.ParameterInfo()
  name.vb: ParameterInfo()
  spec.csharp:
  - uid: System.Reflection.ParameterInfo
    name: ParameterInfo
    fullName: System.Reflection.ParameterInfo
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Reflection.ParameterInfo
    name: ParameterInfo
    fullName: System.Reflection.ParameterInfo
  - name: ()
    fullName: ()
- uid: System.Object[]
  isExternal: false
  name: Object[]
  fullName: System.Object[]
  fullname.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ()
    fullName: ()
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.Reflection.TargetException
  isExternal: false
  name: TargetException
  fullName: System.Reflection.TargetException
- uid: System.Reflection.TargetInvocationException
  isExternal: false
  name: TargetInvocationException
  fullName: System.Reflection.TargetInvocationException
- uid: System.Reflection.TargetParameterCountException
  isExternal: false
  name: TargetParameterCountException
  fullName: System.Reflection.TargetParameterCountException
- uid: System.MethodAccessException
  isExternal: false
  name: MethodAccessException
  fullName: System.MethodAccessException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
