items:
- uid: System.Threading.WaitHandle
  commentId: T:System.Threading.WaitHandle
  id: WaitHandle
  parent: System.Threading
  children:
  - System.Threading.WaitHandle.#ctor
  - System.Threading.WaitHandle.Dispose
  - System.Threading.WaitHandle.Dispose(System.Boolean)
  - System.Threading.WaitHandle.InvalidHandle
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  - System.Threading.WaitHandle.WaitOne
  - System.Threading.WaitHandle.WaitOne(System.Int32)
  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  - System.Threading.WaitHandle.WaitTimeout
  langs:
  - csharp
  - vb
  name: WaitHandle
  fullName: System.Threading.WaitHandle
  type: Class
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitHandle
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3201
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see Overview of Synchronization Primitives.</p>\n<p>The <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class itself is abstract. Classes derived from <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> methods to block while waiting for access to shared resources. The classes derived from <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> include: </p>\n<ul><li>\n<p>The <xref href=\"System.Threading.Mutex\" data-throw-if-not-resolved=\"false\"></xref> class. See Mutexes.</p>\n</li><li>\n<p>The <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class and its derived classes, <xref href=\"System.Threading.AutoResetEvent\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref>. See EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent.</p>\n</li><li>\n<p>The <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class. See Semaphore and SemaphoreSlim.</p>\n</li></ul>\n<p>Threads can block on an individual wait handle by calling the instance method <xref href=\"System.Threading.WaitHandle.WaitOne\" data-throw-if-not-resolved=\"false\"></xref>, which is inherited by classes derived from <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>The derived classes of <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> differ in their thread affinity. Event wait handles (<xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.AutoResetEvent\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref href=\"System.Threading.Mutex.ReleaseMutex\" data-throw-if-not-resolved=\"false\"></xref> method on a mutex that it does not own.</p>\n<p>Because the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class derives from <xref href=\"System.MarshalByRefObject\" data-throw-if-not-resolved=\"false\"></xref>, these classes can be used to synchronize the activities of threads across application domain boundaries.</p>\n<p> In addition to its derived classes, the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:</p>\n<ul><li>\n<p>\n<xref href=\"System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\" data-throw-if-not-resolved=\"false\"></xref>, which allows a thread to signal one wait handle and immediately wait on another. </p>\n</li><li>\n<p>\n<xref href=\"System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\" data-throw-if-not-resolved=\"false\"></xref>, which allows a thread to wait until all the wait handles in an array receive a signal.</p>\n</li><li>\n<p>\n<xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\" data-throw-if-not-resolved=\"false\"></xref>, which allows a thread to wait until any one of a specified set of wait handles has been signaled . </p>\n</li></ul>\n<p> The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context. </p>\n<p>This type implements the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method in a <strong>try</strong>/<strong>catch</strong> block. To dispose of it indirectly, use a language construct such as <strong>using</strong> (in C#) or <strong>Using</strong> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface topic.</p>\n<p>\n<xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> implements the <xref href=\"System.IDisposable.Dispose\" data-throw-if-not-resolved=\"false\"></xref> pattern. See Dispose Pattern. When you derive from <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref>, use the <xref href=\"System.Threading.WaitHandle.SafeWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> property to store your native handle operating system handle. You do not need to override the protected <xref href=\"System.Threading.WaitHandle.Dispose(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method unless you use additional unmanaged resources. </p>\n"
  example:
  - "\n<p>The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\" data-throw-if-not-resolved=\"false\"></xref> methods of the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>WaitHandle#1"
  syntax:
    content: 'public abstract class WaitHandle : IDisposable'
    content.vb: >-
      Public MustInherit Class WaitHandle
          Implements IDisposable
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Threading.WaitHandle.InvalidHandle
  commentId: F:System.Threading.WaitHandle.InvalidHandle
  id: InvalidHandle
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: InvalidHandle
  fullName: System.Threading.WaitHandle.InvalidHandle
  type: Field
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: InvalidHandle
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3203
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Represents an invalid native operating system handle. This field is read-only.</p>\n"
  remarks: "\n<p>Used internally to initialize the <xref href=\"System.Threading.WaitHandle.Handle\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  syntax:
    content: protected static readonly IntPtr InvalidHandle
    content.vb: Protected Shared ReadOnly InvalidHandle As IntPtr
    return:
      type: System.IntPtr
  modifiers.csharp:
  - protected
  - static
  - readonly
  modifiers.vb:
  - Protected
  - Shared
  - ReadOnly
- uid: System.Threading.WaitHandle.WaitTimeout
  commentId: F:System.Threading.WaitHandle.WaitTimeout
  id: WaitTimeout
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitTimeout
  fullName: System.Threading.WaitHandle.WaitTimeout
  type: Field
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitTimeout
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3204
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Indicates that a <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> operation timed out before any of the wait handles were signaled. This field is constant.</p>\n"
  remarks: "\n<p>This field is one of the possible return values of <strong>WaitAny</strong>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.</p>System.Threading.WaitHandle.WaitAny2#1"
  syntax:
    content: public const int WaitTimeout = 258
    content.vb: Public Const WaitTimeout As Integer = 258
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - const
  modifiers.vb:
  - Public
  - Const
- uid: System.Threading.WaitHandle.#ctor
  commentId: M:System.Threading.WaitHandle.#ctor
  id: '#ctor'
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitHandle()
  fullName: System.Threading.WaitHandle.WaitHandle()
  type: Constructor
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3205
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: protected WaitHandle()
    content.vb: Protected Sub New
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Threading.WaitHandle.Dispose
  commentId: M:System.Threading.WaitHandle.Dispose
  id: Dispose
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Threading.WaitHandle.Dispose()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3206
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Releases all resources used by the current instance of the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>This method is equivalent to the <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>Always call <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.WaitHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> before you release your last reference to the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref>. Otherwise, the resources it is using will not be freed.</p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.WaitHandle.Dispose(System.Boolean)
  commentId: M:System.Threading.WaitHandle.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Threading.WaitHandle.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3207
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>When overridden in a derived class, releases the unmanaged resources used by the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref>, and optionally releases the managed resources.</p>\n"
  remarks: "\n<p>This method is called by the <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Threading.WaitHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> methods with the <em>explicitDisposing</em> parameter set to <strong>true</strong>.  When the <em>explicitDisposing</em> parameter is <strong>true</strong>, this method releases all resources held by any managed objects that this <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> object references.</p>\n"
  syntax:
    content: protected virtual void Dispose(bool explicitDisposing)
    content.vb: Protected Overridable Sub Dispose(explicitDisposing As Boolean)
    parameters:
    - id: explicitDisposing
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to release both managed and unmanaged resources; <strong>false</strong> to release only unmanaged resources. </p>\n"
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  id: WaitAll(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAll(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAll
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3208
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for all the elements in the specified array to receive a signal.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> is new in the .NET Framework version 2.0. In previous versions, the <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method returns <strong>true</strong> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown. If the array contains duplicates, the call fails with a <xref href=\"System.DuplicateWaitObjectException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method is not supported on threads that have <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Calling this method overload is equivalent to calling the <xref href=\"System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying -1 (or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) for <em>millisecondsTimeout</em>and <strong>true</strong> for <em>exitContext</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.</p>System.Threading.WaitHandle.WaitAll1#1"
  syntax:
    content: public static bool WaitAll(WaitHandle[] waitHandles)
    content.vb: Public Shared Function WaitAll(waitHandles As WaitHandle()) As Boolean
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> when every element in <em>waitHandles</em> has received a signal; otherwise the method never returns.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>. -or- </p>\n<p>One or more of the objects in the <em>waitHandles</em> array are <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>waitHandles</em> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n"
  - type: System.DuplicateWaitObjectException
    commentId: T:System.DuplicateWaitObjectException
    description: "\n<p>In the <see href=\"http://go.microsoft.com/fwlink/?LinkID=247912\">.NET for Windows Store apps</see> or the Portable Class Library, catch the base class exception, <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>, instead.</p>\n<p>The <em>waitHandles</em> array contains elements that are duplicates. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute is applied to the thread procedure for the current thread, and <em>waitHandles</em> contains more than one element. </p>\n"
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "\n<p>\n<em>waitHandles</em> is an array with no elements and the .NET Framework version is 1.0 or 1.1. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle())
  name.vb: WaitAll(WaitHandle())
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)
  id: WaitAll(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAll(WaitHandle[], Int32)
  fullName: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAll
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3209
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> value to specify the time interval.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown. If there are duplicates in the array, the call fails with a <xref href=\"System.DuplicateWaitObjectException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method is not supported on threads that have <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  syntax:
    content: public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout)
    content.vb: Public Shared Function WaitAll(waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates). </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> when every element in <em>waitHandles</em> has received a signal; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>One or more of the objects in the <em>waitHandles</em> array is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>waitHandles</em> is an array with no elements. </p>\n"
  - type: System.DuplicateWaitObjectException
    commentId: T:System.DuplicateWaitObjectException
    description: "\n<p>In the <see href=\"http://go.microsoft.com/fwlink/?LinkID=247912\">.NET for Windows Store apps</see> or the Portable Class Library, catch the base class exception, <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>, instead.</p>\n<p>The <em>waitHandles</em> array contains elements that are duplicates. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute is applied to the thread procedure for the current thread, and <em>waitHandles</em> contains more than one element. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle(), System.Int32)
  name.vb: WaitAll(WaitHandle(), Int32)
- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  id: WaitAll(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAll(WaitHandle[], TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[], System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAll
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3210
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> value to specify the time interval.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown. If the array contains duplicates, the call will fail.</p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see> method is not supported on threads that have <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The maximum value for <em>timeout</em> is <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  syntax:
    content: public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout)
    content.vb: Public Shared Function WaitAll(waitHandles As WaitHandle(), timeout As TimeSpan) As Boolean
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object. </p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds, to wait indefinitely. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> when every element in <em>waitHandles</em> has received a signal; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>. </p>\n<p>-or- </p>\n<p>One or more of the objects in the <em>waitHandles</em> array is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>waitHandles</em> is an array with no elements. </p>\n"
  - type: System.DuplicateWaitObjectException
    commentId: T:System.DuplicateWaitObjectException
    description: "\n<p>In the <see href=\"http://go.microsoft.com/fwlink/?LinkID=247912\">.NET for Windows Store apps</see> or the Portable Class Library, catch the base class exception, <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>, instead.</p>\n<p>The <em>waitHandles</em> array contains elements that are duplicates. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute is applied to the thread procedure for the current thread, and <em>waitHandles</em> contains more than one element. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out. </p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle(), System.TimeSpan)
  name.vb: WaitAll(WaitHandle(), TimeSpan)
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  id: WaitAny(System.Threading.WaitHandle[])
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAny(WaitHandle[])
  fullName: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAny
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3211
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for any of the elements in the specified array to receive a signal.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> is new in the .NET Framework version 2.0. In previous versions, the <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method returns <strong>true</strong> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method throws an <xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> only when the wait completes because of an abandoned mutex. If <em>waitHandles</em> contains a released mutex with a lower index number than the abandoned mutex, the <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method completes normally and the exception is not thrown.</p>\n<p>In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref href=\"System.Threading.Mutex\" data-throw-if-not-resolved=\"false\"></xref>, and that <strong>Mutex</strong> is at index 0 (zero) in a <strong>WaitAny</strong> array on another thread, the index returned by <strong>WaitAny</strong> is 128 instead of 0.</p>\n<p>This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>Calling this method overload is equivalent to calling the <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying -1 (or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) for <em>millisecondsTimeout</em>and <strong>true</strong> for <em>exitContext</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates calling the <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\" data-throw-if-not-resolved=\"false\"></xref>method.</p>WaitHandle#1"
  syntax:
    content: public static int WaitAny(WaitHandle[] waitHandles)
    content.vb: Public Shared Function WaitAny(waitHandles As WaitHandle()) As Integer
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The array index of the object that satisfied the wait.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>One or more of the objects in the <em>waitHandles</em> array is <strong>null</strong>. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits. </p>\n"
  - type: System.ApplicationException
    commentId: T:System.ApplicationException
    description: "\n<p>\n<em>waitHandles</em> is an array with no elements, and the .NET Framework version is 1.0 or 1.1. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>waitHandles</em> is an array with no elements, and the .NET Framework version is 2.0 or later. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle())
  name.vb: WaitAny(WaitHandle())
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)
  id: WaitAny(System.Threading.WaitHandle[],System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAny(WaitHandle[], Int32)
  fullName: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAny
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3212
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method throws an <xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> only when the wait completes because of an abandoned mutex. If <em>waitHandles</em> contains a released mutex with a lower index number than the abandoned mutex, the <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method completes normally and the exception is not thrown.</p>\n<p>This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  syntax:
    content: public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout)
    content.vb: Public Shared Function WaitAny(waitHandles As WaitHandle(), millisecondsTimeout As Integer) As Integer
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\" data-throw-if-not-resolved=\"false\"></xref> if no object satisfied the wait and a time interval equivalent to <em>millisecondsTimeout</em> has passed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>One or more of the objects in the <em>waitHandles</em> array is <strong>null</strong>. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>waitHandles</em> is an array with no elements. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle(), System.Int32)
  name.vb: WaitAny(WaitHandle(), Int32)
- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  id: WaitAny(System.Threading.WaitHandle[],System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitAny(WaitHandle[], TimeSpan)
  fullName: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitAny
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3213
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> to specify the time interval.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is zero, the method does not block. It tests the state of the wait handles and returns immediately. </p>\n<p>The <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method throws an <xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> only when the wait completes because of an abandoned mutex. If <em>waitHandles</em> contains a released mutex with a lower index number than the abandoned mutex, the <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> method completes normally and the exception is not thrown.</p>\n<p>This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>The maximum value for <em>timeout</em> is <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  syntax:
    content: public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout)
    content.vb: Public Shared Function WaitAny(waitHandles As WaitHandle(), timeout As TimeSpan) As Integer
    parameters:
    - id: waitHandles
      type: System.Threading.WaitHandle[]
      description: "\n<p>A <strong>WaitHandle</strong> array containing the objects for which the current instance will wait. </p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\" data-throw-if-not-resolved=\"false\"></xref> if no object satisfied the wait and a time interval equivalent to <em>timeout</em> has passed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>waitHandles</em> parameter is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>One or more of the objects in the <em>waitHandles</em> array is <strong>null</strong>. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The number of objects in <em>waitHandles</em> is greater than the system permits. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out. </p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>waitHandles</em> is an array with no elements. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>waitHandles</em> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle(), System.TimeSpan)
  name.vb: WaitAny(WaitHandle(), TimeSpan)
- uid: System.Threading.WaitHandle.WaitOne
  commentId: M:System.Threading.WaitHandle.WaitOne
  id: WaitOne
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitOne()
  fullName: System.Threading.WaitHandle.WaitOne()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitOne
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3214
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> receives a signal.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.AbandonedMutexException\" data-throw-if-not-resolved=\"false\"></xref> is new in the .NET Framework version 2.0. In previous versions, the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method returns <strong>true</strong> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging. </p>\n<p>The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref href=\"System.IAsyncResult\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n<p>Calling this method overload is equivalent to calling the <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying -1 or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> for the first parameter and <strong>false</strong> for the second parameter.</p>\n<p>Override this method to customize the behavior of derived classes.</p>\n"
  example:
  - "\n<p>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</p>System.Threading.WaitHandle.WaitOne1#1"
  syntax:
    content: public virtual bool WaitOne()
    content.vb: Public Overridable Function WaitOne As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current instance receives a signal. If the current instance is never signaled, <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> never returns.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Threading.WaitHandle.WaitOne(System.Int32)
  commentId: M:System.Threading.WaitHandle.WaitOne(System.Int32)
  id: WaitOne(System.Int32)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitOne(Int32)
  fullName: System.Threading.WaitHandle.WaitOne(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitOne
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3215
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </p>\n<p>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref href=\"System.IAsyncResult\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n<p>Override this method to customize the behavior of derived classes.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  example:
  - "\n<p>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.</p>System.Threading.WaitHandle.WaitOne2#1"
  syntax:
    content: public virtual bool WaitOne(int millisecondsTimeout)
    content.vb: Public Overridable Function WaitOne(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1) to wait indefinitely. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current instance receives a signal; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  commentId: M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  id: WaitOne(System.TimeSpan)
  parent: System.Threading.WaitHandle
  langs:
  - csharp
  - vb
  name: WaitOne(TimeSpan)
  fullName: System.Threading.WaitHandle.WaitOne(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitOne
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 3216
  assemblies:
  - System.Runtime
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> to specify the time interval.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is zero, the method does not block. It tests the state of the wait handle and returns immediately. </p>\n<p>The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref href=\"System.IAsyncResult\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n<p>Override this method to customize the behavior of derived classes.</p>\n<p>The maximum value for <em>timeout</em> is <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Calling this method overload is the same as calling the <xref href=\"System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> overload and specifying <strong>false</strong> for <em>exitContext</em>. </p>\n"
  syntax:
    content: public virtual bool WaitOne(TimeSpan timeout)
    content.vb: Public Overridable Function WaitOne(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current instance receives a signal; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out.</p>\n<p>-or-</p>\n<p>\n<em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.Threading.AbandonedMutexException
    commentId: T:System.Threading.AbandonedMutexException
    description: "\n<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> in another application domain.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: false
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: false
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: false
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: false
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: false
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: false
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Object.ToString
  parent: System.Object
  isExternal: false
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Threading.WaitHandle[]
  isExternal: false
  name: WaitHandle[]
  fullName: System.Threading.WaitHandle[]
  fullname.vb: System.Threading.WaitHandle()
  name.vb: WaitHandle()
  spec.csharp:
  - uid: System.Threading.WaitHandle
    name: WaitHandle
    fullName: System.Threading.WaitHandle
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Threading.WaitHandle
    name: WaitHandle
    fullName: System.Threading.WaitHandle
  - name: ()
    fullName: ()
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.DuplicateWaitObjectException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ApplicationException
- uid: System.Threading.AbandonedMutexException
  isExternal: false
  name: AbandonedMutexException
  fullName: System.Threading.AbandonedMutexException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
