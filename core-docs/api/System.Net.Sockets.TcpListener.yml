items:
- uid: System.Net.Sockets.TcpListener
  commentId: T:System.Net.Sockets.TcpListener
  id: TcpListener
  parent: System.Net.Sockets
  children:
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  - System.Net.Sockets.TcpListener.AcceptSocketAsync
  - System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  - System.Net.Sockets.TcpListener.Active
  - System.Net.Sockets.TcpListener.ExclusiveAddressUse
  - System.Net.Sockets.TcpListener.LocalEndpoint
  - System.Net.Sockets.TcpListener.Pending
  - System.Net.Sockets.TcpListener.Server
  - System.Net.Sockets.TcpListener.Start
  - System.Net.Sockets.TcpListener.Start(System.Int32)
  - System.Net.Sockets.TcpListener.Stop
  langs:
  - csharp
  - vb
  name: TcpListener
  fullName: System.Net.Sockets.TcpListener
  type: Class
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TcpListener
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 439
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Listens for connections from TCP network clients.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> class provides simple methods that listen for and accept incoming connection requests in blocking synchronous mode. You can use either a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to connect with a <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref>. Create a <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> using an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref>, a Local IP address and port number, or just a port number. Specify <xref href=\"System.Net.IPAddress.Any\" data-throw-if-not-resolved=\"false\"></xref> for the local IP address and 0 for the local port number if you want the underlying service provider to assign those values for you. If you choose to do this, you can use the <xref href=\"System.Net.Sockets.TcpListener.LocalEndpoint\" data-throw-if-not-resolved=\"false\"></xref> property to identify the assigned information, after the socket has connected.</p>\n<p>Use the <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method to begin listening for incoming connection requests. <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> will queue incoming connections until you either call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method or it has queued <xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\" data-throw-if-not-resolved=\"false\"></xref>. Use either <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> to pull a connection from the incoming connection request queue. These two methods will block. If you want to avoid blocking, you can use the <xref href=\"System.Net.Sockets.TcpListener.Pending\" data-throw-if-not-resolved=\"false\"></xref> method first to determine if connection requests are available in the queue.</p>\n<p>Call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method to close the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method does not close any accepted connections. You are responsible for closing these separately.</p>\n"
  example:
  - "\n<p>The following code example creates a <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Net.Sockets.TcpListener#1<p>See <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> for a client example.</p>"
  syntax:
    content: public class TcpListener
    content.vb: Public Class TcpListener
  seealso:
  - type: System.Net.Sockets.TcpClient
    commentId: T:System.Net.Sockets.TcpClient
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  commentId: M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)
  id: '#ctor(System.Net.IPAddress,System.Int32)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: TcpListener(IPAddress, Int32)
  fullName: System.Net.Sockets.TcpListener.TcpListener(System.Net.IPAddress, System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 441
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> class that listens for incoming connection attempts on the specified local IP address and port number.</p>\n"
  remarks: "\n<p>This constructor allows you to specify the local IP address and port number on which to listen for incoming connection attempts. Before calling this constructor you must first create an <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> using the desired local address. Pass this <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> to the constructor as the <em>localaddr</em> parameter. If you do not care which local address is assigned, specify <xref href=\"System.Net.IPAddress.Any\" data-throw-if-not-resolved=\"false\"></xref> for the <em>localaddr</em> parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can specify 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000. If you use this approach, you can discover what local network address and port number has been assigned by using the <xref href=\"System.Net.Sockets.TcpListener.LocalEndpoint\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>Call the <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method to begin listening for incoming connection attempts.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example creates an instance of the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> class using a local IP address and port number.</p>Classic TcpListener.PublicMethodsAndPropertiesExample#2"
  syntax:
    content: public TcpListener(IPAddress localaddr, int port)
    content.vb: Public Sub New(localaddr As IPAddress, port As Integer)
    parameters:
    - id: localaddr
      type: System.Net.IPAddress
      description: "\n<p>An <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> that represents the local IP address. </p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port on which to listen for incoming connection attempts. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>localaddr</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>port</em> is not between <xref href=\"System.Net.IPEndPoint.MinPort\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.IPEndPoint.MaxPort\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Net.IPAddress
    commentId: T:System.Net.IPAddress
  - type: System.Net.Sockets.TcpListener.Start
    commentId: M:System.Net.Sockets.TcpListener.Start
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  commentId: M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)
  id: '#ctor(System.Net.IPEndPoint)'
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: TcpListener(IPEndPoint)
  fullName: System.Net.Sockets.TcpListener.TcpListener(System.Net.IPEndPoint)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 442
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> class with the specified local endpoint.</p>\n"
  remarks: "\n<p>This constructor allows you to specify the local IP address and port number on which to listen for incoming connection attempts. Before using this constructor, you must create an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> using the desired local IP address and port number. Pass this <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> to the constructor as the <em>localEP</em> parameter.</p>\n<p>If you do not care which local address is assigned, you can create an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> using <xref href=\"System.Net.IPAddress.Any\" data-throw-if-not-resolved=\"false\"></xref> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000. If you use this approach, you can discover what local network address and port number has been assigned by using the <xref href=\"System.Net.Sockets.TcpListener.LocalEndpoint\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>Call the <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method to begin listening for incoming connection attempts.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example creates an instance of the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> class using the local endpoint.</p>Classic TcpListener.PublicMethodsAndPropertiesExample#1"
  syntax:
    content: public TcpListener(IPEndPoint localEP)
    content.vb: Public Sub New(localEP As IPEndPoint)
    parameters:
    - id: localEP
      type: System.Net.IPEndPoint
      description: "\n<p>An <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref> that represents the local endpoint to which to bind the listener <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>localEP</em> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Net.IPEndPoint
    commentId: T:System.Net.IPEndPoint
  - type: System.Net.Sockets.TcpListener.Start
    commentId: M:System.Net.Sockets.TcpListener.Start
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.Active
  commentId: P:System.Net.Sockets.TcpListener.Active
  id: Active
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Active
  fullName: System.Net.Sockets.TcpListener.Active
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Active
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 443
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets a value that indicates whether <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> is actively listening for client connections.</p>\n"
  remarks: "\n<p>Classes deriving from <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> can use this property to determine if the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is currently listening for incoming connection attempts. The <xref href=\"System.Net.Sockets.TcpClient.Active\" data-throw-if-not-resolved=\"false\"></xref> property can be used to avoid redundant <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> attempts.</p>\n"
  syntax:
    content: protected bool Active { get; }
    content.vb: Protected ReadOnly Property Active As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> is actively listening; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Net.Sockets.TcpListener.Start
    commentId: M:System.Net.Sockets.TcpListener.Start
  modifiers.csharp:
  - protected
  - get
  modifiers.vb:
  - Protected
  - ReadOnly
- uid: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  commentId: P:System.Net.Sockets.TcpListener.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpListener.ExclusiveAddressUse
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExclusiveAddressUse
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 444
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> allows only one underlying socket to listen to a specific port.</p>\n"
  remarks: "\n<p>By default, multiple listeners can listen to a specific port. However, only one of the listeners can perform operations on the network traffic sent to the port. If more than one listener attempts to bind to a particular port, then the one with the more specific IP address handles the network traffic sent to that port. You can use the <xref href=\"System.Net.Sockets.Socket.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property to prevent multiple listeners from listening to a specific port.</p>\n<p>Set this property before calling <see cref=\"Overload:System.Net.Sockets.TcpListener.Start\"></see>, or call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method and then set this property.</p>\n"
  example:
  - "\n<p>The following code example gets and sets the <xref href=\"System.Net.Sockets.TcpListener.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property.</p>System.Net.Sockets.TcpListener1#2"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    content.vb: Public Property ExclusiveAddressUse As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> allows only one <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> to listen to a specific port; otherwise, <strong>false</strong>. . The default is <strong>true</strong> for Windows Server 2003 and Windows XP Service Pack 2 and later, and <strong>false</strong> for all other versions.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> has been started. Call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method and then set the <xref href=\"System.Net.Sockets.Socket.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the underlying socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.LocalEndpoint
  commentId: P:System.Net.Sockets.TcpListener.LocalEndpoint
  id: LocalEndpoint
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: LocalEndpoint
  fullName: System.Net.Sockets.TcpListener.LocalEndpoint
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LocalEndpoint
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 445
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the underlying <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> of the current <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>You can use the <xref href=\"System.Net.Sockets.TcpListener.LocalEndpoint\" data-throw-if-not-resolved=\"false\"></xref> property to identify the local network interface and port number being used to listen for incoming client connection requests, after a socket connection has been made. You must first cast this <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Net.IPEndPoint\" data-throw-if-not-resolved=\"false\"></xref>. You can then call the <xref href=\"System.Net.IPEndPoint.Address\" data-throw-if-not-resolved=\"false\"></xref> property to retrieve the local IP address, and the <xref href=\"System.Net.IPEndPoint.Port\" data-throw-if-not-resolved=\"false\"></xref> property to retrieve the local port number.</p>\n"
  example:
  - "\n<p>The following code example displays the local IP address and port number on which the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> is listening for incoming connection requests.</p>TcpListener_Pending_LocalEndPoint#1"
  syntax:
    content: public EndPoint LocalEndpoint { get; }
    content.vb: Public ReadOnly Property LocalEndpoint As EndPoint
    parameters: []
    return:
      type: System.Net.EndPoint
      description: "\n<p>The <xref href=\"System.Net.EndPoint\" data-throw-if-not-resolved=\"false\"></xref> to which the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is bound.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Listen(System.Int32)
    commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  - type: System.Net.EndPoint
    commentId: T:System.Net.EndPoint
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.TcpListener.Server
  commentId: P:System.Net.Sockets.TcpListener.Server
  id: Server
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Server
  fullName: System.Net.Sockets.TcpListener.Server
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Server
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 446
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the underlying network <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> creates a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to listen for incoming client connection requests. Classes deriving from <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> can use this property to get this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Use the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> returned by the <xref href=\"System.Net.Sockets.TcpListener.Server\" data-throw-if-not-resolved=\"false\"></xref> property if you require access beyond that which <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> provides.</p>\n<p>The <xref href=\"System.Net.Sockets.TcpListener.Server\" data-throw-if-not-resolved=\"false\"></xref> property only returns the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> used to listen for incoming client connection requests. Use the <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method to accept a pending connection request and obtain a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for sending and receiving data. You can also use the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method to accept a pending connection request and obtain a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> for sending and receiving data.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.TcpListener.Server\" data-throw-if-not-resolved=\"false\"></xref> property. The underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is retrieved and the <xref href=\"System.Net.Sockets.SocketOptionName.Linger\" data-throw-if-not-resolved=\"false\"></xref><xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> option is configured to time out after 10 seconds if data still remains in the network buffer after the connection is closed.</p>TcpListenerProtectedMembers1#1"
  syntax:
    content: public Socket Server { get; }
    content.vb: Public ReadOnly Property Server As Socket
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "\n<p>The underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket
    commentId: T:System.Net.Sockets.Socket
  - type: System.Net.Sockets.TcpListener.AcceptSocket
    commentId: M:System.Net.Sockets.TcpListener.AcceptSocket
  - type: System.Net.Sockets.TcpListener.AcceptTcpClient
    commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClient
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.TcpListener.AcceptSocketAsync
  commentId: M:System.Net.Sockets.TcpListener.AcceptSocketAsync
  id: AcceptSocketAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: AcceptSocketAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptSocketAsync()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AcceptSocketAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 447
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Accepts a pending connection request as an asynchronous operation.</p>\n"
  remarks: "\n<p>This operation will not block. The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>  object will complete after the socket connection has been accepted.</p>\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> returned in <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref> is initialized with the IP address and port number of the remote host. You can use any of the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> methods available in the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> class to communicate with the remote host. When you are finished using the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, be sure to call its <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method. If your application is relatively simple, consider using the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method rather than the <xref href=\"System.Net.Sockets.TcpListener.AcceptSocketAsync\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> provides you with simple methods for sending and receiving data over a network in blocking synchronous mode.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Task<Socket> AcceptSocketAsync()
    content.vb: Public Function AcceptSocketAsync As Task(Of Socket)
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation. The <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property on the task object returns a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> used to send and receive data.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The listener has not been started with a call to <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Net.Sockets.TcpListener.AcceptTcpClient
    commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClient
  - type: System.Net.Sockets.Socket
    commentId: T:System.Net.Sockets.Socket
  - type: System.Net.Sockets.TcpListener.Pending
    commentId: M:System.Net.Sockets.TcpListener.Pending
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync
  id: AcceptTcpClientAsync
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: AcceptTcpClientAsync()
  fullName: System.Net.Sockets.TcpListener.AcceptTcpClientAsync()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AcceptTcpClientAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 448
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Accepts a pending connection request as an asynchronous operation. </p>\n"
  remarks: "\n<p>This operation will not block. The returned <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>  object will complete after the TCP connection has been accepted.</p>\n<p>Use the <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> method to obtain the underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> of the returned <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> in the <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> will provide you with methods for sending and receiving with the remote host. When you are through with the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>, be sure to call its <xref href=\"System.Net.Sockets.TcpClient.Close\" data-throw-if-not-resolved=\"false\"></xref> method. If you want greater flexibility than a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> offers, consider using <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.TcpListener.AcceptSocketAsync\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Task<TcpClient> AcceptTcpClientAsync()
    content.vb: Public Function AcceptTcpClientAsync As Task(Of TcpClient)
    return:
      type: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task`1\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation. The <xref href=\"System.Threading.Tasks.Task`1.Result\" data-throw-if-not-resolved=\"false\"></xref> property on the task object returns a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> used to send and receive data.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The listener has not been started with a call to <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>Use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error. </p>\n"
  seealso:
  - type: System.Net.Sockets.TcpClient
    commentId: T:System.Net.Sockets.TcpClient
  - type: System.Net.Sockets.TcpListener.AcceptSocket
    commentId: M:System.Net.Sockets.TcpListener.AcceptSocket
  - type: System.Net.Sockets.Socket
    commentId: T:System.Net.Sockets.Socket
  - type: System.Net.Sockets.NetworkStream
    commentId: T:System.Net.Sockets.NetworkStream
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.Pending
  commentId: M:System.Net.Sockets.TcpListener.Pending
  id: Pending
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Pending()
  fullName: System.Net.Sockets.TcpListener.Pending()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Pending
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 449
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Determines if there are pending connection requests.</p>\n"
  remarks: "\n<p>This non-blocking method determines if there are any pending connection requests. Because the <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> methods block execution until the <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method has queued an incoming connection request, the <xref href=\"System.Net.Sockets.TcpListener.Pending\" data-throw-if-not-resolved=\"false\"></xref> method can be used to determine if connections are available before attempting to accept them.</p>\n"
  example:
  - "\n<p>The following code example checks the <xref href=\"System.Net.Sockets.TcpListener.Pending\" data-throw-if-not-resolved=\"false\"></xref> method. If a connection request is waiting to be accepted, then a call to the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method is made.</p>TcpListener_Pending_LocalEndPoint#1"
  syntax:
    content: public bool Pending()
    content.vb: Public Function Pending As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if connections are pending; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The listener has not been started with a call to <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Net.Sockets.TcpListener.Start
    commentId: M:System.Net.Sockets.TcpListener.Start
  - type: System.Net.Sockets.TcpListener.AcceptSocket
    commentId: M:System.Net.Sockets.TcpListener.AcceptSocket
  - type: System.Net.Sockets.TcpListener.AcceptTcpClient
    commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClient
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.Start
  commentId: M:System.Net.Sockets.TcpListener.Start
  id: Start
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Start()
  fullName: System.Net.Sockets.TcpListener.Start()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 450
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Starts listening for incoming connection requests.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method initializes the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, binds it to a local endpoint, and listens for incoming connection attempts. If a connection request is received, the <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method will queue the request and continue listening for additional requests until you call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method. If <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> receives a connection request after it has already queued the maximum number of connections, it will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> on the client.</p>\n<p>To remove a connection from the incoming connection queue, use either the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method will remove a connection from the queue and return a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> that you can use to send and receive data. The <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method will return a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> that you can use to do the same. If your application only requires synchronous I/O, use <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref>. For more detailed behavioral control, use <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref>. Both of these methods block until a connection request is available in the queue.</p>\n<p>Use the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method to close the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> and stop listening. You are responsible for closing your accepted connections separately.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> is used to listen for incoming client connection attempts.</p>System.Net.Sockets.TcpListener1#3"
  syntax:
    content: public void Start()
    content.vb: Public Sub Start
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>Use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Listen(System.Int32)
    commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.TcpListener.AcceptTcpClient
    commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClient
  - type: System.Net.Sockets.TcpListener.Stop
    commentId: M:System.Net.Sockets.TcpListener.Stop
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.Start(System.Int32)
  commentId: M:System.Net.Sockets.TcpListener.Start(System.Int32)
  id: Start(System.Int32)
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Start(Int32)
  fullName: System.Net.Sockets.TcpListener.Start(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 451
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Starts listening for incoming connection requests with a maximum number of pending connection.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> method initializes the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>, binds it to a local endpoint, and listens for incoming connection attempts. If a connection request is received, <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> will queue the request and continue listening for additional requests until you call the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method. If <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> receives a connection request after it has already queued the maximum number of connections it will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref> on the client.</p>\n<p>To remove a connection from the incoming connection queue, use either the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref> method will remove a connection from the queue and return a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> that you can use to send and receive data. The <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method will return a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> that you can use to do the same. If your application only requires synchronous I/O, use the <xref href=\"System.Net.Sockets.TcpListener.AcceptTcpClient\" data-throw-if-not-resolved=\"false\"></xref>. For more detailed behavioral control, use <xref href=\"System.Net.Sockets.TcpListener.AcceptSocket\" data-throw-if-not-resolved=\"false\"></xref> method. Both of these methods block until a connection request is available in the queue. </p>\n<p>Use the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method to close the <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> and stop listening. You are responsible for closing your accepted connections separately.</p>\n<p>Use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <see href=\"http://msdn.microsoft.com/library/\">http://msdn.microsoft.com/library/</see> for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how <xref href=\"System.Net.Sockets.TcpListener.Start\" data-throw-if-not-resolved=\"false\"></xref> is used to listen for incoming client connection attempts.</p>System.Net.Sockets.TcpListener1#3"
  syntax:
    content: public void Start(int backlog)
    content.vb: Public Sub Start(backlog As Integer)
    parameters:
    - id: backlog
      type: System.Int32
      description: "\n<p>The maximum length of the pending connections queue.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred while accessing the socket. See the Remarks section for more information. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The<em> backlog</em> parameter is less than zero or exceeds the maximum number of permitted connections.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is null.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Listen(System.Int32)
    commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)
  - type: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)
  - type: System.Net.Sockets.TcpListener.AcceptTcpClient
    commentId: M:System.Net.Sockets.TcpListener.AcceptTcpClient
  - type: System.Net.Sockets.TcpListener.AcceptSocket
    commentId: M:System.Net.Sockets.TcpListener.AcceptSocket
  - type: System.Net.Sockets.TcpListener.Stop
    commentId: M:System.Net.Sockets.TcpListener.Stop
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpListener.Stop
  commentId: M:System.Net.Sockets.TcpListener.Stop
  id: Stop
  parent: System.Net.Sockets.TcpListener
  langs:
  - csharp
  - vb
  name: Stop()
  fullName: System.Net.Sockets.TcpListener.Stop()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stop
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 452
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Closes the listener.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> closes the listener. Any unaccepted connection requests in the queue will be lost. Remote hosts waiting for a connection to be accepted will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. You are responsible for closing your accepted connections separately.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates using the <xref href=\"System.Net.Sockets.TcpListener.Stop\" data-throw-if-not-resolved=\"false\"></xref> method to close the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Net.Sockets.TcpListener#1"
  syntax:
    content: public void Stop()
    content.vb: Public Sub Stop
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>Use the <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Close
    commentId: M:System.Net.Sockets.Socket.Close
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Net.Sockets
  isExternal: false
  name: System.Net.Sockets
  fullName: System.Net.Sockets
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: false
  name: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Net
  isExternal: false
  name: System.Net
  fullName: System.Net
- uid: System.Net.IPEndPoint
  isExternal: false
  name: IPEndPoint
  fullName: System.Net.IPEndPoint
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Net.EndPoint
  parent: System.Net
  isExternal: false
  name: EndPoint
  fullName: System.Net.EndPoint
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: false
  name: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Threading.Tasks.Task{System.Net.Sockets.Socket}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Socket>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.Socket>
  fullname.vb: System.Threading.Tasks.Task(Of System.Net.Sockets.Socket)
  name.vb: Task(Of Socket)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Net.Sockets.Socket
    name: Socket
    fullName: System.Net.Sockets.Socket
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Net.Sockets.Socket
    name: Socket
    fullName: System.Net.Sockets.Socket
  - name: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  parent: System.Threading.Tasks
  isExternal: false
  name: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    fullName: <
  - name: TResult
    fullName: TResult
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    fullName: '(Of '
  - name: TResult
    fullName: TResult
  - name: )
    fullName: )
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Threading.Tasks.Task{System.Net.Sockets.TcpClient}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<TcpClient>
  fullName: System.Threading.Tasks.Task<System.Net.Sockets.TcpClient>
  fullname.vb: System.Threading.Tasks.Task(Of System.Net.Sockets.TcpClient)
  name.vb: Task(Of TcpClient)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    fullName: System.Net.Sockets.TcpClient
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Net.Sockets.TcpClient
    name: TcpClient
    fullName: System.Net.Sockets.TcpClient
  - name: )
    fullName: )
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.Net.Sockets.SocketException
  isExternal: false
  name: SocketException
  fullName: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
