items:
- uid: System.Threading.CancellationToken
  commentId: T:System.Threading.CancellationToken
  id: CancellationToken
  parent: System.Threading
  children:
  - System.Threading.CancellationToken.#ctor(System.Boolean)
  - System.Threading.CancellationToken.CanBeCanceled
  - System.Threading.CancellationToken.Equals(System.Object)
  - System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)
  - System.Threading.CancellationToken.GetHashCode
  - System.Threading.CancellationToken.IsCancellationRequested
  - System.Threading.CancellationToken.None
  - System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  - System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  - System.Threading.CancellationToken.Register(System.Action)
  - System.Threading.CancellationToken.Register(System.Action,System.Boolean)
  - System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)
  - System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)
  - System.Threading.CancellationToken.ThrowIfCancellationRequested
  - System.Threading.CancellationToken.WaitHandle
  langs:
  - csharp
  - vb
  name: CancellationToken
  fullName: System.Threading.CancellationToken
  type: Struct
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CancellationToken
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 40
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Propagates notification that operations should be canceled.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> enables cooperative cancellation between threads, thread pool work items, or <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> objects. You create a cancellation token by instantiating a <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> object, which manages cancellation tokens retrieved from its <xref href=\"System.Threading.CancellationTokenSource.Token\" data-throw-if-not-resolved=\"false\"></xref> property. You then  pass the cancellation token to any number of threads, tasks, or operations that should receive notice of cancellation. The token cannot be used to initiate cancellation. When the owning object calls <xref href=\"System.Threading.CancellationTokenSource.Cancel\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property on every copy of the cancellation token is set to <strong>true</strong>. The objects that receive the notification can respond in whatever manner is appropriate.</p>\n<p>For more information and code examples see Cancellation in Managed Threads.</p>\n"
  example:
  - "\n<p>The following example uses a random number generator to emulate a data collection application that reads 10 integral values from eleven different instruments. A value of zero indicates that the measurement has failed for one instrument, in which case the operation should be cancelled and no overall mean should be computed. </p>\n<p>To handle the possible cancellation of the operation, the example instantiates a <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> object that generates a cancellation token which is passed to a <xref href=\"System.Threading.Tasks.TaskFactory\" data-throw-if-not-resolved=\"false\"></xref> object. The <xref href=\"System.Threading.Tasks.TaskFactory\" data-throw-if-not-resolved=\"false\"></xref> object in turn passes the cancellation token to each of the tasks responsible for collecting readings for a particular instrument. The <xref href=\"System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method is called to ensure that the mean is computed only after all readings have been gathered successfully. If a task has not because it has been cancelled, the call to the <xref href=\"System.Threading.Tasks.TaskFactory.ContinueWhenAll``2(System.Threading.Tasks.Task{``0}[],System.Func{System.Threading.Tasks.Task{``0}[],``1},System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> method throws an exception. </p>System.Threading.CancellationTokenSource.Class#1"
  syntax:
    content: >-
      [ComVisible(false)]

      [HostProtection(Synchronization = true, ExternalThreading = true)]

      [DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")]

      public struct CancellationToken
    content.vb: >-
      <ComVisible(False)>

      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      <DebuggerDisplay("IsCancellationRequested = {IsCancellationRequested}")>

      Public Structure CancellationToken
  inheritedMembers:
  - System.ValueType.ToString
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetType
  attributes:
  - type: System.Runtime.InteropServices.StructLayoutAttribute
    ctor: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)
    arguments:
    - type: System.Runtime.InteropServices.LayoutKind
      value: 0
  modifiers.csharp:
  - public
  - struct
  modifiers.vb:
  - Public
  - Structure
- uid: System.Threading.CancellationToken.#ctor(System.Boolean)
  commentId: M:System.Threading.CancellationToken.#ctor(System.Boolean)
  id: '#ctor(System.Boolean)'
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: CancellationToken(Boolean)
  fullName: System.Threading.CancellationToken.CancellationToken(System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 155
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Initializes the <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Tokens created with this constructor will remain in the canceled state specified by the <em>canceled</em> parameter. If <em>canceled</em> is <strong>false</strong>, both <xref href=\"System.Threading.CancellationToken.CanBeCanceled\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> will be <strong>false</strong>.</p>\n<p> If <em>canceled</em> is <strong>true</strong>, both <xref href=\"System.Threading.CancellationToken.CanBeCanceled\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> will be <strong>true</strong>.</p>\n"
  example:
  - 
  syntax:
    content: public CancellationToken(bool canceled)
    content.vb: Public Sub New(canceled As Boolean)
    parameters:
    - id: canceled
      type: System.Boolean
      description: "\nThe canceled state for the token.\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.CancellationToken.CanBeCanceled
  commentId: P:System.Threading.CancellationToken.CanBeCanceled
  id: CanBeCanceled
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: CanBeCanceled
  fullName: System.Threading.CancellationToken.CanBeCanceled
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CanBeCanceled
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 99
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Gets whether this token is capable of being in the canceled state. </p>\n"
  remarks: "\n<p>If <xref href=\"System.Threading.CancellationToken.CanBeCanceled\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong>, it is guaranteed that the token will never transition into a canceled state, meaning that <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> will never return <strong>true</strong>. A cancellation token that cannot be canceled is returned by the static <xref href=\"System.Threading.CancellationToken.None\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>You can optionally use this property to determine whether a cancellation token can be canceled before examing the value of the <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether it has been canceled.</p>\n"
  example:
  - 
  syntax:
    content: public bool CanBeCanceled { get; }
    content.vb: Public ReadOnly Property CanBeCanceled As Boolean
    parameters: []
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.CancellationToken.IsCancellationRequested
  commentId: P:System.Threading.CancellationToken.IsCancellationRequested
  id: IsCancellationRequested
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: IsCancellationRequested
  fullName: System.Threading.CancellationToken.IsCancellationRequested
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsCancellationRequested
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 83
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Gets whether cancellation has been requested for this token.</p>\n"
  remarks: "\n<p> This property indicates whether cancellation has been requested for this token, either through the token initially being constructed in a canceled state, or through calling <xref href=\"System.Threading.CancellationTokenSource.Cancel\" data-throw-if-not-resolved=\"false\"></xref> on the token's associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>  If this property is <strong>true</strong>, it only guarantees that cancellation has been requested. It does not guarantee that every registered handler has finished executing, nor that cancellation requests have finished propagating to all registered handlers. Additional synchronization may be required, particularly in situations where related objects are being canceled concurrently.</p>\n"
  example:
  - "\n<p>The following is a simple example that executes a server process until the <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>. </p>System.Threading.Tasks.CancellationToken.IsCancellationRequested#12<p>The example instantiates a <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> object, which controls access to the cancellation token. It then defines two thread procedures. The first is defined as a lambda expression that pools the keyboard and, when the \"C\" key is pressed, calls <xref href=\"System.Threading.CancellationTokenSource.Cancel\" data-throw-if-not-resolved=\"false\"></xref> to set the cancellation token to the cancelled state. The second is a parameterized method, <code>ServerClass.StaticMethod</code>, that executes a loop until the <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>. </p><p>The main thread then starts the two threads and blocks until the thread that executes the <code>ServerClass.StaticMethod</code> method terminates. </p>"
  syntax:
    content: public bool IsCancellationRequested { get; }
    content.vb: Public ReadOnly Property IsCancellationRequested As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: Whether cancellation has been requested for this token.
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.CancellationToken.None
  commentId: P:System.Threading.CancellationToken.None
  id: None
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: None
  fullName: System.Threading.CancellationToken.None
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: None
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 59
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Returns an empty <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  remarks: "\n<p>The cancellation token returned by this property cannot be canceled; that is, its <xref href=\"System.Threading.CancellationToken.CanBeCanceled\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n<p>You can also use the C#  default(CancellationToken) statement to create an empty cancellation token. </p>\n"
  example:
  - 
  syntax:
    content: public static CancellationToken None { get; }
    content.vb: Public Shared ReadOnly Property None As CancellationToken
    parameters: []
    return:
      type: System.Threading.CancellationToken
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.CancellationToken.WaitHandle
  commentId: P:System.Threading.CancellationToken.WaitHandle
  id: WaitHandle
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: WaitHandle
  fullName: System.Threading.CancellationToken.WaitHandle
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitHandle
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 117
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Gets a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> that is signaled when the token is canceled.</p>\n"
  remarks: "\n<p>Accessing this property causes a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> to be instantiated. It is preferable to only use this property when necessary, and to then dispose the associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> instance at the earliest opportunity (disposing the source will dispose of this allocated handle). The handle should not be closed or disposed directly.</p>\n"
  example:
  - 
  syntax:
    content: public WaitHandle WaitHandle { get; }
    content.vb: Public ReadOnly Property WaitHandle As WaitHandle
    parameters: []
    return:
      type: System.Threading.WaitHandle
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.CancellationToken.Equals(System.Object)
  commentId: M:System.Threading.CancellationToken.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.Threading.CancellationToken.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Equals
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 398
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Determines whether the current <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> instance is equal to the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public override bool Equals(object other)
    content.vb: Public Overrides Function Equals(other As Object) As Boolean
    parameters:
    - id: other
      type: System.Object
      description: The other object to which to compare this instance.
    return:
      type: System.Boolean
      description: "True if <em>other</em> is a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>\nand if the two instances are equal; otherwise, false. Two tokens are equal if they are associated\nwith the same <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> or if they were both constructed \nfrom public CancellationToken constructors and their <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> values are equal."
  overridden: System.ValueType.Equals(System.Object)
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>An associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)
  commentId: M:System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)
  id: Equals(System.Threading.CancellationToken)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Equals(CancellationToken)
  fullName: System.Threading.CancellationToken.Equals(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Equals
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 362
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Determines whether the current <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> instance is equal to the specified token.</p>\n"
  example:
  - 
  syntax:
    content: public bool Equals(CancellationToken other)
    content.vb: Public Function Equals(other As CancellationToken) As Boolean
    parameters:
    - id: other
      type: System.Threading.CancellationToken
      description: >-
        The other <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> to which to compare this

        instance.
    return:
      type: System.Boolean
      description: "True if the instances are equal; otherwise, false. Two tokens are equal if they are associated\nwith the same <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> or if they were both constructed \nfrom public CancellationToken constructors and their <xref href=\"System.Threading.CancellationToken.IsCancellationRequested\" data-throw-if-not-resolved=\"false\"></xref> values are equal."
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.CancellationToken.GetHashCode
  commentId: M:System.Threading.CancellationToken.GetHashCode
  id: GetHashCode
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.Threading.CancellationToken.GetHashCode()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetHashCode
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 412
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Serves as a hash function for a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public override int GetHashCode()
    content.vb: Public Overrides Function GetHashCode As Integer
    return:
      type: System.Int32
      description: A hash code for the current <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> instance.
  overridden: System.ValueType.GetHashCode
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  commentId: M:System.Threading.CancellationToken.op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  id: op_Equality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Equality(CancellationToken, CancellationToken)
  fullName: System.Threading.CancellationToken.Equality(System.Threading.CancellationToken, System.Threading.CancellationToken)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Equality
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 431
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Determines whether two <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> instances are equal.</p>\n"
  example:
  - 
  syntax:
    content: public static bool operator ==(CancellationToken left, CancellationToken right)
    content.vb: Public Shared Operator =(left As CancellationToken, right As CancellationToken) As Boolean
    parameters:
    - id: left
      type: System.Threading.CancellationToken
      description: The first instance.
    - id: right
      type: System.Threading.CancellationToken
      description: The second instance.
    return:
      type: System.Boolean
      description: True if the instances are equal; otherwise, false.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>An associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  commentId: M:System.Threading.CancellationToken.op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  id: op_Inequality(System.Threading.CancellationToken,System.Threading.CancellationToken)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Inequality(CancellationToken, CancellationToken)
  fullName: System.Threading.CancellationToken.Inequality(System.Threading.CancellationToken, System.Threading.CancellationToken)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Inequality
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 444
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Determines whether two <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> instances are not equal.</p>\n"
  example:
  - 
  syntax:
    content: public static bool operator !=(CancellationToken left, CancellationToken right)
    content.vb: Public Shared Operator <>(left As CancellationToken, right As CancellationToken) As Boolean
    parameters:
    - id: left
      type: System.Threading.CancellationToken
      description: The first instance.
    - id: right
      type: System.Threading.CancellationToken
      description: The second instance.
    return:
      type: System.Boolean
      description: True if the instances are not equal; otherwise, false.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>An associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.CancellationToken.Register(System.Action)
  commentId: M:System.Threading.CancellationToken.Register(System.Action)
  id: Register(System.Action)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Register(Action)
  fullName: System.Threading.CancellationToken.Register(System.Action)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Register
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 191
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Registers a delegate that will be called when this <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> is canceled.</p>\n"
  remarks: "\n<p> If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate generates will be propagated out of this method call.</p>\n<p>  The current <xref href=\"System.Threading.ExecutionContext\" data-throw-if-not-resolved=\"false\"></xref>, if one exists, will be captured along with the delegate and will be used when executing it.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: public CancellationTokenRegistration Register(Action callback)
    content.vb: Public Function Register(callback As Action) As CancellationTokenRegistration
    parameters:
    - id: callback
      type: System.Action
      description: The delegate to be executed when the <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> is canceled.
    return:
      type: System.Threading.CancellationTokenRegistration
      description: "The <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> instance that can \nbe used to deregister the callback."
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>callback</em> is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.CancellationToken.Register(System.Action,System.Boolean)
  commentId: M:System.Threading.CancellationToken.Register(System.Action,System.Boolean)
  id: Register(System.Action,System.Boolean)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Register(Action, Boolean)
  fullName: System.Threading.CancellationToken.Register(System.Action, System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Register
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 226
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Registers a delegate that will be called when this <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> is canceled.</p>\n"
  remarks: "\n<p> If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate generates will be propogated out of this method call.</p>\n<p>If <em>useSynchronizationContext</em> is <strong>true</strong>, the current <xref href=\"System.Threading.ExecutionContext\" data-throw-if-not-resolved=\"false\"></xref>, if one exists, will be captured along with the delegate and will be used when executing it.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext)
    content.vb: Public Function Register(callback As Action, useSynchronizationContext As Boolean) As CancellationTokenRegistration
    parameters:
    - id: callback
      type: System.Action
      description: The delegate to be executed when the <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> is canceled.
    - id: useSynchronizationContext
      type: System.Boolean
      description: >-
        A Boolean value that indicates whether to capture

        the current <xref href="System.Threading.SynchronizationContext" data-throw-if-not-resolved="false"></xref> and use it

        when invoking the <em>callback</em>.
    return:
      type: System.Threading.CancellationTokenRegistration
      description: "The <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> instance that can \nbe used to deregister the callback."
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>callback</em> is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)
  commentId: M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object)
  id: Register(System.Action{System.Object},System.Object)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Register(Action<Object>, Object)
  fullName: System.Threading.CancellationToken.Register(System.Action<System.Object>, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Register
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 259
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Registers a delegate that will be called when this <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> is canceled.</p>\n"
  remarks: "\n<p> If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate generates will be propogated out of this method call.</p>\n<p>  The current <xref href=\"System.Threading.ExecutionContext\" data-throw-if-not-resolved=\"false\"></xref>, if one exists, will be captured along with the delegate and will be used when executing it.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: public CancellationTokenRegistration Register(Action<object> callback, object state)
    content.vb: Public Function Register(callback As Action(Of Object), state As Object) As CancellationTokenRegistration
    parameters:
    - id: callback
      type: System.Action{System.Object}
      description: The delegate to be executed when the <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> is canceled.
    - id: state
      type: System.Object
      description: The state to pass to the <em>callback</em> when the delegate is invoked.  This may be null.
    return:
      type: System.Threading.CancellationTokenRegistration
      description: "The <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> instance that can \nbe used to deregister the callback."
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>callback</em> is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.CancellationToken.Register(System.Action(Of System.Object), System.Object)
  name.vb: Register(Action(Of Object), Object)
- uid: System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)
  commentId: M:System.Threading.CancellationToken.Register(System.Action{System.Object},System.Object,System.Boolean)
  id: Register(System.Action{System.Object},System.Object,System.Boolean)
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: Register(Action<Object>, Object, Boolean)
  fullName: System.Threading.CancellationToken.Register(System.Action<System.Object>, System.Object, System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Register
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 297
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Registers a delegate that will be called when this <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> is canceled.</p>\n"
  remarks: "\n<p> If this token is already in the canceled state, the delegate will be run immediately and synchronously. Any exception the delegate generates will be propogated out of this method call.</p>\n<p>  The current <xref href=\"System.Threading.ExecutionContext\" data-throw-if-not-resolved=\"false\"></xref>, if one exists, will be captured along with the delegate and will be used when executing it.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: public CancellationTokenRegistration Register(Action<object> callback, object state, bool useSynchronizationContext)
    content.vb: Public Function Register(callback As Action(Of Object), state As Object, useSynchronizationContext As Boolean) As CancellationTokenRegistration
    parameters:
    - id: callback
      type: System.Action{System.Object}
      description: The delegate to be executed when the <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> is canceled.
    - id: state
      type: System.Object
      description: The state to pass to the <em>callback</em> when the delegate is invoked.  This may be null.
    - id: useSynchronizationContext
      type: System.Boolean
      description: >-
        A Boolean value that indicates whether to capture

        the current <xref href="System.Threading.SynchronizationContext" data-throw-if-not-resolved="false"></xref> and use it

        when invoking the <em>callback</em>.
    return:
      type: System.Threading.CancellationTokenRegistration
      description: "The <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> instance that can \nbe used to deregister the callback."
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>callback</em> is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.CancellationToken.Register(System.Action(Of System.Object), System.Object, System.Boolean)
  name.vb: Register(Action(Of Object), Object, Boolean)
- uid: System.Threading.CancellationToken.ThrowIfCancellationRequested
  commentId: M:System.Threading.CancellationToken.ThrowIfCancellationRequested
  id: ThrowIfCancellationRequested
  parent: System.Threading.CancellationToken
  langs:
  - csharp
  - vb
  name: ThrowIfCancellationRequested()
  fullName: System.Threading.CancellationToken.ThrowIfCancellationRequested()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/CancellationToken.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ThrowIfCancellationRequested
    path: src/mscorlib/src/System/Threading/CancellationToken.cs
    startLine: 463
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading
  summary: "\n<p>Throws a <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> if this token has had cancellation requested.</p>\n"
  remarks: "\n<p>This method provides functionality equivalent to:</p>\n<p>C#</p>\n<pre><code>    if (token.IsCancellationRequested) \nthrow new OperationCanceledException(token);</code></pre>\n<pre><code class=\"vb#\">    If token.IsCancellationRequested Then\nThrow New OperationCanceledException(token)\nEnd If</code></pre>\n"
  example:
  - 
  syntax:
    content: public void ThrowIfCancellationRequested()
    content.vb: Public Sub ThrowIfCancellationRequested
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>The token has had cancellation requested.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The associated <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.ValueType.ToString
  parent: System.ValueType
  isExternal: false
  name: ToString()
  fullName: System.ValueType.ToString()
  spec.csharp:
  - uid: System.ValueType.ToString
    name: ToString
    fullName: System.ValueType.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.ToString
    name: ToString
    fullName: System.ValueType.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.ValueType
  parent: System
  isExternal: false
  name: ValueType
  fullName: System.ValueType
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: false
  name: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.ValueType.Equals(System.Object)
  parent: System.ValueType
  isExternal: true
  name: Equals(Object)
  fullName: System.ValueType.Equals(System.Object)
  spec.csharp:
  - uid: System.ValueType.Equals(System.Object)
    name: Equals
    fullName: System.ValueType.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.Equals(System.Object)
    name: Equals
    fullName: System.ValueType.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.ValueType.GetHashCode
  parent: System.ValueType
  isExternal: false
  name: GetHashCode()
  fullName: System.ValueType.GetHashCode()
  spec.csharp:
  - uid: System.ValueType.GetHashCode
    name: GetHashCode
    fullName: System.ValueType.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.GetHashCode
    name: GetHashCode
    fullName: System.ValueType.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Action
  parent: System
  isExternal: false
  name: Action
  fullName: System.Action
- uid: System.Threading.CancellationTokenRegistration
  parent: System.Threading
  isExternal: false
  name: CancellationTokenRegistration
  fullName: System.Threading.CancellationTokenRegistration
- uid: System.Action{System.Object}
  parent: System
  definition: System.Action`1
  name: Action<Object>
  fullName: System.Action<System.Object>
  fullname.vb: System.Action(Of System.Object)
  name.vb: Action(Of Object)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    fullName: System.Action
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    fullName: System.Action
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Action`1
  parent: System
  isExternal: false
  name: Action<T>
  fullName: System.Action<T>
  fullname.vb: System.Action(Of T)
  name.vb: Action(Of T)
  spec.csharp:
  - uid: System.Action`1
    name: Action
    fullName: System.Action
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Action`1
    name: Action
    fullName: System.Action
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.OperationCanceledException
  parent: System
  isExternal: false
  name: OperationCanceledException
  fullName: System.OperationCanceledException
