items:
- uid: System.Reflection.Emit.OpCodes
  commentId: T:System.Reflection.Emit.OpCodes
  id: OpCodes
  parent: System.Reflection.Emit
  children:
  - System.Reflection.Emit.OpCodes.Add
  - System.Reflection.Emit.OpCodes.Add_Ovf
  - System.Reflection.Emit.OpCodes.Add_Ovf_Un
  - System.Reflection.Emit.OpCodes.And
  - System.Reflection.Emit.OpCodes.Arglist
  - System.Reflection.Emit.OpCodes.Beq
  - System.Reflection.Emit.OpCodes.Beq_S
  - System.Reflection.Emit.OpCodes.Bge
  - System.Reflection.Emit.OpCodes.Bge_S
  - System.Reflection.Emit.OpCodes.Bge_Un
  - System.Reflection.Emit.OpCodes.Bge_Un_S
  - System.Reflection.Emit.OpCodes.Bgt
  - System.Reflection.Emit.OpCodes.Bgt_S
  - System.Reflection.Emit.OpCodes.Bgt_Un
  - System.Reflection.Emit.OpCodes.Bgt_Un_S
  - System.Reflection.Emit.OpCodes.Ble
  - System.Reflection.Emit.OpCodes.Ble_S
  - System.Reflection.Emit.OpCodes.Ble_Un
  - System.Reflection.Emit.OpCodes.Ble_Un_S
  - System.Reflection.Emit.OpCodes.Blt
  - System.Reflection.Emit.OpCodes.Blt_S
  - System.Reflection.Emit.OpCodes.Blt_Un
  - System.Reflection.Emit.OpCodes.Blt_Un_S
  - System.Reflection.Emit.OpCodes.Bne_Un
  - System.Reflection.Emit.OpCodes.Bne_Un_S
  - System.Reflection.Emit.OpCodes.Box
  - System.Reflection.Emit.OpCodes.Br
  - System.Reflection.Emit.OpCodes.Br_S
  - System.Reflection.Emit.OpCodes.Break
  - System.Reflection.Emit.OpCodes.Brfalse
  - System.Reflection.Emit.OpCodes.Brfalse_S
  - System.Reflection.Emit.OpCodes.Brtrue
  - System.Reflection.Emit.OpCodes.Brtrue_S
  - System.Reflection.Emit.OpCodes.Call
  - System.Reflection.Emit.OpCodes.Calli
  - System.Reflection.Emit.OpCodes.Callvirt
  - System.Reflection.Emit.OpCodes.Castclass
  - System.Reflection.Emit.OpCodes.Ceq
  - System.Reflection.Emit.OpCodes.Cgt
  - System.Reflection.Emit.OpCodes.Cgt_Un
  - System.Reflection.Emit.OpCodes.Ckfinite
  - System.Reflection.Emit.OpCodes.Clt
  - System.Reflection.Emit.OpCodes.Clt_Un
  - System.Reflection.Emit.OpCodes.Constrained
  - System.Reflection.Emit.OpCodes.Conv_I
  - System.Reflection.Emit.OpCodes.Conv_I1
  - System.Reflection.Emit.OpCodes.Conv_I2
  - System.Reflection.Emit.OpCodes.Conv_I4
  - System.Reflection.Emit.OpCodes.Conv_I8
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I1
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I2
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I4
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I8
  - System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U1
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U2
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U4
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U8
  - System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un
  - System.Reflection.Emit.OpCodes.Conv_R_Un
  - System.Reflection.Emit.OpCodes.Conv_R4
  - System.Reflection.Emit.OpCodes.Conv_R8
  - System.Reflection.Emit.OpCodes.Conv_U
  - System.Reflection.Emit.OpCodes.Conv_U1
  - System.Reflection.Emit.OpCodes.Conv_U2
  - System.Reflection.Emit.OpCodes.Conv_U4
  - System.Reflection.Emit.OpCodes.Conv_U8
  - System.Reflection.Emit.OpCodes.Cpblk
  - System.Reflection.Emit.OpCodes.Cpobj
  - System.Reflection.Emit.OpCodes.Div
  - System.Reflection.Emit.OpCodes.Div_Un
  - System.Reflection.Emit.OpCodes.Dup
  - System.Reflection.Emit.OpCodes.Endfilter
  - System.Reflection.Emit.OpCodes.Endfinally
  - System.Reflection.Emit.OpCodes.Initblk
  - System.Reflection.Emit.OpCodes.Initobj
  - System.Reflection.Emit.OpCodes.Isinst
  - System.Reflection.Emit.OpCodes.Jmp
  - System.Reflection.Emit.OpCodes.Ldarg
  - System.Reflection.Emit.OpCodes.Ldarg_0
  - System.Reflection.Emit.OpCodes.Ldarg_1
  - System.Reflection.Emit.OpCodes.Ldarg_2
  - System.Reflection.Emit.OpCodes.Ldarg_3
  - System.Reflection.Emit.OpCodes.Ldarg_S
  - System.Reflection.Emit.OpCodes.Ldarga
  - System.Reflection.Emit.OpCodes.Ldarga_S
  - System.Reflection.Emit.OpCodes.Ldc_I4
  - System.Reflection.Emit.OpCodes.Ldc_I4_0
  - System.Reflection.Emit.OpCodes.Ldc_I4_1
  - System.Reflection.Emit.OpCodes.Ldc_I4_2
  - System.Reflection.Emit.OpCodes.Ldc_I4_3
  - System.Reflection.Emit.OpCodes.Ldc_I4_4
  - System.Reflection.Emit.OpCodes.Ldc_I4_5
  - System.Reflection.Emit.OpCodes.Ldc_I4_6
  - System.Reflection.Emit.OpCodes.Ldc_I4_7
  - System.Reflection.Emit.OpCodes.Ldc_I4_8
  - System.Reflection.Emit.OpCodes.Ldc_I4_M1
  - System.Reflection.Emit.OpCodes.Ldc_I4_S
  - System.Reflection.Emit.OpCodes.Ldc_I8
  - System.Reflection.Emit.OpCodes.Ldc_R4
  - System.Reflection.Emit.OpCodes.Ldc_R8
  - System.Reflection.Emit.OpCodes.Ldelem
  - System.Reflection.Emit.OpCodes.Ldelem_I
  - System.Reflection.Emit.OpCodes.Ldelem_I1
  - System.Reflection.Emit.OpCodes.Ldelem_I2
  - System.Reflection.Emit.OpCodes.Ldelem_I4
  - System.Reflection.Emit.OpCodes.Ldelem_I8
  - System.Reflection.Emit.OpCodes.Ldelem_R4
  - System.Reflection.Emit.OpCodes.Ldelem_R8
  - System.Reflection.Emit.OpCodes.Ldelem_Ref
  - System.Reflection.Emit.OpCodes.Ldelem_U1
  - System.Reflection.Emit.OpCodes.Ldelem_U2
  - System.Reflection.Emit.OpCodes.Ldelem_U4
  - System.Reflection.Emit.OpCodes.Ldelema
  - System.Reflection.Emit.OpCodes.Ldfld
  - System.Reflection.Emit.OpCodes.Ldflda
  - System.Reflection.Emit.OpCodes.Ldftn
  - System.Reflection.Emit.OpCodes.Ldind_I
  - System.Reflection.Emit.OpCodes.Ldind_I1
  - System.Reflection.Emit.OpCodes.Ldind_I2
  - System.Reflection.Emit.OpCodes.Ldind_I4
  - System.Reflection.Emit.OpCodes.Ldind_I8
  - System.Reflection.Emit.OpCodes.Ldind_R4
  - System.Reflection.Emit.OpCodes.Ldind_R8
  - System.Reflection.Emit.OpCodes.Ldind_Ref
  - System.Reflection.Emit.OpCodes.Ldind_U1
  - System.Reflection.Emit.OpCodes.Ldind_U2
  - System.Reflection.Emit.OpCodes.Ldind_U4
  - System.Reflection.Emit.OpCodes.Ldlen
  - System.Reflection.Emit.OpCodes.Ldloc
  - System.Reflection.Emit.OpCodes.Ldloc_0
  - System.Reflection.Emit.OpCodes.Ldloc_1
  - System.Reflection.Emit.OpCodes.Ldloc_2
  - System.Reflection.Emit.OpCodes.Ldloc_3
  - System.Reflection.Emit.OpCodes.Ldloc_S
  - System.Reflection.Emit.OpCodes.Ldloca
  - System.Reflection.Emit.OpCodes.Ldloca_S
  - System.Reflection.Emit.OpCodes.Ldnull
  - System.Reflection.Emit.OpCodes.Ldobj
  - System.Reflection.Emit.OpCodes.Ldsfld
  - System.Reflection.Emit.OpCodes.Ldsflda
  - System.Reflection.Emit.OpCodes.Ldstr
  - System.Reflection.Emit.OpCodes.Ldtoken
  - System.Reflection.Emit.OpCodes.Ldvirtftn
  - System.Reflection.Emit.OpCodes.Leave
  - System.Reflection.Emit.OpCodes.Leave_S
  - System.Reflection.Emit.OpCodes.Localloc
  - System.Reflection.Emit.OpCodes.Mkrefany
  - System.Reflection.Emit.OpCodes.Mul
  - System.Reflection.Emit.OpCodes.Mul_Ovf
  - System.Reflection.Emit.OpCodes.Mul_Ovf_Un
  - System.Reflection.Emit.OpCodes.Neg
  - System.Reflection.Emit.OpCodes.Newarr
  - System.Reflection.Emit.OpCodes.Newobj
  - System.Reflection.Emit.OpCodes.Nop
  - System.Reflection.Emit.OpCodes.Not
  - System.Reflection.Emit.OpCodes.Or
  - System.Reflection.Emit.OpCodes.Pop
  - System.Reflection.Emit.OpCodes.Prefix1
  - System.Reflection.Emit.OpCodes.Prefix2
  - System.Reflection.Emit.OpCodes.Prefix3
  - System.Reflection.Emit.OpCodes.Prefix4
  - System.Reflection.Emit.OpCodes.Prefix5
  - System.Reflection.Emit.OpCodes.Prefix6
  - System.Reflection.Emit.OpCodes.Prefix7
  - System.Reflection.Emit.OpCodes.Prefixref
  - System.Reflection.Emit.OpCodes.Readonly
  - System.Reflection.Emit.OpCodes.Refanytype
  - System.Reflection.Emit.OpCodes.Refanyval
  - System.Reflection.Emit.OpCodes.Rem
  - System.Reflection.Emit.OpCodes.Rem_Un
  - System.Reflection.Emit.OpCodes.Ret
  - System.Reflection.Emit.OpCodes.Rethrow
  - System.Reflection.Emit.OpCodes.Shl
  - System.Reflection.Emit.OpCodes.Shr
  - System.Reflection.Emit.OpCodes.Shr_Un
  - System.Reflection.Emit.OpCodes.Sizeof
  - System.Reflection.Emit.OpCodes.Starg
  - System.Reflection.Emit.OpCodes.Starg_S
  - System.Reflection.Emit.OpCodes.Stelem
  - System.Reflection.Emit.OpCodes.Stelem_I
  - System.Reflection.Emit.OpCodes.Stelem_I1
  - System.Reflection.Emit.OpCodes.Stelem_I2
  - System.Reflection.Emit.OpCodes.Stelem_I4
  - System.Reflection.Emit.OpCodes.Stelem_I8
  - System.Reflection.Emit.OpCodes.Stelem_R4
  - System.Reflection.Emit.OpCodes.Stelem_R8
  - System.Reflection.Emit.OpCodes.Stelem_Ref
  - System.Reflection.Emit.OpCodes.Stfld
  - System.Reflection.Emit.OpCodes.Stind_I
  - System.Reflection.Emit.OpCodes.Stind_I1
  - System.Reflection.Emit.OpCodes.Stind_I2
  - System.Reflection.Emit.OpCodes.Stind_I4
  - System.Reflection.Emit.OpCodes.Stind_I8
  - System.Reflection.Emit.OpCodes.Stind_R4
  - System.Reflection.Emit.OpCodes.Stind_R8
  - System.Reflection.Emit.OpCodes.Stind_Ref
  - System.Reflection.Emit.OpCodes.Stloc
  - System.Reflection.Emit.OpCodes.Stloc_0
  - System.Reflection.Emit.OpCodes.Stloc_1
  - System.Reflection.Emit.OpCodes.Stloc_2
  - System.Reflection.Emit.OpCodes.Stloc_3
  - System.Reflection.Emit.OpCodes.Stloc_S
  - System.Reflection.Emit.OpCodes.Stobj
  - System.Reflection.Emit.OpCodes.Stsfld
  - System.Reflection.Emit.OpCodes.Sub
  - System.Reflection.Emit.OpCodes.Sub_Ovf
  - System.Reflection.Emit.OpCodes.Sub_Ovf_Un
  - System.Reflection.Emit.OpCodes.Switch
  - System.Reflection.Emit.OpCodes.Tailcall
  - System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)
  - System.Reflection.Emit.OpCodes.Throw
  - System.Reflection.Emit.OpCodes.Unaligned
  - System.Reflection.Emit.OpCodes.Unbox
  - System.Reflection.Emit.OpCodes.Unbox_Any
  - System.Reflection.Emit.OpCodes.Volatile
  - System.Reflection.Emit.OpCodes.Xor
  langs:
  - csharp
  - vb
  name: OpCodes
  fullName: System.Reflection.Emit.OpCodes
  type: Class
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OpCodes
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 192
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Provides field representations of the Microsoft Intermediate Language (MSIL) instructions for emission by the <xref href=\"System.Reflection.Emit.ILGenerator\" data-throw-if-not-resolved=\"false\"></xref> class members (such as <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n"
  remarks: "\n<p>For a detailed description of the member opcodes, see the Common Language Infrastructure (CLI) documentation, especially \"Partition III: CIL Instruction Set\" and \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n"
  example:
  - "\n<p>The following example demonstrates the construction of a dynamic method using <xref href=\"System.Reflection.Emit.ILGenerator\" data-throw-if-not-resolved=\"false\"></xref> to emit <strong>OpCodes</strong> into a <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Reflection.Emit.ILGenerator.OpCodes Example#1"
  syntax:
    content: 'public class OpCodes : object'
    content.vb: >-
      Public Class OpCodes
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Reflection.Emit.OpCodes.Add
  commentId: F:System.Reflection.Emit.OpCodes.Add
  id: Add
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Add
  fullName: System.Reflection.Emit.OpCodes.Add
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Add
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 195
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds two values and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is added to <em>value2</em>.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>Overflow is not detected for integer operations (for proper overflow handling, see <xref href=\"System.Reflection.Emit.OpCodes.Add_Ovf\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>Integer addition wraps, rather than saturates. For example, assuming 8-bit integers where <em>value1</em> is set to 255 and <em>value2</em> is set to 1, the wrapped result is 0 rather than 256.</p>\n<p>Floating-point overflow returns <strong>+inf</strong> (<strong>PositiveInfinity</strong>) or <strong>-inf</strong> (<strong>NegativeInfinity</strong>).</p>\n<p>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, <strong>int32</strong> and <strong>float</strong>; <strong>int32</strong> and <strong>int64</strong>), it is an invalid Microsoft Intermediate Language (MSIL) and generates an error.</p>\n<p>operand </p>\n<p>value1 type </p>\n<p>value2 type </p>\n<p>result type </p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>add</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Add
    content.vb: Public Shared ReadOnly Add As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Add_Ovf
  commentId: F:System.Reflection.Emit.OpCodes.Add_Ovf
  id: Add_Ovf
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Add_Ovf
  fullName: System.Reflection.Emit.OpCodes.Add_Ovf
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Add_Ovf
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 196
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds two integers, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is added to <em>value2</em> with a check for overflow.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result is not represented in the result type.</p>\n<p>You can perform this operation on signed integers. For floating-point values, use <xref href=\"System.Reflection.Emit.OpCodes.Add\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, <strong>int32</strong> and <strong>float</strong>; <strong>int32</strong> and <strong>int64</strong>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</p>\n<p>operand </p>\n<p>value1 type </p>\n<p>value2 type </p>\n<p>result type </p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>add.ovf</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Add_Ovf
    content.vb: Public Shared ReadOnly Add_Ovf As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Add_Ovf_Un
  commentId: F:System.Reflection.Emit.OpCodes.Add_Ovf_Un
  id: Add_Ovf_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Add_Ovf_Un
  fullName: System.Reflection.Emit.OpCodes.Add_Ovf_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Add_Ovf_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 197
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is added to <em>value2</em> with a check for overflow.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result is not represented in the result type.</p>\n<p>You can perform this operation on signed integers. For floating-point values, use <xref href=\"System.Reflection.Emit.OpCodes.Add\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The acceptable operand types and their corresponding result data type are listed in the table below. If there is no entry for a particular type combination (for example, <strong>int32</strong> and <strong>float</strong>; <strong>int32</strong> and <strong>int64</strong>), it is an invalid Microsoft Intermediate Language (MSIL) instruction and generates an error.</p>\n<p>operand </p>\n<p>value1 type </p>\n<p>value2 type </p>\n<p>result type </p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>add.ovf.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Add_Ovf_Un
    content.vb: Public Shared ReadOnly Add_Ovf_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.And
  commentId: F:System.Reflection.Emit.OpCodes.And
  id: And
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: And
  fullName: System.Reflection.Emit.OpCodes.And
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: And
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 198
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Computes the bitwise AND of two values and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Instruction </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value1</em> and <em>value2</em> are popped from the stack; the bitwise AND of the two values is computed.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>and</strong> instruction computes the bitwise AND of the top two values on the stack and leaves the result on the stack.</p>\n<p>\n<strong>And</strong> is an integer-specific operation.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>and</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode And
    content.vb: Public Shared ReadOnly And As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Arglist
  commentId: F:System.Reflection.Emit.OpCodes.Arglist
  id: Arglist
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Arglist
  fullName: System.Reflection.Emit.OpCodes.Arglist
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Arglist
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 199
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns an unmanaged pointer to the argument list of the current method.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>No evaluation stack behaviors are performed by this operation.</p>\n<p>The <strong>arglist</strong> instruction returns an opaque handle (an unmanaged pointer, of type <strong>native int</strong>) that represents the argument list of the current method. This handle is valid only during the lifetime of the current method. You can, however, pass the handle to other methods as long as the current method is on the thread of control. You can only execute the <strong>arglist</strong> instruction within a method that takes a variable number of arguments.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>arglist</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Arglist
    content.vb: Public Shared ReadOnly Arglist As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Beq
  commentId: F:System.Reflection.Emit.OpCodes.Beq
  id: Beq
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Beq
  fullName: System.Reflection.Emit.OpCodes.Beq
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Beq
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 200
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if two values are equal.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>beq</strong> instruction transfers control to the specified target instruction if <em>value1</em> is equal to <em>value2</em>. The effect is the same as performing a <strong>ceq</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>The acceptable operand types are encapsulated below: </p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</p>\n<p>Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref href=\"System.Reflection.Emit.OpCodes.Leave\" data-throw-if-not-resolved=\"false\"></xref> instruction instead).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>beq</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Beq
    content.vb: Public Shared ReadOnly Beq As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Beq_S
  commentId: F:System.Reflection.Emit.OpCodes.Beq_S
  id: Beq_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Beq_S
  fullName: System.Reflection.Emit.OpCodes.Beq_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Beq_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 201
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if two values are equal.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>beq.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is equal to <em>value2</em>. The effect is the same as performing a <strong>ceq</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>The acceptable operand types are encapsulated below: </p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</p>\n<p>Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction (such transfers are severely restricted and must use the <xref href=\"System.Reflection.Emit.OpCodes.Leave\" data-throw-if-not-resolved=\"false\"></xref> instruction instead).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>beq.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Beq_S
    content.vb: Public Shared ReadOnly Beq_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bge
  commentId: F:System.Reflection.Emit.OpCodes.Bge
  id: Bge
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bge
  fullName: System.Reflection.Emit.OpCodes.Bge
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bge
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 202
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is greater than or equal to the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bge</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than or equal to <em>value2</em>. The effect is identical to performing a <strong>clt.un</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bge</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bge
    content.vb: Public Shared ReadOnly Bge As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bge_S
  commentId: F:System.Reflection.Emit.OpCodes.Bge_S
  id: Bge_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bge_S
  fullName: System.Reflection.Emit.OpCodes.Bge_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bge_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 203
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is greater than or equal to the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bge.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than or equal to <em>value2</em>. The effect is identical to performing a <strong>clt.un</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bge.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bge_S
    content.vb: Public Shared ReadOnly Bge_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bge_Un
  commentId: F:System.Reflection.Emit.OpCodes.Bge_Un
  id: Bge_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bge_Un
  fullName: System.Reflection.Emit.OpCodes.Bge_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bge_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 204
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bge.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than or equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>clt</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bge.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bge_Un
    content.vb: Public Shared ReadOnly Bge_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bge_Un_S
  commentId: F:System.Reflection.Emit.OpCodes.Bge_Un_S
  id: Bge_Un_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bge_Un_S
  fullName: System.Reflection.Emit.OpCodes.Bge_Un_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bge_Un_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 205
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bge.un.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than or equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>clt</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bge.un.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bge_Un_S
    content.vb: Public Shared ReadOnly Bge_Un_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bgt
  commentId: F:System.Reflection.Emit.OpCodes.Bgt
  id: Bgt
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bgt
  fullName: System.Reflection.Emit.OpCodes.Bgt
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bgt
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 206
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is greater than the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bgt</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than <em>value2</em>. The effect is identical to performing a <strong>cgt</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bgt</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bgt
    content.vb: Public Shared ReadOnly Bgt As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bgt_S
  commentId: F:System.Reflection.Emit.OpCodes.Bgt_S
  id: Bgt_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bgt_S
  fullName: System.Reflection.Emit.OpCodes.Bgt_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bgt_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 207
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is greater than the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bgt.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than <em>value2</em>. The effect is identical to performing a <strong>cgt</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bgt.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bgt_S
    content.vb: Public Shared ReadOnly Bgt_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bgt_Un
  commentId: F:System.Reflection.Emit.OpCodes.Bgt_Un
  id: Bgt_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bgt_Un
  fullName: System.Reflection.Emit.OpCodes.Bgt_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bgt_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 208
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bgt.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>cgt.un</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bgt.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bgt_Un
    content.vb: Public Shared ReadOnly Bgt_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bgt_Un_S
  commentId: F:System.Reflection.Emit.OpCodes.Bgt_Un_S
  id: Bgt_Un_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bgt_Un_S
  fullName: System.Reflection.Emit.OpCodes.Bgt_Un_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bgt_Un_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 209
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is greater than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is greater than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bgt.un.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is greater than <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>cgt.un</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bgt.un.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bgt_Un_S
    content.vb: Public Shared ReadOnly Bgt_Un_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ble
  commentId: F:System.Reflection.Emit.OpCodes.Ble
  id: Ble
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ble
  fullName: System.Reflection.Emit.OpCodes.Ble
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ble
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 210
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is less than or equal to the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>ble</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than or equal to <em>value2</em>. The effect is identical to performing a <strong>cgt</strong> instruction (<strong>cgt.un</strong> for floats) followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ble</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ble
    content.vb: Public Shared ReadOnly Ble As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ble_S
  commentId: F:System.Reflection.Emit.OpCodes.Ble_S
  id: Ble_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ble_S
  fullName: System.Reflection.Emit.OpCodes.Ble_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ble_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 211
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>ble.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than or equal to <em>value2</em>. The effect is identical to performing a <strong>cgt</strong> instruction (<strong>cgt.un</strong> for floats) instruction followed by a<strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ble.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ble_S
    content.vb: Public Shared ReadOnly Ble_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ble_Un
  commentId: F:System.Reflection.Emit.OpCodes.Ble_Un
  id: Ble_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ble_Un
  fullName: System.Reflection.Emit.OpCodes.Ble_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ble_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 212
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>ble.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than or equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>cgt.un</strong> instruction (<strong>cgt</strong> for floats) followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ble.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ble_Un
    content.vb: Public Shared ReadOnly Ble_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ble_Un_S
  commentId: F:System.Reflection.Emit.OpCodes.Ble_Un_S
  id: Ble_Un_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ble_Un_S
  fullName: System.Reflection.Emit.OpCodes.Ble_Un_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ble_Un_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 213
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than or equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>ble.un.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than or equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>cgt.un</strong> instruction (<strong>cgt</strong> for floats) followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ble.un.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ble_Un_S
    content.vb: Public Shared ReadOnly Ble_Un_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Blt
  commentId: F:System.Reflection.Emit.OpCodes.Blt
  id: Blt
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Blt
  fullName: System.Reflection.Emit.OpCodes.Blt
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Blt
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 214
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is less than the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>blt</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than or equal to <em>value2</em>. The effect is identical to performing a <strong>clt</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>blt</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Blt
    content.vb: Public Shared ReadOnly Blt As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Blt_S
  commentId: F:System.Reflection.Emit.OpCodes.Blt_S
  id: Blt_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Blt_S
  fullName: System.Reflection.Emit.OpCodes.Blt_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Blt_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 215
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is less than the second value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>blt.s</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than <em>value2</em>. The effect is identical to performing a <strong>clt</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>blt.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Blt_S
    content.vb: Public Shared ReadOnly Blt_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Blt_Un
  commentId: F:System.Reflection.Emit.OpCodes.Blt_Un
  id: Blt_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Blt_Un
  fullName: System.Reflection.Emit.OpCodes.Blt_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Blt_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 216
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>blt.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>clt.un</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>blt.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Blt_Un
    content.vb: Public Shared ReadOnly Blt_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Blt_Un_S
  commentId: F:System.Reflection.Emit.OpCodes.Blt_Un_S
  id: Blt_Un_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Blt_Un_S
  fullName: System.Reflection.Emit.OpCodes.Blt_Un_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Blt_Un_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 217
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if the first value is less than the second value, when comparing unsigned integer values or unordered float values.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is less than <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>blt.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is less than <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>clt.un</strong> instruction followed by a <strong>brtrue</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>blt.un.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Blt_Un_S
    content.vb: Public Shared ReadOnly Blt_Un_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bne_Un
  commentId: F:System.Reflection.Emit.OpCodes.Bne_Un
  id: Bne_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bne_Un
  fullName: System.Reflection.Emit.OpCodes.Bne_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bne_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 218
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction when two unsigned integer values or unordered float values are not equal.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is not equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bne.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is not equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>ceq</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bne.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bne_Un
    content.vb: Public Shared ReadOnly Bne_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Bne_Un_S
  commentId: F:System.Reflection.Emit.OpCodes.Bne_Un_S
  id: Bne_Un_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Bne_Un_S
  fullName: System.Reflection.Emit.OpCodes.Bne_Un_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Bne_Un_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 219
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) when two unsigned integer values or unordered float values are not equal.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; if <em>value1</em> is not equal to <em>value2</em>, the branch operation is performed.</p>\n</li></ol>\n<p>The <strong>bne.un</strong> instruction transfers control to the specified target instruction if <em>value1</em> is not equal to <em>value2</em>, when compared using unsigned integer or unordered float values. The effect is identical to performing a <strong>ceq</strong> instruction followed by a <strong>brfalse</strong> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>bne.un.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Bne_Un_S
    content.vb: Public Shared ReadOnly Bne_Un_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Box
  commentId: F:System.Reflection.Emit.OpCodes.Box
  id: Box
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Box
  fullName: System.Reflection.Emit.OpCodes.Box
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Box
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 220
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts a value type to an object reference (type <strong>O</strong>).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value type is pushed onto the stack.</p>\n</li><li>\n<p>The value type is popped from the stack; the <strong>box</strong> operation is performed.</p>\n</li><li>\n<p>An object reference to the resulting \"boxed\" value type is pushed onto the stack.</p>\n</li></ol>\n<p>A value type has two separate representations within the Common Language Infrastructure (CLI): </p>\n<ul><li>\n<p>A 'raw' form used when a value type is embedded within another object or on the stack.</p>\n</li><li>\n<p>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</p>\n</li></ul>\n<p>The <strong>box</strong> instruction converts the 'raw' (unboxed) value type into an object reference (type <strong>O</strong>). This is accomplished by creating a new object and copying the data from the value type into the newly allocated object. <em>valTypeToken</em> is a metadata token indicating the type of the value type on the stack.</p>\n<p>\n<xref href=\"System.OutOfMemoryException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if there is insufficient memory to satisfy the request.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code, rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>box</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Box
    content.vb: Public Shared ReadOnly Box As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Br
  commentId: F:System.Reflection.Emit.OpCodes.Br
  id: Br
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Br
  fullName: System.Reflection.Emit.OpCodes.Br
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Br
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 221
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Unconditionally transfers control to a target instruction.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>No evaluation stack behaviors are performed by this operation.</p>\n<p>The <strong>br</strong> instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>br</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Br
    content.vb: Public Shared ReadOnly Br As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Br_S
  commentId: F:System.Reflection.Emit.OpCodes.Br_S
  id: Br_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Br_S
  fullName: System.Reflection.Emit.OpCodes.Br_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Br_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 222
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Unconditionally transfers control to a target instruction (short form).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>No evaluation stack behaviors are performed by this operation.</p>\n<p>The <strong>br.s</strong> instruction unconditionally transfers control to a target instruction. The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>br.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Br_S
    content.vb: Public Shared ReadOnly Br_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Break
  commentId: F:System.Reflection.Emit.OpCodes.Break
  id: Break
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Break
  fullName: System.Reflection.Emit.OpCodes.Break
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Break
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 223
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break point has been tripped.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>No evaluation stack behaviors are performed by this operation.</p>\n<p>The <strong>break</strong> instruction is for debugging support. It signals the CLI to inform the debugger that a break point has been tripped. It has no other effect on the interpreter state.</p>\n<p>The <strong>break</strong> instruction has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</p>\n<p>The <strong>break</strong> instruction can trap to a debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>break</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Break
    content.vb: Public Shared ReadOnly Break As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Brfalse
  commentId: F:System.Reflection.Emit.OpCodes.Brfalse
  id: Brfalse
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Brfalse
  fullName: System.Reflection.Emit.OpCodes.Brfalse
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Brfalse
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 224
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if <em>value</em> is <strong>false</strong>, a null reference (<strong>Nothing</strong> in Visual Basic), or zero.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack by a previous operation.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack; if <em>value</em> is <strong>false</strong>, branch to <em>target</em>.</p>\n</li></ol>\n<p>The <strong>brfalse</strong> instruction (and its aliases <strong>brnull</strong> and <strong>brzero</strong>) transfers control to the specified target instruction if <em>value</em> (of type <strong>int32</strong>, <strong>int64</strong>, object reference <strong>O</strong>, managed pointer <strong>&</strong>, transient pointer <strong>*</strong>, <strong>native int</strong>) is zero (<strong>false</strong>). If <em>value</em> is non-zero (<strong>true</strong>) execution continues at the next instruction.</p>\n<p>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>brfalse</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Brfalse
    content.vb: Public Shared ReadOnly Brfalse As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Brfalse_S
  commentId: F:System.Reflection.Emit.OpCodes.Brfalse_S
  id: Brfalse_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Brfalse_S
  fullName: System.Reflection.Emit.OpCodes.Brfalse_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Brfalse_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 225
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if <em>value</em> is <strong>false</strong>, a null reference, or zero.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack by a previous operation.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack; if <em>value</em> is <strong>false</strong>, branch to <em>target</em>.</p>\n</li></ol>\n<p>The <strong>brfalse.s</strong> instruction (and its aliases <strong>brnull</strong> and <strong>brzero</strong>) transfers control to the specified target instruction if <em>value</em> (of type <strong>int32</strong>, <strong>int64</strong>, object reference <strong>O</strong>, managed pointer <strong>&</strong>, transient pointer <strong>*</strong>, <strong>native int</strong>) is zero (<strong>false</strong>). If <em>value</em> is non-zero (<strong>true</strong>) execution continues at the next instruction.</p>\n<p>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>brfalse.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Brfalse_S
    content.vb: Public Shared ReadOnly Brfalse_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Brtrue
  commentId: F:System.Reflection.Emit.OpCodes.Brtrue
  id: Brtrue
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Brtrue
  fullName: System.Reflection.Emit.OpCodes.Brtrue
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Brtrue
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 226
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction if <em>value</em> is <strong>true</strong>, not null, or non-zero.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack by a previous operation.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack; if <em>value</em> is <strong>true</strong>, branch to <em>target</em>.</p>\n</li></ol>\n<p>The <strong>brtrue</strong> instruction transfers control to the specified target instruction if <em>value</em> (type <strong>native int</strong>) is nonzero (<strong>true</strong>). If <em>value</em> is zero (<strong>false</strong>) execution continues at the next instruction.</p>\n<p>If <em>value</em> is an object reference (type <strong>O</strong>) then <strong>brinst</strong> (an alias for <strong>brtrue</strong>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref href=\"System.Reflection.Emit.OpCodes.Ldnull\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>brtrue</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Brtrue
    content.vb: Public Shared ReadOnly Brtrue As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Brtrue_S
  commentId: F:System.Reflection.Emit.OpCodes.Brtrue_S
  id: Brtrue_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Brtrue_S
  fullName: System.Reflection.Emit.OpCodes.Brtrue_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Brtrue_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 227
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control to a target instruction (short form) if <em>value</em> is <strong>true</strong>, not null, or non-zero.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack by a previous operation.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack; if <em>value</em> is <strong>true</strong>, branch to <em>target</em>.</p>\n</li></ol>\n<p>The <strong>brtrue.s</strong> instruction transfers control to the specified target instruction if <em>value</em> (type <strong>native int</strong>) is nonzero (<strong>true</strong>). If <em>value</em> is zero (<strong>false</strong>) execution continues at the next instruction.</p>\n<p>If <em>value</em> is an object reference (type <strong>O</strong>) then <strong>brinst</strong> (an alias for <strong>brtrue</strong>) transfers control if it represents an instance of an object (for example, if it is not the null object reference; see <xref href=\"System.Reflection.Emit.OpCodes.Ldnull\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>The target instruction is represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes. Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>brtrue.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Brtrue_S
    content.vb: Public Shared ReadOnly Brtrue_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Call
  commentId: F:System.Reflection.Emit.OpCodes.Call
  id: Call
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Call
  fullName: System.Reflection.Emit.OpCodes.Call
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Call
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 228
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Calls the method indicated by the passed method descriptor.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> are pushed onto the stack.</p>\n</li><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> are popped from the stack; the method call is performed with these arguments and control is transferred to the method referred to by the method descriptor. When complete, a return value is generated by the callee method and sent to the caller.</p>\n</li><li>\n<p>The return value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>call</strong> instruction calls the method indicated by the method descriptor passed with the instruction. The method descriptor is a metadata token that indicates the method to call and the number, type, and order of the arguments that have been placed on the stack to be passed to that method as well as the calling convention to be used. The <strong>call</strong> instruction can be immediately preceded by a <strong>tail</strong> (<xref href=\"System.Reflection.Emit.OpCodes.Tailcall\" data-throw-if-not-resolved=\"false\"></xref>) prefix instruction to specify that the current method state should be released before transferring control. If the call transfers control to a method of higher trust than the origin method, the stack frame is not released. Instead, the execution continues silently as if the <strong>tail</strong> had not been supplied. The metadata token carries sufficient information to determine whether the call is to a static method, an instance method, a virtual method, or a global function. In all of these cases the destination address is determined entirely from the method descriptor (contrast this with the <xref href=\"System.Reflection.Emit.OpCodes.Callvirt\" data-throw-if-not-resolved=\"false\"></xref> instruction for calling virtual methods, where the destination address also depends upon the runtime type of the instance reference pushed before the <xref href=\"System.Reflection.Emit.OpCodes.Callvirt\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. There are three important special cases: </p>\n<p>1. Calls to an instance (or virtual) method must push that instance reference before any of the user-visible arguments. The instance reference must not be a null reference. The signature carried in the metadata does not contain an entry in the parameter list for the <strong>this</strong> pointer; instead, it uses a bit to indicate whether the method requires passing the <strong>this</strong> pointer.</p>\n<p>2. It is valid to call a virtual method using <strong>call</strong> (rather than <strong>callvirt</strong>); this indicates that the method is to be resolved using the class specified by method rather than as specified dynamically from the object being invoked.</p>\n<p>3. Note that a delegate's <strong>Invoke</strong> method can be called with either the <strong>call</strong> or <strong>callvirt</strong> instruction.</p>\n<p>\n<xref href=\"System.Security.SecurityException\" data-throw-if-not-resolved=\"false\"></xref> may be thrown if system security does not grant the caller access to the called method. The security check may occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</p>\n<p>When calling methods of System.Object on value types, consider using the <strong>constrained</strong> prefix with the <strong>callvirt</strong> instruction instead of emitting a <strong>call</strong> instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the <strong>constrained</strong> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <strong>MethodImpl</strong>. These issues are described in more detail in the <xref href=\"System.Reflection.Emit.OpCodes.Constrained\" data-throw-if-not-resolved=\"false\"></xref> opcode.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>call</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li><li>\n<p>ILGenerator.EmitCall(OpCode, MethodInfo, Type[]) </p>\n</li></ul>\n<p>The <xref href=\"System.Reflection.Emit.ILGenerator.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method is provided for <strong>varargs</strong> calls. Use the <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method for normal calls. </p>\n"
  syntax:
    content: public static readonly OpCode Call
    content.vb: Public Shared ReadOnly Call As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Calli
  commentId: F:System.Reflection.Emit.OpCodes.Calli
  id: Calli
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Calli
  fullName: System.Reflection.Emit.OpCodes.Calli
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Calli
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 229
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Calls the method indicated on the evaluation stack (as a pointer to an entry point) with arguments described by a calling convention.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> are pushed onto the stack.</p>\n</li><li>\n<p>The method entry pointer is pushed onto the stack.</p>\n</li><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> and the method entry pointer are popped from the stack; the call to the method is performed. When complete, a return value is generated by the callee method and sent to the caller.</p>\n</li><li>\n<p>The return value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>calli</strong> instruction calls the method entry pointer with the arguments <em>arg1</em> through <em>argN</em>. The types of these arguments are described by the specific calling convention (<em>callSiteDesc</em>). The <strong>calli</strong> instruction may be immediately preceded by a <strong>tail</strong> prefix (<xref href=\"System.Reflection.Emit.OpCodes.Tailcall\" data-throw-if-not-resolved=\"false\"></xref>) to specify that the current method state should be released before transferring control. If the call would transfer control to a method of higher trust than the origin method the stack frame will not be released; instead, the execution will continue silently as if the <strong>tail</strong> had not been supplied.</p>\n<p>The method entry pointer is assumed to be a specific pointer to native code (of the target machine) that can be legitimately called with the arguments described by the calling convention (a metadata token for a stand-alone signature). Such a pointer can be created using the <xref href=\"System.Reflection.Emit.OpCodes.Ldftn\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Ldvirtftn\" data-throw-if-not-resolved=\"false\"></xref> instructions, or passed in from native code.</p>\n<p>The calling convention is not checked dynamically, so code that uses a <strong>calli</strong> instruction does not work correctly if the destination does not actually use the specified calling convention.</p>\n<p>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The argument-building code sequence for an instance or virtual method must push that instance reference (which must not be a null reference) before any of the user-visible arguments.</p>\n<p>\n<xref href=\"System.Security.SecurityException\" data-throw-if-not-resolved=\"false\"></xref> may be thrown if the system security does not grant the caller access to the called method. The security check can occur when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> methods can be used to perform a <strong>calli</strong> instruction on the stack. Note that <strong>calli</strong> should be called through the below methods rather than using the <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> class to place the instruction directly on the stack.</p>\n<ul><li>\n<p>ILGenerator.EmitCalli(Opcode, CallingConventions, Type, Type[], Type[]) for calls using a managed calling convention.</p>\n</li><li>\n<p>ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls using an unmanaged calling convention.</p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Calli
    content.vb: Public Shared ReadOnly Calli As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Callvirt
  commentId: F:System.Reflection.Emit.OpCodes.Callvirt
  id: Callvirt
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Callvirt
  fullName: System.Reflection.Emit.OpCodes.Callvirt
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Callvirt
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 230
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Calls a late-bound method on an object, pushing the return value onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>obj</em> is pushed onto the stack.</p>\n</li><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> are pushed onto the stack.</p>\n</li><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> and the object reference <em>obj</em> are popped from the stack; the method call is performed with these arguments and control is transferred to the method in <em>obj</em> referred to by the method metadata token. When complete, a return value is generated by the callee method and sent to the caller.</p>\n</li><li>\n<p>The return value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>callvirt</strong> instruction calls a late-bound method on an object. That is, the method is chosen based on the runtime type of <em>obj</em> rather than the compile-time class visible in the method pointer. <strong>Callvirt</strong> can be used to call both virtual and instance methods. The <strong>callvirt</strong> instruction may be immediately preceded by a <strong>tail</strong> (<xref href=\"System.Reflection.Emit.OpCodes.Tailcall\" data-throw-if-not-resolved=\"false\"></xref>) prefix to specify that the current stack frame should be released before transferring control. If the call would transfer control to a method of higher trust than the original method the stack frame will not be released.</p>\n<p>The method metadata token provides the name, class and signature of the method to call. The class associated with <em>obj</em> is the class of which it is an instance. If the class defines a non-static method that matches the indicated method name and signature, this method is called. Otherwise all classes in the base class chain of this class are checked in order. It is an error if no method is found.</p>\n<p>\n<strong>Callvirt</strong> pops the object and the associated arguments off the evaluation stack before calling the method. If the method has a return value, it is pushed on the stack upon method completion. On the callee side, the <em>obj</em> parameter is accessed as argument 0, <em>arg1</em> as argument 1, and so on.</p>\n<p>The arguments are placed on the stack in left-to-right order. That is, the first argument is computed and placed on the stack, then the second argument, then the third, until all necessary arguments are atop the stack in descending order. The instance reference <em>obj</em> (always required for <strong>callvirt</strong>) must be pushed before any of the user-visible arguments. The signature (carried in the metadata token) need not contain an entry in the parameter list for the this pointer.</p>\n<p>Note that a virtual method can also be called using the<xref href=\"System.Reflection.Emit.OpCodes.Call\" data-throw-if-not-resolved=\"false\"></xref> instruction.</p>\n<p>\n<xref href=\"System.MissingMethodException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if a non-static method with the indicated name and signature could not be found in the class associated with <em>obj</em> or any of its base classes. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if obj is null.</p>\n<p>\n<xref href=\"System.Security.SecurityException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if system security does not grant the caller access to the called method. The security check may occur when the CIL is converted to native code rather than at run time.</p>\n<p>When calling methods of System.Object on value types, consider using the <strong>constrained</strong> prefix with the <strong>callvirt</strong> instruction. This removes the need to emit different IL depending on whether or not the value type overrides the method, avoiding a potential versioning problem. Consider using the <strong>constrained</strong> prefix when invoking interface methods on value types, since the value type method implementing the interface method can be changed using a <strong>MethodImpl</strong>. These issues are described in more detail in the <xref href=\"System.Reflection.Emit.OpCodes.Constrained\" data-throw-if-not-resolved=\"false\"></xref> opcode.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>callvirt</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li><li>\n<p>ILGenerator.EmitCall(OpCode, MethodInfo, Type[]) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Callvirt
    content.vb: Public Shared ReadOnly Callvirt As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Castclass
  commentId: F:System.Reflection.Emit.OpCodes.Castclass
  id: Castclass
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Castclass
  fullName: System.Reflection.Emit.OpCodes.Castclass
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Castclass
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 231
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Attempts to cast an object passed by reference to the specified class.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack; the referenced object is cast as the specified <em>class</em>.</p>\n</li><li>\n<p>If successful, a new object reference is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>castclass</strong> instruction attempts to cast the object reference (type <strong>O</strong>) atop the stack to a specified class. The new class is specified by a metadata token indicating the desired class. If the class of the object on the top of the stack does not implement the new class (assuming the new class is an interface) and is not a derived class of the new class then an <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown. If the object reference is a null reference, <strong>castclass</strong> succeeds and returns the new object as a null reference.</p>\n<p>\n<xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if obj cannot be cast to class.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if class cannot be found. This is typically detected when a Microsoft Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>castclass</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Castclass
    content.vb: Public Shared ReadOnly Castclass As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ceq
  commentId: F:System.Reflection.Emit.OpCodes.Ceq
  id: Ceq
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ceq
  fullName: System.Reflection.Emit.OpCodes.Ceq
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ceq
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 232
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compares two values. If they are equal, the integer value 1 <strong>(int32</strong>) is pushed onto the evaluation stack; otherwise 0 (<strong>int32</strong>) is pushed onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is compared to <em>value2</em>.</p>\n</li><li>\n<p>If <em>value1</em> is equal to <em>value2</em>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ceq</strong> instruction compares <em>value1</em> and <em>value2</em>. If <em>value1</em> is equal to <em>value2</em>, then 1 (of type <strong>int32</strong>) is pushed on the stack. Otherwise 0 (of type <strong>int32</strong>) is pushed on the stack.</p>\n<p>For floating-point number, <strong>ceq</strong> will return 0 if the numbers are unordered (either or both are NaN). The infinite values are equal to themselves.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ceq</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ceq
    content.vb: Public Shared ReadOnly Ceq As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Cgt
  commentId: F:System.Reflection.Emit.OpCodes.Cgt
  id: Cgt
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Cgt
  fullName: System.Reflection.Emit.OpCodes.Cgt
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Cgt
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 233
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compares two values. If the first value is greater than the second, the integer value 1 <strong>(int32</strong>) is pushed onto the evaluation stack; otherwise 0 (<strong>int32</strong>) is pushed onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <strong>cgt</strong> tests if <em>value1</em> is greater than <em>value2</em>.</p>\n</li><li>\n<p>If <em>value1</em> is greater than <em>value2</em>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>cgt</strong> instruction compares <em>value1</em> and <em>value2</em>. If <em>value1</em> is strictly greater than <em>value2</em>, then an <strong>int32</strong> value of 1 is pushed on the stack. Otherwise, an <strong>int32</strong> value of 0 is pushed on the stack.</p>\n<ul><li>\n<p>For floating-point numbers, <strong>cgt</strong> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</p>\n</li></ul>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>cgt</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Cgt
    content.vb: Public Shared ReadOnly Cgt As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Cgt_Un
  commentId: F:System.Reflection.Emit.OpCodes.Cgt_Un
  id: Cgt_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Cgt_Un
  fullName: System.Reflection.Emit.OpCodes.Cgt_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Cgt_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 234
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compares two unsigned or unordered values. If the first value is greater than the second, the integer value 1 <strong>(int32</strong>) is pushed onto the evaluation stack; otherwise 0 (<strong>int32</strong>) is pushed onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <strong>cgt.un</strong> tests if <em>value1</em> is greater than <em>value2</em>.</p>\n</li><li>\n<p>If <em>value1</em> is greater than <em>value2</em>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</p>\n</li></ol>\n<p>An <strong>int32</strong> value of 1 is pushed on the stack if any of the following is <strong>true</strong> : </p>\n<p>For floating-point numbers, <em>value1</em> is not ordered with respect to <em>value2</em>.</p>\n<p>For integer values, <em>value1</em> is strictly greater than <em>value2</em> when considered as unsigned numbers.</p>\n<p>Otherwise an <strong>int32</strong> value of 0 is pushed on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>cgt.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Cgt_Un
    content.vb: Public Shared ReadOnly Cgt_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ckfinite
  commentId: F:System.Reflection.Emit.OpCodes.Ckfinite
  id: Ckfinite
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ckfinite
  fullName: System.Reflection.Emit.OpCodes.Ckfinite
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ckfinite
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 235
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Throws <xref href=\"System.ArithmeticException\" data-throw-if-not-resolved=\"false\"></xref> if value is not a finite number.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack..</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the <strong>ckfinite</strong> instruction is performed on it.</p>\n</li><li>\n<p>\n<em>value</em> is pushed back onto the stack if no exception is thrown.</p>\n</li></ol>\n<p>The <strong>ckfinite instruction</strong> throws <xref href=\"System.ArithmeticException\" data-throw-if-not-resolved=\"false\"></xref> if <em>value</em> (a floating-point number) is either a \"not a number\" value (NaN) or a <strong>+-</strong> infinity value. <strong>Ckfinite</strong> leaves the value on the stack if no exception is thrown. Execution is unspecified if <em>value</em> is not a floating-point number.</p>\n<p>\n<xref href=\"System.ArithmeticException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>value</em> is not a 'normal' number.</p>\n<p>Note that a special exception or a derived class of <xref href=\"System.ArithmeticException\" data-throw-if-not-resolved=\"false\"></xref> may be more appropriate, passing the incorrect value to the exception handler.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ckfinite</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ckfinite
    content.vb: Public Shared ReadOnly Ckfinite As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Clt
  commentId: F:System.Reflection.Emit.OpCodes.Clt
  id: Clt
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Clt
  fullName: System.Reflection.Emit.OpCodes.Clt
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Clt
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 236
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compares two values. If the first value is less than the second, the integer value 1 <strong>(int32</strong>) is pushed onto the evaluation stack; otherwise 0 (<strong>int32</strong>) is pushed onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: <em>value1</em> is pushed onto the stack.</p>\n<ol><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <strong>clt</strong> tests if <em>value1</em> is less than <em>value2</em>.</p>\n</li><li>\n<p>If <em>value1</em> is less than <em>value2</em>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>clt</strong> instruction compares <em>value1</em> and <em>value2</em>. If <em>value1</em> is strictly less than <em>value2</em>, then an <strong>int32</strong> value of 1 is pushed on the stack. Otherwise, an <strong>int32</strong> value of 0 is pushed on the stack.</p>\n<ul><li>\n<p>For floating-point numbers, <strong>clt</strong> returns 0 if the numbers are unordered (that is, if one or both of the arguments are NaN).</p>\n</li></ul>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>clt</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Clt
    content.vb: Public Shared ReadOnly Clt As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Clt_Un
  commentId: F:System.Reflection.Emit.OpCodes.Clt_Un
  id: Clt_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Clt_Un
  fullName: System.Reflection.Emit.OpCodes.Clt_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Clt_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 237
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compares the unsigned or unordered values <em>value1</em> and <em>value2</em>. If <em>value1</em> is less than <em>value2</em>, then the integer value 1 <strong>(int32</strong>) is pushed onto the evaluation stack; otherwise 0 (<strong>int32</strong>) is pushed onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <strong>clt.un</strong> tests if <em>value1</em> is less than <em>value2</em>.</p>\n</li><li>\n<p>If <em>value1</em> is less than <em>value2</em>, 1 is pushed onto the stack; otherwise 0 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>clt.un</strong> instruction compares <em>value1</em> and <em>value2</em>. An <strong>int32</strong> value of 1 is pushed on the stack if any of the following is true: </p>\n<ul><li>\n<p>\n<em>value1</em> is strictly less than <em>value2</em> (as for <strong>clt</strong>).</p>\n</li><li>\n<p>For floating-point numbers, <em>value1</em> is not ordered with respect to <em>value2</em>.</p>\n</li><li>\n<p>For integer values, <em>value1</em> is strictly less than <em>value2</em> when considered as unsigned numbers.</p>\n</li></ul>\n<p>Otherwise, an <strong>int32</strong> value of 0 is pushed on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>clt.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Clt_Un
    content.vb: Public Shared ReadOnly Clt_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Constrained
  commentId: F:System.Reflection.Emit.OpCodes.Constrained
  id: Constrained
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Constrained
  fullName: System.Reflection.Emit.OpCodes.Constrained
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Constrained
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 238
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Constrains the type on which a virtual method call is made.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The <strong>constrained</strong> prefix is permitted only on a <strong>callvirt</strong> instruction. </p>\n<p>The state of the MSIL stack at this point must be as follows: </p>\n<ol><li>\n<p>A managed pointer, <em>ptr</em>, is pushed onto the stack. The type of <em>ptr</em> must be a managed pointer (<strong>&</strong>) to <em>thisType</em>. Note that this is different from the case of an unprefixed <strong>callvirt</strong> instruction, which expects a reference of <em>thisType</em>.</p>\n</li><li>\n<p>Method arguments <em>arg1</em> through <em>argN</em> are pushed onto the stack, just as with an unprefixed <strong>callvirt</strong> instruction.</p>\n</li></ol>\n<p>The <strong>constrained</strong> prefix is designed to allow <strong>callvirt</strong> instructions to be made in a uniform way independent of whether <em>thisType</em> is a value type or a reference type.</p>\n<p>When a <strong>callvirt</strong> <em>method</em> instruction has been prefixed by <strong>constrained</strong> <em>thisType</em>, the instruction is executed as follows: </p>\n<ul><li>\n<p>If <em>thisType</em> is a reference type (as opposed to a value type) then <em>ptr</em> is dereferenced and passed as the 'this' pointer to the <strong>callvirt</strong> of <em>method</em>.</p>\n</li><li>\n<p>If <em>thisType</em> is a value type and <em>thisType</em> implements <em>method</em> then <em>ptr</em> is passed unmodified as the 'this' pointer to a <strong>call</strong> <em>method</em> instruction, for the implementation of <em>method</em> by <em>thisType</em>.</p>\n</li><li>\n<p>If <em>thisType</em> is a value type and <em>thisType</em> does not implement <em>method</em> then <em>ptr</em> is dereferenced, boxed, and passed as the 'this' pointer to the <strong>callvirt</strong> <em>method</em> instruction.</p>\n</li></ul>\n<p>This last case can occur only when <em>method</em> was defined on <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.ValueType\" data-throw-if-not-resolved=\"false\"></xref>, or<xref href=\"System.Enum\" data-throw-if-not-resolved=\"false\"></xref> and not overridden by <em>thisType</em>. In this case, the boxing causes a copy of the original object to be made. However, because none of the methods of <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.ValueType\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Enum\" data-throw-if-not-resolved=\"false\"></xref> modify the state of the object, this fact cannot be detected.  </p>\n<p>The <strong>constrained</strong> prefix supports IL generators that create generic code. Normally the <strong>callvirt</strong> instruction is not valid on value types. Instead it is required that IL compilers effectively perform the 'this' transformation outlined above at compile time, depending on the type of <em>ptr</em> and the method being called. However, when <em>ptr</em> is a generic type that is unknown at compile time, it is not possible to make this transformation at compile time.</p>\n<p>The <strong>constrained</strong>opcode allows IL compilers to make a call to a virtual function in a uniform way independent of whether <em>ptr</em> is a value type or a reference type. Although it is intended for the case where <em>thisType</em> is a generic type variable, the <strong>constrained</strong> prefix also works for nongeneric types and can reduce the complexity of generating virtual calls in languages that hide the distinction between value types and reference types. </p>\n<p>Using the <strong>constrained</strong> prefix also avoids potential versioning problems with value types. If the <strong>constrained</strong> prefix is not used, different IL must be emitted depending on whether or not a value type overrides a method of System.Object. For example, if a value type <code>V</code> overrides the Object.ToString() method, a <strong>call</strong> <code>V.ToString()</code> instruction is emitted; if it does not, a <strong>box</strong> instruction and a <strong>callvirt</strong> <code>Object.ToString()</code> instruction are emitted. A versioning problem can arise in the former case if the override is later removed, and in the latter case if an override is later added. </p>\n<p>The <strong>constrained</strong> prefix can also be used for invocation of interface methods on value types, because the value type method implementing the interface method can be changed using a <strong>MethodImpl</strong>. If the <strong>constrained</strong>prefix is not used, the compiler is forced to choose which of the value type's methods to bind to at compile time. Using the <strong>constrained</strong> prefix allows the MSIL to bind to the method that implements the interface method at run time, rather than at compile time.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>constrained</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Constrained
    content.vb: Public Shared ReadOnly Constrained As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_I
  commentId: F:System.Reflection.Emit.OpCodes.Conv_I
  id: Conv_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_I
  fullName: System.Reflection.Emit.OpCodes.Conv_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 239
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>native int</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.i</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_I
    content.vb: Public Shared ReadOnly Conv_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_I1
  commentId: F:System.Reflection.Emit.OpCodes.Conv_I1
  id: Conv_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_I1
  fullName: System.Reflection.Emit.OpCodes.Conv_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 240
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>int8</strong>, then extends (pads) it to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.i1</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I1\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_I1
    content.vb: Public Shared ReadOnly Conv_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_I2
  commentId: F:System.Reflection.Emit.OpCodes.Conv_I2
  id: Conv_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_I2
  fullName: System.Reflection.Emit.OpCodes.Conv_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 241
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>int16</strong>, then extends (pads) it to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.i2</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I2\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_I2
    content.vb: Public Shared ReadOnly Conv_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_I4
  commentId: F:System.Reflection.Emit.OpCodes.Conv_I4
  id: Conv_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_I4
  fullName: System.Reflection.Emit.OpCodes.Conv_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 242
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.i4</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I4\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_I4
    content.vb: Public Shared ReadOnly Conv_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_I8
  commentId: F:System.Reflection.Emit.OpCodes.Conv_I8
  id: Conv_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_I8
  fullName: System.Reflection.Emit.OpCodes.Conv_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 243
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>int64</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.i8</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I8\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_I8
    content.vb: Public Shared ReadOnly Conv_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I
  id: Conv_Ovf_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 244
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to signed <strong>native int</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I
    content.vb: Public Shared ReadOnly Conv_Ovf_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un
  id: Conv_Ovf_I_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 245
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to signed <strong>native int</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_I_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1
  id: Conv_Ovf_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I1
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 246
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to signed <strong>int8</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i1</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I1
    content.vb: Public Shared ReadOnly Conv_Ovf_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un
  id: Conv_Ovf_I1_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I1_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I1_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 247
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to signed <strong>int8</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i1.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i1.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I1_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2
  id: Conv_Ovf_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I2
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 248
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to signed <strong>int16</strong> and extending it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i2</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I2
    content.vb: Public Shared ReadOnly Conv_Ovf_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un
  id: Conv_Ovf_I2_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I2_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I2_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 249
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to signed <strong>int16</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i2.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i2.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I2_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4
  id: Conv_Ovf_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I4
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 250
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to signed <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i4</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I4
    content.vb: Public Shared ReadOnly Conv_Ovf_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un
  id: Conv_Ovf_I4_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I4_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I4_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 251
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to signed <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i4.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i4.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I4_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8
  id: Conv_Ovf_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I8
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 252
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to signed <strong>int64</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i8</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I8
    content.vb: Public Shared ReadOnly Conv_Ovf_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un
  id: Conv_Ovf_I8_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_I8_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_I8_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 253
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to signed <strong>int64</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.i8.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.i8.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_I8_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U
  id: Conv_Ovf_U
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 254
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to <strong>unsigned native int</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U
    content.vb: Public Shared ReadOnly Conv_Ovf_U As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un
  id: Conv_Ovf_U_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 255
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to <strong>unsigned native int</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.uvf.u.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_U_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1
  id: Conv_Ovf_U1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U1
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 256
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to <strong>unsigned int8</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u1</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U1
    content.vb: Public Shared ReadOnly Conv_Ovf_U1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un
  id: Conv_Ovf_U1_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U1_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U1_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 257
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to <strong>unsigned int8</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u1.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u1.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U1_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2
  id: Conv_Ovf_U2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U2
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 258
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to <strong>unsigned int16</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u2</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U2
    content.vb: Public Shared ReadOnly Conv_Ovf_U2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un
  id: Conv_Ovf_U2_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U2_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U2_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 259
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to <strong>unsigned int16</strong> and extends it to <strong>int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u2.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u2.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U2_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4
  id: Conv_Ovf_U4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U4
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 260
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to <strong>unsigned int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u4</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong>are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U4
    content.vb: Public Shared ReadOnly Conv_Ovf_U4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un
  id: Conv_Ovf_U4_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U4_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U4_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 261
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to <strong>unsigned int32</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u4.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u4.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U4_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8
  id: Conv_Ovf_U8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U8
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 262
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the signed value on top of the evaluation stack to <strong>unsigned int64</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u8</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U8
    content.vb: Public Shared ReadOnly Conv_Ovf_U8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un
  id: Conv_Ovf_U8_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_Ovf_U8_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_Ovf_U8_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 263
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned value on top of the evaluation stack to <strong>unsigned int64</strong>, throwing <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> on overflow.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted. If overflow occurs, an exception is thrown.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.ovf.u8.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and places that converted value on the top of the stack. If the value is too large or too small to be represented by the target type, an exception is thrown.</p>\n<p>Conversions from floating-point numbers to integer values truncate the number toward zero. Note that integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.ovf.i</strong> or <strong>conv.ovf.u</strong> are used, in which case the result is also <strong>native int</strong>).</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.ovf.u8.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_Ovf_U8_Un
    content.vb: Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_R_Un
  commentId: F:System.Reflection.Emit.OpCodes.Conv_R_Un
  id: Conv_R_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_R_Un
  fullName: System.Reflection.Emit.OpCodes.Conv_R_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_R_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 264
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the unsigned integer value on top of the evaluation stack to <strong>float32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.r.un</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from a <strong>float64</strong> to a <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the <em>result</em> returned is unspecified. The <strong>conv.r.un</strong> operation takes an integer off the stack, interprets it as unsigned, and replaces it with a floating-point number to represent the integer: either a <strong>float32</strong>, if this is wide enough to represent the integer without loss of precision, or else a <strong>float64</strong>.</p>\n<p>No exceptions are ever thrown when using this field.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.r.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_R_Un
    content.vb: Public Shared ReadOnly Conv_R_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_R4
  commentId: F:System.Reflection.Emit.OpCodes.Conv_R4
  id: Conv_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_R4
  fullName: System.Reflection.Emit.OpCodes.Conv_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 265
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>float32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.r4</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_R4
    content.vb: Public Shared ReadOnly Conv_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_R8
  commentId: F:System.Reflection.Emit.OpCodes.Conv_R8
  id: Conv_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_R8
  fullName: System.Reflection.Emit.OpCodes.Conv_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 266
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>float64</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.r8</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_R8
    content.vb: Public Shared ReadOnly Conv_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_U
  commentId: F:System.Reflection.Emit.OpCodes.Conv_U
  id: Conv_U
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_U
  fullName: System.Reflection.Emit.OpCodes.Conv_U
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_U
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 267
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>unsigned native int</strong>, and extends it to <strong>native int</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.u</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.u</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_U
    content.vb: Public Shared ReadOnly Conv_U As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_U1
  commentId: F:System.Reflection.Emit.OpCodes.Conv_U1
  id: Conv_U1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_U1
  fullName: System.Reflection.Emit.OpCodes.Conv_U1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_U1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 268
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>unsigned int8</strong>, and extends it to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.u1</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I1\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.u1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_U1
    content.vb: Public Shared ReadOnly Conv_U1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_U2
  commentId: F:System.Reflection.Emit.OpCodes.Conv_U2
  id: Conv_U2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_U2
  fullName: System.Reflection.Emit.OpCodes.Conv_U2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_U2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 269
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>unsigned int16</strong>, and extends it to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.u2</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I2\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.u2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_U2
    content.vb: Public Shared ReadOnly Conv_U2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_U4
  commentId: F:System.Reflection.Emit.OpCodes.Conv_U4
  id: Conv_U4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_U4
  fullName: System.Reflection.Emit.OpCodes.Conv_U4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_U4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 270
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>unsigned int32</strong>, and extends it to <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.u4</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I4\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.u4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_U4
    content.vb: Public Shared ReadOnly Conv_U4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Conv_U8
  commentId: F:System.Reflection.Emit.OpCodes.Conv_U8
  id: Conv_U8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Conv_U8
  fullName: System.Reflection.Emit.OpCodes.Conv_U8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Conv_U8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 271
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the value on top of the evaluation stack to <strong>unsigned int64</strong>, and extends it to <strong>int64</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and the conversion operation is attempted.</p>\n</li><li>\n<p>If the conversion is successful, the resulting value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>conv.u8</strong> opcode converts the <em>value</em> on top of the stack to the type specified in the opcode, and leave that converted value on the top of the stack. Integer values of less than 4 bytes are extended to <strong>int32</strong> when they are loaded onto the evaluation stack (unless <strong>conv.i</strong> or <strong>conv.u</strong> is used, in which case the result is also <strong>native int</strong>). Floating-point values are converted to the <strong>F</strong> type.</p>\n<p>Conversion from floating-point numbers to integer values truncates the number toward zero. When converting from an <strong>float64</strong> to an <strong>float32</strong>, precision can be lost. If <em>value</em> is too large to fit in a <strong>float32 (F)</strong>, positive infinity (if <em>value</em> is positive) or negative infinity (if <em>value</em> is negative) is returned. If overflow occurs converting one integer type to another, the high order bits are truncated. If the result is smaller than an <strong>int32</strong>, the value is sign-extended to fill the slot.</p>\n<p>If overflow occurs converting a floating-point type to an integer the value returned is unspecified.</p>\n<p>No exceptions are ever thrown when using this field. See <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I8\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un\" data-throw-if-not-resolved=\"false\"></xref> for equivalent instructions that will throw an exception when the result type can not properly represent the result value.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>conv.u8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Conv_U8
    content.vb: Public Shared ReadOnly Conv_U8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Cpblk
  commentId: F:System.Reflection.Emit.OpCodes.Cpblk
  id: Cpblk
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Cpblk
  fullName: System.Reflection.Emit.OpCodes.Cpblk
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Cpblk
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 272
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Copies a specified number bytes from a source address to a destination address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The destination address is pushed onto the stack.</p>\n</li><li>\n<p>The source address is pushed onto the stack.</p>\n</li><li>\n<p>The number of bytes to copy is pushed onto the stack.</p>\n</li><li>\n<p>The number of bytes, the source address, and the destination address are popped from the stack; the specified number of bytes are copied from the source address to the destination address.</p>\n</li></ol>\n<p>The <strong>cpblk</strong> instruction copies a number (type <strong>unsigned int32</strong>) of bytes from a source address (of type <strong>*</strong>, <strong>native int</strong>, or <strong>&</strong>) to a destination address (of type <strong>*</strong>, <strong>native int</strong>, or <strong>&</strong>). The behavior of <strong>cpblk</strong> is unspecified if the source and destination areas overlap.</p>\n<p>\n<strong>cpblk</strong> assumes that both the source and destination addressed are aligned to the natural size of the machine. The <strong>cpblk</strong> instruction can be immediately preceded by the <strong>unaligned.<prefix></strong> instruction to indicate that either the source or the destination is unaligned.</p>\n<p>The operation of the <strong>cpblk</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref>prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> may be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>cpblk</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Cpblk
    content.vb: Public Shared ReadOnly Cpblk As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Cpobj
  commentId: F:System.Reflection.Emit.OpCodes.Cpobj
  id: Cpobj
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Cpobj
  fullName: System.Reflection.Emit.OpCodes.Cpobj
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Cpobj
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 273
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Copies the value type located at the address of an object (type <strong>&</strong>, <strong>*</strong> or <strong>native int</strong>) to the address of the destination object (type <strong>&</strong>, <strong>*</strong> or <strong>native int</strong>).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The destination object reference is pushed onto the stack.</p>\n</li><li>\n<p>The source object reference is pushed onto the stack.</p>\n</li><li>\n<p>The two object references are popped from the stack; the value type at the address of the source object is copied to the address of the destination object.</p>\n</li></ol>\n<p>The behavior of <strong>cpobj</strong> is unspecified if the source and destination object references are not pointers to instances of the class represented by the class token <em>classTok</em> (a <strong>typeref</strong> or <strong>typedef</strong>), or if <em>classTok</em> does not represent a value type.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> may be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>cpobj</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Cpobj
    content.vb: Public Shared ReadOnly Cpobj As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Div
  commentId: F:System.Reflection.Emit.OpCodes.Div
  id: Div
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Div
  fullName: System.Reflection.Emit.OpCodes.Div
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Div
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 274
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Divides two values and pushes the result as a floating-point (type <strong>F</strong>) or quotient (type <strong>int32</strong>) onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is divided by <em>value2</em>.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<em>result</em> = <em>value1</em> div value2 satisfies the following conditions: </p>\n<p>| <em>result</em> | = | <em>value1</em> | / | <em>value2</em> |, and: </p>\n<p>sign(<em>result</em>) = +, if sign(<em>value1</em>) = sign(<em>value2</em>), or -, if sign(<em>value1</em>) ~= sign(<em>value2</em>) </p>\n<p>The <strong>div</strong> instruction computes the result and pushes it on the stack.</p>\n<p>Integer division truncates towards zero.</p>\n<p>Division of a finite number by zero produces the correctly signed infinite value.</p>\n<p>Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number) value. Any number divided by infinity will produce a zero value.</p>\n<p>Integral operations throw <xref href=\"System.ArithmeticException\" data-throw-if-not-resolved=\"false\"></xref> if the result cannot be represented in the result type. This can happen if <em>value1</em> is the maximum negative value, and <em>value2</em> is -1.</p>\n<p>Integral operations throw <xref href=\"System.DivideByZeroException\" data-throw-if-not-resolved=\"false\"></xref> if <em>value2</em> is zero.</p>\n<p>Note that on Intel-based platforms an <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when computing (minint div -1). Floating-point operations never throw an exception (they produce NaNs or infinities instead).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>div</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Div
    content.vb: Public Shared ReadOnly Div As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Div_Un
  commentId: F:System.Reflection.Emit.OpCodes.Div_Un
  id: Div_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Div_Un
  fullName: System.Reflection.Emit.OpCodes.Div_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Div_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 275
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Divides two unsigned integer values and pushes the result (<strong>int32</strong>) onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is divided by <em>value2</em>.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>div.un</strong> instruction computes <em>value1</em> divided by <em>value2</em>, both taken as unsigned integers, and pushes the <em>result</em> on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>div.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Div_Un
    content.vb: Public Shared ReadOnly Div_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Dup
  commentId: F:System.Reflection.Emit.OpCodes.Dup
  id: Dup
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Dup
  fullName: System.Reflection.Emit.OpCodes.Dup
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dup
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 276
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Copies the current topmost value on the evaluation stack, and then pushes the copy onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped off of the stack for duplication.</p>\n</li><li>\n<p>\n<em>value</em> is pushed back onto the stack.</p>\n</li><li>\n<p>A duplicate value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>dup</strong> instruction duplicates the top element of the stack, and leaves two identical values atop it.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>dup</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Dup
    content.vb: Public Shared ReadOnly Dup As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Endfilter
  commentId: F:System.Reflection.Emit.OpCodes.Endfilter
  id: Endfilter
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Endfilter
  fullName: System.Reflection.Emit.OpCodes.Endfilter
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Endfilter
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 277
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control from the <strong>filter</strong> clause of an exception back to the Common Language Infrastructure (CLI) exception handler.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack; <strong>endfilter</strong> is executed and control is transferred to the exception handler.</p>\n</li></ol>\n<p>\n<em>Value</em> (which must be of type <strong>int32</strong> and is one of a specific set of values) is returned from the filter clause. It should be one of: </p>\n<ul><li>\n<p>\n<strong>exception_continue_search</strong> (<em>value</em> = 0) to continue searching for an exception handler </p>\n</li><li>\n<p>\n<strong>exception_execute_handler</strong> (<em>value</em> = 1) to start the second phase of exception handling where finally blocks are run until the handler associated with this filter clause is located. Upon discovery, the handler is executed.</p>\n</li></ul>\n<p>Other integer values will produce unspecified results.</p>\n<p>The entry point of a filter, as shown in the method's exception table, must be the first instruction in the filter's code block. The <strong>endfilter</strong> instruction must be the last instruction in the filter's code block (hence there can only be one <strong>endfilter</strong> for any single filter block). After executing the <strong>endfilter</strong> instruction, control logically flows back to the CLI exception handling mechanism.</p>\n<p>Control cannot be transferred into a filter block except through the exception mechanism. Control cannot be transferred out of a filter block except through the use of a <strong>throw</strong> instruction or by executing the final <strong>endfilter</strong> instruction. You cannot embed a <strong>try</strong> block within a <strong>filter</strong> block. If an exception is thrown inside the <strong>filter</strong> block, it is intercepted and a value of 0 (<strong>exception_continue_search</strong>) is returned.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>endfilter</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Endfilter
    content.vb: Public Shared ReadOnly Endfilter As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Endfinally
  commentId: F:System.Reflection.Emit.OpCodes.Endfinally
  id: Endfinally
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Endfinally
  fullName: System.Reflection.Emit.OpCodes.Endfinally
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Endfinally
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 278
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Transfers control from the <strong>fault</strong> or <strong>finally</strong> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There are no stack transition behaviors for this instruction.</p>\n<p>\n<strong>Endfinally</strong> and <strong>endfault</strong> signal the end of the <strong>finally</strong> or <strong>fault</strong> clause so that stack unwinding can continue until the exception handler is invoked. The <strong>endfinally</strong> or <strong>endfault</strong> instruction transfers control back to the CLI exception mechanism. The mechanism then searches for the next <strong>finally</strong> clause in the chain if the protected block was exited with a leave instruction. If the protected block was exited with an exception, the CLI will search for the next <strong>finally</strong> or <strong>fault</strong>, or enter the exception handler chosen during the first pass of exception handling.</p>\n<p>An <strong>endfinally</strong> instruction might only appear lexically within a <strong>finally</strong> block. Unlike the <strong>endfilter</strong> instruction, there is no requirement that the block end with an <strong>endfinally</strong> instruction, and there can be as many <strong>endfinally</strong> instructions within the block as required. These same restrictions apply to the <strong>endfault</strong> instruction and the <strong>fault</strong> block.</p>\n<p>Control cannot be transferred into a <strong>finally</strong> (or <strong>fault</strong>) block except through the exception mechanism. Control cannot be transferred out of a <strong>finally</strong> (or <strong>fault</strong>) block except through the use of a <strong>throw</strong> instruction or executing the <strong>endfinally</strong> (or <strong>endfault</strong>) instruction. In particular, you cannot \"fall out\" of a <strong>finally</strong> (or <strong>fault</strong>) block or to execute a <xref href=\"System.Reflection.Emit.OpCodes.Ret\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Leave\" data-throw-if-not-resolved=\"false\"></xref> instruction within a <strong>finally</strong> (or <strong>fault</strong>) block.</p>\n<p>Note that the <strong>endfault</strong> and <strong>endfinally</strong> instructions are aliases - they correspond to the same opcode.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>endfinally</strong> (<strong>endfault</strong>) opcode, as well as the <strong>ILGenerator</strong> method <xref href=\"System.Reflection.Emit.ILGenerator.EndExceptionBlock\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li><li>\n<p>ILGenerator.EndExceptionBlock() </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Endfinally
    content.vb: Public Shared ReadOnly Endfinally As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Initblk
  commentId: F:System.Reflection.Emit.OpCodes.Initblk
  id: Initblk
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Initblk
  fullName: System.Reflection.Emit.OpCodes.Initblk
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Initblk
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 279
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Initializes a specified block of memory at a specific address to a given size and initial value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A starting address is pushed onto the stack.</p>\n</li><li>\n<p>An initialization value is pushed onto the stack.</p>\n</li><li>\n<p>The number of bytes to initialize is pushed onto the stack.</p>\n</li><li>\n<p>The number of bytes, the initialization value, and the starting address are popped from the stack, and the initialization is performed as per their values.</p>\n</li></ol>\n<p>The <strong>initblk</strong> instruction sets the number (<strong>unsigned int32</strong>) of bytes starting at the specified address (of type <strong>native int</strong>, <strong>&</strong>, or <strong>*</strong>) to the initialization value (of type <strong>unsigned int8</strong>). <strong>initblk</strong> assumes that the starting address is aligned to the natural size of the machine.</p>\n<p>The operation of the <strong>initblk</strong> instructions can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> may be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>initblk</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Initblk
    content.vb: Public Shared ReadOnly Initblk As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Initobj
  commentId: F:System.Reflection.Emit.OpCodes.Initobj
  id: Initobj
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Initobj
  fullName: System.Reflection.Emit.OpCodes.Initobj
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Initobj
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 280
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Initializes each field of the value type at a specified address to a null reference or a 0 of the appropriate primitive type.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address of the value type to initialize is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value type at the specified address is initialized as type <em>typeTok</em>.</p>\n</li></ol>\n<p>The <strong>initobj</strong> instruction initializes each field of the value type specified by the pushed address (of type <strong>native int</strong>, <strong>&</strong>, or <strong>*</strong>) to a null reference or a 0 of the appropriate primitive type. After this method is called, the instance is ready for a constructor method to be called. If <em>typeTok</em> is a reference type, this instruction has the same effect as <strong>ldnull</strong> followed by <strong>stind.ref</strong>.</p>\n<p>Unlike <xref href=\"System.Reflection.Emit.OpCodes.Newobj\" data-throw-if-not-resolved=\"false\"></xref>, <strong>initobj</strong> does not call the constructor method. <strong>Initobj</strong> is intended for initializing value types, while <strong>newobj</strong> is used to allocate and initialize objects.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>initobj</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Initobj
    content.vb: Public Shared ReadOnly Initobj As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Isinst
  commentId: F:System.Reflection.Emit.OpCodes.Isinst
  id: Isinst
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Isinst
  fullName: System.Reflection.Emit.OpCodes.Isinst
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Isinst
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 281
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Tests whether an object reference (type <strong>O</strong>) is an instance of a particular class.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack and tested to see if it is an instance of the class passed in <em>class</em>.</p>\n</li><li>\n<p>The result (either an object reference or a null reference) is pushed onto the stack.</p>\n</li></ol>\n<p>\n<em>Class</em> is a metadata token indicating the desired class. If the class of the object on the top of the stack implements <em>class</em> (if <em>class</em> is an interface) or is a derived class of <em>class</em> (if <em>class</em> is a regular class) then it is cast to type <em>class</em> and the result is pushed on the stack, exactly as though <xref href=\"System.Reflection.Emit.OpCodes.Castclass\" data-throw-if-not-resolved=\"false\"></xref> had been called. Otherwise, a null reference is pushed on the stack. If the object reference itself is a null reference, then <strong>isinst</strong> likewise returns a null reference.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>isinst</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Isinst
    content.vb: Public Shared ReadOnly Isinst As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Jmp
  commentId: F:System.Reflection.Emit.OpCodes.Jmp
  id: Jmp
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Jmp
  fullName: System.Reflection.Emit.OpCodes.Jmp
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Jmp
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 282
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Exits current method and jumps to specified method.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There are no stack transition behaviors for this instruction.</p>\n<p>The <strong>jmp</strong> (jump) instruction transfers control to the method specified by <em>method</em>, which is a metadata token for a method reference. The current arguments are transferred to the destination method.</p>\n<p>The evaluation stack must be empty when this instruction is executed. The calling convention, number and type of arguments at the destination address must match that of the current method.</p>\n<p>The <strong>jmp</strong> instruction cannot be used to transferred control out of a <strong>try</strong>, <strong>filter</strong>, <strong>catch</strong>, or <strong>finally</strong> block.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>jmp</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Jmp
    content.vb: Public Shared ReadOnly Jmp As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg
  id: Ldarg
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg
  fullName: System.Reflection.Emit.OpCodes.Ldarg
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 283
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads an argument (referenced by a specified index value) onto the stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at <em>index</em> is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg</strong> instruction pushes the argument indexed at <em>index</em>, where arguments are indexed from 0 onwards, onto the evaluation stack. The <strong>ldarg</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>For procedures that take a variable-length argument list, the <strong>ldarg</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref href=\"System.Reflection.Emit.OpCodes.Arglist\" data-throw-if-not-resolved=\"false\"></xref> instruction for more details).</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg
    content.vb: Public Shared ReadOnly Ldarg As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg_0
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_0
  id: Ldarg_0
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg_0
  fullName: System.Reflection.Emit.OpCodes.Ldarg_0
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg_0
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 284
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the argument at index 0 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at index 0 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg.0</strong> instruction is an efficient encoding for loading the argument value at index 0.</p>\n<p>The <strong>ldarg.0</strong> instruction pushes the argument indexed at 0 onto the evaluation stack. The <strong>ldarg.0</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg.0</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg_0
    content.vb: Public Shared ReadOnly Ldarg_0 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg_1
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_1
  id: Ldarg_1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg_1
  fullName: System.Reflection.Emit.OpCodes.Ldarg_1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg_1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 285
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the argument at index 1 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at index 1 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg.1</strong> instruction is an efficient encoding for loading the argument value at index 1.</p>\n<p>The <strong>ldarg.1</strong> instruction pushes the argument indexed at 1 onto the evaluation stack. The <strong>ldarg.1</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg.1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg_1
    content.vb: Public Shared ReadOnly Ldarg_1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg_2
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_2
  id: Ldarg_2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg_2
  fullName: System.Reflection.Emit.OpCodes.Ldarg_2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg_2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 286
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the argument at index 2 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at index 2 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg.2</strong> instruction is an efficient encoding for loading the argument value at index 2.</p>\n<p>The <strong>ldarg.2</strong> instruction pushes the argument indexed at 2 onto the evaluation stack. The <strong>ldarg.2</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg.2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg_2
    content.vb: Public Shared ReadOnly Ldarg_2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg_3
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_3
  id: Ldarg_3
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg_3
  fullName: System.Reflection.Emit.OpCodes.Ldarg_3
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg_3
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 287
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the argument at index 3 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at index 3 is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg.3</strong> instruction is an efficient encoding for loading the argument value at index 3.</p>\n<p>The <strong>ldarg.3</strong> instruction pushes the argument indexed at 3 onto the evaluation stack. The <strong>ldarg.3</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg.3</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg_3
    content.vb: Public Shared ReadOnly Ldarg_3 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarg_S
  commentId: F:System.Reflection.Emit.OpCodes.Ldarg_S
  id: Ldarg_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarg_S
  fullName: System.Reflection.Emit.OpCodes.Ldarg_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarg_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 288
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the argument (referenced by a specified short form index) onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The argument value at <em>index</em> is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarg.s</strong> instruction is an efficient encoding for loading arguments indexed from 4 through 255.</p>\n<p>The <strong>ldarg.s</strong> instruction pushes the argument indexed at <em>index</em>, where arguments are indexed from 0 onwards, onto the evaluation stack. The <strong>ldarg.s</strong> instruction can be used to load a value type or a primitive value onto the stack by copying it from an incoming argument. The type of the argument value is the same as the type of the argument, as specified by the current method's signature.</p>\n<p>For procedures that take a variable-length argument list, the <strong>ldarg.s</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature (see the <xref href=\"System.Reflection.Emit.OpCodes.Arglist\" data-throw-if-not-resolved=\"false\"></xref> instruction for more details).</p>\n<p>Arguments that hold an integer value smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarg.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarg_S
    content.vb: Public Shared ReadOnly Ldarg_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarga
  commentId: F:System.Reflection.Emit.OpCodes.Ldarga
  id: Ldarga
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarga
  fullName: System.Reflection.Emit.OpCodes.Ldarga
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarga
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 289
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Load an argument address onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address <em>addr</em> of the argument indexed by <em>index</em> is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldarga</strong> instruction fetches the address (of type <strong>*</strong>) of the argument indexed by <em>index</em>, where arguments are indexed from 0 onwards. The address <em>addr</em> is always aligned to a natural boundary on the target machine.</p>\n<p>For procedures that take a variable-length argument list, the <strong>ldarga</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</p>\n<p>\n<strong>ldarga</strong> is used for by-ref parameter passing. For other cases, <xref href=\"System.Reflection.Emit.OpCodes.Ldarg\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Starg\" data-throw-if-not-resolved=\"false\"></xref> should be used.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarga</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarga
    content.vb: Public Shared ReadOnly Ldarga As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldarga_S
  commentId: F:System.Reflection.Emit.OpCodes.Ldarga_S
  id: Ldarga_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldarga_S
  fullName: System.Reflection.Emit.OpCodes.Ldarga_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldarga_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 290
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Load an argument address, in short form, onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address <em>addr</em> of the argument indexed by <em>index</em> is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldarga.s</strong> (the short form of <strong>ldarga</strong>) should be used for argument numbers 0 through 255, and is a more efficient encoding.</p>\n<p>The <strong>ldarga.s</strong> instruction fetches the address (of type<strong>*</strong>) of the argument indexed by <em>index</em>, where arguments are indexed from 0 onwards. The address <em>addr</em> is always aligned to a natural boundary on the target machine.</p>\n<p>For procedures that take a variable-length argument list, the <strong>ldarga.s</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</p>\n<p>\n<strong>ldarga.s</strong> is used for by-ref parameter passing. For other cases, <xref href=\"System.Reflection.Emit.OpCodes.Ldarg_S\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Starg_S\" data-throw-if-not-resolved=\"false\"></xref> should be used.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldarga.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldarga_S
    content.vb: Public Shared ReadOnly Ldarga_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4
  id: Ldc_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 291
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a supplied value of type <strong>int32</strong> onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value <em>num</em> is pushed onto the stack.</p>\n</li></ol>\n<p>Note that there are special short (and hence more efficient) encodings for the integers -128 through 127, and especially short encodings for -1 through 8. All short encodings push 4 byte integers on the stack. Longer encodings are used for 8 byte integers and 4 and 8 byte floating-point numbers, as well as 4-byte values that do not fit in the short forms. There are three ways to push an 8 byte integer constant onto the stack </p>\n<p>1. Use the <xref href=\"System.Reflection.Emit.OpCodes.Ldc_I8\" data-throw-if-not-resolved=\"false\"></xref> instruction for constants that must be expressed in more than 32 bits.</p>\n<p>2. Use the <xref href=\"System.Reflection.Emit.OpCodes.Ldc_I4\" data-throw-if-not-resolved=\"false\"></xref> instruction followed by a <xref href=\"System.Reflection.Emit.OpCodes.Conv_I8\" data-throw-if-not-resolved=\"false\"></xref> for constants that require 9 to 32 bits.</p>\n<p>3. Use a short form instruction followed by a <xref href=\"System.Reflection.Emit.OpCodes.Conv_I8\" data-throw-if-not-resolved=\"false\"></xref> for constants that can be expressed in 8 or fewer bits.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, int) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4
    content.vb: Public Shared ReadOnly Ldc_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_0
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_0
  id: Ldc_I4_0
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_0
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_0
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_0
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 292
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 0 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 0 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.0</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_0
    content.vb: Public Shared ReadOnly Ldc_I4_0 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_1
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_1
  id: Ldc_I4_1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_1
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 293
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 1 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 1 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_1
    content.vb: Public Shared ReadOnly Ldc_I4_1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_2
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_2
  id: Ldc_I4_2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_2
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 294
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 2 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 2 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_2
    content.vb: Public Shared ReadOnly Ldc_I4_2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_3
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_3
  id: Ldc_I4_3
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_3
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_3
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_3
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 295
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 3 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 3 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.3</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_3
    content.vb: Public Shared ReadOnly Ldc_I4_3 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_4
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_4
  id: Ldc_I4_4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_4
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 296
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 4 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 4 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_4
    content.vb: Public Shared ReadOnly Ldc_I4_4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_5
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_5
  id: Ldc_I4_5
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_5
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_5
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_5
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 297
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 5 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 5 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.5</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_5
    content.vb: Public Shared ReadOnly Ldc_I4_5 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_6
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_6
  id: Ldc_I4_6
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_6
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_6
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_6
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 298
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 6 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 6 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.6</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_6
    content.vb: Public Shared ReadOnly Ldc_I4_6 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_7
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_7
  id: Ldc_I4_7
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_7
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_7
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_7
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 299
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 7 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 7 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.7</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_7
    content.vb: Public Shared ReadOnly Ldc_I4_7 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_8
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_8
  id: Ldc_I4_8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_8
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 300
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of 8 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value 8 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_8
    content.vb: Public Shared ReadOnly Ldc_I4_8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_M1
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_M1
  id: Ldc_I4_M1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_M1
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_M1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_M1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 301
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the integer value of -1 onto the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value -1 is pushed onto the stack.</p>\n</li></ol>\n<p>This is a special short encoding for the push of the integer value 0. All special short encodings push 4 byte integers on the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.m1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_M1
    content.vb: Public Shared ReadOnly Ldc_I4_M1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I4_S
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I4_S
  id: Ldc_I4_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I4_S
  fullName: System.Reflection.Emit.OpCodes.Ldc_I4_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I4_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 302
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the supplied <strong>int8</strong> value onto the evaluation stack as an <strong>int32</strong>, short form.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value <em>num</em> is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldc.i4.s</strong> is a more efficient encoding for pushing the integers from -128 to 127 onto the evaluation stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i4.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I4_S
    content.vb: Public Shared ReadOnly Ldc_I4_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_I8
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_I8
  id: Ldc_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_I8
  fullName: System.Reflection.Emit.OpCodes.Ldc_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 303
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a supplied value of type <strong>int64</strong> onto the evaluation stack as an <strong>int64</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value <em>num</em> is pushed onto the stack.</p>\n</li></ol>\n<p>This encoding pushes an <strong>int64</strong> value onto the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, long) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_I8
    content.vb: Public Shared ReadOnly Ldc_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_R4
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_R4
  id: Ldc_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_R4
  fullName: System.Reflection.Emit.OpCodes.Ldc_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 304
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a supplied value of type <strong>float32</strong> onto the evaluation stack as type <strong>F</strong> (float).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value <em>num</em> is pushed onto the stack.</p>\n</li></ol>\n<p>This encoding pushes a <strong>float32</strong> value onto the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, single) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_R4
    content.vb: Public Shared ReadOnly Ldc_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldc_R8
  commentId: F:System.Reflection.Emit.OpCodes.Ldc_R8
  id: Ldc_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldc_R8
  fullName: System.Reflection.Emit.OpCodes.Ldc_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldc_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 305
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a supplied value of type <strong>float64</strong> onto the evaluation stack as type <strong>F</strong> (float).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value <em>num</em> is pushed onto the stack.</p>\n</li></ol>\n<p>This encoding pushes a <strong>float64</strong> value onto the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldc.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, double) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldc_R8
    content.vb: Public Shared ReadOnly Ldc_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem
  id: Ldelem
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem
  fullName: System.Reflection.Emit.OpCodes.Ldelem
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 306
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element at a specified array index onto the top of the evaluation stack as the type specified in the instruction. </p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects, and hence represented by a value of type <strong>O</strong>.</p>\n<p>The type of the return value is specified by the token <em>typeTok</em> in the instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the upper bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem
    content.vb: Public Shared ReadOnly Ldelem As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_I
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I
  id: Ldelem_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_I
  fullName: System.Reflection.Emit.OpCodes.Ldelem_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 307
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>native int</strong> at a specified array index onto the top of the evaluation stack as a <strong>native int</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.i</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.i</strong> is <strong>native int</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_I
    content.vb: Public Shared ReadOnly Ldelem_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_I1
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I1
  id: Ldelem_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_I1
  fullName: System.Reflection.Emit.OpCodes.Ldelem_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 308
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>int8</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.i1</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.i1</strong> is <strong>int8</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_I1
    content.vb: Public Shared ReadOnly Ldelem_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_I2
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I2
  id: Ldelem_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_I2
  fullName: System.Reflection.Emit.OpCodes.Ldelem_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 309
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>int16</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.i2</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.i2</strong> is <strong>int16</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_I2
    content.vb: Public Shared ReadOnly Ldelem_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_I4
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I4
  id: Ldelem_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_I4
  fullName: System.Reflection.Emit.OpCodes.Ldelem_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 310
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>int32</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.i4</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.i4</strong> is <strong>int32</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_I4
    content.vb: Public Shared ReadOnly Ldelem_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_I8
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_I8
  id: Ldelem_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_I8
  fullName: System.Reflection.Emit.OpCodes.Ldelem_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 311
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>int64</strong> at a specified array index onto the top of the evaluation stack as an <strong>int64</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.i8</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.i8</strong> is <strong>int64</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_I8
    content.vb: Public Shared ReadOnly Ldelem_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_R4
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_R4
  id: Ldelem_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_R4
  fullName: System.Reflection.Emit.OpCodes.Ldelem_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 312
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>float32</strong> at a specified array index onto the top of the evaluation stack as type <strong>F</strong> (float).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.r4</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.r4</strong> is <strong>float32</strong>.</p>\n<p>Floating-point values are converted to type <strong>F</strong> when loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_R4
    content.vb: Public Shared ReadOnly Ldelem_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_R8
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_R8
  id: Ldelem_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_R8
  fullName: System.Reflection.Emit.OpCodes.Ldelem_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 313
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>float64</strong> at a specified array index onto the top of the evaluation stack as type <strong>F</strong> (float).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary:</p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.r8</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.r8</strong> is <strong>float64</strong>.</p>\n<p>Floating-point values are converted to type <strong>F</strong> when loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_R8
    content.vb: Public Shared ReadOnly Ldelem_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_Ref
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_Ref
  id: Ldelem_Ref
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_Ref
  fullName: System.Reflection.Emit.OpCodes.Ldelem_Ref
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_Ref
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 314
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element containing an object reference at a specified array index onto the top of the evaluation stack as type <strong>O</strong> (object reference).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.ref</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.ref</strong> is type <strong>O</strong> (object reference).</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.ref</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_Ref
    content.vb: Public Shared ReadOnly Ldelem_Ref As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_U1
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U1
  id: Ldelem_U1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_U1
  fullName: System.Reflection.Emit.OpCodes.Ldelem_U1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_U1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 315
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>unsigned int8</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.u1</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.u1</strong> is <strong>int8</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.u1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_U1
    content.vb: Public Shared ReadOnly Ldelem_U1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_U2
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U2
  id: Ldelem_U2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_U2
  fullName: System.Reflection.Emit.OpCodes.Ldelem_U2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_U2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 316
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>unsigned int16</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.u2</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.u2</strong> is <strong>int16</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.u2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_U2
    content.vb: Public Shared ReadOnly Ldelem_U2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelem_U4
  commentId: F:System.Reflection.Emit.OpCodes.Ldelem_U4
  id: Ldelem_U4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelem_U4
  fullName: System.Reflection.Emit.OpCodes.Ldelem_U4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelem_U4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 317
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the element with type <strong>unsigned int32</strong> at a specified array index onto the top of the evaluation stack as an <strong>int32</strong>.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the value stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelem.u4</strong> instruction loads the value of the element with index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>.</p>\n<p>The return value for <strong>ldelem.u4</strong> is <strong>int32</strong>.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if array does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelem.u4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelem_U4
    content.vb: Public Shared ReadOnly Ldelem_U4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldelema
  commentId: F:System.Reflection.Emit.OpCodes.Ldelema
  id: Ldelema
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldelema
  fullName: System.Reflection.Emit.OpCodes.Ldelema
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldelema
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 318
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the address of the array element at a specified array index onto the top of the evaluation stack as type <strong>&</strong> (managed pointer).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>An index value <em>index</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>index</em> and <em>array</em> are popped from the stack; the address stored at position <em>index</em> in <em>array</em> is looked up.</p>\n</li><li>\n<p>The address is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldelema</strong> is used to retrieve the address of an object at a particular index in an array of objects (of type <em>class</em>). The <strong>ldelema</strong> instruction loads the address of the value at index <em>index</em> (type <strong>native int</strong>) in the zero-based one-dimensional array <em>array</em> and places it on the top of the stack. Arrays are objects and hence represented by a value of type <strong>O</strong>. The value must be of type <em>class</em> passed with the instruction.</p>\n<p>The return value for <strong>ldelema</strong> is a managed pointer (type <strong>&</strong>).</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldelema</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldelema
    content.vb: Public Shared ReadOnly Ldelema As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldfld
  commentId: F:System.Reflection.Emit.OpCodes.Ldfld
  id: Ldfld
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldfld
  fullName: System.Reflection.Emit.OpCodes.Ldfld
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldfld
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 319
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Finds the value of a field in the object whose reference is currently on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference (or pointer) is pushed onto the stack.</p>\n</li><li>\n<p>The object reference (or pointer) is popped from the stack; the value of the specified field in the object is found.</p>\n</li><li>\n<p>The value stored in the field is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldfld</strong> instruction pushes the value of a field located in an object onto the stack. The object must be on the stack as an object reference (type <strong>O</strong>), a managed pointer (type <strong>&</strong>), an unmanaged pointer (type <strong>native int</strong>), a transient pointer (type <strong>*</strong>), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member. The return type is the same as the one associated with the field. The field may be either an instance field (in which case the object must not be a null reference) or a static field.</p>\n<p>The <strong>ldfld</strong> instruction can be preceded by either or both of the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> prefixes.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object is null and the field is not static.</p>\n<p>\n<xref href=\"System.MissingFieldException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldfld</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldfld
    content.vb: Public Shared ReadOnly Ldfld As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldflda
  commentId: F:System.Reflection.Emit.OpCodes.Ldflda
  id: Ldflda
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldflda
  fullName: System.Reflection.Emit.OpCodes.Ldflda
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldflda
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 320
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Finds the address of a field in the object whose reference is currently on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference (or pointer) is pushed onto the stack.</p>\n</li><li>\n<p>The object reference (or pointer) is popped from the stack; the address of the specified field in the object is found.</p>\n</li><li>\n<p>The address of the specified field is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldflda</strong> instruction pushes the address of a field located in an object onto the stack. The object must be on the stack as an object reference (type <strong>O</strong>), a managed pointer (type <strong>&</strong>), an unmanaged pointer (type <strong>native int</strong>), a transient pointer (type <strong>*</strong>), or an instance of a value type. The use of an unmanaged pointer is not permitted in verifiable code. The object's field is specified by a metadata token that must refer to a field member.</p>\n<p>The value returned by <strong>ldflda</strong> is a managed pointer (type <strong>&</strong>) unless the object is pushed onto the stack as an unmanaged pointer, in which case the return address is also an unmanaged pointer (type <strong>native int</strong>).</p>\n<p>The <strong>ldflda</strong> instruction can be preceded by either or both of the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> prefixes.</p>\n<p>\n<xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object is not within the application domain from which it is being accessed. The address of a field that is not inside the accessing application domain cannot be loaded.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object is null and the field is not static.</p>\n<p>\n<xref href=\"System.MissingFieldException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the specified field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldflda</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldflda
    content.vb: Public Shared ReadOnly Ldflda As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldftn
  commentId: F:System.Reflection.Emit.OpCodes.Ldftn
  id: Ldftn
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldftn
  fullName: System.Reflection.Emit.OpCodes.Ldftn
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldftn
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 321
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes an unmanaged pointer (type <strong>native int</strong>) to the native code implementing a specific method onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The unmanaged pointer to a specific method is pushed onto the stack.</p>\n</li></ol>\n<p>The specific method (<em>method</em>) can be called using the <xref href=\"System.Reflection.Emit.OpCodes.Calli\" data-throw-if-not-resolved=\"false\"></xref> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</p>\n<p>The value returned points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldftn</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldftn
    content.vb: Public Shared ReadOnly Ldftn As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_I
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I
  id: Ldind_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_I
  fullName: System.Reflection.Emit.OpCodes.Ldind_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 322
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>native int</strong> as a <strong>native int</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.i</strong> instruction indirectly loads a <strong>native int</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as a <strong>native int</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_I
    content.vb: Public Shared ReadOnly Ldind_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_I1
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I1
  id: Ldind_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_I1
  fullName: System.Reflection.Emit.OpCodes.Ldind_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 323
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>int8</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack..</p>\n</li></ol>\n<p>The <strong>ldind.i1</strong> instruction indirectly loads an <strong>int8</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_I1
    content.vb: Public Shared ReadOnly Ldind_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_I2
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I2
  id: Ldind_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_I2
  fullName: System.Reflection.Emit.OpCodes.Ldind_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 324
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>int16</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.i2</strong> instruction indirectly loads an <strong>int16</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref>and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_I2
    content.vb: Public Shared ReadOnly Ldind_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_I4
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I4
  id: Ldind_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_I4
  fullName: System.Reflection.Emit.OpCodes.Ldind_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 325
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>int32</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.i4</strong> instruction indirectly loads an <strong>int32</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_I4
    content.vb: Public Shared ReadOnly Ldind_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_I8
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_I8
  id: Ldind_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_I8
  fullName: System.Reflection.Emit.OpCodes.Ldind_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 326
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>int64</strong> as an <strong>int64</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.i8</strong> instruction indirectly loads an <strong>int64</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int64</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_I8
    content.vb: Public Shared ReadOnly Ldind_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_R4
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_R4
  id: Ldind_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_R4
  fullName: System.Reflection.Emit.OpCodes.Ldind_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 327
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>float32</strong> as a type <strong>F</strong> (float) onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.r4</strong> instruction indirectly loads a <strong>float32</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as a type <strong>F</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_R4
    content.vb: Public Shared ReadOnly Ldind_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_R8
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_R8
  id: Ldind_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_R8
  fullName: System.Reflection.Emit.OpCodes.Ldind_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 328
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>float64</strong> as a type <strong>F</strong> (float) onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.r8</strong> instruction indirectly loads a <strong>float64</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as a <strong>float64</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_R8
    content.vb: Public Shared ReadOnly Ldind_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_Ref
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_Ref
  id: Ldind_Ref
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_Ref
  fullName: System.Reflection.Emit.OpCodes.Ldind_Ref
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_Ref
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 329
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads an object reference as a type <strong>O</strong> (object reference) onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the object reference located at the address is fetched.</p>\n</li><li>\n<p>The fetched reference is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.ref</strong> instruction indirectly loads the object reference the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as type <strong>O</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.ref</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_Ref
    content.vb: Public Shared ReadOnly Ldind_Ref As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_U1
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U1
  id: Ldind_U1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_U1
  fullName: System.Reflection.Emit.OpCodes.Ldind_U1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_U1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 330
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>unsigned int8</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.u1</strong> instruction indirectly loads an <strong>unsigned int8</strong> value from the specified address (of type<strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.u1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_U1
    content.vb: Public Shared ReadOnly Ldind_U1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_U2
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U2
  id: Ldind_U2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_U2
  fullName: System.Reflection.Emit.OpCodes.Ldind_U2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_U2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 331
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>unsigned int16</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.u2</strong> instruction indirectly loads an <strong>unsigned int16</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.u2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_U2
    content.vb: Public Shared ReadOnly Ldind_U2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldind_U4
  commentId: F:System.Reflection.Emit.OpCodes.Ldind_U4
  id: Ldind_U4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldind_U4
  fullName: System.Reflection.Emit.OpCodes.Ldind_U4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldind_U4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 332
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads a value of type <strong>unsigned int32</strong> as an <strong>int32</strong> onto the evaluation stack indirectly.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack; the value located at the address is fetched.</p>\n</li><li>\n<p>The fetched value is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldind.u4</strong> instruction indirectly loads an <strong>unsigned int32</strong> value from the specified address (of type <strong>native int</strong>, <strong>&</strong>, or *) onto the stack as an <strong>int32</strong>.</p>\n<p>All of the <strong>ldind</strong> instructions are shortcuts for a <xref href=\"System.Reflection.Emit.OpCodes.Ldobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that specifies the corresponding built-in value class.</p>\n<p>Note that integer values of less than 4 bytes are extended to <strong>int32</strong> (not <strong>native int</strong>) when they are loaded onto the evaluation stack. Floating-point values are converted to <strong>F</strong> type when loaded onto the evaluation stack.</p>\n<p>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <strong>ldind</strong> instructions are used in a manner consistent with the type of the pointer.</p>\n<p>The address initially pushed onto the stack must be aligned to the natural size of objects on the machine or a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can occur (see the <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction for preventative measures). The results of all MSIL instructions that return addresses (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloca\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldarga\" data-throw-if-not-resolved=\"false\"></xref>) are safely aligned. For datatypes larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> can be thrown if an invalid address is detected.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldind.u4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldind_U4
    content.vb: Public Shared ReadOnly Ldind_U4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldlen
  commentId: F:System.Reflection.Emit.OpCodes.Ldlen
  id: Ldlen
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldlen
  fullName: System.Reflection.Emit.OpCodes.Ldlen
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldlen
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 333
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the number of elements of a zero-based, one-dimensional array onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array is pushed onto the stack.</p>\n</li><li>\n<p>The array reference is popped from the stack and the length is computed.</p>\n</li><li>\n<p>The length is pushed onto the stack.</p>\n</li></ol>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The length is returned as a <strong>natural unsigned int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the array reference is a null reference.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldlen</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldlen
    content.vb: Public Shared ReadOnly Ldlen As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc
  id: Ldloc
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc
  fullName: System.Reflection.Emit.OpCodes.Ldloc
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 334
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at a specific index onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the specified index is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldloc</strong> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method only if the initialize flag on the method is true. There are 65,535 (2^16-1) local variables possible (0-65,534). Index 65,535 is not valid since likely implementations will use a 2-byte integer to track both a local's index, along with the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</p>\n<p>The <strong>ldloc.0</strong>, <strong>ldloc.1</strong>, <strong>ldloc.2</strong>, and <strong>ldloc.3</strong> instructions provide an efficient encoding for accessing the first four local variables.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>ldloc</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, LocalBuilder) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc
    content.vb: Public Shared ReadOnly Ldloc As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc_0
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_0
  id: Ldloc_0
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc_0
  fullName: System.Reflection.Emit.OpCodes.Ldloc_0
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc_0
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 335
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at index 0 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the index 0 is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldloc.0</strong> is an especially efficient encoding for <xref href=\"System.Reflection.Emit.OpCodes.Ldloc\" data-throw-if-not-resolved=\"false\"></xref>, allowing access to the local variable at index 0.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloc.0</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc_0
    content.vb: Public Shared ReadOnly Ldloc_0 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc_1
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_1
  id: Ldloc_1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc_1
  fullName: System.Reflection.Emit.OpCodes.Ldloc_1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc_1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 336
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at index 1 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the index 1 is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldloc.1</strong> is an especially efficient encoding for <xref href=\"System.Reflection.Emit.OpCodes.Ldloc\" data-throw-if-not-resolved=\"false\"></xref>, allowing access to the local variable at index 1.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloc.1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc_1
    content.vb: Public Shared ReadOnly Ldloc_1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc_2
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_2
  id: Ldloc_2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc_2
  fullName: System.Reflection.Emit.OpCodes.Ldloc_2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc_2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 337
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at index 2 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the index 2 is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldloc.2</strong> is an especially efficient encoding for <xref href=\"System.Reflection.Emit.OpCodes.Ldloc\" data-throw-if-not-resolved=\"false\"></xref>, allowing access to the local variable at index 2.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloc.2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc_2
    content.vb: Public Shared ReadOnly Ldloc_2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc_3
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_3
  id: Ldloc_3
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc_3
  fullName: System.Reflection.Emit.OpCodes.Ldloc_3
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc_3
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 338
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at index 3 onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the index 3 is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldloc.3</strong> is an especially efficient encoding for <xref href=\"System.Reflection.Emit.OpCodes.Ldloc\" data-throw-if-not-resolved=\"false\"></xref>, allowing access to the local variable at index 3.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloc.3</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc_3
    content.vb: Public Shared ReadOnly Ldloc_3 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloc_S
  commentId: F:System.Reflection.Emit.OpCodes.Ldloc_S
  id: Ldloc_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloc_S
  fullName: System.Reflection.Emit.OpCodes.Ldloc_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloc_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 339
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the local variable at a specific index onto the evaluation stack, short form.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The local variable value at the specified index is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldloc.s</strong> instruction pushes the contents of the local variable number at the passed index onto the evaluation stack, where the local variables are numbered 0 onwards. Local variables are initialized to 0 before entering the method if the initialize flag on the method is true. There are 256 (2^8) local variables possible (0-255) in the short form, which is a more efficient encoding than <strong>ldloc</strong>.</p>\n<p>The type of the value is the same as the type of the local variable, which is specified in the method header. See Partition I. Local variables that are smaller than 4 bytes long are expanded to type <strong>int32</strong> when they are loaded onto the stack. Floating-point values are expanded to their native size (type <strong>F</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>ldloc.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, LocalBuilder) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloc_S
    content.vb: Public Shared ReadOnly Ldloc_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloca
  commentId: F:System.Reflection.Emit.OpCodes.Ldloca
  id: Ldloca
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloca
  fullName: System.Reflection.Emit.OpCodes.Ldloca
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloca
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 340
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the address of the local variable at a specific index onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address stored in the local variable at the specified index is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldloca</strong> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref href=\"System.Reflection.Emit.OpCodes.Ldind_I\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Stind_I\" data-throw-if-not-resolved=\"false\"></xref>. The result is a transient pointer (type <strong>*</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloca</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloca
    content.vb: Public Shared ReadOnly Ldloca As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldloca_S
  commentId: F:System.Reflection.Emit.OpCodes.Ldloca_S
  id: Ldloca_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldloca_S
  fullName: System.Reflection.Emit.OpCodes.Ldloca_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldloca_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 341
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Loads the address of the local variable at a specific index onto the evaluation stack, short form.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address stored in the local variable at the specified index is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldloca.s</strong> instruction pushes the address of the local variable number at the passed index onto the stack, where local variables are numbered 0 onwards. The value pushed on the stack is already aligned correctly for use with instructions like <xref href=\"System.Reflection.Emit.OpCodes.Ldind_I\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Stind_I\" data-throw-if-not-resolved=\"false\"></xref>. The result is a transient pointer (type <strong>*</strong>).</p>\n<p>The <strong>ldloca.s</strong> instruction provides an efficient encoding for use with the local variables 0 through 255.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldloca.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldloca_S
    content.vb: Public Shared ReadOnly Ldloca_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldnull
  commentId: F:System.Reflection.Emit.OpCodes.Ldnull
  id: Ldnull
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldnull
  fullName: System.Reflection.Emit.OpCodes.Ldnull
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldnull
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 342
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a null reference (type <strong>O</strong>) onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A null object reference is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>ldnull</strong> pushes a null reference (type <strong>O</strong>) on the stack. This is used to initialize locations before they are populated with data, or when they become deprecated.</p>\n<p>\n<strong>ldnull</strong> provides a null reference that is size-independent.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldnull</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldnull
    content.vb: Public Shared ReadOnly Ldnull As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldobj
  commentId: F:System.Reflection.Emit.OpCodes.Ldobj
  id: Ldobj
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldobj
  fullName: System.Reflection.Emit.OpCodes.Ldobj
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldobj
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 343
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Copies the value type object pointed to by an address to the top of the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address of a value type object is pushed onto the stack.</p>\n</li><li>\n<p>The address is popped from the stack and the instance at that particular address is looked up.</p>\n</li><li>\n<p>The value of the object stored at that address is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldobj</strong> instruction is used to pass a value type as a parameter.</p>\n<p>The <strong>ldobj</strong> instruction copies the value pointed to by <em>addrOfValObj</em> (of type <strong>&</strong>, <strong>*</strong>, or <strong>native int</strong>) to the top of the stack. The number of bytes copied depends on the size of the class (as specified by the <em>class</em> parameter). The <em>class</em> parameter is a metadata token representing the value type.</p>\n<p>The operation of the <strong>ldobj</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if class cannot be found. This is typically detected when the Microsoft Intermediate Language (MSIL) instruction is converted to native code rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldobj</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldobj
    content.vb: Public Shared ReadOnly Ldobj As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldsfld
  commentId: F:System.Reflection.Emit.OpCodes.Ldsfld
  id: Ldsfld
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldsfld
  fullName: System.Reflection.Emit.OpCodes.Ldsfld
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldsfld
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 344
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the value of a static field onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value of the specific field is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldsfld</strong> instruction pushes the value of a static (shared among all instances of a class) field on the stack. The return type is that associated with the passed metadata token <em>field</em>.</p>\n<p>The <strong>ldsfld</strong> instruction can have a <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> prefix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldsfld</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldsfld
    content.vb: Public Shared ReadOnly Ldsfld As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldsflda
  commentId: F:System.Reflection.Emit.OpCodes.Ldsflda
  id: Ldsflda
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldsflda
  fullName: System.Reflection.Emit.OpCodes.Ldsflda
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldsflda
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 345
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the address of a static field onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The address of a specific field is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldsflda</strong> instruction pushes the address of a static (shared among all instances of a class) field on the stack. The address may be represented as a transient pointer (type <strong>*</strong>) if the metadata token <em>field</em> refers to a type whose memory is managed. Otherwise, it corresponds to an unmanaged pointer (type <strong>native int</strong>). Note that <em>field</em> may be a static global with an assigned relative virtual address (the offset of the field from the base address at which its containing PE file is loaded into memory) where the memory is unmanaged.</p>\n<p>The <strong>ldsflda</strong> instruction can have a <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> prefix.</p>\n<p>\n<xref href=\"System.MissingFieldException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldsflda</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldsflda
    content.vb: Public Shared ReadOnly Ldsflda As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldstr
  commentId: F:System.Reflection.Emit.OpCodes.Ldstr
  id: Ldstr
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldstr
  fullName: System.Reflection.Emit.OpCodes.Ldstr
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldstr
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 346
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a new object reference to a string literal stored in the metadata.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to a string is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldstr</strong> instruction pushes an object reference (type <strong>O</strong>) to a new string object representing the specific string literal stored in the metadata. The <strong>ldstr</strong> instruction allocates the requisite amount of memory and performs any format conversion required to convert the string literal from the form used in the file to the string format required at runtime.</p>\n<p>The Common Language Infrastructure (CLI) guarantees that the result of two <strong>ldstr</strong> instructions referring to two metadata tokens that have the same sequence of characters return precisely the same string object (a process known as \"string interning\").</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldstr</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, string) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldstr
    content.vb: Public Shared ReadOnly Ldstr As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldtoken
  commentId: F:System.Reflection.Emit.OpCodes.Ldtoken
  id: Ldtoken
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldtoken
  fullName: System.Reflection.Emit.OpCodes.Ldtoken
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldtoken
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 347
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts a metadata token to its runtime representation, pushing it onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The passed token is converted to a <strong>RuntimeHandle</strong> and pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>ldtoken</strong> instruction pushes a <strong>RuntimeHandle</strong> for the specified metadata token. A <strong>RuntimeHandle</strong> can be a <strong>fieldref/fielddef</strong>, a <strong>methodref/methoddef</strong>, or a <strong>typeref/typedef</strong>.</p>\n<p>The value pushed on the stack can be used in calls to <strong>Reflection</strong> methods in the system class library.</p>\n<p>For information on runtime handles, see the following classes: <xref href=\"System.RuntimeFieldHandle\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.RuntimeTypeHandle\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.RuntimeMethodHandle\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>ldtoken</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldtoken
    content.vb: Public Shared ReadOnly Ldtoken As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ldvirtftn
  commentId: F:System.Reflection.Emit.OpCodes.Ldvirtftn
  id: Ldvirtftn
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ldvirtftn
  fullName: System.Reflection.Emit.OpCodes.Ldvirtftn
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ldvirtftn
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 348
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes an unmanaged pointer (type <strong>native int</strong>) to the native code implementing a particular virtual method associated with a specified object onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack and the address of the entry point to the method (as specified by the metadata token <em>method</em>) is looked up.</p>\n</li><li>\n<p>The pointer to <em>method</em> is pushed onto the stack.</p>\n</li></ol>\n<p>The resulting unmanaged pointer pushed onto the stack by the <strong>ldvirtftn</strong> instruction can be called using the <xref href=\"System.Reflection.Emit.OpCodes.Calli\" data-throw-if-not-resolved=\"false\"></xref> instruction if it references a managed method (or a stub that transitions from managed to unmanaged code).</p>\n<p>The unmanaged pointer points to native code using the CLR calling convention. This method pointer should not be passed to unmanaged native code as a callback routine.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ldvirtftn</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, MethodInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ldvirtftn
    content.vb: Public Shared ReadOnly Ldvirtftn As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Leave
  commentId: F:System.Reflection.Emit.OpCodes.Leave
  id: Leave
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Leave
  fullName: System.Reflection.Emit.OpCodes.Leave
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Leave
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 349
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Exits a protected region of code, unconditionally transferring control to a specific target instruction.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There is no stack transition behavior specified for this instruction.</p>\n<p>The <strong>leave</strong> instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>The <strong>leave</strong> instruction is similar to the <strong>br</strong> instruction, but it can be used to exit a <strong>try</strong>, <strong>filter</strong>, or <strong>catch</strong> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The <strong>leave</strong> instruction empties the evaluation stack and ensures that the appropriate surrounding <strong>finally</strong> blocks are executed.</p>\n<p>You cannot use a <strong>leave</strong> instruction to exit a <strong>finally</strong> block. To ease code generation for exception handlers it is valid from within a catch block to use a <strong>leave</strong> instruction to transfer control to any instruction within the associated <strong>try</strong> block.</p>\n<p>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>leave</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Leave
    content.vb: Public Shared ReadOnly Leave As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Leave_S
  commentId: F:System.Reflection.Emit.OpCodes.Leave_S
  id: Leave_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Leave_S
  fullName: System.Reflection.Emit.OpCodes.Leave_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Leave_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 350
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Exits a protected region of code, unconditionally transferring control to a target instruction (short form).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There is no stack transition behavior specified for this instruction.</p>\n<p>The <strong>leave.s</strong> instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the beginning of the instruction following the current instruction.</p>\n<p>The <strong>leave.s</strong> instruction is similar to the <strong>br</strong> instruction, but it can be used to exit a <strong>try</strong>, <strong>filter</strong>, or <strong>catch</strong> block whereas the ordinary branch instructions can only be used in such a block to transfer control within it. The <strong>leave.s</strong> instruction empties the evaluation stack and ensures that the appropriate surrounding <strong>finally</strong> blocks are executed.</p>\n<p>You cannot use a <strong>leave.s</strong> instruction to exit a <strong>finally</strong> block. To ease code generation for exception handlers it is valid from within a catch block to use a <strong>leave.s</strong> instruction to transfer control to any instruction within the associated <strong>try</strong> block.</p>\n<p>If an instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>leave.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Leave_S
    content.vb: Public Shared ReadOnly Leave_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Localloc
  commentId: F:System.Reflection.Emit.OpCodes.Localloc
  id: Localloc
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Localloc
  fullName: System.Reflection.Emit.OpCodes.Localloc
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Localloc
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 351
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address (a transient pointer, type <strong>*</strong>) of the first allocated byte onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The number of bytes to be allocated is pushed onto the stack.</p>\n</li><li>\n<p>The number of bytes is popped from the stack; an amount of memory corresponding to the size is allocated from the local heap.</p>\n</li><li>\n<p>A pointer to the first byte of the allocated memory is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>localloc</strong> instruction allocates <em>size</em> (type <strong>natural unsigned int</strong>) bytes from the local dynamic memory pool and returns the address (a transient pointer, type <strong>*</strong>) of the first allocated byte. The block of memory returned is initialized to 0 only if the initialize flag on the method is <strong>true</strong>. When the current method executes a <xref href=\"System.Reflection.Emit.OpCodes.Ret\" data-throw-if-not-resolved=\"false\"></xref>, the local memory pool is made available for reuse.</p>\n<p>The resulting address is aligned so that any primitive data type can be stored there using the <strong>stind</strong> instructions (such as <xref href=\"System.Reflection.Emit.OpCodes.Stind_I4\" data-throw-if-not-resolved=\"false\"></xref>) and loaded using the <strong>ldind</strong> instructions (such as <xref href=\"System.Reflection.Emit.OpCodes.Ldind_I4\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>The <strong>localloc</strong> instruction cannot occur within a <strong>filter</strong>, <strong>catch</strong>, <strong>finally</strong>, or <strong>fault</strong> block.</p>\n<p>\n<xref href=\"System.StackOverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if there is insufficient memory to service the request.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>localloc</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Localloc
    content.vb: Public Shared ReadOnly Localloc As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Mkrefany
  commentId: F:System.Reflection.Emit.OpCodes.Mkrefany
  id: Mkrefany
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Mkrefany
  fullName: System.Reflection.Emit.OpCodes.Mkrefany
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Mkrefany
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 352
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes a typed reference to an instance of a specific type onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A pointer to piece of data is pushed onto the stack.</p>\n</li><li>\n<p>The pointer is popped and converted to a typed reference of type <em>class</em>.</p>\n</li><li>\n<p>The typed reference is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>mkrefany</strong> instruction supports the passing of dynamically typed references. The pointer must be of type <strong>&</strong>, <strong>*</strong>, or <strong>native int</strong>, and hold the valid address of a piece of data. <em>Class</em> is the class token describing the type of the data referenced by the pointer. <strong>Mkrefany</strong> pushes a typed reference on the stack, providing an opaque descriptor of the pointer and the type <em>class</em>.</p>\n<p>The only valid operation permitted upon a typed reference is to pass it to a method that requires a typed reference as a parameter. The callee can then use the <xref href=\"System.Reflection.Emit.OpCodes.Refanytype\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Refanyval\" data-throw-if-not-resolved=\"false\"></xref> instructions to retrieve the type (class) and the address respectively.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>class</em> cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>mkrefany</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Mkrefany
    content.vb: Public Shared ReadOnly Mkrefany As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Mul
  commentId: F:System.Reflection.Emit.OpCodes.Mul
  id: Mul
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Mul
  fullName: System.Reflection.Emit.OpCodes.Mul
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Mul
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 353
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Multiplies two values and pushes the result on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is multiplied by <em>value2</em>.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>mul</strong> instruction multiplies <em>value1</em> by <em>value2</em> and pushes the result on the stack. Integer operations silently truncate the upper bits on overflow.</p>\n<p>See <xref href=\"System.Reflection.Emit.OpCodes.Mul_Ovf\" data-throw-if-not-resolved=\"false\"></xref> for an integer-specific multiply operation with overflow handling.</p>\n<p>For floating-point types, 0 * infinity = NaN.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>mul</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Mul
    content.vb: Public Shared ReadOnly Mul As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Mul_Ovf
  commentId: F:System.Reflection.Emit.OpCodes.Mul_Ovf
  id: Mul_Ovf
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Mul_Ovf
  fullName: System.Reflection.Emit.OpCodes.Mul_Ovf
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Mul_Ovf
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 354
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Multiplies two integer values, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is multiplied by <em>value2</em>, with an overflow check.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>mul.ovf</strong> instruction multiplies integer <em>value1</em> by integer <em>value2</em> and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>mul.ovf</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Mul_Ovf
    content.vb: Public Shared ReadOnly Mul_Ovf As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Mul_Ovf_Un
  commentId: F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un
  id: Mul_Ovf_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Mul_Ovf_Un
  fullName: System.Reflection.Emit.OpCodes.Mul_Ovf_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Mul_Ovf_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 355
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Multiplies two unsigned integer values, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value1</em> is multiplied by <em>value2</em>, with an overflow check.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>mul.ovf.un</strong> instruction multiplies unsigned integer <em>value1</em> by unsigned integer <em>value2</em> and pushes the result on the stack. An exception is thrown if the result will not fit in the result type.</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>mul.ovf.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Mul_Ovf_Un
    content.vb: Public Shared ReadOnly Mul_Ovf_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Neg
  commentId: F:System.Reflection.Emit.OpCodes.Neg
  id: Neg
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Neg
  fullName: System.Reflection.Emit.OpCodes.Neg
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Neg
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 356
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Negates a value and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>A value is popped from the stack and negated.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>neg</strong> instruction negates value and pushes the result on top of the stack. The return type is the same as the operand type.</p>\n<p>Negation of integral values is standard two's complement negation. In particular, negating the most negative number (which does not have a positive counterpart) yields the most negative number. To detect this overflow use the <xref href=\"System.Reflection.Emit.OpCodes.Sub_Ovf\" data-throw-if-not-resolved=\"false\"></xref> instruction instead (that is, subtract from 0).</p>\n<p>Negating a floating-point number cannot overflow, and negating NaN returns NaN.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>neg</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Neg
    content.vb: Public Shared ReadOnly Neg As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Newarr
  commentId: F:System.Reflection.Emit.OpCodes.Newarr
  id: Newarr
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Newarr
  fullName: System.Reflection.Emit.OpCodes.Newarr
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Newarr
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 357
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes an object reference to a new zero-based, one-dimensional array whose elements are of a specific type onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The number of elements in the array is pushed onto the stack.</p>\n</li><li>\n<p>The number of elements is popped from the stack and the array is created.</p>\n</li><li>\n<p>An object reference to the new array is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>newarr</strong> instruction pushes an object reference (type <strong>O</strong>) to a new zero-based, one-dimensional array whose elements are of type <em>etype</em> (a metadata token describing the type). The number of elements in the new array should be specified as a <strong>native int</strong>. Valid array indexes range from zero to the maximum number of elements minus one.</p>\n<p>The elements of an array can be any type, including value types.</p>\n<p>Zero-based, one-dimensional arrays of numbers are created using a metadata token referencing the appropriate value type (<xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>, and so on). Elements of the array are initialized to 0 of the appropriate type.</p>\n<p>Nonzero-based one-dimensional arrays and multidimensional arrays are created using <xref href=\"System.Reflection.Emit.OpCodes.Newobj\" data-throw-if-not-resolved=\"false\"></xref> rather than <strong>newarr</strong>. More commonly, they are created using the methods of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class in the .NET Framework.</p>\n<p>\n<xref href=\"System.OutOfMemoryException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if there is insufficient memory to satisfy the request.</p>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>numElems</em> is less than 0.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>newarr</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Newarr
    content.vb: Public Shared ReadOnly Newarr As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Newobj
  commentId: F:System.Reflection.Emit.OpCodes.Newobj
  id: Newobj
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Newobj
  fullName: System.Reflection.Emit.OpCodes.Newobj
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Newobj
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 358
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Creates a new object or a new instance of a value type, pushing an object reference (type <strong>O</strong>) onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>Arguments <em>arg1</em> through <em>argn</em> are pushed on the stack in sequence.</p>\n</li><li>\n<p>Arguments <em>argn</em> through <em>arg1</em> are popped from the stack and passed to <em>ctor</em> for object creation.</p>\n</li><li>\n<p>A reference to the new object is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>newobj</strong> instruction creates a new object or a new instance of a value type. <em>Ctor</em> is a metadata token (a <strong>methodref</strong> or <strong>methoddef</strong> that must be marked as a constructor) that indicates the name, class and signature of the constructor to call.</p>\n<p>The <strong>newobj</strong> instruction allocates a new instance of the class associated with <em>ctor</em> and initializes all the fields in the new instance to 0 (of the proper type) or null references as appropriate. It then calls the constructor <em>ctor</em> with the given arguments along with the newly created instance. After the constructor has been called, the now initialized object reference (type <strong>O</strong>) is pushed on the stack.</p>\n<p>From the constructor's point of view, the uninitialized object is argument 0 and the other arguments passed to newobj follow in order.</p>\n<p>All zero-based, one-dimensional arrays are created using <xref href=\"System.Reflection.Emit.OpCodes.Newarr\" data-throw-if-not-resolved=\"false\"></xref>, not <strong>newobj</strong>. On the other hand, all other arrays (more than one dimension, or one-dimensional but not zero-based) are created using <strong>newobj</strong>.</p>\n<p>Value types are not usually created using <strong>newobj</strong>. They are usually allocated either as arguments or local variables, using <strong>newarr</strong> (for zero-based, one-dimensional arrays), or as fields of objects. Once allocated, they are initialized using <xref href=\"System.Reflection.Emit.OpCodes.Initobj\" data-throw-if-not-resolved=\"false\"></xref>. However, the <strong>newobj</strong> instruction can be used to create a new instance of a value type on the stack, that can then be passed as an argument, stored in a local, and so on.</p>\n<p>\n<xref href=\"System.OutOfMemoryException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if there is insufficient memory to satisfy the request.</p>\n<p>\n<xref href=\"System.MissingMethodException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if a constructor method <em>ctor</em> with the indicated name, class and signature could not be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>newobj</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, ConstructorInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Newobj
    content.vb: Public Shared ReadOnly Newobj As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Nop
  commentId: F:System.Reflection.Emit.OpCodes.Nop
  id: Nop
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Nop
  fullName: System.Reflection.Emit.OpCodes.Nop
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Nop
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 359
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Fills space if opcodes are patched. No meaningful operation is performed although a processing cycle can be consumed.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There is no stack transitional behavior defined for this instruction.</p>\n<p>The <strong>nop</strong> operation does nothing. It is intended to fill in space if opcodes are patched.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>nop</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Nop
    content.vb: Public Shared ReadOnly Nop As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Not
  commentId: F:System.Reflection.Emit.OpCodes.Not
  id: Not
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Not
  fullName: System.Reflection.Emit.OpCodes.Not
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Not
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 360
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Computes the bitwise complement of the integer value on top of the stack and pushes the result onto the evaluation stack as the same type.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value</em> is popped from the stack and its bitwise complement computed.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>not</strong> instruction computes the bitwise complement of an integer value and pushes the result onto the stack. The return type is the same as the operand type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>not</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Not
    content.vb: Public Shared ReadOnly Not As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Or
  commentId: F:System.Reflection.Emit.OpCodes.Or
  id: Or
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Or
  fullName: System.Reflection.Emit.OpCodes.Or
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Or
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 361
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Compute the bitwise complement of the two integer values on top of the stack and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack and their bitwise OR computed.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>or</strong> instruction computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</p>\n<p>\n<strong>Or</strong> is an integer-specific operation.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>or</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Or
    content.vb: Public Shared ReadOnly Or As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Pop
  commentId: F:System.Reflection.Emit.OpCodes.Pop
  id: Pop
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Pop
  fullName: System.Reflection.Emit.OpCodes.Pop
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Pop
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 362
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Removes the value currently on top of the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The top value is popped from the stack.</p>\n</li></ol>\n<p>The <strong>pop</strong> instruction removes the top element from the stack.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>pop</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Pop
    content.vb: Public Shared ReadOnly Pop As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix1
  commentId: F:System.Reflection.Emit.OpCodes.Prefix1
  id: Prefix1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix1
  fullName: System.Reflection.Emit.OpCodes.Prefix1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 363
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix1
    content.vb: Public Shared ReadOnly Prefix1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix2
  commentId: F:System.Reflection.Emit.OpCodes.Prefix2
  id: Prefix2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix2
  fullName: System.Reflection.Emit.OpCodes.Prefix2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 364
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix2
    content.vb: Public Shared ReadOnly Prefix2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix3
  commentId: F:System.Reflection.Emit.OpCodes.Prefix3
  id: Prefix3
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix3
  fullName: System.Reflection.Emit.OpCodes.Prefix3
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix3
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 365
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix3
    content.vb: Public Shared ReadOnly Prefix3 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix4
  commentId: F:System.Reflection.Emit.OpCodes.Prefix4
  id: Prefix4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix4
  fullName: System.Reflection.Emit.OpCodes.Prefix4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 366
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix4
    content.vb: Public Shared ReadOnly Prefix4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix5
  commentId: F:System.Reflection.Emit.OpCodes.Prefix5
  id: Prefix5
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix5
  fullName: System.Reflection.Emit.OpCodes.Prefix5
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix5
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 367
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix5
    content.vb: Public Shared ReadOnly Prefix5 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix6
  commentId: F:System.Reflection.Emit.OpCodes.Prefix6
  id: Prefix6
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix6
  fullName: System.Reflection.Emit.OpCodes.Prefix6
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix6
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 368
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix6
    content.vb: Public Shared ReadOnly Prefix6 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefix7
  commentId: F:System.Reflection.Emit.OpCodes.Prefix7
  id: Prefix7
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefix7
  fullName: System.Reflection.Emit.OpCodes.Prefix7
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefix7
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 369
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefix7
    content.vb: Public Shared ReadOnly Prefix7 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Prefixref
  commentId: F:System.Reflection.Emit.OpCodes.Prefixref
  id: Prefixref
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Prefixref
  fullName: System.Reflection.Emit.OpCodes.Prefixref
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Prefixref
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 370
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>This is a reserved instruction.</p>\n"
  syntax:
    content: public static readonly OpCode Prefixref
    content.vb: Public Shared ReadOnly Prefixref As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Readonly
  commentId: F:System.Reflection.Emit.OpCodes.Readonly
  id: Readonly
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Readonly
  fullName: System.Reflection.Emit.OpCodes.Readonly
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Readonly
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 371
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Specifies that the subsequent array address operation performs no type check at run time, and that it returns a managed pointer whose mutability is restricted.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>This prefix can only appear immediately preceding the <strong>ldelema</strong> instruction and calls to the special <strong>Address</strong> method on arrays. Its effect on the subsequent operation is twofold: </p>\n<ol><li>\n<p>At run time, no type check operation is performed. Note that there is normally an implicit type check for the <strong>ldelema</strong> and <strong>stelem</strong> instructions when used on reference type arrays. There is never a run-time type check for value classes, so <strong>readonly</strong> is a no-op in that case. </p>\n</li><li>\n<p>The verifier treats the result of the address-of operation as a managed pointer with restricted mutability. </p>\n</li></ol>\n<p>The pointer is said to have restricted mutability because the defining type controls whether the value can be mutated. For value classes that expose no public fields or methods that update the value in place, the pointer is read-only (hence the name of the prefix). In particular, the classes representing primitive types (for example, System.Int32) do not expose mutators and thus are read-only. </p>\n<p>A managed pointer restricted in this fashion can be used only in the following ways:  </p>\n<ul><li>\n<p>As the <em>object</em> parameter for the <strong>ldfld</strong>, <strong>ldflda</strong>, <strong>stfld</strong>, <strong>call</strong>, or<strong>constrained callvirt</strong> instructions.</p>\n</li><li>\n<p>As the <em>pointer</em> parameter to the <strong>ldobj</strong> instruction or to one of the <strong>ldind</strong> instructions.</p>\n</li><li>\n<p>As the <em>source</em> parameter to the <strong>cpobj</strong> instruction. </p>\n</li></ul>\n<p>All other operations disallowed, including the <strong>stobj</strong>, <strong>initobj</strong>, or <strong>mkrefany</strong> operations, or any of the <strong>stind</strong> instructions.  </p>\n<p>The purpose of the <strong>readonly</strong> prefix is to avoid a type check when fetching an element from an array in generic code. For example, the expression <code>arr[i].m()</code>, where the element type of the array <code>arr</code> is a generic type that has been constrained to have an interface with method <code>m</code>, might compile to the following MSIL.</p>\n<pre><code>ldloc arr\nldloc i\nreadonly.\nldelema !0    // Loads the pointer to the object.\n             // Load the arguments to the call.\nconstrained. !0\ncallvirt m</code></pre>\n<p>Without the <strong>readonly</strong> prefix, the <strong>ldelema</strong> instruction would perform a type check in the case where !0 was a reference type. Not only is this type check inefficient, but it is semantically incorrect. The type check for <strong>ldelema</strong> is an exact match, which is too strong. If the array held subclasses of type !0, the code above would fail the type check. </p>\n<p>The address of the array element is fetched, instead of the element itself, in order to have a handle for <code>arr[i]</code> that works for both value types and reference types, and thus can be passed to the <strong>constrained callvirt</strong> instruction.</p>\n<p>In general it would be unsafe to skip the run-time check if the array held elements of a reference type. To be safe, it is necessary to ensure that no modifications to the array are made through this pointer. The verifier rules ensure this. The restricted managed pointer can be passed as the object of instance method calls, so it is not strictly speaking read-only for value types, but there is no type safety problem for value types.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>readonly</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Readonly
    content.vb: Public Shared ReadOnly Readonly As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Refanytype
  commentId: F:System.Reflection.Emit.OpCodes.Refanytype
  id: Refanytype
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Refanytype
  fullName: System.Reflection.Emit.OpCodes.Refanytype
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Refanytype
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 372
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the type token embedded in a typed reference.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value type reference is pushed onto the stack.</p>\n</li><li>\n<p>The typed reference is popped from the stack and its corresponding type token retrieved.</p>\n</li><li>\n<p>The type token is pushed onto the stack.</p>\n</li></ol>\n<p>A typed reference contains a type token and an address to an object instance.</p>\n<p>The <strong>refanytype</strong> instruction retrieves the type token embedded in the typed reference. See the <xref href=\"System.Reflection.Emit.OpCodes.Mkrefany\" data-throw-if-not-resolved=\"false\"></xref> instruction for information on creating typed references.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>refanytype</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Refanytype
    content.vb: Public Shared ReadOnly Refanytype As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Refanyval
  commentId: F:System.Reflection.Emit.OpCodes.Refanyval
  id: Refanyval
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Refanyval
  fullName: System.Reflection.Emit.OpCodes.Refanyval
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Refanyval
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 373
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the address (type <strong>&</strong>) embedded in a typed reference.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value type reference is pushed onto the stack.</p>\n</li><li>\n<p>The typed reference is popped from the stack and the corresponding address retrieved.</p>\n</li><li>\n<p>The address is pushed onto the stack.</p>\n</li></ol>\n<p>A typed reference contains a type token and an address to an object instance.</p>\n<p>The <strong>refanyval</strong> instruction retrieves the address embedded in the a typed reference. The type embedded in the typed reference supplied on the stack must match the type specified by <em>type</em> (a metadata token, either a <strong>typedef</strong> or a <strong>typeref</strong>). See the <xref href=\"System.Reflection.Emit.OpCodes.Mkrefany\" data-throw-if-not-resolved=\"false\"></xref> instruction for related content.</p>\n<p>\n<xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>type</em> is not identical to the type stored in the type reference (in this case, <em>type</em> is the class supplied to the <xref href=\"System.Reflection.Emit.OpCodes.Mkrefany\" data-throw-if-not-resolved=\"false\"></xref> instruction that constructed said typed reference).</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>type</em> cannot be found.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>refanyval</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Refanyval
    content.vb: Public Shared ReadOnly Refanyval As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Rem
  commentId: F:System.Reflection.Emit.OpCodes.Rem
  id: Rem
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Rem
  fullName: System.Reflection.Emit.OpCodes.Rem
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Rem
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 374
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Divides two values and pushes the remainder onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>ReplaceThisText</p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A <em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack and the remainder of <em>value1</em><strong>div</strong><em>value2</em> computed.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<em>result</em> = <em>value1</em><strong>rem</strong><em>value2</em> satisfies the following conditions: </p>\n<p>\n<em>result</em> = <em>value1</em> - <em>value2</em><strong></strong> (<em>value1</em><strong>div</strong><em>value2</em>), and: </p>\n<p>0 = | <em>result</em> | < | <em>value2</em> |, sign(<em>result</em>) = sign(<em>value1</em>), where <strong>div</strong> is the division instruction that truncates towards zero.</p>\n<p>If <em>value2</em> is zero or <em>value1</em> is infinity the result is NaN. If <em>value2</em> is infinity, the result is <em>value1</em> (negated for <strong>-infinity</strong>).</p>\n<p>Integral operations throw <xref href=\"System.DivideByZeroException\" data-throw-if-not-resolved=\"false\"></xref> if <em>value2</em> is zero.</p>\n<p>Note that on the Intel-based platforms an <xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when computing (minint <strong>rem</strong> -1).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>rem</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Rem
    content.vb: Public Shared ReadOnly Rem As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Rem_Un
  commentId: F:System.Reflection.Emit.OpCodes.Rem_Un
  id: Rem_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Rem_Un
  fullName: System.Reflection.Emit.OpCodes.Rem_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Rem_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 375
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Divides two unsigned values and pushes the remainder onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack and the remainder of <em>value1</em><strong>div</strong><em>value2</em> computed.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<em>result</em> = <em>value1</em><strong>rem.un</strong><em>value2</em> satisfies the following conditions: </p>\n<p>\n<em>result</em> = <em>value1</em> - <em>value2</em> x(<em>value1</em><strong>div.un</strong><em>value2</em>), and: </p>\n<p>0 = <em>result</em> < <em>value2</em>, where <strong>div.un</strong> is the unsigned division instruction.</p>\n<p>The <strong>rem.un</strong> instruction computes <em>result</em> and pushes it on the stack. <strong>Rem.un</strong> treats its arguments as unsigned integers, while <xref href=\"System.Reflection.Emit.OpCodes.Rem\" data-throw-if-not-resolved=\"false\"></xref> treats them as signed integers.</p>\n<p>\n<strong>Rem.un</strong> is unspecified for floating-point numbers.</p>\n<p>Integral operations throw <xref href=\"System.DivideByZeroException\" data-throw-if-not-resolved=\"false\"></xref> if <em>value2</em> is zero.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>rem.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Rem_Un
    content.vb: Public Shared ReadOnly Rem_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Ret
  commentId: F:System.Reflection.Emit.OpCodes.Ret
  id: Ret
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Ret
  fullName: System.Reflection.Emit.OpCodes.Ret
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ret
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 376
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns from the current method, pushing a return value (if present) from the callee's evaluation stack onto the caller's evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The return value is popped from the callee evaluation stack.</p>\n</li><li>\n<p>The return value obtained in step 1 is pushed onto the caller evaluation stack.</p>\n</li></ol>\n<p>If the return value is not present on the callee evaluation stack, no value is returned (no stack transition behaviors for either the callee or caller method).</p>\n<p>The type of the return value, if any, of the current method determines the type of value to be fetched from the top of the stack and copied onto the stack of the method that called the current method. The evaluation stack for the current method must be empty except for the value to be returned.</p>\n<p>The <strong>ret</strong> instruction cannot be used to transfer control out of a<strong>try</strong>, <strong>filter</strong>, <strong>catch</strong>, or <strong>finally</strong> block. From within a <strong>try</strong> or <strong>catch</strong>, use the <xref href=\"System.Reflection.Emit.OpCodes.Leave\" data-throw-if-not-resolved=\"false\"></xref> instruction with a destination of a <strong>ret</strong> instruction that is outside all enclosing exception blocks. Because the <strong>filter</strong> and <strong>finally</strong> blocks are logically part of exception handling and not the method in which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not perform a method return from within a <strong>filter</strong> or <strong>finally</strong>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>ret</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Ret
    content.vb: Public Shared ReadOnly Ret As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Rethrow
  commentId: F:System.Reflection.Emit.OpCodes.Rethrow
  id: Rethrow
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Rethrow
  fullName: System.Reflection.Emit.OpCodes.Rethrow
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Rethrow
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 377
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Rethrows the current exception.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>No stack transition behavior is defined for this instruction.</p>\n<p>The <em>rethrow</em> instruction is only permitted within the body of a <strong>catch</strong> handler. It throws the same exception that was caught by this handler.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>rethrow</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Rethrow
    content.vb: Public Shared ReadOnly Rethrow As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Shl
  commentId: F:System.Reflection.Emit.OpCodes.Shl
  id: Shl
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Shl
  fullName: System.Reflection.Emit.OpCodes.Shl
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Shl
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 378
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Shifts an integer value to the left (in zeroes) by a specified number of bits, pushing the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The amount of bits to be shifted is pushed onto the stack.</p>\n</li><li>\n<p>The number of bits to be shifted and the value are popped from the stack; the value is shifted left by the specified number of bits.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>shl</strong> instruction shifts the value (type <strong>int32</strong>, <strong>int64</strong> or <strong>native int</strong>) left by the specified number of bits. The number of bits is a value of type <strong>int32</strong> or <strong>native int</strong>. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</p>\n<p>\n<strong>Shl</strong> inserts a zero bit in the lowest position on each shift.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>shl</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Shl
    content.vb: Public Shared ReadOnly Shl As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Shr
  commentId: F:System.Reflection.Emit.OpCodes.Shr
  id: Shr
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Shr
  fullName: System.Reflection.Emit.OpCodes.Shr
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Shr
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 379
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Shifts an integer value (in sign) to the right by a specified number of bits, pushing the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The amount of bits to be shifted is pushed onto the stack.</p>\n</li><li>\n<p>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>shr.un</strong> instruction shifts the value (type <strong>int32</strong>, <strong>int64</strong> or <strong>native int</strong>) right by the specified number of bits. The number of bits is a value of type <strong>int32</strong> or <strong>native int</strong>. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</p>\n<p>\n<strong>Shr</strong> replicates the high order bit on each shift, preserving the sign of the original value in the <em>result</em>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>shr</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Shr
    content.vb: Public Shared ReadOnly Shr As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Shr_Un
  commentId: F:System.Reflection.Emit.OpCodes.Shr_Un
  id: Shr_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Shr_Un
  fullName: System.Reflection.Emit.OpCodes.Shr_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Shr_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 380
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Shifts an unsigned integer value (in zeroes) to the right by a specified number of bits, pushing the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The amount of bits to be shifted is pushed onto the stack.</p>\n</li><li>\n<p>The number of bits to be shifted and the value are popped from the stack; the value is shifted right by the specified number of bits.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>shr.un</strong> instruction shifts the value (type <strong>int32</strong>, <strong>int64</strong> or <strong>native int</strong>) right by the specified number of bits. The number of bits is a value of type <strong>int32</strong>, <strong>int64</strong> or <strong>native int</strong>. The return value is unspecified if the number of bits to be shifted is greater than or equal to the width (in bits) of the supplied value.</p>\n<p>\n<strong>Shr.un</strong> inserts a zero bit in the highest position on each shift.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>shr.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Shr_Un
    content.vb: Public Shared ReadOnly Shr_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Sizeof
  commentId: F:System.Reflection.Emit.OpCodes.Sizeof
  id: Sizeof
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Sizeof
  fullName: System.Reflection.Emit.OpCodes.Sizeof
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sizeof
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 381
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pushes the size, in bytes, of a supplied value type onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The size (in bytes) of the supplied value type (<em>valType</em>) is pushed onto the stack.</p>\n</li></ol>\n<p>\n<em>valType</em> must be a metadata token (a <strong>typeref</strong> or <strong>typedef</strong>) that specifies a value type, reference type, or generic type parameter.</p>\n<p>For a reference type, the size returned is the size of a reference value of the corresponding type (4 bytes on 32-bit systems), not the size of the data stored in objects referred to by the reference value. A generic type parameter can be used only in the body of the type or method that defines it. When that type or method is instantiated, the generic type parameter is replaced by a value type or reference type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>sizeof</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Sizeof
    content.vb: Public Shared ReadOnly Sizeof As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  seealso:
  - type: System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Starg
  commentId: F:System.Reflection.Emit.OpCodes.Starg
  id: Starg
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Starg
  fullName: System.Reflection.Emit.OpCodes.Starg
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Starg
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 382
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores the value on top of the evaluation stack in the argument slot at a specified index.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value currently on top of the stack is popped and placed in argument slot <em>num</em>.</p>\n</li></ol>\n<p>The <strong>starg</strong> instruction pops a value from the stack and places it in argument slot <em>num</em>. The type of the value must match the type of the argument, as specified in the current method's signature.</p>\n<p>For procedures that take a variable argument list, the <strong>starg</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</p>\n<p>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>starg</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Starg
    content.vb: Public Shared ReadOnly Starg As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Starg_S
  commentId: F:System.Reflection.Emit.OpCodes.Starg_S
  id: Starg_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Starg_S
  fullName: System.Reflection.Emit.OpCodes.Starg_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Starg_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 383
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores the value on top of the evaluation stack in the argument slot at a specified index, short form.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>The value currently on top of the stack is popped and placed in argument slot <em>num</em>.</p>\n</li></ol>\n<p>The <strong>starg.s</strong> instruction pops a value from the stack and places it in argument slot <em>num</em>. The type of the value must match the type of the argument, as specified in the current method's signature.</p>\n<p>The <strong>starg.s</strong> instruction provides an efficient encoding for use with the first 256 arguments.</p>\n<p>For procedures that take a variable argument list, the <strong>starg.s</strong> instruction can be used only for the initial fixed arguments, not those in the variable part of the signature.</p>\n<p>Performing a store into arguments that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the argument. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref>method overload can use the <strong>starg.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Starg_S
    content.vb: Public Shared ReadOnly Starg_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem
  commentId: F:System.Reflection.Emit.OpCodes.Stelem
  id: Stelem
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem
  fullName: System.Reflection.Emit.OpCodes.Stelem
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 384
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the value on the evaluation stack, whose type is specified in the instruction.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>An index value, <em>index</em>, to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value of the type specified in the instruction is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem</strong> instruction replaces the value of the element at the supplied zero-based index in the one-dimensional array <em>array</em> with the value. The value has the type specified by the token <em>typeTok</em> in the instruction.</p>\n<p>Arrays are objects, and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem
    content.vb: Public Shared ReadOnly Stelem As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_I
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I
  id: Stelem_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_I
  fullName: System.Reflection.Emit.OpCodes.Stelem_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 385
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>native int</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.i</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>native int</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_I
    content.vb: Public Shared ReadOnly Stelem_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_I1
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I1
  id: Stelem_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_I1
  fullName: System.Reflection.Emit.OpCodes.Stelem_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 386
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>int8</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.i1</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>int8</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_I1
    content.vb: Public Shared ReadOnly Stelem_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_I2
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I2
  id: Stelem_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_I2
  fullName: System.Reflection.Emit.OpCodes.Stelem_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 387
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>int16</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.i2</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>int16</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_I2
    content.vb: Public Shared ReadOnly Stelem_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_I4
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I4
  id: Stelem_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_I4
  fullName: System.Reflection.Emit.OpCodes.Stelem_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 388
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>int32</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.i4</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>int32</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_I4
    content.vb: Public Shared ReadOnly Stelem_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_I8
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_I8
  id: Stelem_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_I8
  fullName: System.Reflection.Emit.OpCodes.Stelem_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 389
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>int64</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.i8</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>int64</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_I8
    content.vb: Public Shared ReadOnly Stelem_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_R4
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_R4
  id: Stelem_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_R4
  fullName: System.Reflection.Emit.OpCodes.Stelem_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 390
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>float32</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.r4</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>float32</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_R4
    content.vb: Public Shared ReadOnly Stelem_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_R8
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_R8
  id: Stelem_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_R8
  fullName: System.Reflection.Emit.OpCodes.Stelem_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 391
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the <strong>float64</strong> value on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.r8</strong> instruction replaces the value of the element <em>index</em> in the one-dimensional array <em>array</em> with the <strong>float64</strong> value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_R8
    content.vb: Public Shared ReadOnly Stelem_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stelem_Ref
  commentId: F:System.Reflection.Emit.OpCodes.Stelem_Ref
  id: Stelem_Ref
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stelem_Ref
  fullName: System.Reflection.Emit.OpCodes.Stelem_Ref
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stelem_Ref
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 392
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the array element at a given index with the object ref value (type <strong>O</strong>) on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference to an array, <em>array</em>, is pushed onto the stack.</p>\n</li><li>\n<p>A valid index to an element in <em>array</em> is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value, the index, and the array reference are popped from the stack; the value is put into the array element at the given index.</p>\n</li></ol>\n<p>The <strong>stelem.ref</strong> instruction replaces the value of the element at the supplied index in the one-dimensional array <em>array</em> with the <strong>ref</strong> (type <strong>O</strong>) value pushed onto the stack.</p>\n<p>Arrays are objects and hence represented by a value of type <strong>O</strong>. The index is type <strong>native int</strong>.</p>\n<p>Note that <strong>stelem.ref</strong> implicitly casts the supplied value to the element type of <em>array</em> before assigning the value to the array element. This cast can fail, even for verified code. Thus the <strong>stelem.ref</strong> instruction can throw <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref>. For one-dimensional arrays that aren't zero-based and for multidimensional arrays, the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class provides a <xref href=\"System.Array.SetValue(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> is a null reference.</p>\n<p>\n<xref href=\"System.IndexOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>index</em> is negative, or larger than the bound of <em>array</em>.</p>\n<p>\n<xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>array</em> does not hold elements of the required type.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stelem.ref</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stelem_Ref
    content.vb: Public Shared ReadOnly Stelem_Ref As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stfld
  commentId: F:System.Reflection.Emit.OpCodes.Stfld
  id: Stfld
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stfld
  fullName: System.Reflection.Emit.OpCodes.Stfld
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stfld
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 393
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the value stored in the field of an object reference or pointer with a new value.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference or pointer is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the object reference/pointer are popped from the stack; the value of <em>field</em> in the object is replaced with the supplied value.</p>\n</li></ol>\n<p>The <strong>stfld</strong> instruction replaces the value of a field of an object (type <strong>O</strong>) or via a pointer (type <strong>native int</strong>, <strong>&</strong>, or <strong>*</strong>) with a given value. <em>Field</em> is a metadata token that refers to a field member reference. The <strong>stfld</strong> instruction can have a prefix of either or both of <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object reference or pointer is a null reference and the field isn't static.</p>\n<p>\n<xref href=\"System.MissingFieldException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>field</em> is not found in the metadata. This is typically checked when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stfld</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stfld
    content.vb: Public Shared ReadOnly Stfld As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_I
  commentId: F:System.Reflection.Emit.OpCodes.Stind_I
  id: Stind_I
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_I
  fullName: System.Reflection.Emit.OpCodes.Stind_I
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_I
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 394
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>native int</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.i</strong> instruction stores a <strong>native int</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.i</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.i</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.i</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_I
    content.vb: Public Shared ReadOnly Stind_I As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_I1
  commentId: F:System.Reflection.Emit.OpCodes.Stind_I1
  id: Stind_I1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_I1
  fullName: System.Reflection.Emit.OpCodes.Stind_I1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_I1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 395
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>int8</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.i1</strong> instruction stores an <strong>int8</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.i1</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.i1</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.i1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_I1
    content.vb: Public Shared ReadOnly Stind_I1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_I2
  commentId: F:System.Reflection.Emit.OpCodes.Stind_I2
  id: Stind_I2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_I2
  fullName: System.Reflection.Emit.OpCodes.Stind_I2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_I2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 396
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>int16</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.i2</strong> instruction stores an <strong>int16</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.2i</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.i2</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref>prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.i2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_I2
    content.vb: Public Shared ReadOnly Stind_I2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_I4
  commentId: F:System.Reflection.Emit.OpCodes.Stind_I4
  id: Stind_I4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_I4
  fullName: System.Reflection.Emit.OpCodes.Stind_I4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_I4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 397
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>int32</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.i4</strong> instruction stores an <strong>int32</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.i4</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.i4</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.i4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_I4
    content.vb: Public Shared ReadOnly Stind_I4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_I8
  commentId: F:System.Reflection.Emit.OpCodes.Stind_I8
  id: Stind_I8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_I8
  fullName: System.Reflection.Emit.OpCodes.Stind_I8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_I8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 398
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>int64</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.i8</strong> instruction stores an <strong>int64</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.i8</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.i</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.i8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_I8
    content.vb: Public Shared ReadOnly Stind_I8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_R4
  commentId: F:System.Reflection.Emit.OpCodes.Stind_R4
  id: Stind_R4
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_R4
  fullName: System.Reflection.Emit.OpCodes.Stind_R4
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_R4
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 399
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>float32</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.r4</strong> instruction stores a <strong>float32</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.r4</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.r4</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.r4</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_R4
    content.vb: Public Shared ReadOnly Stind_R4 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_R8
  commentId: F:System.Reflection.Emit.OpCodes.Stind_R8
  id: Stind_R8
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_R8
  fullName: System.Reflection.Emit.OpCodes.Stind_R8
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_R8
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 400
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a value of type <strong>float64</strong> at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.r8</strong> instruction stores a <strong>float64</strong> value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.r8</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.r8</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.r8</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_R8
    content.vb: Public Shared ReadOnly Stind_R8 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stind_Ref
  commentId: F:System.Reflection.Emit.OpCodes.Stind_Ref
  id: Stind_Ref
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stind_Ref
  fullName: System.Reflection.Emit.OpCodes.Stind_Ref
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stind_Ref
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 401
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Stores a object reference value at a supplied address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value and the address are popped from the stack; the value is stored at the address.</p>\n</li></ol>\n<p>The <strong>stind.ref</strong> instruction stores an object reference value at the supplied address (type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>).</p>\n<p>Type safe operation requires that the <strong>stind.ref</strong> instruction be used in a manner consistent with the type of the pointer. The operation of the <strong>stind.ref</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>addr</em> is not naturally aligned for the argument type implied by the instruction suffix.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stind.ref</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stind_Ref
    content.vb: Public Shared ReadOnly Stind_Ref As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc
  commentId: F:System.Reflection.Emit.OpCodes.Stloc
  id: Stloc
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc
  fullName: System.Reflection.Emit.OpCodes.Stloc
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 402
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at a specified index.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in local variable <em>index</em>.</p>\n</li></ol>\n<p>The <strong>stloc</strong> instruction pops the top value off the evaluation stack and moves it into local variable number <em>index</em>, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>Correct Microsoft Intermediate Language (MSIL) instructions require that <em>index</em> be a valid local index. For the <strong>stloc</strong> instruction, <em>index</em> must lie in the range 0 to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding 65535 is pragmatic: likely implementations will use a 2-byte integer to track both a local's index, as well as the total number of locals for a given method. If an index of 65535 had been made valid, it would require a wider integer to track the number of locals in such a method.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>stloc</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, LocalBuilder) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, short) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc
    content.vb: Public Shared ReadOnly Stloc As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc_0
  commentId: F:System.Reflection.Emit.OpCodes.Stloc_0
  id: Stloc_0
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc_0
  fullName: System.Reflection.Emit.OpCodes.Stloc_0
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc_0
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 403
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 0.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in the local variable indexed by 0.</p>\n</li></ol>\n<p>The <strong>stloc.0</strong> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 0. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>\n<strong>stloc.0</strong> is an especially efficient encoding for storing values in local variable 0.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stloc.0</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc_0
    content.vb: Public Shared ReadOnly Stloc_0 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc_1
  commentId: F:System.Reflection.Emit.OpCodes.Stloc_1
  id: Stloc_1
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc_1
  fullName: System.Reflection.Emit.OpCodes.Stloc_1
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc_1
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 404
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 1.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in the local variable indexed by 1.</p>\n</li></ol>\n<p>The <strong>stloc.1</strong> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 1. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>\n<strong>stloc.1</strong> is an especially efficient encoding for storing values in local variable 1.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stloc.1</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc_1
    content.vb: Public Shared ReadOnly Stloc_1 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc_2
  commentId: F:System.Reflection.Emit.OpCodes.Stloc_2
  id: Stloc_2
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc_2
  fullName: System.Reflection.Emit.OpCodes.Stloc_2
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc_2
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 405
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 2.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in the local variable indexed by 2.</p>\n</li></ol>\n<p>The <strong>stloc.2</strong> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 2. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>\n<strong>stloc.2</strong> is an especially efficient encoding for storing values in local variable 2.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stloc.2</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc_2
    content.vb: Public Shared ReadOnly Stloc_2 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc_3
  commentId: F:System.Reflection.Emit.OpCodes.Stloc_3
  id: Stloc_3
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc_3
  fullName: System.Reflection.Emit.OpCodes.Stloc_3
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc_3
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 406
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at index 3.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in the local variable indexed by 3.</p>\n</li></ol>\n<p>The <strong>stloc.3</strong> instruction pops the top value off the evaluation stack and moves it into the local variable indexed by 3. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>\n<strong>stloc.3</strong> is an especially efficient encoding for storing values in local variable 3.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stloc.3</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc_3
    content.vb: Public Shared ReadOnly Stloc_3 As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stloc_S
  commentId: F:System.Reflection.Emit.OpCodes.Stloc_S
  id: Stloc_S
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stloc_S
  fullName: System.Reflection.Emit.OpCodes.Stloc_S
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stloc_S
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 407
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Pops the current value from the top of the evaluation stack and stores it in a the local variable list at <em>index</em> (short form).</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is popped off of the stack and placed in local variable <em>index</em>.</p>\n</li></ol>\n<p>The <strong>stloc.s</strong> instruction pops the top value off the evaluation stack and moves it into local variable number <em>index</em>, where local variables are numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's local signature.</p>\n<p>The <strong>stloc.s</strong> instruction provides an efficient encoding for local variables 0 through 255.</p>\n<p>Storing into locals that hold an integer value smaller than 4 bytes long truncates the value as it moves from the stack to the local variable. Floating-point values are rounded from their native size (type <strong>F</strong>) to the size associated with the argument.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>stloc.s</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, LocalBuilder) </p>\n</li><li>\n<p>ILGenerator.Emit(OpCode, byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stloc_S
    content.vb: Public Shared ReadOnly Stloc_S As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stobj
  commentId: F:System.Reflection.Emit.OpCodes.Stobj
  id: Stobj
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stobj
  fullName: System.Reflection.Emit.OpCodes.Stobj
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stobj
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 408
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Copies a value of a specified type from the evaluation stack into a supplied memory address.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li><li>\n<p>A value type object of type <em>class</em> is pushed onto the stack.</p>\n</li><li>\n<p>The object and the address are popped from the stack; the value type object is stored at the address.</p>\n</li></ol>\n<p>The <strong>stobj</strong> instruction copies the value type object into the address specified by the address (a pointer of type <strong>native int</strong>, <strong>*</strong>, or <strong>&</strong>). The number of bytes copied depends on the size of the class represented by <em>class</em>, a metadata token representing a value type.</p>\n<p>The operation of the <strong>stobj</strong> instruction can be altered by an immediately preceding <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> prefix instruction.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if class cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run time.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stobj</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stobj
    content.vb: Public Shared ReadOnly Stobj As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Stsfld
  commentId: F:System.Reflection.Emit.OpCodes.Stsfld
  id: Stsfld
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Stsfld
  fullName: System.Reflection.Emit.OpCodes.Stsfld
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Stsfld
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 409
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Replaces the value of a static field with a value from the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>A value is popped from the stack and stored in <em>field</em>.</p>\n</li></ol>\n<p>The <strong>stsfld</strong> instruction replaces the value of a static field with a value from the stack. <em>field</em> is a metadata token that must refer to a static field member.</p>\n<p>The <strong>stsfld</strong> instruction may be prefixed by <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>\n<xref href=\"System.MissingFieldException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if field is not found in the metadata. This is typically checked when Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at run time.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>stsfld</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, FieldInfo) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Stsfld
    content.vb: Public Shared ReadOnly Stsfld As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Sub
  commentId: F:System.Reflection.Emit.OpCodes.Sub
  id: Sub
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Sub
  fullName: System.Reflection.Emit.OpCodes.Sub
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sub
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 410
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Subtracts one value from another and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value2</em> is subtracted from <em>value1</em>.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>Overflow is not detected for integer operations (for proper overflow handling, see <xref href=\"System.Reflection.Emit.OpCodes.Sub_Ovf\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>Integer subtraction wraps, rather than saturates. For example: assuming 8-bit integers, where <em>value1</em> is set to 0 and <em>value2</em> is set to 1, the \"wrapped\" result will be 255.</p>\n<p>Floating-point overflow returns <strong>+inf</strong> (<strong>PositiveInfinity</strong>) or <strong>-inf</strong> (<strong>NegativeInfinity</strong>).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>sub</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Sub
    content.vb: Public Shared ReadOnly Sub As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Sub_Ovf
  commentId: F:System.Reflection.Emit.OpCodes.Sub_Ovf
  id: Sub_Ovf
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Sub_Ovf
  fullName: System.Reflection.Emit.OpCodes.Sub_Ovf
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sub_Ovf
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 411
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Subtracts one integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value2</em> is subtracted from <em>value1</em> with a check for overflow.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>This operation is performed on signed integers; for floating-point values, use <xref href=\"System.Reflection.Emit.OpCodes.Sub\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>sub.ovf</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Sub_Ovf
    content.vb: Public Shared ReadOnly Sub_Ovf As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Sub_Ovf_Un
  commentId: F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un
  id: Sub_Ovf_Un
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Sub_Ovf_Un
  fullName: System.Reflection.Emit.OpCodes.Sub_Ovf_Un
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sub_Ovf_Un
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 412
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Subtracts one unsigned integer value from another, performs an overflow check, and pushes the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack; <em>value2</em> is subtracted from <em>value1</em> with a check for overflow.</p>\n</li><li>\n<p>The result is pushed onto the stack.</p>\n</li></ol>\n<p>\n<xref href=\"System.OverflowException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the result can not be represented in the result type.</p>\n<p>This operation is performed on signed integers; for floating-point values, use <xref href=\"System.Reflection.Emit.OpCodes.Sub\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>sub.ovf.un</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Sub_Ovf_Un
    content.vb: Public Shared ReadOnly Sub_Ovf_Un As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Switch
  commentId: F:System.Reflection.Emit.OpCodes.Switch
  id: Switch
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Switch
  fullName: System.Reflection.Emit.OpCodes.Switch
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Switch
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 413
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Implements a jump table.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>A value is pushed onto the stack.</p>\n</li><li>\n<p>The value is popped off the stack and execution is transferred to the instruction at the offset indexed by the value, where the value is less than <em>N</em>.</p>\n</li></ol>\n<p>The <strong>switch</strong> instruction implements a jump table. The format of the instruction is an <strong>unsigned int32</strong> representing the number of targets <em>N</em>, followed by <em>N</em> int32 values specifying jump targets. These targets are represented as offsets (positive or negative) from the beginning of the instruction following this <strong>switch</strong> instruction.</p>\n<p>The <strong>switch</strong> instruction pops a value off the stack and compares it, as an unsigned integer, to <em>N</em>. If value is less than <em>N</em>, execution is transferred to the target indexed by value, where targets are numbered from 0 (for example, a value of 0 takes the first target, a value of 1 takes the second target, and so on). If the value is greater than or equal to <em>N</em>, execution continues at the next instruction (fall through).</p>\n<p>If the target instruction has one or more prefix codes, control can only be transferred to the first of these prefixes.</p>\n<p>Control transfers into and out of <strong>try</strong>, <strong>catch</strong>, <strong>filter</strong>, and <strong>finally</strong> blocks cannot be performed by this instruction. (Such transfers are severely restricted and must use the leave instruction instead).</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>switch</strong> opcode. The <em>Label[]</em> argument is an array of Labels representing 32-bit offsets.</p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label[]) </p>\n</li></ul>\n"
  example:
  - "\n<p>The following code sample illustrates the use of the <strong>Switch</strong> opcode to generate a jump table using an array of <xref href=\"System.Reflection.Emit.Label\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Reflection.Emit.ILGenerator.Emit Example 2#1"
  syntax:
    content: public static readonly OpCode Switch
    content.vb: Public Shared ReadOnly Switch As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Tailcall
  commentId: F:System.Reflection.Emit.OpCodes.Tailcall
  id: Tailcall
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Tailcall
  fullName: System.Reflection.Emit.OpCodes.Tailcall
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Tailcall
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 414
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Performs a postfixed method call instruction such that the current method's stack frame is removed before the actual call instruction is executed.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>There is no stack transition behavior defined for this instruction.</p>\n<p>The <strong>tail</strong> prefix instruction must immediately precede a <xref href=\"System.Reflection.Emit.OpCodes.Call\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.Emit.OpCodes.Calli\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Reflection.Emit.OpCodes.Callvirt\" data-throw-if-not-resolved=\"false\"></xref> instruction. It indicates that the current method's stack frame should be removed before the call instruction is executed. It also implies that the value returned from the following call is also the value returned by the current method, and the call can therefore be converted into a cross-method jump.</p>\n<p>The stack must be empty except for the arguments being transferred by the following call. The instruction following the call instruction must be a ret. Thus the only valid code sequence is <strong>tail. call</strong> (or <strong>calli</strong> or <strong>callvirt</strong>). Correct Microsoft Intermediate Language (MSIL) instructions must not branch to the <strong>call</strong> instruction, but they may branch to the subsequent <xref href=\"System.Reflection.Emit.OpCodes.Ret\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The current frame cannot be discarded when control is transferred from untrusted code to trusted code, since this would jeopardize code identity security. The .NET Framework security checks can therefore cause the <strong>tail</strong> to be ignored, leaving a standard <xref href=\"System.Reflection.Emit.OpCodes.Call\" data-throw-if-not-resolved=\"false\"></xref> instruction. Similarly, in order to allow the exit of a synchronized region to occur after the call returns, the <strong>tail</strong> prefix is ignored when used to exit a method that is marked synchronized.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>tail</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Tailcall
    content.vb: Public Shared ReadOnly Tailcall As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Throw
  commentId: F:System.Reflection.Emit.OpCodes.Throw
  id: Throw
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Throw
  fullName: System.Reflection.Emit.OpCodes.Throw
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Throw
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 415
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Throws the exception object currently on the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference (to an exception) is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack and the exception thrown.</p>\n</li></ol>\n<p>The <strong>throw</strong> instruction throws the exception object (type <strong>O</strong>) currently on the stack.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object reference is a null reference.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>throw</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Throw
    content.vb: Public Shared ReadOnly Throw As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Unaligned
  commentId: F:System.Reflection.Emit.OpCodes.Unaligned
  id: Unaligned
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Unaligned
  fullName: System.Reflection.Emit.OpCodes.Unaligned
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Unaligned
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 416
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Indicates that an address currently atop the evaluation stack might not be aligned to the natural size of the immediately following <strong>ldind</strong>, <strong>stind</strong>, <strong>ldfld</strong>, <strong>stfld</strong>, <strong>ldobj</strong>, <strong>stobj</strong>, <strong>initblk</strong>, or <strong>cpblk</strong> instruction.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>Unaligned</strong> specifies that the address (an unmanaged pointer, <strong>native int</strong>) on the stack might not be aligned to the natural size of the immediately following <strong>ldind</strong>, <strong>stind</strong>, <strong>ldfld</strong>, <strong>stfld</strong>, <strong>ldobj</strong>, <strong>stobj</strong>, <strong>initblk</strong>, or <strong>cpblk</strong> instruction. That is, for a <xref href=\"System.Reflection.Emit.OpCodes.Ldind_I4\" data-throw-if-not-resolved=\"false\"></xref> instruction the alignment of the address may not be to a 4-byte boundary. For <strong>initblk</strong> and <strong>cpblk</strong> the default alignment is architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code generators that do not restrict their output to a 32-bit word size must use <strong>unaligned</strong> if the alignment is not known at compile time to be 8-byte.</p>\n<p>The value of alignment must be 1, 2, or 4 and means that the generated code should assume that the address is byte, double-byte, or quad-byte aligned, respectively. Note that transient pointers (type <strong>*</strong>) are always aligned.</p>\n<p>While the alignment for a <strong>cpblk</strong> instruction would logically require two numbers (one for the source and one for the destination), there is no noticeable impact on performance if only the lower number is specified.</p>\n<p>The <strong>unaligned</strong> and <strong>volatile</strong> prefixes can be combined in either order. They must immediately precede a <strong>ldind</strong>, <strong>stind</strong>, <strong>ldfld</strong>, <strong>stfld</strong>, <strong>ldobj</strong>, <strong>stobj</strong>, <strong>initblk</strong>, or <strong>cpblk</strong>instruction. Only the <xref href=\"System.Reflection.Emit.OpCodes.Volatile\" data-throw-if-not-resolved=\"false\"></xref> prefix is allowed for the <xref href=\"System.Reflection.Emit.OpCodes.Ldsfld\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Stsfld\" data-throw-if-not-resolved=\"false\"></xref> instructions.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overloads can use the <strong>unaligned</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Label) </p>\n</li><li>\n<p>ILGenerator.Emit(Opcode, Byte) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Unaligned
    content.vb: Public Shared ReadOnly Unaligned As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Unbox
  commentId: F:System.Reflection.Emit.OpCodes.Unbox
  id: Unbox
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Unbox
  fullName: System.Reflection.Emit.OpCodes.Unbox
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Unbox
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 417
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the boxed representation of a value type to its unboxed form.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack and unboxed to a value type pointer.</p>\n</li><li>\n<p>The value type pointer is pushed onto the stack.</p>\n</li></ol>\n<p>A value type has two separate representations within the Common Language Infrastructure (CLI): </p>\n<ul><li>\n<p>A 'raw' form used when a value type is embedded within another object.</p>\n</li><li>\n<p>A 'boxed' form, where the data in the value type is wrapped (boxed) into an object so it can exist as an independent entity.</p>\n</li></ul>\n<p>The <strong>unbox</strong> instruction converts the object reference (type <strong>O</strong>), the boxed representation of a value type, to a value type pointer (a managed pointer, type <strong>&</strong>), its unboxed form. The supplied value type (<em>valType</em>) is a metadata token indicating the type of value type contained within the boxed object.</p>\n<p>Unlike <xref href=\"System.Reflection.Emit.OpCodes.Box\" data-throw-if-not-resolved=\"false\"></xref>, which is required to make a copy of a value type for use in the object, <strong>unbox</strong> is not required to copy the value type from the object. Typically it simply computes the address of the value type that is already present inside of the boxed object.</p>\n<p>\n<xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object is not boxed as <em>valType</em>.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the object reference is a null reference.</p>\n<p>\n<xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the value type <em>valType</em> cannot be found. This is typically detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>unbox</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Unbox
    content.vb: Public Shared ReadOnly Unbox As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Unbox_Any
  commentId: F:System.Reflection.Emit.OpCodes.Unbox_Any
  id: Unbox_Any
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Unbox_Any
  fullName: System.Reflection.Emit.OpCodes.Unbox_Any
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Unbox_Any
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 418
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Converts the boxed representation of a type specified in the instruction to its unboxed form. </p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft intermediate language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format</p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An object reference <em>obj</em> is pushed onto the stack.</p>\n</li><li>\n<p>The object reference is popped from the stack and unboxed to the type specified in the instruction.</p>\n</li><li>\n<p>The resulting object reference or value type is pushed onto the stack.</p>\n</li></ol>\n<p>When applied to the boxed form of a value type, the <strong>unbox.any</strong> instruction extracts the value contained within <em>obj</em> (of type <strong>O</strong>), and is therefore equivalent to <strong>unbox</strong> followed by <strong>ldobj</strong>.</p>\n<p>When applied to a reference type, the <strong>unbox.any</strong> instruction has the same effect as <strong>castclass</strong> <em>typeTok</em>.</p>\n<p>If the operand <em>typeTok</em> is a generic type parameter, then the runtime behavior is determined by the type that is specified for that generic type parameter.</p>\n<p>\n<xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>obj</em> is not a boxed type.</p>\n<p>\n<xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if <em>obj</em> is a null reference.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>unbox.any</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode, Type) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Unbox_Any
    content.vb: Public Shared ReadOnly Unbox_Any As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Volatile
  commentId: F:System.Reflection.Emit.OpCodes.Volatile
  id: Volatile
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Volatile
  fullName: System.Reflection.Emit.OpCodes.Volatile
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Volatile
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 419
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Specifies that an address currently atop the evaluation stack might be volatile, and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>An address is pushed onto the stack.</p>\n</li></ol>\n<p>\n<strong>volatile</strong>. specifies that the address is a volatile address (that is, it can be referenced externally to the current thread of execution) and the results of reading that location cannot be cached or that multiple stores to that location cannot be suppressed. Marking an access as <strong>volatile</strong> affects only that single access; other accesses to the same location must be marked separately. Access to volatile locations need not be performed atomically.</p>\n<p>The <xref href=\"System.Reflection.Emit.OpCodes.Unaligned\" data-throw-if-not-resolved=\"false\"></xref> and <strong>volatile</strong> prefixes can be combined in either order. They must immediately precede a <strong>ldind</strong>, <strong>stind</strong>, <strong>ldfld</strong>, <strong>stfld</strong>, <strong>ldobj</strong>, <strong>stobj</strong>, <strong>initblk</strong>, or <strong>cpblk</strong> instruction. Only the <strong>volatile</strong> prefix is allowed for the <xref href=\"System.Reflection.Emit.OpCodes.Ldsfld\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Stsfld\" data-throw-if-not-resolved=\"false\"></xref> instructions.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>volatile</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Volatile
    content.vb: Public Shared ReadOnly Volatile As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.Xor
  commentId: F:System.Reflection.Emit.OpCodes.Xor
  id: Xor
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: Xor
  fullName: System.Reflection.Emit.OpCodes.Xor
  type: Field
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Xor
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 420
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Computes the bitwise XOR of the top two values on the evaluation stack, pushing the result onto the evaluation stack.</p>\n"
  remarks: "\n<p>The following table lists the instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along with a brief reference summary: </p>\n<p>Format </p>\n<p>Assembly Format </p>\n<p>Description </p>\n<p>The stack transitional behavior, in sequential order, is: </p>\n<ol><li>\n<p>\n<em>value1</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> is pushed onto the stack.</p>\n</li><li>\n<p>\n<em>value2</em> and <em>value1</em> are popped from the stack and their bitwise XOR computed.</p>\n</li><li>\n<p>\n  The bitwise XOR of <em>value2</em> and <em>value1</em> is pushed onto the stack.</p>\n</li></ol>\n<p>The <strong>xor</strong> instruction computes the bitwise XOR of the top two values on the stack and leaves the result on the stack.</p>\n<p>\n<strong>Xor</strong> is an integer-specific operation.</p>\n<p>The following <xref href=\"System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)\" data-throw-if-not-resolved=\"false\"></xref> method overload can use the <strong>xor</strong> opcode: </p>\n<ul><li>\n<p>ILGenerator.Emit(OpCode) </p>\n</li></ul>\n"
  syntax:
    content: public static readonly OpCode Xor
    content.vb: Public Shared ReadOnly Xor As OpCode
    return:
      type: System.Reflection.Emit.OpCode
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)
  commentId: M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)
  id: TakesSingleByteArgument(System.Reflection.Emit.OpCode)
  parent: System.Reflection.Emit.OpCodes
  langs:
  - csharp
  - vb
  name: TakesSingleByteArgument(OpCode)
  fullName: System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TakesSingleByteArgument
    path: src/System.Reflection.Primitives/ref/System.Reflection.Primitives.cs
    startLine: 421
  assemblies:
  - System.Reflection.Primitives
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns true or false if the supplied opcode takes a single byte argument.</p>\n"
  remarks: "\n<p>This method can be used to find which MSIL opcodes are \"short form\", for use in optimized code.</p>\n<p>\n<strong>TakesSingleByteArgument</strong> returns <strong>true</strong> if the <xref href=\"System.Reflection.Emit.OpCode\" data-throw-if-not-resolved=\"false\"></xref> instance takes a single byte argument in the following cases: </p>\n<ul><li>\n<p>The opcode performs a branch instruction to a byte-sized address (for example, <xref href=\"System.Reflection.Emit.OpCodes.Br_S\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Bgt_S\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n</li><li>\n<p>The opcode pushes a byte value onto the stack (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldc_I4_S\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n</li><li>\n<p>The opcode references a variable or argument via the byte-sized \"short form\" (for example, <xref href=\"System.Reflection.Emit.OpCodes.Ldloc_S\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Stloc_S\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n</li></ul>\n<p>Otherwise, it returns <strong>false</strong>.</p>\n<p>The example below demonstrates the use of <strong>TakesSingleByteArgument</strong> by reflecting on to the <strong>OpCodes</strong> class and testing to see whether each <strong>OpCode</strong> field takes a single-byte argument.</p>System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1"
  syntax:
    content: public static bool TakesSingleByteArgument(OpCode inst)
    content.vb: Public Shared Function TakesSingleByteArgument(inst As OpCode) As Boolean
    parameters:
    - id: inst
      type: System.Reflection.Emit.OpCode
      description: "\n<p>An instance of an Opcode object. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>True</strong> or <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: System.Reflection.Emit
  isExternal: false
  name: System.Reflection.Emit
  fullName: System.Reflection.Emit
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Reflection.Emit.OpCode
  parent: System.Reflection.Emit
  isExternal: false
  name: OpCode
  fullName: System.Reflection.Emit.OpCode
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
