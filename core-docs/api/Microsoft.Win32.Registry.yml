items:
- uid: Microsoft.Win32.Registry
  commentId: T:Microsoft.Win32.Registry
  id: Registry
  parent: Microsoft.Win32
  children:
  - Microsoft.Win32.Registry.ClassesRoot
  - Microsoft.Win32.Registry.CurrentConfig
  - Microsoft.Win32.Registry.CurrentUser
  - Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  - Microsoft.Win32.Registry.LocalMachine
  - Microsoft.Win32.Registry.PerformanceData
  - Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  - Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  - Microsoft.Win32.Registry.Users
  langs:
  - csharp
  - vb
  name: Registry
  fullName: Microsoft.Win32.Registry
  type: Class
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Registry
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 17
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Provides <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the root keys in the Windows registry, and <strong>static</strong> methods to access key/value pairs.</p>\n"
  remarks: "\n<p>This class provides the set of standard root keys found in the registry on machines running Windows. The registry is a storage facility for information about applications, users, and default system settings. For example, applications can use the registry for storing information that needs to be preserved after the application is closed, and access that same information when the application is reloaded. For instance, you can store color preferences, screen locations, or the size of the window. You can control this data for each user by storing the information in a different location in the registry.</p>\n<p>The base, or root <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> instances that are exposed by the <strong>Registry</strong> class delineate the basic storage mechanism for subkeys and values in the registry. All keys are read-only because the registry depends on their existence. The keys exposed by <strong>Registry</strong> are: </p>\n<xref href=\"Microsoft.Win32.Registry.CurrentUser\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores information about user preferences. </p>\n<xref href=\"Microsoft.Win32.Registry.LocalMachine\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores configuration information for the local machine. </p>\n<xref href=\"Microsoft.Win32.Registry.ClassesRoot\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores information about types (and classes) and their properties. </p>\n<xref href=\"Microsoft.Win32.Registry.Users\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores information about the default user configuration. </p>\n<xref href=\"Microsoft.Win32.Registry.PerformanceData\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores performance information for software components. </p>\n<xref href=\"Microsoft.Win32.Registry.CurrentConfig\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores non-user-specific hardware information. </p>\n<xref href=\"Microsoft.Win32.Registry.DynData\" data-throw-if-not-resolved=\"false\"></xref>\n<p>Stores dynamic data. </p>\n<p>Once you have identified the root key under which you want to store/retrieve information from the registry, you can use the <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> class to add or remove subkeys, and manipulate the values for a given key.</p>\n<p>Hardware devices can place information in the registry automatically using the Plug and Play interface. Software for installing device drivers can place information in the registry by writing to standard APIs.</p>\n"
  example:
  - >-
    <p>This section contains two code examples. The first example demonstrates root keys, and the second example demonstrates the <strong>static</strong><xref href="Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)" data-throw-if-not-resolved="false"></xref> and <see cref="Overload:Microsoft.Win32.Registry.SetValue"></see> methods.</p>

    <p>Example 1</p>

    <p>The following code example demonstrates how to retrieve the subkeys of the HKEY_USERS key, and print their names to the screen. Use the <xref href="Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)" data-throw-if-not-resolved="false"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <strong>RegistryKey</strong> to manipulate that key.</p>Classic Registry.Users Example#1<p>Example 2</p><p>The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of <em>defaultValue</em> when a name/value pair does not exist.</p>Microsoft.Win32.Registry.GetSet#1
  syntax:
    content: 'public class Registry : object'
    content.vb: >-
      Public Class Registry
          Inherits Object
  seealso:
  - type: Microsoft.Win32.RegistryHive
    commentId: T:Microsoft.Win32.RegistryHive
  - type: Microsoft.Win32.RegistryKey
    commentId: T:Microsoft.Win32.RegistryKey
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: Microsoft.Win32.Registry.ClassesRoot
  commentId: F:Microsoft.Win32.Registry.ClassesRoot
  id: ClassesRoot
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: ClassesRoot
  fullName: Microsoft.Win32.Registry.ClassesRoot
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ClassesRoot
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 38
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Defines the types (or classes) of documents and the properties associated with those types. This field reads the Windows registry base key HKEY_CLASSES_ROOT.</p>\n"
  remarks: "\n<p>Both conventional applications and OLE applications use data that is stored under this key. This key also provides backward compatibility with the Windows 3.1 registration database by storing information for DDE and OLE support. File viewers and user interface extensions store their OLE class identifiers in this key, and processing servers are registered in this key.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key.</p>Classic Registry.ClassesRoot Example#1"
  syntax:
    content: public static readonly RegistryKey ClassesRoot
    content.vb: Public Shared ReadOnly ClassesRoot As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.CurrentConfig
  commentId: F:Microsoft.Win32.Registry.CurrentConfig
  id: CurrentConfig
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: CurrentConfig
  fullName: Microsoft.Win32.Registry.CurrentConfig
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CurrentConfig
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 59
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Contains configuration information pertaining to the hardware that is not specific to the user. This field reads the Windows registry base key HKEY_CURRENT_CONFIG.</p>\n"
  remarks: "\n<p>This member is mapped to a subkey within <xref href=\"Microsoft.Win32.Registry.LocalMachine\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>An example of using this member is an application that stores a different server name for its data depending on whether the system is attached to a network.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key.</p>Classic Registry.CurrentConfig Example#1"
  syntax:
    content: public static readonly RegistryKey CurrentConfig
    content.vb: Public Shared ReadOnly CurrentConfig As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.CurrentUser
  commentId: F:Microsoft.Win32.Registry.CurrentUser
  id: CurrentUser
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: CurrentUser
  fullName: Microsoft.Win32.Registry.CurrentUser
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CurrentUser
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 24
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Contains information about the current user preferences. This field reads the Windows registry base key HKEY_CURRENT_USER </p>\n"
  remarks: "\n<p>Information stored in this key includes the settings of environment variables and data about program groups, colors, printers, network connections, and application preferences. This key makes it easier to establish the current user's settings. In this key, software vendors store the current user-specific preferences to be used within their applications. Microsoft, for example, creates the HKEY_CURRENT_USER\\Software\\Microsoft key for its applications to use, with each application creating its own subkey under the Microsoft key.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key.</p>Classic Registry.CurrentUser Example#1"
  syntax:
    content: public static readonly RegistryKey CurrentUser
    content.vb: Public Shared ReadOnly CurrentUser As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.LocalMachine
  commentId: F:Microsoft.Win32.Registry.LocalMachine
  id: LocalMachine
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: LocalMachine
  fullName: Microsoft.Win32.Registry.LocalMachine
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LocalMachine
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 31
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Contains the configuration data for the local machine. This field reads the Windows registry base key HKEY_LOCAL_MACHINE.</p>\n"
  remarks: "\n<p>\n<strong>LocalMachine</strong> contains five keys: </p>           Hardware <p>Describes the physical hardware in the computer, the way device drivers use that hardware, and mappings and related data that link kernel-mode drivers with user-mode code. All data in this key is recreated each time the system is started. The Description subkey describes the actual computer hardware. The DeviceMap subkey contains miscellaneous data in formats specific to particular classes of drivers. The ResourceMap subkey describes which device drivers claim which hardware resources. The Windows NT Diagnostics program (Winmsdp.exe) can report on its contents in an easy-to-read form. </p>           SAM<p>The directory services database of security information for user and group accounts, and for the domains in Windows 2000 Server (SAM is the Security Account Manager, known as the directory services database). </p>           Security <p>Contains the local security policy, such as specific user rights. This key is used only by the Windows 2000 security subsystem. </p>           Software <p>The per-computer software database. This key contains data about software installed on the local computer, along with various items of miscellaneous configuration data. </p>           System <p>Controls system startup, device driver loading, Windows 2000 services, and operating system behavior. </p><p>By convention, if similar data exists under <xref href=\"Microsoft.Win32.Registry.CurrentUser\" data-throw-if-not-resolved=\"false\"></xref> and under <xref href=\"Microsoft.Win32.Registry.LocalMachine\" data-throw-if-not-resolved=\"false\"></xref>, the data in <xref href=\"Microsoft.Win32.Registry.CurrentUser\" data-throw-if-not-resolved=\"false\"></xref> takes precedence. However, values in this key can also extend (rather than replace) data in Registry.LocalMachine. Also, some items (such as device driver loading entries) are meaningless if they occur outside of Registry.LocalMachine.</p>"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key.</p>Classic Registry.LocalMachine Example#1"
  syntax:
    content: public static readonly RegistryKey LocalMachine
    content.vb: Public Shared ReadOnly LocalMachine As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.PerformanceData
  commentId: F:Microsoft.Win32.Registry.PerformanceData
  id: PerformanceData
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: PerformanceData
  fullName: Microsoft.Win32.Registry.PerformanceData
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PerformanceData
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 52
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Contains performance information for software components. This field reads the Windows registry base key HKEY_PERFORMANCE_DATA.</p>\n"
  remarks: "\n<p>Each software component creates keys for its objects, counters when it is installed, and writes counter data while it is executing. You can access this data as you would access any other registry data, using the <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> functions.</p>\n<p>Although you use the registry to collect performance data, the data is not stored in the registry database. Instead, accessing the registry with this key causes the system to collect the data from the appropriate system object managers.</p>\n<p>To obtain performance data from the local system, use the <xref href=\"Microsoft.Win32.RegistryKey.GetValue(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, with the Registry.PerformanceData key. The first call opens the key (you do not need to explicitly open the key first). However, be sure to use the <xref href=\"Microsoft.Win32.RegistryKey.Close\" data-throw-if-not-resolved=\"false\"></xref> method to close the handle to the key when you are finished obtaining performance data. The user cannot install or remove a software component while its performance data is in use.</p>\n<p>To obtain performance data from a remote system, you must use the <xref href=\"Microsoft.Win32.RegistryKey.OpenRemoteBaseKey(Microsoft.Win32.RegistryHive,System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, with the computer name of the remote system and the Registry.PerformanceData key. This call retrieves a key representing the performance data for the remote system. To retrieve the data, call <xref href=\"Microsoft.Win32.RegistryKey.GetValue(System.String)\" data-throw-if-not-resolved=\"false\"></xref> using this key, rather than the Registry.PerformanceData key.</p>\n<p>On Windows Server 2003, a user must at least belong to the Performance Monitor Users group in order to access subkeys of this base key. </p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key. Note that this example can often return no results, since there might be no performance data.</p>Classic Registry.PerformanceData Example#1"
  syntax:
    content: public static readonly RegistryKey PerformanceData
    content.vb: Public Shared ReadOnly PerformanceData As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.Users
  commentId: F:Microsoft.Win32.Registry.Users
  id: Users
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: Users
  fullName: Microsoft.Win32.Registry.Users
  type: Field
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Users
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 45
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Contains information about the default user configuration. This field reads the Windows registry base key HKEY_USERS.</p>\n"
  remarks: "\n<p>This key contains a branch for each user of the computer. The default configuration is supplied for new users on the local computer and for the default current user if the user has not changed preferences. Because Windows 98/ME also supports Registry.Users, applications can access the user-specific information the same way they do under Windows 2000. Each user's information is stored in a separate file, which can be stored locally or on a network server. Windows 98/ME can copy this file to the user's current system so that settings can move from one computer to another with the user.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve the subkeys of this key, and prints their names to the screen. Use the <xref href=\"Microsoft.Win32.RegistryKey.OpenSubKey(System.String,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to create an instance of the particular subkey of interest. You can then use other operations in <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> to manipulate that key.</p>Classic Registry.Users Example#1"
  syntax:
    content: public static readonly RegistryKey Users
    content.vb: Public Shared ReadOnly Users As RegistryKey
    return:
      type: Microsoft.Win32.RegistryKey
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  commentId: M:Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)
  id: GetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: GetValue(String, String, Object)
  fullName: Microsoft.Win32.Registry.GetValue(System.String, System.String, System.Object)
  type: Method
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetValue
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 121
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Retrieves the value associated with the specified name, in the specified registry key. If the name is not found in the specified key, returns a default value that you provide, or <strong>null</strong> if the specified key does not exist. </p>\n"
  remarks: "\n<p>The string <em>valueName</em> is not case-sensitive.</p>\n<p>A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To retrieve this unnamed value, specify either <strong>null</strong> or the empty string (\"\") for <em>valuName</em>.</p>\n<p>Valid root names are HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" accesses key/value pairs for the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root. </p>\n<p>When the <xref href=\"Microsoft.Win32.RegistryKey.GetValue(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method retrieves expandable string values (<xref href=\"Microsoft.Win32.RegistryValueKind.ExpandString\" data-throw-if-not-resolved=\"false\"></xref>), it expands environment strings using data from the local environment. If a value containing expandable references to environment variables has been stored as a string (<xref href=\"Microsoft.Win32.RegistryValueKind.String\" data-throw-if-not-resolved=\"false\"></xref>), rather than as an expandable string (<xref href=\"Microsoft.Win32.RegistryValueKind.ExpandString\" data-throw-if-not-resolved=\"false\"></xref>), <xref href=\"Microsoft.Win32.RegistryKey.GetValue(System.String)\" data-throw-if-not-resolved=\"false\"></xref> does not expand it. You can expand such a string after it has been retrieved by calling the <xref href=\"System.Environment.ExpandEnvironmentVariables(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The recommended way to retrieve data from HKEY_PERFORMANCE_DATA is to use the <xref href=\"System.Diagnostics.PerformanceCounter\" data-throw-if-not-resolved=\"false\"></xref> class rather than the <see cref=\"Overload:Microsoft.Win32.RegistryKey.GetValue\"></see> method.</p>\n<p>The <xref href=\"Microsoft.Win32.Registry.GetValue(System.String,System.String,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <see cref=\"Overload:Microsoft.Win32.Registry.SetValue\"></see> methods open and close registry keys each time they are used, so they do not perform as well as the methods of the <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> class if you access a large number of values.</p>\n<p>\n<xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</p>\n"
  example:
  - "\n<p>The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of <em>defaultValue</em> when a name/value pair does not exist.</p>Microsoft.Win32.Registry.GetSet#1"
  syntax:
    content: public static object GetValue(string keyName, string valueName, object defaultValue)
    content.vb: Public Shared Function GetValue(keyName As String, valueName As String, defaultValue As Object) As Object
    parameters:
    - id: keyName
      type: System.String
    - id: valueName
      type: System.String
    - id: defaultValue
      type: System.Object
    return:
      type: System.Object
  exceptions:
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>The user does not have the permissions required to read from the registry key. </p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>The <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> that contains the specified value has been marked for deletion. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>keyName</em> does not begin with a valid registry root. </p>\n"
  see:
  - type: System.Security.Permissions.RegistryPermission
    commentId: T:System.Security.Permissions.RegistryPermission
  - type: System.Security.Permissions.EnvironmentPermission
    commentId: T:System.Security.Permissions.EnvironmentPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  commentId: M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object)
  id: SetValue(System.String,System.String,System.Object)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: SetValue(String, String, Object)
  fullName: Microsoft.Win32.Registry.SetValue(System.String, System.String, System.Object)
  type: Method
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetValue
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 142
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Sets the specified name/value pair on the specified registry key. If the specified key does not exist, it is created.</p>\n"
  remarks: "\n<p>Starting with the .NET Framework 4, the <em>valueName</em> parameter is no longer restricted to a maximum of 255 characters; however, the <em>keyName</em> parameter continues to have the 255-character restriction.</p>\n<p>Because many values can be stored in each key in the registry, you must use the <em>valueName</em> parameter to specify the particular value you want to set.</p>\n<p>A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To set this unnamed value, specify either <strong>null</strong> or the empty string (\"\") for <em>valueName</em>.</p>\n<p>If <em>valueName</em> does not exist in the key, it is created and the associated value is set to <em>value</em>.</p>\n<p>If <em>keyName</em> specifies a subkey that does not exist, the subkey is created in the specified root. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" creates the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root. The string \"HKEY_CURRENT_USER\\MyTestKey\\Key2\\Key3\" creates the nested subkeys \"MyTestKey\", \"MyTestKey\\Key2\", and \"MyTestKey\\Key2\\Key3\".</p>\n<p>Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</p>\n<p>The <see cref=\"Overload:Microsoft.Win32.Registry.SetValue\"></see> method opens a registry key, sets the value, and closes the key each time it is called. If you need to modify a large number of values, the <see cref=\"Overload:Microsoft.Win32.RegistryKey.SetValue\"></see> method might provide better performance. The <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</p>\n<p>This overload of <see cref=\"Overload:Microsoft.Win32.Registry.SetValue\"></see> stores 64-bit integers as strings (<xref href=\"Microsoft.Win32.RegistryValueKind.String\" data-throw-if-not-resolved=\"false\"></xref>). To store 64-bit numbers as <xref href=\"Microsoft.Win32.RegistryValueKind.QWord\" data-throw-if-not-resolved=\"false\"></xref> values, use the <xref href=\"Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)\" data-throw-if-not-resolved=\"false\"></xref> method overload.</p>\n<p>This overload of <see cref=\"Overload:Microsoft.Win32.Registry.SetValue\"></see> stores all string values as <xref href=\"Microsoft.Win32.RegistryValueKind.String\" data-throw-if-not-resolved=\"false\"></xref> objects, even if they contain expandable references to environment variables. To save string values as expandable strings (<xref href=\"Microsoft.Win32.RegistryValueKind.ExpandString\" data-throw-if-not-resolved=\"false\"></xref>), use the <xref href=\"Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)\" data-throw-if-not-resolved=\"false\"></xref> method overload.</p>\n<p>This overload is equivalent to calling the <xref href=\"Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)\" data-throw-if-not-resolved=\"false\"></xref> method overload with <xref href=\"Microsoft.Win32.RegistryValueKind.Unknown\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages. A Unicode character that is invalid for the current code page is replaced by the best available match. No exception is thrown.</p>\n"
  example:
  - "\n<p>The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of <em>defaultValue</em> when a name/value pair does not exist.</p>Microsoft.Win32.Registry.GetSet#1"
  syntax:
    content: public static void SetValue(string keyName, string valueName, object value)
    content.vb: Public Shared Sub SetValue(keyName As String, valueName As String, value As Object)
    parameters:
    - id: keyName
      type: System.String
    - id: valueName
      type: System.String
    - id: value
      type: System.Object
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>value</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>keyName</em> does not begin with a valid registry root. </p>\n<p>-or-</p>\n<p>\n<em>keyName</em> is longer than the maximum length allowed (255 characters).</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> is read-only, and thus cannot be written to; for example, it is a root-level node. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>The user does not have the permissions required to create or modify registry keys. </p>\n"
  see:
  - type: System.Security.Permissions.RegistryPermission
    commentId: T:System.Security.Permissions.RegistryPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  commentId: M:Microsoft.Win32.Registry.SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  id: SetValue(System.String,System.String,System.Object,Microsoft.Win32.RegistryValueKind)
  parent: Microsoft.Win32.Registry
  langs:
  - csharp
  - vb
  name: SetValue(String, String, Object, RegistryValueKind)
  fullName: Microsoft.Win32.Registry.SetValue(System.String, System.String, System.Object, Microsoft.Win32.RegistryValueKind)
  type: Method
  source:
    remote:
      path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetValue
    path: src/Microsoft.Win32.Registry/src/Microsoft/Win32/Registry.cs
    startLine: 147
  assemblies:
  - Microsoft.Win32.Registry
  namespace: Microsoft.Win32
  summary: "\n<p>Sets the name/value pair on the specified registry key, using the specified registry data type. If the specified key does not exist, it is created.</p>\n"
  remarks: "\n<p>Starting with the .NET Framework 4, the <em>valueName</em> parameter is no longer restricted to a maximum of 255 characters; however, the <em>keyName</em> parameter continues have the 255-character restriction.</p>\n<p>Because many values can be stored in each key in the registry, you must use the <em>valueName</em> parameter to specify the particular value you want to set.</p>\n<p>A registry key can contain one value that is not associated with any name. When this unnamed value is displayed in the registry editor, the string \"(Default)\" appears instead of a name. To set this unnamed value, specify either <strong>null</strong> or the empty string (\"\") for <em>valueName</em>.</p>\n<p>If <em>valueName</em> does not exist in the key, it is created and the associated value is set to <em>value</em>.</p>\n<p>If <em>keyName</em> specifies a subkey that does not exist, the subkey is created in the specified root. For example, in Visual Basic the string \"HKEY_CURRENT_USER\\MyTestKey\" creates the subkey \"MyTestKey\" in the HKEY_CURRENT_USER root. The string \"HKEY_CURRENT_USER\\MyTestKey\\Key2\\Key3\" creates the nested subkeys \"MyTestKey\", \"MyTestKey\\Key2\", and \"MyTestKey\\Key2\\Key3\".</p>\n<p>Valid root names include HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_PERFORMANCE_DATA, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA.</p>\n<p>The <see cref=\"Overload:Microsoft.Win32.Registry.SetValue\"></see> method opens a registry key, sets the value, and closes the key each time it is called. If you need to modify a large number of values, the <see cref=\"Overload:Microsoft.Win32.RegistryKey.SetValue\"></see> method might provide better performance. The <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> class also provides methods that allow you to add an access control list (ACL) to a registry key, to test the data type of a value before retrieving it, and to delete keys.</p>\n<p>If the type of the specified <em>value</em> does not match the specified <em>valueKind</em>, and the data cannot be converted, <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref> is thrown. For example, you can store a <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> as a <xref href=\"Microsoft.Win32.RegistryValueKind.DWord\" data-throw-if-not-resolved=\"false\"></xref>, but only if its value is less than the maximum value of a <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>. You cannot store a single string value as a <xref href=\"Microsoft.Win32.RegistryValueKind.MultiString\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If boxed values are passed for <xref href=\"Microsoft.Win32.RegistryValueKind.DWord\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"Microsoft.Win32.RegistryValueKind.QWord\" data-throw-if-not-resolved=\"false\"></xref>, the conversion is done using the invariant culture.</p>\n<p>On Windows 98 and Windows Millennium Edition (Windows Me), the registry is not Unicode, and not all Unicode characters are valid for all code pages. A Unicode character that is invalid for the current code page is replaced by the best available match. No exception is thrown.</p>\n"
  example:
  - "\n<p>The following code example stores values of several data types in an example key, creating the key as it does so, and then retrieves and displays the values. The example demonstrates storing and retrieving the default (nameless) name/value pair, and the use of <em>defaultValue</em> when a name/value pair does not exist.</p>Microsoft.Win32.Registry.GetSet#1"
  syntax:
    content: public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind)
    content.vb: Public Shared Sub SetValue(keyName As String, valueName As String, value As Object, valueKind As RegistryValueKind)
    parameters:
    - id: keyName
      type: System.String
    - id: valueName
      type: System.String
    - id: value
      type: System.Object
    - id: valueKind
      type: Microsoft.Win32.RegistryValueKind
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>value</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>keyName</em> does not begin with a valid registry root.</p>\n<p>-or-</p>\n<p>\n<em>keyName</em> is longer than the maximum length allowed (255 characters).</p>\n<p>-or- </p>\n<p>The type of <em>value</em> did not match the registry data type specified by <em>valueKind</em>, therefore the data could not be converted properly. </p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The <xref href=\"Microsoft.Win32.RegistryKey\" data-throw-if-not-resolved=\"false\"></xref> is read-only, and thus cannot be written to; for example, it is a root-level node, or the key has not been opened with write access. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>The user does not have the permissions required to create or modify registry keys. </p>\n"
  see:
  - type: System.Security.Permissions.RegistryPermission
    commentId: T:System.Security.Permissions.RegistryPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: Microsoft.Win32
  isExternal: false
  name: Microsoft.Win32
  fullName: Microsoft.Win32
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: Microsoft.Win32.RegistryKey
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryKey
  fullName: Microsoft.Win32.RegistryKey
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: Microsoft.Win32.RegistryValueKind
  parent: Microsoft.Win32
  isExternal: false
  name: RegistryValueKind
  fullName: Microsoft.Win32.RegistryValueKind
- uid: System.Security.SecurityException
  isExternal: false
  name: SecurityException
  fullName: System.Security.SecurityException
- uid: System.IO.IOException
  parent: System.IO
  isExternal: false
  name: IOException
  fullName: System.IO.IOException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.UnauthorizedAccessException
  isExternal: false
  name: UnauthorizedAccessException
  fullName: System.UnauthorizedAccessException
