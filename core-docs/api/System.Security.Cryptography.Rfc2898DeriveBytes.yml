items:
- uid: System.Security.Cryptography.Rfc2898DeriveBytes
  commentId: T:System.Security.Cryptography.Rfc2898DeriveBytes
  id: Rfc2898DeriveBytes
  parent: System.Security.Cryptography
  children:
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  - System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  - System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  - System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  - System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes
  type: Class
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Rfc2898DeriveBytes
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 104
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on <xref href=\"System.Security.Cryptography.HMACSHA1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class to create two identical keys for the <xref href=\"System.Security.Cryptography.TripleDES\" data-throw-if-not-resolved=\"false\"></xref> class.  It then encrypts and decrypts some data using the keys.</p>rfc28981#1"
  syntax:
    content: 'public class Rfc2898DeriveBytes : DeriveBytes, IDisposable'
    content.vb: >-
      Public Class Rfc2898DeriveBytes
          Inherits DeriveBytes
          Implements IDisposable
  inheritance:
  - System.Object
  - System.Security.Cryptography.DeriveBytes
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Security.Cryptography.DeriveBytes.Dispose
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
  id: '#ctor(System.Byte[],System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes(Byte[], Byte[], Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.Byte[], System.Byte[], System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 106
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class using a password, a salt, and number of iterations to derive the key.</p>\n"
  remarks: "\n<p>The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  syntax:
    content: public Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations)
    content.vb: Public Sub New(password As Byte(), salt As Byte(), iterations As Integer)
    parameters:
    - id: password
      type: System.Byte[]
      description: "\n<p>The password used to derive the key. </p>\n"
    - id: salt
      type: System.Byte[]
      description: "\n<p>The key salt used to derive the key.</p>\n"
    - id: iterations
      type: System.Int32
      description: "\n<p>The number of iterations for the operation. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes or the iteration count is less than 1. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The password or salt is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.Byte(), System.Byte(), System.Int32)
  name.vb: Rfc2898DeriveBytes(Byte(), Byte(), Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
  id: '#ctor(System.String,System.Byte[])'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes(String, Byte[])
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Byte[])
  type: Constructor
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 107
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class using a password and salt to derive the key.</p>\n"
  remarks: "\n<p>The salt size must be 8 bytes or larger.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class to create two identical keys for the <xref href=\"System.Security.Cryptography.TripleDES\" data-throw-if-not-resolved=\"false\"></xref> class.  It then encrypts and decrypts some data using the keys.</p>rfc28981#1"
  syntax:
    content: public Rfc2898DeriveBytes(string password, byte[] salt)
    content.vb: Public Sub New(password As String, salt As Byte())
    parameters:
    - id: password
      type: System.String
      description: "\n<p>The password used to derive the key. </p>\n"
    - id: salt
      type: System.Byte[]
      description: "\n<p>The key salt used to derive the key. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes or the iteration count is less than 1. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The password or salt is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Byte())
  name.vb: Rfc2898DeriveBytes(String, Byte())
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
  id: '#ctor(System.String,System.Byte[],System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes(String, Byte[], Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Byte[], System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 108
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class using a password, a salt, and number of iterations to derive the key.</p>\n"
  remarks: "\n<p>The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class to create two identical keys for the <xref href=\"System.Security.Cryptography.TripleDES\" data-throw-if-not-resolved=\"false\"></xref> class.  It then encrypts and decrypts some data using the keys.</p>rfc28981#1"
  syntax:
    content: public Rfc2898DeriveBytes(string password, byte[] salt, int iterations)
    content.vb: Public Sub New(password As String, salt As Byte(), iterations As Integer)
    parameters:
    - id: password
      type: System.String
      description: "\n<p>The password used to derive the key. </p>\n"
    - id: salt
      type: System.Byte[]
      description: "\n<p>The key salt used to derive the key. </p>\n"
    - id: iterations
      type: System.Int32
      description: "\n<p>The number of iterations for the operation. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes or the iteration count is less than 1. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The password or salt is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Byte(), System.Int32)
  name.vb: Rfc2898DeriveBytes(String, Byte(), Int32)
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
  id: '#ctor(System.String,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes(String, Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 109
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class using the password and salt size to derive the key.</p>\n"
  remarks: "\n<p>The salt size must be 8 bytes or larger.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information about PBKDF2, see RFC 2898, \"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  syntax:
    content: public Rfc2898DeriveBytes(string password, int saltSize)
    content.vb: Public Sub New(password As String, saltSize As Integer)
    parameters:
    - id: password
      type: System.String
      description: "\n<p>The password used to derive the key. </p>\n"
    - id: saltSize
      type: System.Int32
      description: "\n<p>The size of the random salt that you want the class to generate. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The password or salt is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
  id: '#ctor(System.String,System.Int32,System.Int32)'
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Rfc2898DeriveBytes(String, Int32, Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Rfc2898DeriveBytes(System.String, System.Int32, System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 110
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class using a password, a salt size, and number of iterations to derive the key.</p>\n"
  remarks: "\n<p>The salt size must be 8 bytes or larger and the iteration count must be greater than zero. The minimum recommended number of iterations is 1000.</p>\n<p>RFC 2898 includes methods for creating a key and initialization vector (IV) from a password and salt. You can use PBKDF2, a password-based key derivation function, to derive keys using a pseudo-random function that allows keys of virtually unlimited length to be generated. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class can be used to produce a derived key from a base key and other parameters. In a password-based key derivation function, the base key is a password and the other parameters are a salt value and an iteration count.</p>\n<p>For more information on PBKDF2, see RFC 2898,\"PKCS #5: Password-Based Cryptography Specification Version 2.0,\" available on the <see href=\"http://go.microsoft.com/fwlink/?LinkID=37119\">Request for Comments Web site</see>. See section 5.2, \"PBKDF2,\" for complete details.</p>\n<p>Never hard-code a password within your source code.  Hard-coded passwords can be retrieved from an assembly by using the Ildasm.exe (IL Disassembler), by using a hexadecimal editor, or by simply opening up the assembly in a text editor such as Notepad.exe. </p>\n"
  syntax:
    content: public Rfc2898DeriveBytes(string password, int saltSize, int iterations)
    content.vb: Public Sub New(password As String, saltSize As Integer, iterations As Integer)
    parameters:
    - id: password
      type: System.String
      description: "\n<p>The password used to derive the key. </p>\n"
    - id: saltSize
      type: System.Int32
      description: "\n<p>The size of the random salt that you want the class to generate. </p>\n"
    - id: iterations
      type: System.Int32
      description: "\n<p>The number of iterations for the operation. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes or the iteration count is less than 1. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The password or salt is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>iterations </em>is out of range. This parameter requires a non-negative number.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  commentId: P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  id: IterationCount
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: IterationCount
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount
  type: Property
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IterationCount
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 111
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Gets or sets the number of iterations for the operation.</p>\n"
  remarks: "\n<p>Iteration count is the number of times an operation is performed. For this method, the count should be greater than zero. The minimum recommended number of iterations is 1000.</p>\n"
  example:
  - "\n<p>The following example shows how to use the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount\" data-throw-if-not-resolved=\"false\"></xref> property to display the number of iterations used in the generation of the key. This code example is part of a larger example provided for the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class.</p>rfc28981#3"
  syntax:
    content: public int IterationCount { get; set; }
    content.vb: Public Property IterationCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The number of iterations for the operation.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The number of iterations is less than 1. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  commentId: P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  id: Salt
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Salt
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Salt
  type: Property
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Salt
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 112
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Gets or sets the key salt value for the operation.</p>\n"
  remarks: "\n<p>Salt, a random set of bytes, is used to make unauthorized decrypting of a message more difficult. A dictionary attack is an attack in which the attacker attempts to decrypt an encrypted message by comparing the encrypted value with previously computed encrypted values for the most likely keys. This attack is made much more difficult by the introduction of salt, or random bytes, at the end of the password before the key derivation.</p>\n"
  syntax:
    content: public byte[] Salt { get; set; }
    content.vb: Public Property Salt As Byte()
    parameters: []
    return:
      type: System.Byte[]
      description: "\n<p>The key salt value for the operation.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The specified salt size is smaller than 8 bytes. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The salt is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 113
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class and optionally releases the managed resources.</p>\n"
  remarks: "\n<p>This method is called by the public <strong>Dispose()</strong> method and the <strong>Finalize</strong> method. <strong>Dispose()</strong> invokes the protected <strong>Dispose(Boolean)</strong> method with the <em>disposing</em> parameter set to <strong>true</strong>. <strong>Finalize</strong> invokes <strong>Dispose</strong> with <em>disposing</em> set to <strong>false</strong>.</p>\n<p>When the <em>disposing</em> parameter is <strong>true</strong>, this method releases all resources held by any managed objects that this <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> references. This method invokes the <strong>Dispose()</strong> method of each referenced object.</p>\n"
  syntax:
    content: protected override void Dispose(bool disposing)
    content.vb: Protected Overrides Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to release both managed and unmanaged resources; <strong>false</strong> to release only unmanaged resources. </p>\n"
  overridden: System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)
  modifiers.csharp:
  - protected
  - override
  modifiers.vb:
  - Protected
  - Overrides
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  id: GetBytes(System.Int32)
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: GetBytes(Int32)
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 114
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Returns the pseudo-random key for this object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class implements PBKDF2 functionality by using a pseudorandom number generator based on <xref href=\"System.Security.Cryptography.HMACSHA1\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class takes a password, a salt, and an iteration count, and then generates keys through calls to the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. Repeated calls to this method will not generate the same key; instead, appending two calls of the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method with a <em>cb</em> parameter value of <em>20</em> is the equivalent of calling the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method once with a <em>cb</em> parameter value of <em>40</em>.</p>\n"
  example:
  - "\n<p>The following example shows how to use the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to get the key for an instance of <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref>. This code example is part of a larger example provided for the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class.</p>rfc28981#2"
  syntax:
    content: public override byte[] GetBytes(int cb)
    content.vb: Public Overrides Function GetBytes(cb As Integer) As Byte()
    parameters:
    - id: cb
      type: System.Int32
      description: "\n<p>The number of pseudo-random key bytes to generate. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>A byte array filled with pseudo-random key bytes.</p>\n"
  overridden: System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>cb </em>is out of range. This parameter requires a non-negative number.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  commentId: M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset
  id: Reset
  parent: System.Security.Cryptography.Rfc2898DeriveBytes
  langs:
  - csharp
  - vb
  name: Reset()
  fullName: System.Security.Cryptography.Rfc2898DeriveBytes.Reset()
  type: Method
  source:
    remote:
      path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Reset
    path: src/System.Security.Cryptography.Algorithms/ref/4.0/System.Security.Cryptography.Algorithms.cs
    startLine: 115
  assemblies:
  - System.Security.Cryptography.Algorithms
  namespace: System.Security.Cryptography
  summary: "\n<p>Resets the state of the operation.</p>\n"
  remarks: "\n<p>This method is automatically called if the salt or iteration count is modified.</p>\n"
  example:
  - "\n<p>The following example shows how to use the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes.Reset\" data-throw-if-not-resolved=\"false\"></xref> method. This code example is part of a larger example provided for the <xref href=\"System.Security.Cryptography.Rfc2898DeriveBytes\" data-throw-if-not-resolved=\"false\"></xref> class.</p>rfc28981#5"
  syntax:
    content: public override void Reset()
    content.vb: Public Overrides Sub Reset
  overridden: System.Security.Cryptography.DeriveBytes.Reset
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
references:
- uid: System.Security.Cryptography
  isExternal: false
  name: System.Security.Cryptography
  fullName: System.Security.Cryptography
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Security.Cryptography.DeriveBytes
  parent: System.Security.Cryptography
  isExternal: false
  name: DeriveBytes
  fullName: System.Security.Cryptography.DeriveBytes
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Security.Cryptography.DeriveBytes.Dispose
  parent: System.Security.Cryptography.DeriveBytes
  isExternal: false
  name: Dispose()
  fullName: System.Security.Cryptography.DeriveBytes.Dispose()
  spec.csharp:
  - uid: System.Security.Cryptography.DeriveBytes.Dispose
    name: Dispose
    fullName: System.Security.Cryptography.DeriveBytes.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Security.Cryptography.DeriveBytes.Dispose
    name: Dispose
    fullName: System.Security.Cryptography.DeriveBytes.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Byte[]
  isExternal: true
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)
  parent: System.Security.Cryptography.DeriveBytes
  isExternal: true
  name: Dispose(Boolean)
  fullName: System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)
  spec.csharp:
  - uid: System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)
    name: Dispose
    fullName: System.Security.Cryptography.DeriveBytes.Dispose
  - name: (
    fullName: (
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Security.Cryptography.DeriveBytes.Dispose(System.Boolean)
    name: Dispose
    fullName: System.Security.Cryptography.DeriveBytes.Dispose
  - name: (
    fullName: (
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
  parent: System.Security.Cryptography.DeriveBytes
  isExternal: true
  name: GetBytes(Int32)
  fullName: System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
  spec.csharp:
  - uid: System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
    name: GetBytes
    fullName: System.Security.Cryptography.DeriveBytes.GetBytes
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
    name: GetBytes
    fullName: System.Security.Cryptography.DeriveBytes.GetBytes
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Security.Cryptography.DeriveBytes.Reset
  parent: System.Security.Cryptography.DeriveBytes
  isExternal: false
  name: Reset()
  fullName: System.Security.Cryptography.DeriveBytes.Reset()
  spec.csharp:
  - uid: System.Security.Cryptography.DeriveBytes.Reset
    name: Reset
    fullName: System.Security.Cryptography.DeriveBytes.Reset
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Security.Cryptography.DeriveBytes.Reset
    name: Reset
    fullName: System.Security.Cryptography.DeriveBytes.Reset
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
