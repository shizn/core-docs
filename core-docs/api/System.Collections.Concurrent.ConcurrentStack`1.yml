items:
- uid: System.Collections.Concurrent.ConcurrentStack`1
  commentId: T:System.Collections.Concurrent.ConcurrentStack`1
  id: ConcurrentStack`1
  parent: System.Collections.Concurrent
  children:
  - System.Collections.Concurrent.ConcurrentStack`1.#ctor
  - System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})
  - System.Collections.Concurrent.ConcurrentStack`1.Clear
  - System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)
  - System.Collections.Concurrent.ConcurrentStack`1.Count
  - System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator
  - System.Collections.Concurrent.ConcurrentStack`1.IsEmpty
  - System.Collections.Concurrent.ConcurrentStack`1.Push(`0)
  - System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])
  - System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot
  - System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator
  - System.Collections.Concurrent.ConcurrentStack`1.ToArray
  - System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)
  - System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)
  - System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])
  - System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)
  langs:
  - csharp
  - vb
  name: ConcurrentStack<T>
  fullName: System.Collections.Concurrent.ConcurrentStack<T>
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ConcurrentStack
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 45
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Represents a thread-safe last in-first out (LIFO) collection.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> implements the <xref href=\"System.Collections.Generic.IReadOnlyCollection`1\" data-throw-if-not-resolved=\"false\"></xref> interface starting with the .NET Framework 4.6; in previous versions of the .NET Framework, the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> class did not implement this interface. </p>\n<p>\n<xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> provides a few main operations:</p>\n<ul><li>\n<p>\n<xref href=\"System.Collections.Concurrent.ConcurrentStack`1.Push(`0)\" data-throw-if-not-resolved=\"false\"></xref> inserts an element at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>\n<xref href=\"System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)\" data-throw-if-not-resolved=\"false\"></xref> removes an element from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>, or returns <strong>false</strong> if the item cannot be removed.</p>\n</li><li>\n<p>\n<xref href=\"System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)\" data-throw-if-not-resolved=\"false\"></xref> returns an element that is at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> but does not remove it from the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>The <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])\" data-throw-if-not-resolved=\"false\"></xref> methods provide efficient pushing and popping of multiple elements in a single operation.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example shows how to use a <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> to push and pop individual items:</p>System.Collections.Concurrent.ConcurrentStack#2<p>The following example shows how to use a <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> to push and pop ranges of items:</p>System.Collections.Concurrent.ConcurrentStack#1"
  syntax:
    content: >-
      [DebuggerDisplay("Count = {Count}")]

      [DebuggerTypeProxy(typeof (SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView<>))]

      [HostProtection(Synchronization = true, ExternalThreading = true)]

      public class ConcurrentStack<T> : IProducerConsumerCollection<T>, ICollection, IReadOnlyCollection<T>, IEnumerable<T>, IEnumerable
    content.vb: >-
      <DebuggerDisplay("Count = {Count}")>

      <DebuggerTypeProxy(GetType(SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView(Of )))>

      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      Public Class ConcurrentStack(Of T)
          Implements IProducerConsumerCollection(Of T), ICollection, IReadOnlyCollection(Of T), IEnumerable(Of T), IEnumerable
    typeParameters:
    - id: T
      description: Specifies the type of elements in the stack.
  inheritance:
  - System.Object
  implements:
  - System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  - System.Collections.Generic.IReadOnlyCollection{{T}}
  - System.Collections.Generic.IEnumerable{{T}}
  - System.Collections.ICollection
  - System.Collections.IEnumerable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T)
  name.vb: ConcurrentStack(Of T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.#ctor
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.#ctor
  id: '#ctor'
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ConcurrentStack()
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.ConcurrentStack()
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 87
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - 
  syntax:
    content: public ConcurrentStack()
    content.vb: Public Sub New
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).ConcurrentStack()
- uid: System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.#ctor(System.Collections.Generic.IEnumerable{`0})
  id: '#ctor(System.Collections.Generic.IEnumerable{`0})'
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ConcurrentStack(IEnumerable<T>)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.ConcurrentStack(System.Collections.Generic.IEnumerable<T>)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 99
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> class that contains elements copied from the specified collection</p>\n"
  example:
  - 
  syntax:
    content: public ConcurrentStack(IEnumerable<T> collection)
    content.vb: Public Sub New(collection As IEnumerable(Of T))
    parameters:
    - id: collection
      type: System.Collections.Generic.IEnumerable{{T}}
      description: The collection whose elements are copied to the new <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>collection</em> argument is null.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).ConcurrentStack(System.Collections.Generic.IEnumerable(Of T))
  name.vb: ConcurrentStack(IEnumerable(Of T))
- uid: System.Collections.Concurrent.ConcurrentStack`1.Count
  commentId: P:System.Collections.Concurrent.ConcurrentStack`1.Count
  id: Count
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: Count
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.Count
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Count
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 199
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Gets the number of elements contained in the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For determining whether the collection contains any items, use of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.IsEmpty\" data-throw-if-not-resolved=\"false\"></xref> property is recommended rather than retrieving the number of items from the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.Count\" data-throw-if-not-resolved=\"false\"></xref> property and comparing it to 0.</p>\n"
  example:
  - 
  syntax:
    content: public int Count { get; }
    content.vb: Public ReadOnly Property Count As Integer
    parameters: []
    return:
      type: System.Int32
      description: The number of elements contained in the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  implements:
  - System.Collections.Generic.IReadOnlyCollection{{T}}.Count
  - System.Collections.ICollection.Count
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).Count
- uid: System.Collections.Concurrent.ConcurrentStack`1.IsEmpty
  commentId: P:System.Collections.Concurrent.ConcurrentStack`1.IsEmpty
  id: IsEmpty
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: IsEmpty
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.IsEmpty
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsEmpty
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 181
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Gets a value that indicates whether the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> is empty.</p>\n"
  remarks: "\n<p>For determining whether the collection contains any items, use of this property is recommended rather than retrieving the number of items from the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.Count\" data-throw-if-not-resolved=\"false\"></xref> property and comparing it to 0. However, as this collection is intended to be accessed concurrently, it may be the case that another thread will modify the collection after <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.IsEmpty\" data-throw-if-not-resolved=\"false\"></xref> returns, thus invalidating the result.</p>\n<p>For a code example, see <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public bool IsEmpty { get; }
    content.vb: Public ReadOnly Property IsEmpty As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: true if the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref> is empty; otherwise, false.
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).IsEmpty
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized
  commentId: P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#IsSynchronized
  id: System#Collections#ICollection#IsSynchronized
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ICollection.IsSynchronized
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.ICollection.IsSynchronized
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.ICollection.IsSynchronized
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 231
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Gets a value indicating whether access to the <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> is synchronized with the SyncRoot.</p>\n"
  example:
  - 
  syntax:
    content: bool ICollection.IsSynchronized { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.ICollection.IsSynchronized As Boolean Implements ICollection.IsSynchronized
    parameters: []
    return:
      type: System.Boolean
      description: >-
        true if access to the <xref href="System.Collections.ICollection" data-throw-if-not-resolved="false"></xref> is synchronized

        with the SyncRoot; otherwise, false. For <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>, this property always

        returns false.
  implements:
  - System.Collections.ICollection.IsSynchronized
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.ICollection.IsSynchronized
  name.vb: System.Collections.ICollection.IsSynchronized
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot
  commentId: P:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#SyncRoot
  id: System#Collections#ICollection#SyncRoot
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ICollection.SyncRoot
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.ICollection.SyncRoot
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.ICollection.SyncRoot
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 245
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Gets an object that can be used to synchronize access to the <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref>. This property is not supported.</p>\n"
  example:
  - 
  syntax:
    content: object ICollection.SyncRoot { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.ICollection.SyncRoot As Object Implements ICollection.SyncRoot
    parameters: []
    return:
      type: System.Object
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The SyncRoot property is not supported</p>\n"
  implements:
  - System.Collections.ICollection.SyncRoot
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.ICollection.SyncRoot
  name.vb: System.Collections.ICollection.SyncRoot
- uid: System.Collections.Concurrent.ConcurrentStack`1.Clear
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.Clear
  id: Clear
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: Clear()
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.Clear()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Clear
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 256
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Removes all objects from the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public void Clear()
    content.vb: Public Sub Clear
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).Clear()
- uid: System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.CopyTo(`0[],System.Int32)
  id: CopyTo(`0[],System.Int32)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: CopyTo(T[], Int32)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.CopyTo(T[], System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CopyTo
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 325
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Copies the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> elements to an existing one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>, starting at the specified array index.</p>\n"
  example:
  - 
  syntax:
    content: public void CopyTo(T[] array, int index)
    content.vb: Public Sub CopyTo(array As T(), index As Integer)
    parameters:
    - id: array
      type: '{T}[]'
      description: >-
        The one-dimensional <xref href="System.Array" data-throw-if-not-resolved="false"></xref> that is the destination of

        the elements copied from the

        <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>. The <xref href="System.Array" data-throw-if-not-resolved="false"></xref> must have zero-based

        indexing.
    - id: index
      type: System.Int32
      description: >-
        The zero-based index in <em>array</em> at which copying

        begins.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is a null reference (Nothing in Visual Basic).</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> is equal to or greater than the length of the <em>array</em> -or- The number of elements in the source <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> is greater than the available space from <em>index</em> to the end of the destination <em>array</em>.</p>\n<p></p>\n"
  implements:
  - System.Collections.Concurrent.IProducerConsumerCollection{{T}}.CopyTo({T}[],System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).CopyTo(T(), System.Int32)
  name.vb: CopyTo(T(), Int32)
- uid: System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator
  id: GetEnumerator
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: GetEnumerator()
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.GetEnumerator()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetEnumerator
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 800
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Returns an enumerator that iterates through the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not reflect any updates to the collection after <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator\" data-throw-if-not-resolved=\"false\"></xref> was called. The enumerator is safe to use concurrently with reads from and writes to the stack. The enumerator returns items in LIFO (last-in, first-out) order.</p>\n"
  example:
  - 
  syntax:
    content: public IEnumerator<T> GetEnumerator()
    content.vb: Public Function GetEnumerator As IEnumerator(Of T)
    return:
      type: System.Collections.Generic.IEnumerator{{T}}
      description: An enumerator for the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  implements:
  - System.Collections.Generic.IEnumerable{{T}}.GetEnumerator
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).GetEnumerator()
- uid: System.Collections.Concurrent.ConcurrentStack`1.Push(`0)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.Push(`0)
  id: Push(`0)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: Push(T)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.Push(T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Push
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 346
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Inserts an object at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public void Push(T item)
    content.vb: Public Sub Push(item As T)
    parameters:
    - id: item
      type: '{T}'
      description: >
        The object to push onto the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>. The value can be

        a null reference (Nothing in Visual Basic) for reference types.
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).Push(T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[])
  id: PushRange(`0[])
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: PushRange(T[])
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.PushRange(T[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: PushRange
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 377
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Inserts multiple objects at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> atomically.</p>\n"
  remarks: "\n<p>When adding multiple items to the stack, using PushRange is a more efficient mechanism than using <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.Push(`0)\" data-throw-if-not-resolved=\"false\"></xref> one item at a time. Additionally, PushRange guarantees that all of the elements will be added atomically, meaning that no other threads will be able to inject elements between the elements being pushed. Items at lower indices in the <em>items</em> array will be pushed before items at higher indices.</p>\n<p>For a code example, see <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public void PushRange(T[] items)
    content.vb: Public Sub PushRange(items As T())
    parameters:
    - id: items
      type: '{T}[]'
      description: The objects to push onto the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>items</em> is a null reference (Nothing in Visual Basic).</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).PushRange(T())
  name.vb: PushRange(T())
- uid: System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.PushRange(`0[],System.Int32,System.Int32)
  id: PushRange(`0[],System.Int32,System.Int32)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: PushRange(T[], Int32, Int32)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.PushRange(T[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: PushRange
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 408
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Inserts multiple objects at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> atomically.</p>\n"
  remarks: "\n<p>When adding multiple items to the stack, using PushRange is a more efficient mechanism than using <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.Push(`0)\" data-throw-if-not-resolved=\"false\"></xref> one item at a time. Additionally, PushRange guarantees that all of the elements will be added atomically, meaning that no other threads will be able to inject elements between the elements being pushed. Items at lower indices in the <em>items</em> array will be pushed before items at higher indices.</p>\n<p>For a code example, see <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public void PushRange(T[] items, int startIndex, int count)
    content.vb: Public Sub PushRange(items As T(), startIndex As Integer, count As Integer)
    parameters:
    - id: items
      type: '{T}[]'
      description: The objects to push onto the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
    - id: startIndex
      type: System.Int32
      description: >-
        The zero-based offset in <em>items</em> at which to begin

        inserting elements onto the top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
    - id: count
      type: System.Int32
      description: The number of elements to be inserted onto the top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>items</em> is a null reference (Nothing in Visual Basic).</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> or <em>count</em> is negative. Or <em>startIndex</em> is greater than or equal to the length of <em>items</em>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>startIndex</em> + <em>count</em> is greater than the length of <em>items</em>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).PushRange(T(), System.Int32, System.Int32)
  name.vb: PushRange(T(), Int32, Int32)
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)
  id: System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: IProducerConsumerCollection<T>.TryAdd(T)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 502
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to add an object to the <xref href=\"System.Collections.Concurrent.IProducerConsumerCollection`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>, this operation will always insert the object onto the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> and return true.</p>\n"
  example:
  - 
  syntax:
    content: bool IProducerConsumerCollection<T>.TryAdd(T item)
    content.vb: Function System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(item As T) As Boolean Implements IProducerConsumerCollection(Of T).TryAdd
    parameters:
    - id: item
      type: '{T}'
      description: >
        The object to add to the <xref href="System.Collections.Concurrent.IProducerConsumerCollection{T}" data-throw-if-not-resolved="false"></xref>. The value can be a null

        reference (Nothing in Visual Basic) for reference types.
    return:
      type: System.Boolean
      description: true if the object was added successfully; otherwise, false.
  implements:
  - System.Collections.Concurrent.IProducerConsumerCollection{{T}}.TryAdd({T})
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T)
  name.vb: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)
  id: System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: IProducerConsumerCollection<T>.TryTake(out T)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(out T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 756
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to remove and return an object from the <xref href=\"System.Collections.Concurrent.IProducerConsumerCollection`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>, this operation will attempt to pop the object at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: bool IProducerConsumerCollection<T>.TryTake(out T item)
    content.vb: Function System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(ByRef item As T) As Boolean Implements IProducerConsumerCollection(Of T).TryTake
    parameters:
    - id: item
      type: '{T}'
      description: "\nWhen this method returns, if the operation was successful, <em>item</em> contains the\nobject removed. If no object was available to be removed, the value is unspecified.\n"
    return:
      type: System.Boolean
      description: true if an element was removed and returned succesfully; otherwise, false.
  implements:
  - System.Collections.Concurrent.IProducerConsumerCollection{{T}}.TryTake({T}@)
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(ByRef T)
  name.vb: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(ByRef T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  id: System#Collections#ICollection#CopyTo(System.Array,System.Int32)
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ICollection.CopyTo(Array, Int32)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.ICollection.CopyTo(System.Array, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.ICollection.CopyTo
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 290
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Copies the elements of the <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>, starting at a particular <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> index.</p>\n"
  example:
  - 
  syntax:
    content: void ICollection.CopyTo(Array array, int index)
    content.vb: Sub System.Collections.ICollection.CopyTo(array As Array, index As Integer) Implements ICollection.CopyTo
    parameters:
    - id: array
      type: System.Array
      description: >-
        The one-dimensional <xref href="System.Array" data-throw-if-not-resolved="false"></xref> that is the destination of

        the elements copied from the

        <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>. The <xref href="System.Array" data-throw-if-not-resolved="false"></xref> must

        have zero-based indexing.
    - id: index
      type: System.Int32
      description: >-
        The zero-based index in <em>array</em> at which copying

        begins.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is a null reference (Nothing in Visual Basic).</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>array</em> is multidimensional. -or- <em>array</em> does not have zero-based indexing. -or- <em>index</em> is equal to or greater than the length of the <em>array</em> -or- The number of elements in the source <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> is greater than the available space from <em>index</em> to the end of the destination <em>array</em>. -or- The type of the source <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> cannot be cast automatically to the type of the destination <em>array</em>.</p>\n<p></p>\n"
  implements:
  - System.Collections.ICollection.CopyTo(System.Array,System.Int32)
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.ICollection.CopyTo(System.Array, System.Int32)
  name.vb: System.Collections.ICollection.CopyTo(Array, Int32)
- uid: System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.System#Collections#IEnumerable#GetEnumerator
  id: System#Collections#IEnumerable#GetEnumerator
  isEii: true
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: IEnumerable.GetEnumerator()
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.System.Collections.IEnumerable.GetEnumerator()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IEnumerable.GetEnumerator
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 834
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Returns an enumerator that iterates through a collection.</p>\n"
  remarks: "\n<p>The enumeration represents a moment-in-time snapshot of the contents of the stack. It does not reflect any updates to the collection after <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.GetEnumerator\" data-throw-if-not-resolved=\"false\"></xref> was called. The enumerator is safe to use concurrently with reads from and writes to the stack.</p>\n"
  example:
  - 
  syntax:
    content: IEnumerator IEnumerable.GetEnumerator()
    content.vb: Function System.Collections.IEnumerable.GetEnumerator As IEnumerator Implements IEnumerable.GetEnumerator
    return:
      type: System.Collections.IEnumerator
      description: >-
        An <xref href="System.Collections.IEnumerator" data-throw-if-not-resolved="false"></xref> that can be used to iterate through

        the collection.
  implements:
  - System.Collections.IEnumerable.GetEnumerator
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).System.Collections.IEnumerable.GetEnumerator()
  name.vb: System.Collections.IEnumerable.GetEnumerator()
- uid: System.Collections.Concurrent.ConcurrentStack`1.ToArray
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.ToArray
  id: ToArray
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: ToArray()
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.ToArray()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToArray
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 766
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Copies the items stored in the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> to a new array.</p>\n"
  example:
  - 
  syntax:
    content: public T[] ToArray()
    content.vb: Public Function ToArray As T()
    return:
      type: '{T}[]'
      description: A new array containing a snapshot of elements copied from the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
  implements:
  - System.Collections.Concurrent.IProducerConsumerCollection{{T}}.ToArray
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).ToArray()
- uid: System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.TryPeek(`0@)
  id: TryPeek(`0@)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: TryPeek(out T)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.TryPeek(out T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryPeek
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 516
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to return an object from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> without removing it.</p>\n"
  example:
  - 
  syntax:
    content: public bool TryPeek(out T result)
    content.vb: Public Function TryPeek(ByRef result As T) As Boolean
    parameters:
    - id: result
      type: '{T}'
      description: >-
        When this method returns, <em>result</em> contains an object from

        the top of the <xref href="System.Collections.Concurrent.ConccurrentStack{T}" data-throw-if-not-resolved="false"></xref> or an

        unspecified value if the operation failed.
    return:
      type: System.Boolean
      description: true if and object was returned successfully; otherwise, false.
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).TryPeek(ByRef T)
  name.vb: TryPeek(ByRef T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)
  id: TryPop(`0@)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: TryPop(out T)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.TryPop(out T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryPop
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 543
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to pop and return the object at the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For a code example, see <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public bool TryPop(out T result)
    content.vb: Public Function TryPop(ByRef result As T) As Boolean
    parameters:
    - id: result
      type: '{T}'
      description: "\nWhen this method returns, if the operation was successful, <em>result</em> contains the\nobject removed. If no object was available to be removed, the value is unspecified.\n"
    return:
      type: System.Boolean
      description: >-
        true if an element was removed and returned from the top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>

        succesfully; otherwise, false.
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).TryPop(ByRef T)
  name.vb: TryPop(ByRef T)
- uid: System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[])
  id: TryPopRange(`0[])
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: TryPopRange(T[])
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.TryPopRange(T[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryPopRange
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 582
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to pop and return multiple objects from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> atomically.</p>\n"
  remarks: "\n<p>When popping multiple items, if there is little contention on the stack, using <strong>TryPopRange</strong> can be more efficient than using <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)\" data-throw-if-not-resolved=\"false\"></xref> once per item to be removed. Nodes fill the <em>items</em> array with the first item to be popped at the startIndex, the second item to be popped at startIndex + 1, and so on.</p>\n<p>For a code example, see <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: public int TryPopRange(T[] items)
    content.vb: Public Function TryPopRange(items As T()) As Integer
    parameters:
    - id: items
      type: '{T}[]'
      description: "\nThe <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to which objects popped from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> will be added.\n"
    return:
      type: System.Int32
      description: >-
        The number of objects successfully popped from the top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref> and inserted in

        <em>items</em>.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>items</em> is a null argument (Nothing in Visual Basic).</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).TryPopRange(T())
  name.vb: TryPopRange(T())
- uid: System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)
  commentId: M:System.Collections.Concurrent.ConcurrentStack`1.TryPopRange(`0[],System.Int32,System.Int32)
  id: TryPopRange(`0[],System.Int32,System.Int32)
  parent: System.Collections.Concurrent.ConcurrentStack`1
  langs:
  - csharp
  - vb
  name: TryPopRange(T[], Int32, Int32)
  fullName: System.Collections.Concurrent.ConcurrentStack<T>.TryPopRange(T[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryPopRange
    path: src/mscorlib/src/System/Collections/Concurrent/ConcurrentStack.cs
    startLine: 620
  assemblies:
  - System.Collections.Concurrent
  namespace: System.Collections.Concurrent
  summary: "\n<p>Attempts to pop and return multiple objects from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> atomically.</p>\n"
  remarks: "\n<p>When popping multiple items, if there is little contention on the stack, using TryPopRange can be more efficient than using <xref href=\"System.Collections.Concurrent.ConcurrentStack`1.TryPop(`0@)\" data-throw-if-not-resolved=\"false\"></xref> once per item to be removed. Nodes fill the <em>items</em> array with the first item to be popped at the startIndex, the second item to be popped at startIndex + 1, and so on.</p>\n"
  example:
  - 
  syntax:
    content: public int TryPopRange(T[] items, int startIndex, int count)
    content.vb: Public Function TryPopRange(items As T(), startIndex As Integer, count As Integer) As Integer
    parameters:
    - id: items
      type: '{T}[]'
      description: "\nThe <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to which objects popped from the top of the <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> will be added.\n"
    - id: startIndex
      type: System.Int32
      description: >-
        The zero-based offset in <em>items</em> at which to begin

        inserting elements from the top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref>.
    - id: count
      type: System.Int32
      description: The number of elements to be popped from top of the <xref href="System.Collections.Concurrent.ConcurrentStack`1" data-throw-if-not-resolved="false"></xref> and inserted into <em>items</em>.
    return:
      type: System.Int32
      description: "The number of objects successfully popped from the top of \nthe <xref href=\"System.Collections.Concurrent.ConcurrentStack`1\" data-throw-if-not-resolved=\"false\"></xref> and inserted in <em>items</em>."
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>items</em> is a null reference (Nothing in Visual Basic).</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> or <em>count</em> is negative. Or <em>startIndex</em> is greater than or equal to the length of <em>items</em>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>startIndex</em> + <em>count</em> is greater than the length of <em>items</em>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Collections.Concurrent.ConcurrentStack(Of T).TryPopRange(T(), System.Int32, System.Int32)
  name.vb: TryPopRange(T(), Int32, Int32)
references:
- uid: System.Collections.Concurrent
  isExternal: false
  name: System.Collections.Concurrent
  fullName: System.Collections.Concurrent
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  parent: System.Collections.Concurrent
  definition: System.Collections.Concurrent.IProducerConsumerCollection`1
  name: IProducerConsumerCollection<T>
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T)
  name.vb: IProducerConsumerCollection(Of T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1
    name: IProducerConsumerCollection
    fullName: System.Collections.Concurrent.IProducerConsumerCollection
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1
    name: IProducerConsumerCollection
    fullName: System.Collections.Concurrent.IProducerConsumerCollection
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic.IReadOnlyCollection{{T}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IReadOnlyCollection`1
  name: IReadOnlyCollection<T>
  fullName: System.Collections.Generic.IReadOnlyCollection<T>
  fullname.vb: System.Collections.Generic.IReadOnlyCollection(Of T)
  name.vb: IReadOnlyCollection(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IReadOnlyCollection`1
    name: IReadOnlyCollection
    fullName: System.Collections.Generic.IReadOnlyCollection
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IReadOnlyCollection`1
    name: IReadOnlyCollection
    fullName: System.Collections.Generic.IReadOnlyCollection
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{{T}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: false
  name: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.IEnumerable
  parent: System.Collections
  isExternal: false
  name: IEnumerable
  fullName: System.Collections.IEnumerable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Collections.Concurrent.IProducerConsumerCollection`1
  parent: System.Collections.Concurrent
  isExternal: false
  name: IProducerConsumerCollection<T>
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T)
  name.vb: IProducerConsumerCollection(Of T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1
    name: IProducerConsumerCollection
    fullName: System.Collections.Concurrent.IProducerConsumerCollection
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1
    name: IProducerConsumerCollection
    fullName: System.Collections.Concurrent.IProducerConsumerCollection
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic.IReadOnlyCollection`1
  parent: System.Collections.Generic
  isExternal: false
  name: IReadOnlyCollection<T>
  fullName: System.Collections.Generic.IReadOnlyCollection<T>
  fullname.vb: System.Collections.Generic.IReadOnlyCollection(Of T)
  name.vb: IReadOnlyCollection(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IReadOnlyCollection`1
    name: IReadOnlyCollection
    fullName: System.Collections.Generic.IReadOnlyCollection
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IReadOnlyCollection`1
    name: IReadOnlyCollection
    fullName: System.Collections.Generic.IReadOnlyCollection
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections
  isExternal: false
  name: System.Collections
  fullName: System.Collections
- uid: System.Collections.Generic.IReadOnlyCollection{{T}}.Count
  parent: System.Collections.Generic.IReadOnlyCollection{{T}}
  definition: System.Collections.Generic.IReadOnlyCollection`1.Count
  name: Count
  fullName: System.Collections.Generic.IReadOnlyCollection<T>.Count
  fullname.vb: System.Collections.Generic.IReadOnlyCollection(Of T).Count
- uid: System.Collections.ICollection.Count
  parent: System.Collections.ICollection
  isExternal: false
  name: Count
  fullName: System.Collections.ICollection.Count
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Collections.Generic.IReadOnlyCollection`1.Count
  parent: System.Collections.Generic.IReadOnlyCollection`1
  isExternal: false
  name: Count
  fullName: System.Collections.Generic.IReadOnlyCollection<T>.Count
  fullname.vb: System.Collections.Generic.IReadOnlyCollection(Of T).Count
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Collections.ICollection.IsSynchronized
  parent: System.Collections.ICollection
  isExternal: false
  name: IsSynchronized
  fullName: System.Collections.ICollection.IsSynchronized
- uid: System.Collections.ICollection.SyncRoot
  parent: System.Collections.ICollection
  isExternal: false
  name: SyncRoot
  fullName: System.Collections.ICollection.SyncRoot
- uid: System.Collections.Concurrent.IProducerConsumerCollection{{T}}.CopyTo({T}[],System.Int32)
  parent: System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  definition: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
  name: CopyTo(T[], Int32)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.CopyTo(T[], System.Int32)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).CopyTo(T(), System.Int32)
  name.vb: CopyTo(T(), Int32)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
    name: CopyTo
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.CopyTo
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: '[]'
    fullName: '[]'
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
    name: CopyTo
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).CopyTo
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: ()
    fullName: ()
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: '{T}[]'
  isExternal: false
  name: T[]
  fullName: T[]
  fullname.vb: T()
  name.vb: T()
  spec.csharp:
  - name: T
    fullName: T
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - name: T
    fullName: T
  - name: ()
    fullName: ()
- uid: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
  parent: System.Collections.Concurrent.IProducerConsumerCollection`1
  isExternal: true
  name: CopyTo(T[], Int32)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.CopyTo(T[], System.Int32)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).CopyTo(T(), System.Int32)
  name.vb: CopyTo(T(), Int32)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
    name: CopyTo
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.CopyTo
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: '[]'
    fullName: '[]'
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.CopyTo(`0[],System.Int32)
    name: CopyTo
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).CopyTo
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: ()
    fullName: ()
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{{T}}.GetEnumerator
  parent: System.Collections.Generic.IEnumerable{{T}}
  definition: System.Collections.Generic.IEnumerable`1.GetEnumerator
  name: GetEnumerator()
  fullName: System.Collections.Generic.IEnumerable<T>.GetEnumerator()
  fullname.vb: System.Collections.Generic.IEnumerable(Of T).GetEnumerator()
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.Generic.IEnumerable<T>.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.Generic.IEnumerable(Of T).GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerator{{T}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerator`1
  name: IEnumerator<T>
  fullName: System.Collections.Generic.IEnumerator<T>
  fullname.vb: System.Collections.Generic.IEnumerator(Of T)
  name.vb: IEnumerator(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    fullName: System.Collections.Generic.IEnumerator
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    fullName: System.Collections.Generic.IEnumerator
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1.GetEnumerator
  parent: System.Collections.Generic.IEnumerable`1
  isExternal: false
  name: GetEnumerator()
  fullName: System.Collections.Generic.IEnumerable<T>.GetEnumerator()
  fullname.vb: System.Collections.Generic.IEnumerable(Of T).GetEnumerator()
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.Generic.IEnumerable<T>.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.Generic.IEnumerable(Of T).GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerator`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerator<T>
  fullName: System.Collections.Generic.IEnumerator<T>
  fullname.vb: System.Collections.Generic.IEnumerator(Of T)
  name.vb: IEnumerator(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    fullName: System.Collections.Generic.IEnumerator
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerator`1
    name: IEnumerator
    fullName: System.Collections.Generic.IEnumerator
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: '{T}'
  isExternal: false
  name: T
  fullName: T
- uid: System.Collections.Concurrent.IProducerConsumerCollection{{T}}.TryAdd({T})
  parent: System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  definition: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
  name: TryAdd(T)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryAdd(T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
    name: TryAdd
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
    name: TryAdd
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryAdd
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
  parent: System.Collections.Concurrent.IProducerConsumerCollection`1
  isExternal: false
  name: TryAdd(T)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryAdd(T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
    name: TryAdd
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryAdd(`0)
    name: TryAdd
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryAdd
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Concurrent.IProducerConsumerCollection{{T}}.TryTake({T}@)
  parent: System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  definition: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
  name: TryTake(T)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryTake(T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
    name: TryTake
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
    name: TryTake
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryTake
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
  parent: System.Collections.Concurrent.IProducerConsumerCollection`1
  isExternal: false
  name: TryTake(T)
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T)
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryTake(T)
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
    name: TryTake
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)
    name: TryTake
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).TryTake
  - name: (
    fullName: (
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
  parent: System.Collections.ICollection
  isExternal: true
  name: CopyTo(Array, Int32)
  fullName: System.Collections.ICollection.CopyTo(System.Array, System.Int32)
  spec.csharp:
  - uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
    name: CopyTo
    fullName: System.Collections.ICollection.CopyTo
  - name: (
    fullName: (
  - uid: System.Array
    name: Array
    fullName: System.Array
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
    name: CopyTo
    fullName: System.Collections.ICollection.CopyTo
  - name: (
    fullName: (
  - uid: System.Array
    name: Array
    fullName: System.Array
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Array
  parent: System
  isExternal: false
  name: Array
  fullName: System.Array
- uid: System.Collections.IEnumerable.GetEnumerator
  parent: System.Collections.IEnumerable
  isExternal: false
  name: GetEnumerator()
  fullName: System.Collections.IEnumerable.GetEnumerator()
  spec.csharp:
  - uid: System.Collections.IEnumerable.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.IEnumerable.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IEnumerable.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.IEnumerable.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: false
  name: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Collections.Concurrent.IProducerConsumerCollection{{T}}.ToArray
  parent: System.Collections.Concurrent.IProducerConsumerCollection{{T}}
  definition: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
  name: ToArray()
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.ToArray()
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).ToArray()
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
    name: ToArray
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.ToArray
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
    name: ToArray
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).ToArray
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
  parent: System.Collections.Concurrent.IProducerConsumerCollection`1
  isExternal: false
  name: ToArray()
  fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.ToArray()
  fullname.vb: System.Collections.Concurrent.IProducerConsumerCollection(Of T).ToArray()
  spec.csharp:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
    name: ToArray
    fullName: System.Collections.Concurrent.IProducerConsumerCollection<T>.ToArray
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.Concurrent.IProducerConsumerCollection`1.ToArray
    name: ToArray
    fullName: System.Collections.Concurrent.IProducerConsumerCollection(Of T).ToArray
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
