items:
- uid: System.Text.Encoding
  commentId: T:System.Text.Encoding
  id: Encoding
  parent: System.Text
  children:
  - System.Text.Encoding.#ctor
  - System.Text.Encoding.#ctor(System.Int32)
  - System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  - System.Text.Encoding.ASCII
  - System.Text.Encoding.BigEndianUnicode
  - System.Text.Encoding.Clone
  - System.Text.Encoding.CodePage
  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])
  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)
  - System.Text.Encoding.DecoderFallback
  - System.Text.Encoding.EncoderFallback
  - System.Text.Encoding.EncodingName
  - System.Text.Encoding.Equals(System.Object)
  - System.Text.Encoding.GetByteCount(System.Char*,System.Int32)
  - System.Text.Encoding.GetByteCount(System.Char[])
  - System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)
  - System.Text.Encoding.GetByteCount(System.String)
  - System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)
  - System.Text.Encoding.GetBytes(System.Char[])
  - System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)
  - System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)
  - System.Text.Encoding.GetBytes(System.String)
  - System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)
  - System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)
  - System.Text.Encoding.GetCharCount(System.Byte[])
  - System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)
  - System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)
  - System.Text.Encoding.GetChars(System.Byte[])
  - System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)
  - System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)
  - System.Text.Encoding.GetDecoder
  - System.Text.Encoding.GetEncoder
  - System.Text.Encoding.GetEncoding(System.Int32)
  - System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  - System.Text.Encoding.GetEncoding(System.String)
  - System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)
  - System.Text.Encoding.GetHashCode
  - System.Text.Encoding.GetMaxByteCount(System.Int32)
  - System.Text.Encoding.GetMaxCharCount(System.Int32)
  - System.Text.Encoding.GetPreamble
  - System.Text.Encoding.GetString(System.Byte*,System.Int32)
  - System.Text.Encoding.GetString(System.Byte[])
  - System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)
  - System.Text.Encoding.IsSingleByte
  - System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)
  - System.Text.Encoding.Unicode
  - System.Text.Encoding.UTF32
  - System.Text.Encoding.UTF7
  - System.Text.Encoding.UTF8
  - System.Text.Encoding.WebName
  langs:
  - csharp
  - vb
  name: Encoding
  fullName: System.Text.Encoding
  type: Class
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Encoding
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 123
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Represents a character encoding.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p>Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. In contrast, decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters. For information about the Unicode Transformation Formats (UTFs) and other encodings supported by <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>, see Character Encoding in the .NET Framework. </p>\n<p>Note that <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> is intended to operate on Unicode characters instead of arbitrary binary data, such as byte arrays. If you must encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref href=\"System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The .NET Framework provides the following implementations of the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class to support current Unicode encodings and other encodings: </p>\n<ul><li>\n<p>\n<xref href=\"System.Text.ASCIIEncoding\" data-throw-if-not-resolved=\"false\"></xref> encodes Unicode characters as single 7-bit ASCII characters. This encoding only supports character values between U+0000 and U+007F. Code page 20127. Also available through the <xref href=\"System.Text.Encoding.ASCII\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li><li>\n<p>\n<xref href=\"System.Text.UTF7Encoding\" data-throw-if-not-resolved=\"false\"></xref> encodes Unicode characters using the UTF-7 encoding. This encoding supports all Unicode character values. Code page 65000. Also available through the <xref href=\"System.Text.Encoding.UTF7\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li><li>\n<p>\n<xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> encodes Unicode characters using the UTF-8 encoding. This encoding supports all Unicode character values. Code page 65001. Also available through the <xref href=\"System.Text.Encoding.UTF8\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li><li>\n<p>\n<xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> encodes Unicode characters using the UTF-16 encoding. Both little endian and big endian byte orders are supported. Also available through the <xref href=\"System.Text.Encoding.Unicode\" data-throw-if-not-resolved=\"false\"></xref> property and the <xref href=\"System.Text.Encoding.BigEndianUnicode\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li><li>\n<p>\n<xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> encodes Unicode characters using the UTF-32 encoding. Both little endian (code page 12000) and big endian (code page 12001) byte orders are supported. Also available through the <xref href=\"System.Text.Encoding.UTF32\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n</li></ul>\n<p>The <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class is primarily intended to convert between different encodings and Unicode. Often one of the derived Unicode classes is the correct choice for your app.</p>\n<p>Use the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to obtain other encodings, and call the <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> method to get a list of all encodings.</p>\n<p>The following table lists the encodings supported by the .NET Framework. It lists each encoding's code page number and the values of the encoding's <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.EncodingInfo.DisplayName\" data-throw-if-not-resolved=\"false\"></xref> properties. An asterisk in the last column indicates that the code page is natively supported by the .NET Framework, regardless of the underlying platform. Note that code pages whose <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref> property corresponds to an international standard do not necessarily comply in full with that standard. </p>\n<p>Code page </p>\n<p>Name </p>\n<p>Display name </p>\n<p>.NET Framework support</p>\n<p>The following example calls the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetEncoding(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods to get the Greek (Windows) code page encoding. It compares the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> objects returned by the method calls to show that they are equal, and then maps displays the Unicode code point and the corresponding code page value for each character in the Greek alphabet. </p>System.Text.Encoding#1<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p><p>The UTF-16 and the UTF-32 encoders can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (U+0041) is serialized as follows (in hexadecimal): </p><ul><li><p>UTF-16 big endian byte order: 00 41 </p></li><li><p>UTF-16 little endian byte order: 41 00 </p></li><li><p>UTF-32 big endian byte order: 00 00 00 41 </p></li><li><p>UTF-32 little endian byte order: 41 00 00 00 </p></li></ul><p>It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.</p><p>The <xref href=\"System.Text.Encoding.GetPreamble\" data-throw-if-not-resolved=\"false\"></xref> method retrieves an array of bytes that includes the byte order mark (BOM). If this byte array is prefixed to an encoded stream, it helps the decoder to identify the encoding format used.</p><p>For more information on byte order and the byte order mark, see The Unicode Standard at the <see href=\"http://go.microsoft.com/fwlink/?LinkId=37123\">Unicode home page</see>.</p><p>Note that the encoding classes allow errors to:</p><ul><li><p>Silently change to a \"?\" character. </p></li><li><p>Use a \"best fit\" character.</p></li><li><p>Change to an application-specific behavior through use of the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> classes with the U+FFFD Unicode replacement character. </p></li></ul><p>You should throw an exception on any data stream error. An app either uses a \"throwonerror\" flag when applicable or uses the <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref> classes. Best fit fallback is often not recommended because it can cause data loss or confusion and is slower than simple character replacements. For ANSI encodings, the best fit behavior is the default.</p>"
  example:
  - "\n<p>The following example converts a string from one encoding to another.</p>\n<p>The byte[] array is the only type in this example that contains the encoded data. The .NET Char and String types are themselves Unicode, so the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call decodes the data back to Unicode.</p>System.Text.Encoding.Convert Example#1"
  syntax:
    content: 'public abstract class Encoding : object'
    content.vb: >-
      Public MustInherit Class Encoding
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Text.Encoding.#ctor
  commentId: M:System.Text.Encoding.#ctor
  id: '#ctor'
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Encoding()
  fullName: System.Text.Encoding.Encoding()
  type: Constructor
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 125
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Derived classes override this constructor.</p>\n"
  syntax:
    content: protected Encoding()
    content.vb: Protected Sub New
  seealso:
  - type: System.Text.Encoding.CodePage
    commentId: P:System.Text.Encoding.CodePage
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Text.Encoding.#ctor(System.Int32)
  commentId: M:System.Text.Encoding.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Encoding(Int32)
  fullName: System.Text.Encoding.Encoding(System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 126
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class that corresponds to the specified code page.</p>\n"
  remarks: "\n<p>Derived classes override this constructor.</p>\n<p>Calls to this constructor from a derived class create an <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that uses best-fit fallback for both encoding and decoding operations. Both the <xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> properties are read-only and cannot be modified. To control the fallback strategy for a class derived from <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>, call the <xref href=\"System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> constructor.  </p>\n"
  syntax:
    content: protected Encoding(int codePage)
    content.vb: Protected Sub New(codePage As Integer)
    parameters:
    - id: codePage
      type: System.Int32
      description: "\n<p>The code page identifier of the preferred encoding.</p>\n<p>-or- </p>\n<p>0, to use the default encoding. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>codePage</em> is less than zero. </p>\n"
  seealso:
  - type: System.Text.Encoding.CodePage
    commentId: P:System.Text.Encoding.CodePage
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  commentId: M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  id: '#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)'
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Encoding(Int32, EncoderFallback, DecoderFallback)
  fullName: System.Text.Encoding.Encoding(System.Int32, System.Text.EncoderFallback, System.Text.DecoderFallback)
  type: Constructor
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 127
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class that corresponds to the specified code page with the specified encoder and decoder fallback strategies. </p>\n"
  remarks: "\n<p>This constructor is <strong>protected</strong>; derived classes override it. </p>\n<p>You call this constructor from a derived class to control the fallback encoding and decoding strategies. The <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class constructors create read-only encoding objects that don't allow encoder or decoder fallback to be set after the object is created. </p>\n<p>If either <em>encoderFallback</em> or <em>decoderFallback</em> is null, best-fit fallback is used as the corresponding fallback strategy. </p>\n"
  syntax:
    content: protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
    content.vb: Protected Sub New(codePage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback)
    parameters:
    - id: codePage
      type: System.Int32
      description: "\n<p>The encoding code page identifier. </p>\n"
    - id: encoderFallback
      type: System.Text.EncoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding. </p>\n"
    - id: decoderFallback
      type: System.Text.DecoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>codePage</em> is less than zero. </p>\n"
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Text.Encoding.ASCII
  commentId: P:System.Text.Encoding.ASCII
  id: ASCII
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: ASCII
  fullName: System.Text.Encoding.ASCII
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ASCII
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 128
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the ASCII (7-bit) character set.</p>\n"
  remarks: "\n<p>ASCII characters are limited to the lowest 128 Unicode characters, from U+0000 to U+007F.</p>\n<p>When selecting the ASCII encoding for your app, consider the following:</p>\n<ul><li>\n<p>The ASCII encoding is usually appropriate for protocols that require ASCII. </p>\n</li><li>\n<p>If you requires 8-bit encoding (which is sometimes incorrectly referred to as \"ASCII\"), the UTF-8 encoding is recommended over the ASCII encoding. For the characters 0-7F, the results are identical, but use of UTF-8 avoids data loss by allowing representation of all Unicode characters that are representable. Note that the ASCII encoding has an 8th bit ambiguity that can allow malicious use, but the UTF-8 encoding removes ambiguity about the 8th bit.</p>\n</li><li>\n<p>Prior to the .NET Framework version 2.0, the .NET Framework allowed spoofing by ignoring the 8th bit. Beginning with the .NET Framework 2.0, non-ASCII code points fall back during decoding.</p>\n</li></ul>\n<p>The <xref href=\"System.Text.ASCIIEncoding\" data-throw-if-not-resolved=\"false\"></xref> object that is returned by this property might not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref href=\"System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> method to instantiate an <xref href=\"System.Text.ASCIIEncoding\" data-throw-if-not-resolved=\"false\"></xref> object whose fallback is either an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref>, as the following example illustrates. </p>System.Text.Encoding.ASCII#1"
  example:
  - "\n<p>The following example demonstrates the effect of the ASCII encoding on characters that are outside the ASCII range.</p>System.Text.Encoding.ASCII Example#1"
  syntax:
    content: public static Encoding ASCII { get; }
    content.vb: Public Shared ReadOnly Property ASCII As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An  encoding for the ASCII (7-bit) character set.</p>\n"
  seealso:
  - type: System.Text.ASCIIEncoding
    commentId: T:System.Text.ASCIIEncoding
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  - type: System.Text.Encoding.UTF8
    commentId: P:System.Text.Encoding.UTF8
  - type: System.Text.Encoding.Unicode
    commentId: P:System.Text.Encoding.Unicode
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.BigEndianUnicode
  commentId: P:System.Text.Encoding.BigEndianUnicode
  id: BigEndianUnicode
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: BigEndianUnicode
  fullName: System.Text.Encoding.BigEndianUnicode
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: BigEndianUnicode
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 129
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the UTF-16 format that uses the big endian byte order.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref href=\"System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor to instantiate a big endian <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> object whose fallback is either an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref>, as the following example illustrates.</p>System.Text.Encoding.BigEndianUnicode#2<p>The returned <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> object has <xref href=\"System.Text.Encoding.BodyName\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Text.Encoding.HeaderName\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> properties, which yield the name \"unicodeFFFE\". Although the UTF-16 big endian byte order mark is hexadecimal FEFF, the name \"unicodeFFFE\" was chosen because the byte order mark appears as hexadecimal FFFE on little endian Windows computers.</p>"
  example:
  - "\n<p>The following example reads a text file with a UTF-16 encoding using the big endian byte order.</p>System.Text.Encoding.BigEndianUnicode#1<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public static Encoding BigEndianUnicode { get; }
    content.vb: Public Shared ReadOnly Property BigEndianUnicode As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An encoding object for the UTF-16 format that uses the big endian byte order.</p>\n"
  seealso:
  - type: System.Text.UnicodeEncoding
    commentId: T:System.Text.UnicodeEncoding
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  - type: System.Text.Encoding.Unicode
    commentId: P:System.Text.Encoding.Unicode
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.CodePage
  commentId: P:System.Text.Encoding.CodePage
  id: CodePage
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: CodePage
  fullName: System.Text.Encoding.CodePage
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CodePage
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 130
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, gets the code page identifier of the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref>. It displays <xref href=\"System.Text.Encoding.EncodingName\" data-throw-if-not-resolved=\"false\"></xref> but does not compare against it.</p>System.Text.Encoding.Names#1"
  syntax:
    content: public virtual int CodePage { get; }
    content.vb: Public Overridable ReadOnly Property CodePage As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The code page identifier of the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.EncodingInfo.CodePage
    commentId: P:System.Text.EncodingInfo.CodePage
  - type: System.Text.Encoding.WindowsCodePage
    commentId: P:System.Text.Encoding.WindowsCodePage
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Text.Encoding.DecoderFallback
  commentId: P:System.Text.Encoding.DecoderFallback
  id: DecoderFallback
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: DecoderFallback
  fullName: System.Text.Encoding.DecoderFallback
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DecoderFallback
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 131
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets or sets the <xref href=\"System.Text.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> object for the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> object represents an error handler that is invoked when an encoded byte sequence cannot be decoded into a character. Any one of the following handler types is supported:</p>\n<ul><li>\n<p>A best-fit fallback handler, which replaces bytes that cannot be decoded with some suitable replacement character.</p>\n</li><li>\n<p>A replacement fallback handler, which replaces bytes that cannot be decoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref href=\"System.Text.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref>, which by default replaces bytes that cannot be decoded with a question mark (\"?\") character.</p>\n</li><li>\n<p>An exception fallback handler, which throws an exception when bytes cannot be decoded. The .NET Framework includes one exception fallback handler, <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>, which throws a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> when bytes cannot be decoded. </p>\n</li></ul>\n"
  syntax:
    content: public DecoderFallback DecoderFallback { get; }
    content.vb: Public ReadOnly Property DecoderFallback As DecoderFallback
    parameters: []
    return:
      type: System.Text.DecoderFallback
      description: "\n<p>The decoder fallback object for the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The value in a set operation is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object is read-only.</p>\n"
  seealso:
  - type: System.Text.DecoderFallback
    commentId: T:System.Text.DecoderFallback
  - type: System.Text.DecoderFallbackBuffer
    commentId: T:System.Text.DecoderFallbackBuffer
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Text.Encoding.EncoderFallback
  commentId: P:System.Text.Encoding.EncoderFallback
  id: EncoderFallback
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: EncoderFallback
  fullName: System.Text.Encoding.EncoderFallback
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EncoderFallback
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 132
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets or sets the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> object for the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> object represents an error handler that is invoked when a character cannot be converted into an encoded byte sequence. Any one of the following handler types is supported:</p>\n<ul><li>\n<p>A best-fit fallback handler, which replaces characters that cannot be encoded with some suitable replacement character.</p>\n</li><li>\n<p>A replacement fallback handler, which replaces characters that cannot be encoded with some arbitrary replacement character. The .NET Framework includes one replacement fallback handler, <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>, which by default replaces characters that cannot be encoded with a question mark (\"?\") character.</p>\n</li><li>\n<p>An exception fallback handler, which throws an exception when characters cannot be encoded. The .NET Framework includes one exception fallback handler, <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>, which throws an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> when characters cannot be decoded. </p>\n</li></ul>\n"
  syntax:
    content: public EncoderFallback EncoderFallback { get; }
    content.vb: Public ReadOnly Property EncoderFallback As EncoderFallback
    parameters: []
    return:
      type: System.Text.EncoderFallback
      description: "\n<p>The encoder fallback object for the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The value in a set operation is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A value cannot be assigned in a set operation because the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object is read-only.</p>\n"
  seealso:
  - type: System.Text.EncoderFallback
    commentId: T:System.Text.EncoderFallback
  - type: System.Text.EncoderFallbackBuffer
    commentId: T:System.Text.EncoderFallbackBuffer
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Text.Encoding.EncodingName
  commentId: P:System.Text.Encoding.EncodingName
  id: EncodingName
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: EncodingName
  fullName: System.Text.Encoding.EncodingName
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EncodingName
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 133
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, gets the human-readable description of the current encoding.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Encoding.EncodingName\" data-throw-if-not-resolved=\"false\"></xref> property is intended for display. To find a name that can be passed to the <xref href=\"System.Text.Encoding.GetEncoding(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, use the <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  example:
  - "\n<p>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref>. It displays <xref href=\"System.Text.Encoding.EncodingName\" data-throw-if-not-resolved=\"false\"></xref> but does not compare against it.</p>System.Text.Encoding.Names#1"
  syntax:
    content: public virtual string EncodingName { get; }
    content.vb: Public Overridable ReadOnly Property EncodingName As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>The human-readable description of the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.EncodingInfo.DisplayName
    commentId: P:System.Text.EncodingInfo.DisplayName
  - type: System.Text.Encoding.BodyName
    commentId: P:System.Text.Encoding.BodyName
  - type: System.Text.Encoding.HeaderName
    commentId: P:System.Text.Encoding.HeaderName
  - type: System.Text.Encoding.WebName
    commentId: P:System.Text.Encoding.WebName
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Text.Encoding.IsSingleByte
  commentId: P:System.Text.Encoding.IsSingleByte
  id: IsSingleByte
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: IsSingleByte
  fullName: System.Text.Encoding.IsSingleByte
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsSingleByte
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 134
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, gets a value indicating whether the current encoding uses single-byte code points.</p>\n"
  remarks: "\n<p>For a single-byte encoding, for example, <xref href=\"System.Text.ASCIIEncoding\" data-throw-if-not-resolved=\"false\"></xref>, this property retrieves <strong>true</strong>.</p>\n<p>You should be careful in what your application does with the value for <xref href=\"System.Text.Encoding.IsSingleByte\" data-throw-if-not-resolved=\"false\"></xref>. An assumption of how an Encoding will proceed may still be wrong. For example, Windows-1252 has a value of <strong>true</strong> for <xref href=\"System.Text.Encoding.IsSingleByte\" data-throw-if-not-resolved=\"false\"></xref>, but Encoding.GetMaxByteCount(1) returns 2. This is because the method considers potential leftover surrogates from a previous decoder operation.</p>\n"
  example:
  - "\n<p>The following example checks the values of the Boolean properties of each encoding.</p>System.Text.Encoding.IsProps#1"
  syntax:
    content: public virtual bool IsSingleByte { get; }
    content.vb: Public Overridable ReadOnly Property IsSingleByte As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> uses single-byte code points; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Text.Encoding.Unicode
  commentId: P:System.Text.Encoding.Unicode
  id: Unicode
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Unicode
  fullName: System.Text.Encoding.Unicode
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Unicode
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 135
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the UTF-16 format using the little endian byte order.</p>\n"
  remarks: "\n<p>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see Character Encoding in the .NET Framework.</p>\n<p>The <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with a question mark (\"?\") character. Instead, you can call the <xref href=\"System.Text.UnicodeEncoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor to instantiate a little endian <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref> object whose fallback is either an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref>, as the following example illustrates.</p>System.Text.Encoding.Unicode#2"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public static Encoding Unicode { get; }
    content.vb: Public Shared ReadOnly Property Unicode As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An encoding for the UTF-16 format using the little endian byte order.</p>\n"
  seealso:
  - type: System.Text.UnicodeEncoding
    commentId: T:System.Text.UnicodeEncoding
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  - type: System.Text.Encoding.BigEndianUnicode
    commentId: P:System.Text.Encoding.BigEndianUnicode
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.UTF32
  commentId: P:System.Text.Encoding.UTF32
  id: UTF32
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: UTF32
  fullName: System.Text.Encoding.UTF32
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UTF32
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 136
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the UTF-32 format using the little endian byte order.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that is returned by this property may not have the appropriate behavior for your app. It uses replacement fallback to replace each string that it cannot encode and each byte that it cannot decode with the Unicode REPLACEMENT CHARACTER (U+FFFE). Instead, you can call the <xref href=\"System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor to instantiate a <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> object whose fallback is either an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref>, as the following example illustrates.</p>System.Text.Encoding.UTF32#1<p>For a discussion of little endian byte order, see the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic.</p><p>For information about the encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see Character Encoding in the .NET Framework.</p>"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public static Encoding UTF32 { get; }
    content.vb: Public Shared ReadOnly Property UTF32 As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An  encoding object for the UTF-32 format using the little endian byte order.</p>\n"
  seealso:
  - type: System.Text.UTF32Encoding
    commentId: T:System.Text.UTF32Encoding
  - type: System.Text.Encoding.UTF8
    commentId: P:System.Text.Encoding.UTF8
  - type: System.Text.Encoding.Unicode
    commentId: P:System.Text.Encoding.Unicode
  - type: System.Text.Encoding.BigEndianUnicode
    commentId: P:System.Text.Encoding.BigEndianUnicode
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.UTF7
  commentId: P:System.Text.Encoding.UTF7
  id: UTF7
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: UTF7
  fullName: System.Text.Encoding.UTF7
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UTF7
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 137
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the UTF-7 format.</p>\n"
  remarks: "\n<p></p>\n<p>UTF-7 encoding is used primarily in environments that historically have been restricted to 7 bits, such as NNTP and some email applications. Because of issues with robustness and security, you should not use UTF7 encoding in 8-bit environments where UTF-8 encoding can be used instead. </p>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public static Encoding UTF7 { get; }
    content.vb: Public Shared ReadOnly Property UTF7 As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An encoding for the UTF-7 format.</p>\n"
  seealso:
  - type: System.Text.UTF7Encoding
    commentId: T:System.Text.UTF7Encoding
  - type: System.Text.Encoding.UTF8
    commentId: P:System.Text.Encoding.UTF8
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.UTF8
  commentId: P:System.Text.Encoding.UTF8
  id: UTF8
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: UTF8
  fullName: System.Text.Encoding.UTF8
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UTF8
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 138
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Gets an encoding for the UTF-8 format.</p>\n"
  remarks: "\n<p>This property returns a <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that encodes Unicode (UTF-16-encoded) characters into a sequence of one to four bytes per character, and that decodes a UTF-8-encoded byte array to Unicode (UTF-16-encoded) characters. For information about the character encodings supported by the .NET Framework and a discussion of which Unicode encoding to use, see Character Encoding in the .NET Framework. </p>\n<p>The <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that is returned by this property might not have the appropriate behavior for your app. </p>\n<ul><li>\n<p>It returns a <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that provides a Unicode byte order mark (BOM). To instantiate a UTF8 encoding that doesn't provide a BOM, call any overload of the <xref href=\"System.Text.UTF8Encoding.#ctor\" data-throw-if-not-resolved=\"false\"></xref> constructor. </p>\n</li><li>\n<p>It returns a <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> object that uses replacement fallback to replace each string that it can't encode and each byte that it can't decode with a question mark (\"?\") character. Instead, you can call the <xref href=\"System.Text.UTF8Encoding.#ctor(System.Boolean,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor to instantiate a <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref> object whose fallback is either an <xref href=\"System.Text.EncoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Text.DecoderFallbackException\" data-throw-if-not-resolved=\"false\"></xref>, as the following example illustrates.</p>System.Text.Encoding.UTF8#1</li></ul>\n"
  example:
  - "\n<p>The following example defines an array that consists of the following characters: </p>\n<ul><li>\n<p>LATIN SMALL LETTER Z (U+007A)</p>\n</li><li>\n<p>LATIN SMALL LETTER A (U+0061)</p>\n</li><li>\n<p>COMBINING BREVE (U+0306)</p>\n</li><li>\n<p>LATIN SMALL LETTER AE WITH ACUTE (U+01FD)</p>\n</li><li>\n<p>GREEK SMALL LETTER BETA (U+03B2)</p>\n</li><li>\n<p>A surrogate pair (U+D800 U+DD54) that forms GREEK ACROPHONIC ATTIC ONE THOUSAND STATERS (U+10154). </p>\n</li></ul>\n<p>It displays the UTF-16 code units of each character and determines the number of bytes required by a UTF-8 encoder to encode the character array. It then encodes the characters and displays the resulting UTF-8-encoded bytes. </p>System.Text.Encoding.UTF8#2"
  syntax:
    content: public static Encoding UTF8 { get; }
    content.vb: Public Shared ReadOnly Property UTF8 As Encoding
    parameters: []
    return:
      type: System.Text.Encoding
      description: "\n<p>An encoding for the UTF-8 format.</p>\n"
  seealso:
  - type: System.Text.UTF8Encoding
    commentId: T:System.Text.UTF8Encoding
  - type: System.Text.Encoding.GetEncoding(System.Int32)
    commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Text.Encoding.WebName
  commentId: P:System.Text.Encoding.WebName
  id: WebName
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: WebName
  fullName: System.Text.Encoding.WebName
  type: Property
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WebName
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 139
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, gets the name registered with the Internet Assigned Numbers Authority (IANA) for the current encoding.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> property is the same as the <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>Note that <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> returns an IANA-registered name for the encoding. When its value is the name of a standard, the implementation of the encoding might not conform in full to that standard. The <xref href=\"System.Text.Encoding.HeaderName\" data-throw-if-not-resolved=\"false\"></xref> property defines a different encoding that might work better for e-mail headers. However, most apps should use <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> instead.</p>\n<p>For more information on the IANA, go to <see href=\"http://www.iana.org/\">www.iana.org</see>.</p>\n<p>The <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> is the same as the <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref> returned by <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref>. Some of the web names are duplicates; see the remarks for <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> for more information.</p>\n"
  example:
  - "\n<p>The following example includes the <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> in an HTML header.</p>System.Text.Encoding.WebName#1<p>The following example retrieves the different names for each encoding and displays the encodings with one or more names that are different from <xref href=\"System.Text.EncodingInfo.Name\" data-throw-if-not-resolved=\"false\"></xref>. It displays <xref href=\"System.Text.Encoding.EncodingName\" data-throw-if-not-resolved=\"false\"></xref> but does not compare against it.</p>System.Text.Encoding.Names#1"
  syntax:
    content: public virtual string WebName { get; }
    content.vb: Public Overridable ReadOnly Property WebName As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>The IANA name for the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.EncodingInfo.Name
    commentId: P:System.Text.EncodingInfo.Name
  - type: System.Text.Encoding.BodyName
    commentId: P:System.Text.Encoding.BodyName
  - type: System.Text.Encoding.EncodingName
    commentId: P:System.Text.Encoding.EncodingName
  - type: System.Text.Encoding.HeaderName
    commentId: P:System.Text.Encoding.HeaderName
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Text.Encoding.Clone
  commentId: M:System.Text.Encoding.Clone
  id: Clone
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Clone()
  fullName: System.Text.Encoding.Clone()
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Clone
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 140
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, creates a shallow copy of the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>The clone is writable even if the original <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object is read-only. Therefore, the properties of the clone can be modified.</p>\n<p>A shallow copy of an object is a copy of the object only. If the object contains references to other objects, the shallow copy does not create copies of the referred objects. It refers to the original objects instead. In contrast, a deep copy of an object creates a copy of the object and a copy of everything directly or indirectly referenced by that object.</p>\n"
  syntax:
    content: public virtual object Clone()
    content.vb: Public Overridable Function Clone As Object
    return:
      type: System.Object
      description: "\n<p>A copy of the current <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])
  commentId: M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])
  id: Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Convert(Encoding, Encoding, Byte[])
  fullName: System.Text.Encoding.Convert(System.Text.Encoding, System.Text.Encoding, System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Convert
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 141
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Converts an entire byte array from one encoding to another.</p>\n"
  example:
  - "\n<p>The following example converts a Unicode-encoded string to an ASCII-encoded string. Because the ASCII encoding object returned by the <xref href=\"System.Text.Encoding.ASCII\" data-throw-if-not-resolved=\"false\"></xref> property uses replacement fallback and the Pi character is not part of the ASCII character set, the Pi character is replaced with a question mark, as the output from the example shows.</p>System.Text.Encoding.Convert Example#1"
  syntax:
    content: public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes)
    content.vb: Public Shared Function Convert(srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte()) As Byte()
    parameters:
    - id: srcEncoding
      type: System.Text.Encoding
      description: "\n<p>The encoding format of <em>bytes</em>. </p>\n"
    - id: dstEncoding
      type: System.Text.Encoding
      description: "\n<p>The target encoding format. </p>\n"
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The bytes to convert. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> containing the results of converting <em>bytes</em> from <em>srcEncoding</em> to <em>dstEncoding</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>srcEncoding</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>dstEncoding</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<strong>srcEncoding.</strong>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<strong>dstEncoding.</strong>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Text.Encoding.Convert(System.Text.Encoding, System.Text.Encoding, System.Byte())
  name.vb: Convert(Encoding, Encoding, Byte())
- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)
  id: Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Convert(Encoding, Encoding, Byte[], Int32, Int32)
  fullName: System.Text.Encoding.Convert(System.Text.Encoding, System.Text.Encoding, System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Convert
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 142
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Converts a range of bytes in a byte array from one encoding to another.</p>\n"
  syntax:
    content: public static byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, byte[] bytes, int index, int count)
    content.vb: Public Shared Function Convert(srcEncoding As Encoding, dstEncoding As Encoding, bytes As Byte(), index As Integer, count As Integer) As Byte()
    parameters:
    - id: srcEncoding
      type: System.Text.Encoding
      description: "\n<p>The encoding of the source array, <em>bytes</em>. </p>\n"
    - id: dstEncoding
      type: System.Text.Encoding
      description: "\n<p>The encoding of the output array. </p>\n"
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The array of bytes to convert. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first element of <em>bytes</em> to convert. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of bytes to convert. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>An array of type <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> containing the result of converting a range of bytes in <em>bytes</em> from <em>srcEncoding</em> to <em>dstEncoding</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>srcEncoding</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>dstEncoding</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> and <em>count</em> do not specify a valid range in the byte array. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<strong>srcEncoding.</strong>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<strong>dstEncoding.</strong>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Text.Encoding.Convert(System.Text.Encoding, System.Text.Encoding, System.Byte(), System.Int32, System.Int32)
  name.vb: Convert(Encoding, Encoding, Byte(), Int32, Int32)
- uid: System.Text.Encoding.Equals(System.Object)
  commentId: M:System.Text.Encoding.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.Text.Encoding.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Equals
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 143
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Determines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is equal to the current instance.</p>\n"
  remarks: "\n<p>Two instances of <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> are considered equal if they correspond to the same code page and their <strong>EncoderFallback</strong> and <strong>DecoderFallback</strong> objects are equal. In particular, derived code pages all have a code page of 0 and their fallbacks are normally <strong>null </strong>(<strong>Nothing </strong>in Visual Basic .NET). Thus they are all considered equal to one another. One consequence is that when <xref href=\"System.Text.Encoding.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> is used to populate a hash table, all derived encodings compare equal and fall into the same hash table slot.</p>\n"
  example:
  - "\n<p>The following example gets two instances of the same encoding (one by codepage and another by name), and checks their equality.</p>System.Text.Encoding.Equals#1"
  syntax:
    content: public override bool Equals(object value)
    content.vb: Public Overrides Function Equals(value As Object) As Boolean
    parameters:
    - id: value
      type: System.Object
      description: "\n<p>The <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> to compare with the current instance. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>value</em> is an instance of <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> and is equal to the current instance; otherwise, <strong>false</strong>. </p>\n"
  seealso:
  - type: System.Object.Equals(System.Object)
    commentId: M:System.Object.Equals(System.Object)
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Text.Encoding.GetByteCount(System.Char*,System.Int32)
  commentId: M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)
  id: GetByteCount(System.Char*,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetByteCount(Char*, Int32)
  fullName: System.Text.Encoding.GetByteCount(System.Char*, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetByteCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 144
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.</p>\n"
  remarks: "\n<p>To calculate the exact array size that <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> requires to store the resulting bytes, you should call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream.</p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some considerations for using these methods:</p>\n<ul><li>\n<p>Your app may need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used.</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  syntax:
    content: public virtual int GetByteCount(char *chars, int count)
    content.vb: Public Overridable Function GetByteCount(chars As Char *, count As Integer) As Integer
    parameters:
    - id: chars
      type: System.Char*
      description: "\n<p>A pointer to the first character to encode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes produced by encoding the specified characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>count</em> is less than zero. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetByteCount(System.Char[])
  commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  id: GetByteCount(System.Char[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetByteCount(Char[])
  fullName: System.Text.Encoding.GetByteCount(System.Char[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetByteCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 147
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of bytes produced by encoding all the characters in the specified character array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used.</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string versions of the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, you should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public virtual int GetByteCount(char[] chars)
    content.vb: Public Overridable Function GetByteCount(chars As Char()) As Integer
    parameters:
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array containing the characters to encode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes produced by encoding all the characters in the specified character array.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetByteCount(System.Char())
  name.vb: GetByteCount(Char())
- uid: System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)
  id: GetByteCount(System.Char[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetByteCount(Char[], Int32, Int32)
  fullName: System.Text.Encoding.GetByteCount(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetByteCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 148
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of bytes produced by encoding a set of characters from the specified character array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used.</p>\n</li><li>\n<p>If your app handles string inputs, the string version of <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> is recommended.</p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArrIC#1"
  syntax:
    content: public abstract int GetByteCount(char[] chars, int index, int count)
    content.vb: Public MustOverride Function GetByteCount(chars As Char(), index As Integer, count As Integer) As Integer
    parameters:
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array containing the set of characters to encode. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first character to encode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes produced by encoding the specified characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>index</em> and <em>count</em> do not denote a valid range in <em>chars</em>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: System.Text.Encoding.GetByteCount(System.Char(), System.Int32, System.Int32)
  name.vb: GetByteCount(Char(), Int32, Int32)
- uid: System.Text.Encoding.GetByteCount(System.String)
  commentId: M:System.Text.Encoding.GetByteCount(System.String)
  id: GetByteCount(System.String)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetByteCount(String)
  fullName: System.Text.Encoding.GetByteCount(System.String)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetByteCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 149
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of bytes produced by encoding the characters in the specified string.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used.</p>\n</li><li>\n<p>If your app handles string inputs, the string version of <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is recommended. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_String#1"
  syntax:
    content: public virtual int GetByteCount(string s)
    content.vb: Public Overridable Function GetByteCount(s As String) As Integer
    parameters:
    - id: s
      type: System.String
      description: "\n<p>The string containing the set of characters to encode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of bytes produced by encoding the specified characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>s</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)
  commentId: M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)
  id: GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(Char*, Int32, Byte*, Int32)
  fullName: System.Text.Encoding.GetBytes(System.Char*, System.Int32, System.Byte*, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 150
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.</p>\n"
  remarks: "\n<p>To calculate the exact array size that <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> requires to store the resulting bytes, call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  syntax:
    content: public virtual int GetBytes(char *chars, int charCount, byte *bytes, int byteCount)
    content.vb: Public Overridable Function GetBytes(chars As Char *, charCount As Integer, bytes As Byte *, byteCount As Integer) As Integer
    parameters:
    - id: chars
      type: System.Char*
      description: "\n<p>A pointer to the first character to encode. </p>\n"
    - id: charCount
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    - id: bytes
      type: System.Byte*
      description: "\n<p>A pointer to the location at which to start writing the resulting sequence of bytes. </p>\n"
    - id: byteCount
      type: System.Int32
      description: "\n<p>The maximum number of bytes to write. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The actual number of bytes written at the location indicated by the <em>bytes</em> parameter.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>charCount</em> or <em>byteCount</em> is less than zero. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>byteCount</em> is less than the resulting number of bytes. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetBytes(System.Char[])
  commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  id: GetBytes(System.Char[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(Char[])
  fullName: System.Text.Encoding.GetBytes(System.Char[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 153
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes all the characters in the specified character array into a sequence of bytes.</p>\n"
  remarks: "\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should call the string version of the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public virtual byte[] GetBytes(char[] chars)
    content.vb: Public Overridable Function GetBytes(chars As Char()) As Byte()
    parameters:
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array containing the characters to encode. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>A byte array containing the results of encoding the specified set of characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetBytes(System.Char())
  name.vb: GetBytes(Char())
- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)
  id: GetBytes(System.Char[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(Char[], Int32, Int32)
  fullName: System.Text.Encoding.GetBytes(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 154
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes a set of characters from the specified character array into a sequence of bytes.</p>\n"
  remarks: "\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArrIC#1"
  syntax:
    content: public virtual byte[] GetBytes(char[] chars, int index, int count)
    content.vb: Public Overridable Function GetBytes(chars As Char(), index As Integer, count As Integer) As Byte()
    parameters:
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array containing the set of characters to encode. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first character to encode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>A byte array containing the results of encoding the specified set of characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>index</em> and <em>count</em> do not denote a valid range in <em>chars</em>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetBytes(System.Char(), System.Int32, System.Int32)
  name.vb: GetBytes(Char(), Int32, Int32)
- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)
  commentId: M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)
  id: GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(Char[], Int32, Int32, Byte[], Int32)
  fullName: System.Text.Encoding.GetBytes(System.Char[], System.Int32, System.Int32, System.Byte[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 155
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes a set of characters from the specified character array into the specified byte array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, you should call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode three characters from a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArrIC#1"
  syntax:
    content: public abstract int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
    content.vb: Public MustOverride Function GetBytes(chars As Char(), charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer
    parameters:
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array containing the set of characters to encode. </p>\n"
    - id: charIndex
      type: System.Int32
      description: "\n<p>The index of the first character to encode. </p>\n"
    - id: charCount
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array to contain the resulting sequence of bytes. </p>\n"
    - id: byteIndex
      type: System.Int32
      description: "\n<p>The index at which to start writing the resulting sequence of bytes. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The actual number of bytes written into <em>bytes</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>chars</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>charIndex</em> or <em>charCount</em> or <em>byteIndex</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>charIndex</em> and <em>charCount</em> do not denote a valid range in <em>chars</em>.</p>\n<p>-or- </p>\n<p>\n<em>byteIndex</em> is not a valid index in <em>bytes</em>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>bytes</em> does not have enough capacity from <em>byteIndex</em> to the end of the array to accommodate the resulting bytes. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: System.Text.Encoding.GetBytes(System.Char(), System.Int32, System.Int32, System.Byte(), System.Int32)
  name.vb: GetBytes(Char(), Int32, Int32, Byte(), Int32)
- uid: System.Text.Encoding.GetBytes(System.String)
  commentId: M:System.Text.Encoding.GetBytes(System.String)
  id: GetBytes(System.String)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(String)
  fullName: System.Text.Encoding.GetBytes(System.String)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 156
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes all the characters in the specified string into a sequence of bytes.</p>\n"
  remarks: "\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_String#1"
  syntax:
    content: public virtual byte[] GetBytes(string s)
    content.vb: Public Overridable Function GetBytes(s As String) As Byte()
    parameters:
    - id: s
      type: System.String
      description: "\n<p>The string containing the characters to encode. </p>\n"
    return:
      type: System.Byte[]
      description: "\n<p>A byte array containing the results of encoding the specified set of characters.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>s</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)
  commentId: M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)
  id: GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetBytes(String, Int32, Int32, Byte[], Int32)
  fullName: System.Text.Encoding.GetBytes(System.String, System.Int32, System.Int32, System.Byte[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetBytes
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 157
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, encodes a set of characters from the specified string into the specified byte array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, you should call the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, call the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>The <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method determines how many bytes result in encoding a set of Unicode characters, and the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual encoding. The <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple conversions on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to encode many input characters to a code page and process the characters using multiple calls. In this case, you probably need to maintain state between calls, taking into account the state that is persisted by the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object being used. (For example, a character sequence that includes surrogate pairs might end with a high surrogate. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> will remember that high surrogate so that it can be combined with a low surrogate at the beginning of a following call. <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> won't be able to maintain the state, so the character will be sent to the <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>.)</p>\n</li><li>\n<p>If your app handles string inputs, you should use the string version of <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>The Unicode character buffer version of <xref href=\"System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls using the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object or inserting into existing buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref> version that supports byte arrays is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Encoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetByteCount(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible, and does throw an exception if the output buffer is too small. For continuous encoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a string or a range in the string, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_String#1"
  syntax:
    content: public virtual int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
    content.vb: Public Overridable Function GetBytes(s As String, charIndex As Integer, charCount As Integer, bytes As Byte(), byteIndex As Integer) As Integer
    parameters:
    - id: s
      type: System.String
      description: "\n<p>The string containing the set of characters to encode. </p>\n"
    - id: charIndex
      type: System.Int32
      description: "\n<p>The index of the first character to encode. </p>\n"
    - id: charCount
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array to contain the resulting sequence of bytes. </p>\n"
    - id: byteIndex
      type: System.Int32
      description: "\n<p>The index at which to start writing the resulting sequence of bytes. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The actual number of bytes written into <em>bytes</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>s</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>charIndex</em> or <em>charCount</em> or <em>byteIndex</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>charIndex</em> and <em>charCount</em> do not denote a valid range in <em>chars</em>.</p>\n<p>-or- </p>\n<p>\n<em>byteIndex</em> is not a valid index in <em>bytes</em>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>bytes</em> does not have enough capacity from <em>byteIndex</em> to the end of the array to accommodate the resulting bytes. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetMaxByteCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetBytes(System.String, System.Int32, System.Int32, System.Byte(), System.Int32)
  name.vb: GetBytes(String, Int32, Int32, Byte(), Int32)
- uid: System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)
  commentId: M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)
  id: GetCharCount(System.Byte*,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetCharCount(Byte*, Int32)
  fullName: System.Text.Encoding.GetCharCount(System.Byte*, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetCharCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 158
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.</p>\n"
  remarks: "\n<p>To calculate the exact array size that <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> requires to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.</p>\n</li><li>\n<p>If your app handles string outputs, it is recommended to use the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  syntax:
    content: public virtual int GetCharCount(byte *bytes, int count)
    content.vb: Public Overridable Function GetCharCount(bytes As Byte *, count As Integer) As Integer
    parameters:
    - id: bytes
      type: System.Byte*
      description: "\n<p>A pointer to the first byte to decode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of characters produced by decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>count</em> is less than zero. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetCharCount(System.Byte[])
  commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  id: GetCharCount(System.Byte[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetCharCount(Byte[])
  fullName: System.Text.Encoding.GetCharCount(System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetCharCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 161
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of characters produced by decoding all the bytes in the specified byte array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, you should use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the  <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.</p>\n</li><li>\n<p>If your app handles string outputs, you should use the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</p>System.Text.Encoding.GetChars#1"
  syntax:
    content: public virtual int GetCharCount(byte[] bytes)
    content.vb: Public Overridable Function GetCharCount(bytes As Byte()) As Integer
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of characters produced by decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetCharCount(System.Byte())
  name.vb: GetCharCount(Byte())
- uid: System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)
  id: GetCharCount(System.Byte[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetCharCount(Byte[], Int32, Int32)
  fullName: System.Text.Encoding.GetCharCount(System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetCharCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 162
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls.</p>\n</li><li>\n<p>If your app handles string outputs, it is recommended to use the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example converts a string from one encoding to another.</p>System.Text.Encoding.Convert Example#1<p>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</p>System.Text.Encoding.GetCharsIC#1"
  syntax:
    content: public abstract int GetCharCount(byte[] bytes, int index, int count)
    content.vb: Public MustOverride Function GetCharCount(bytes As Byte(), index As Integer, count As Integer) As Integer
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first byte to decode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The number of characters produced by decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>index</em> and <em>count</em> do not denote a valid range in <em>bytes</em>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: System.Text.Encoding.GetCharCount(System.Byte(), System.Int32, System.Int32)
  name.vb: GetCharCount(Byte(), Int32, Int32)
- uid: System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)
  commentId: M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)
  id: GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetChars(Byte*, Int32, Char*, Int32)
  fullName: System.Text.Encoding.GetChars(System.Byte*, System.Int32, System.Char*, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetChars
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 163
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.</p>\n"
  remarks: "\n<p>To calculate the exact array size that <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> requires to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> gets characters from an input byte sequence. <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is different than <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> because <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> expects discrete conversions, while <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> is designed for multiple passes on a single input stream.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> object provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>NoteThis method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref href=\"System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call and continue at the beginning of the next <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call. <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will call the fallback for those incomplete sequences, but <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> will remember those sequences for the next call.)</p>\n</li><li>\n<p>If your app handles string outputs, the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  syntax:
    content: public virtual int GetChars(byte *bytes, int byteCount, char *chars, int charCount)
    content.vb: Public Overridable Function GetChars(bytes As Byte *, byteCount As Integer, chars As Char *, charCount As Integer) As Integer
    parameters:
    - id: bytes
      type: System.Byte*
      description: "\n<p>A pointer to the first byte to decode. </p>\n"
    - id: byteCount
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    - id: chars
      type: System.Char*
      description: "\n<p>A pointer to the location at which to start writing the resulting set of characters. </p>\n"
    - id: charCount
      type: System.Int32
      description: "\n<p>The maximum number of characters to write. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The actual number of characters written at the location indicated by the <em>chars</em> parameter.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>byteCount</em> or <em>charCount</em> is less than zero. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>charCount</em> is less than the resulting number of characters. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetChars(System.Byte[])
  commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  id: GetChars(System.Byte[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetChars(Byte[])
  fullName: System.Text.Encoding.GetChars(System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetChars
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 166
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes all the bytes in the specified byte array into a set of characters.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> gets characters from an input byte sequence. <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> is different than <see cref=\"Overload:System.Text.Decoder.GetChars\"></see> because <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> expects discrete conversions, while <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> is designed for multiple passes on a single input stream.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>NoteThis method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref href=\"System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> call and continue at the beginning of the next <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> call. <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> will call the fallback for those incomplete sequences, but <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> will remember those sequences for the next call.)</p>\n</li><li>\n<p>If your app handles string outputs, it is recommended to use the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</p>System.Text.Encoding.GetChars#1"
  syntax:
    content: public virtual char[] GetChars(byte[] bytes)
    content.vb: Public Overridable Function GetChars(bytes As Byte()) As Char()
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    return:
      type: System.Char[]
      description: "\n<p>A character array containing the results of decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetChars(System.Byte())
  name.vb: GetChars(Byte())
- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)
  id: GetChars(System.Byte[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetChars(Byte[], Int32, Int32)
  fullName: System.Text.Encoding.GetChars(System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetChars
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 167
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a set of characters.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> gets characters from an input byte sequence. <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is different than <see cref=\"Overload:System.Text.Decoder.GetChars\"></see> because <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> expects discrete conversions, while <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> is designed for multiple passes on a single input stream.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>NoteThis method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref href=\"System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call and continue at the beginning of the next <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call. <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will call the fallback for those incomplete sequences, but <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> will remember those sequences for the next call.)</p>\n</li><li>\n<p>If your app handles string outputs, it is recommended to use the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</p>System.Text.Encoding.GetCharsIC#1"
  syntax:
    content: public virtual char[] GetChars(byte[] bytes, int index, int count)
    content.vb: Public Overridable Function GetChars(bytes As Byte(), index As Integer, count As Integer) As Char()
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first byte to decode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.Char[]
      description: "\n<p>A character array containing the results of decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>index</em> and <em>count</em> do not denote a valid range in <em>bytes</em>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetChars(System.Byte(), System.Int32, System.Int32)
  name.vb: GetChars(Byte(), Int32, Int32)
- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)
  commentId: M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)
  id: GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetChars(Byte[], Int32, Int32, Char[], Int32)
  fullName: System.Text.Encoding.GetChars(System.Byte[], System.Int32, System.Int32, System.Char[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetChars
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 168
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into the specified character array.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> gets characters from an input byte sequence. <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is different than <see cref=\"Overload:System.Text.Decoder.GetChars\"></see> because <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> expects discrete conversions, while <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> is designed for multiple passes on a single input stream.</p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>Note This method is intended to operate on Unicode characters, not on arbitrary binary data, such as byte arrays. If you need to encode arbitrary binary data into text, you should use a protocol such as uuencode, which is implemented by methods such as <xref href=\"System.Convert.ToBase64CharArray(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method determines how many characters result in decoding a sequence of bytes, and the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method performs the actual decoding. The <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method expects discrete conversions, in contrast to the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, which handles multiple passes on a single input stream. </p>\n<p>Several versions of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> are supported. The following are some programming considerations for use of these methods:</p>\n<ul><li>\n<p>Your app might need to decode multiple input bytes from a code page and process the bytes using multiple calls. In this case, you probably need to maintain state between calls, because byte sequences can be interrupted when processed in batches. (For example, part of an ISO-2022 shift sequence may end one <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call and continue at the beginning of the next <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> call. <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will call the fallback for those incomplete sequences, but <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> will remember those sequences for the next call.)</p>\n</li><li>\n<p>If your app handles string outputs, the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method is recommended. Since this method must check string length and allocate a buffer, it is slightly slower, but the resulting <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> type is to be preferred.</p>\n</li><li>\n<p>The byte version of <xref href=\"System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> allows some fast techniques, particularly with multiple calls to large buffers. Bear in mind, however, that this method version is sometimes unsafe, since pointers are required.</p>\n</li><li>\n<p>If your app must convert a large amount of data, it should reuse the output buffer. In this case, the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> version that supports output character buffers is the best choice. </p>\n</li><li>\n<p>Consider using the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method instead of <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref>. The conversion method converts as much data as possible and throws an exception if the output buffer is too small. For continuous decoding of a stream, this method is often the best choice.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example converts a string from one encoding to another.</p>System.Text.Encoding.Convert Example#1<p>The following example encodes a string into an array of bytes, and then decodes a range of the bytes into an array of characters.</p>System.Text.Encoding.GetCharsIC#1"
  syntax:
    content: public abstract int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
    content.vb: Public MustOverride Function GetChars(bytes As Byte(), byteIndex As Integer, byteCount As Integer, chars As Char(), charIndex As Integer) As Integer
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    - id: byteIndex
      type: System.Int32
      description: "\n<p>The index of the first byte to decode. </p>\n"
    - id: byteCount
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    - id: chars
      type: System.Char[]
      description: "\n<p>The character array to contain the resulting set of characters. </p>\n"
    - id: charIndex
      type: System.Int32
      description: "\n<p>The index at which to start writing the resulting set of characters. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The actual number of characters written into <em>chars</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>chars</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>byteIndex</em> or <em>byteCount</em> or <em>charIndex</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>byteindex</em> and <em>byteCount</em> do not denote a valid range in <em>bytes</em>.</p>\n<p>-or- </p>\n<p>\n<em>charIndex</em> is not a valid index in <em>chars</em>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>chars</em> does not have enough capacity from <em>charIndex</em> to the end of the array to accommodate the resulting characters. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
  fullName.vb: System.Text.Encoding.GetChars(System.Byte(), System.Int32, System.Int32, System.Char(), System.Int32)
  name.vb: GetChars(Byte(), Int32, Int32, Char(), Int32)
- uid: System.Text.Encoding.GetDecoder
  commentId: M:System.Text.Encoding.GetDecoder
  id: GetDecoder
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetDecoder()
  fullName: System.Text.Encoding.GetDecoder()
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetDecoder
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 169
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, obtains a decoder that converts an encoded sequence of bytes into a sequence of characters.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method of this class. However, a <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> maintains state information between calls so it correctly decodes byte sequences that span blocks. The <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</p>\n"
  syntax:
    content: public virtual Decoder GetDecoder()
    content.vb: Public Overridable Function GetDecoder As Decoder
    return:
      type: System.Text.Decoder
      description: "\n<p>A <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> that converts an encoded sequence of bytes into a sequence of characters.</p>\n"
  seealso:
  - type: System.Text.Decoder
    commentId: T:System.Text.Decoder
  - type: System.Text.Encoding.GetChars(System.Byte[])
    commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetEncoder
  commentId: M:System.Text.Encoding.GetEncoder
  id: GetEncoder
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetEncoder()
  fullName: System.Text.Encoding.GetEncoder()
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetEncoder
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 170
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, obtains an encoder that converts a sequence of Unicode characters into an encoded sequence of bytes.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Encoder.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method of this class. However, a <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> maintains state information between calls so it correctly encodes character sequences that span blocks. The <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high surrogate, and the matching low surrogate might be in the next data block. Therefore, <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.</p>\n"
  syntax:
    content: public virtual Encoder GetEncoder()
    content.vb: Public Overridable Function GetEncoder As Encoder
    return:
      type: System.Text.Encoder
      description: "\n<p>A <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> that converts a sequence of Unicode characters into an encoded sequence of bytes.</p>\n"
  seealso:
  - type: System.Text.Encoder
    commentId: T:System.Text.Encoder
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetEncoding(System.Int32)
  commentId: M:System.Text.Encoding.GetEncoding(System.Int32)
  id: GetEncoding(System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetEncoding(Int32)
  fullName: System.Text.Encoding.GetEncoding(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetEncoding
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 171
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Returns the encoding associated with the specified code page identifier.</p>\n"
  remarks: "\n<p>The fallback handler depends on the encoding type of <em>codepage</em>. If <em>codepage</em> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by <em>codepage</em>, you can call the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> overload.</p>\n<p>The <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings. For a list of code pages, see the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic. Alternatively, you can call the <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> method to get an array of <xref href=\"System.Text.EncodingInfo\" data-throw-if-not-resolved=\"false\"></xref> objects that contains information about all encodings.</p>\n<p>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method returns any additional encodings that are made available by registering an <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value 0 for the <em>codepage</em> argument or, on the full .NET Framework on the Windows desktop, retrieve the value of the <xref href=\"System.Text.Encoding.Default\" data-throw-if-not-resolved=\"false\"></xref> property. To determine the default code pages used on the system, use the Windows <see href=\"http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx\">GetSystemDefaultLangID</see> function. To determine the current ANSI code page, call the Windows <see href=\"http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx\">GetACP</see> function from the full .NET Framework on the Windows desktop.</p>\n<p>Some unsupported code pages cause the exception <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref> to be thrown, whereas others cause <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, your code must catch all exceptions indicated in the Exceptions section.</p>\n<p>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by <strong>Encoding.GetEncoding(0)</strong> is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> class provides a constructor that lets you enable error detection.</p>\n"
  example:
  - "\n<p>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</p>System.Text.Encoding.Equals#1"
  syntax:
    content: public static Encoding GetEncoding(int codepage)
    content.vb: Public Shared Function GetEncoding(codepage As Integer) As Encoding
    parameters:
    - id: codepage
      type: System.Int32
      description: "\n<p>The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic.</p>\n<p>-or- </p>\n<p>0 (zero), to use the default encoding. </p>\n"
    return:
      type: System.Text.Encoding
      description: "\n<p>The encoding that is associated with the specified code page.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>codepage</em> is less than zero or greater than 65535. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>codepage</em> is not supported by the underlying platform. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>codepage</em> is not supported by the underlying platform. </p>\n"
  seealso:
  - type: System.Text.Encoding.CodePage
    commentId: P:System.Text.Encoding.CodePage
  - type: System.Text.Encoding.EncoderFallback
    commentId: P:System.Text.Encoding.EncoderFallback
  - type: System.Text.EncoderFallback
    commentId: T:System.Text.EncoderFallback
  - type: System.Text.Encoding.GetEncodings
    commentId: M:System.Text.Encoding.GetEncodings
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  commentId: M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  id: GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetEncoding(Int32, EncoderFallback, DecoderFallback)
  fullName: System.Text.Encoding.GetEncoding(System.Int32, System.Text.EncoderFallback, System.Text.DecoderFallback)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetEncoding
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 172
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Returns the encoding associated with the specified code page identifier. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</p>\n"
  remarks: "\n<p>Some unsupported code pages cause the exception <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref> to be thrown, whereas others cause <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, your code must catch all exceptions indicated in the Exceptions section.</p>\n<p>The <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</p>\n<p>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> method returns any additional encodings that are made available by registering an <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For this reason, encoding and decoding data using the default code page returned by <strong>Encoding.GetEncoding(0)</strong> is not recommended. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</p>\n<p>For a list of code pages, see the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic. You can call the <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</p>\n<p>To get the encoding associated with the default ANSI code page in the operating system's regional and language settings, you can either supply a value of 0 for the <em>codepage</em> argument or, if your code is running on the full .NET Framework on the Windows desktop, retrieve the value of the <xref href=\"System.Text.Encoding.Default\" data-throw-if-not-resolved=\"false\"></xref> property. To determine the default code pages used on the system, use the Windows <see href=\"http://msdn.microsoft.com/library/windows/desktop/dd318120.aspx\">GetSystemDefaultLangID</see> function. To determine the current ANSI code page, call the Windows <see href=\"http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx\">GetACP</see> function from the full .NET Framework on the Windows desktop.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> class provides a constructor that lets you enable error detection.</p>\n"
  example:
  - "\n<p>The following example demonstrates the <xref href=\"System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>sys.txt.fallbackEncRpl#1"
  syntax:
    content: public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
    content.vb: Public Shared Function GetEncoding(codepage As Integer, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding
    parameters:
    - id: codepage
      type: System.Int32
      description: "\n<p>The code page identifier of the preferred encoding. Possible values are listed in the Code Page column of the table that appears in the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic.</p>\n<p>-or- </p>\n<p>0 (zero), to use the default encoding. </p>\n"
    - id: encoderFallback
      type: System.Text.EncoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding. </p>\n"
    - id: decoderFallback
      type: System.Text.DecoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding. </p>\n"
    return:
      type: System.Text.Encoding
      description: "\n<p>The encoding that is associated with the specified code page.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>codepage</em> is less than zero or greater than 65535. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>codepage</em> is not supported by the underlying platform. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>codepage</em> is not supported by the underlying platform. </p>\n"
  seealso:
  - type: System.Text.Encoding.CodePage
    commentId: P:System.Text.Encoding.CodePage
  - type: System.Text.Encoding.EncoderFallback
    commentId: P:System.Text.Encoding.EncoderFallback
  - type: System.Text.EncoderFallback
    commentId: T:System.Text.EncoderFallback
  - type: System.Text.Encoding.GetEncodings
    commentId: M:System.Text.Encoding.GetEncodings
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Text.Encoding.GetEncoding(System.String)
  commentId: M:System.Text.Encoding.GetEncoding(System.String)
  id: GetEncoding(System.String)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetEncoding(String)
  fullName: System.Text.Encoding.GetEncoding(System.String)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetEncoding
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 173
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Returns the encoding associated with the specified code page name.</p>\n"
  remarks: "\n<p>The fallback handler depends on the encoding type of <em>name</em>. If <em>name</em> is a code page or double-byte character set (DBCS) encoding, a best-fit fallback handler is used. Otherwise, a replacement fallback handler is used. These fallback handlers may not be appropriate for your app. To specify the fallback handler used by the encoding specified by <em>name</em>, you can call the <xref href=\"System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> overload.</p>\n<p>The <strong>GetEncoding</strong> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</p>\n<p>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref href=\"System.Text.Encoding.GetEncoding(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method returns any additional encodings that are made available by registering an <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</p>\n<p>For a list of code pages, see the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic. You can call the <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> method in the full .NET Framework on the Windows desktop to get a list of all encodings.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> class provides a constructor that lets you enable error detection.</p>\n"
  example:
  - "\n<p>The following example gets two instances of the same encoding (one by code page and another by name), and checks their equality.</p>System.Text.Encoding.Equals#1"
  syntax:
    content: public static Encoding GetEncoding(string name)
    content.vb: Public Shared Function GetEncoding(name As String) As Encoding
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic.</p>\n"
    return:
      type: System.Text.Encoding
      description: "\n<p>The encoding  associated with the specified code page.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is not a valid code page name.</p>\n<p>-or- </p>\n<p>The code page indicated by <em>name</em> is not supported by the underlying platform. </p>\n"
  seealso:
  - type: System.Text.Encoding.EncoderFallback
    commentId: P:System.Text.Encoding.EncoderFallback
  - type: System.Text.EncoderFallback
    commentId: T:System.Text.EncoderFallback
  - type: System.Text.Encoding.GetEncodings
    commentId: M:System.Text.Encoding.GetEncodings
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)
  commentId: M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)
  id: GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetEncoding(String, EncoderFallback, DecoderFallback)
  fullName: System.Text.Encoding.GetEncoding(System.String, System.Text.EncoderFallback, System.Text.DecoderFallback)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetEncoding
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 174
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Returns the encoding associated with the specified code page name. Parameters specify an error handler for characters that cannot be encoded and byte sequences that cannot be decoded.</p>\n"
  remarks: "\n<p>The <strong>GetEncoding</strong> method relies on the underlying platform to support most code pages. However, the .NET Framework natively supports some encodings.</p>\n<p>In addition to the encodings that are intrinsically supported on a specific platform version of the .NET Framework, the <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method returns any additional encodings that are made available by registering an <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>The ANSI code pages can be different on different computers, or can be changed for a single computer, leading to data corruption. For the most consistent results, you should use Unicode, such as UTF-8 (code page 65001) or UTF-16, instead of a specific code page.</p>\n<p>For a list of code pages, see the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic. You can call the <xref href=\"System.Text.Encoding.GetEncodings\" data-throw-if-not-resolved=\"false\"></xref> method on the full .NET Framework on the Windows desktop to get a list of all encodings.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns a cached instance with default settings. You should use the constructors of derived classes to get an instance with different settings. For example, the <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref> class provides a constructor that lets you enable error detection.</p>\n"
  example:
  - "\n<p>The following example demonstrates the <xref href=\"System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>sys.txt.fallbackEncRpl#1"
  syntax:
    content: public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback)
    content.vb: Public Shared Function GetEncoding(name As String, encoderFallback As EncoderFallback, decoderFallback As DecoderFallback) As Encoding
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The code page name of the preferred encoding. Any value returned by the <xref href=\"System.Text.Encoding.WebName\" data-throw-if-not-resolved=\"false\"></xref> property is valid. Possible values are listed in the Name column of the table that appears in the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> class topic.</p>\n"
    - id: encoderFallback
      type: System.Text.EncoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a character cannot be encoded with the current encoding. </p>\n"
    - id: decoderFallback
      type: System.Text.DecoderFallback
      description: "\n<p>An object that provides an error-handling procedure when a byte sequence cannot be decoded with the current encoding. </p>\n"
    return:
      type: System.Text.Encoding
      description: "\n<p>The encoding that is associated with the specified code page.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is not a valid code page name.</p>\n<p>-or- </p>\n<p>The code page indicated by <em>name</em> is not supported by the underlying platform. </p>\n"
  seealso:
  - type: System.Text.Encoding.EncoderFallback
    commentId: P:System.Text.Encoding.EncoderFallback
  - type: System.Text.EncoderFallback
    commentId: T:System.Text.EncoderFallback
  - type: System.Text.Encoding.GetEncodings
    commentId: M:System.Text.Encoding.GetEncodings
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Text.Encoding.GetHashCode
  commentId: M:System.Text.Encoding.GetHashCode
  id: GetHashCode
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.Text.Encoding.GetHashCode()
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHashCode
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 175
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Returns the hash code for the current instance.</p>\n"
  syntax:
    content: public override int GetHashCode()
    content.vb: Public Overrides Function GetHashCode As Integer
    return:
      type: System.Int32
      description: "\n<p>The hash code for the current instance.</p>\n"
  seealso:
  - type: System.Object.GetHashCode
    commentId: M:System.Object.GetHashCode
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Text.Encoding.GetMaxByteCount(System.Int32)
  commentId: M:System.Text.Encoding.GetMaxByteCount(System.Int32)
  id: GetMaxByteCount(System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetMaxByteCount(Int32)
  fullName: System.Text.Encoding.GetMaxByteCount(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetMaxByteCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 176
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the maximum number of bytes produced by encoding the specified number of characters.</p>\n"
  remarks: "\n<p>The <em>charCount</em> parameter actually specifies the number of <xref href=\"System.Char\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the Unicode characters to encode, because the .NET Framework internally uses UTF-16 to represent Unicode characters. Consequently, most Unicode characters can be represented by one <xref href=\"System.Char\" data-throw-if-not-resolved=\"false\"></xref> object, but a Unicode character represented by a surrogate pair, for example, requires two <xref href=\"System.Char\" data-throw-if-not-resolved=\"false\"></xref> objects.</p>\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting bytes, you should use the <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetByteCount(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> retrieves a worst-case number, including the worst case for the currently selected <xref href=\"System.Text.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref>. If a fallback is chosen with a potentially large string, <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> retrieves large values, particularly in cases where the worst case for the encoding involves switching modes for every character. For example, this can happen for ISO-2022-JP. For more information, see the blog entry \"<see href=\"http://go.microsoft.com/fwlink/?LinkId=153702\">What's with Encoding.GetMaxByteCount() and Encoding.GetMaxCharCount()?</see>\" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).</p>\n<p>In most cases, this method retrieves reasonable values for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case when a more reasonable buffer is too small. You might also want to consider a different approach using <see cref=\"Overload:System.Text.Encoding.GetByteCount\"></see> or <see cref=\"Overload:System.Text.Encoder.Convert\"></see>.</p>\n<p>When using <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <xref href=\"System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>Note that <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> considers potential leftover surrogates from a previous decoder operation. Because of the decoder, passing a value of 1 to the method retrieves 2 for a single-byte encoding, such as ASCII. You should use the <xref href=\"System.Text.ASCIIEncoding.IsSingleByte\" data-throw-if-not-resolved=\"false\"></xref> property if this information is necessary.</p>\n<p>\n<code>GetMaxByteCount(N)</code> is not necessarily the same value as <code>N* GetMaxByteCount(1)</code>.</p>\n"
  example:
  - "\n<p>The following example determines the number of bytes required to encode a character array, encodes the characters, and displays the resulting bytes.</p>System.Text.Encoding.GetBytes_CharArr#1"
  syntax:
    content: public abstract int GetMaxByteCount(int charCount)
    content.vb: Public MustOverride Function GetMaxByteCount(charCount As Integer) As Integer
    parameters:
    - id: charCount
      type: System.Int32
      description: "\n<p>The number of characters to encode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The maximum number of bytes produced by encoding the specified number of characters.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>charCount</em> is less than zero. </p>\n"
  - type: System.Text.EncoderFallbackException
    commentId: T:System.Text.EncoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.EncoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetBytes(System.Char[])
    commentId: M:System.Text.Encoding.GetBytes(System.Char[])
  - type: System.Text.Encoding.GetByteCount(System.Char[])
    commentId: M:System.Text.Encoding.GetByteCount(System.Char[])
  - type: System.Text.Encoding.GetEncoder
    commentId: M:System.Text.Encoding.GetEncoder
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
- uid: System.Text.Encoding.GetMaxCharCount(System.Int32)
  commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  id: GetMaxCharCount(System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetMaxCharCount(Int32)
  fullName: System.Text.Encoding.GetMaxCharCount(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetMaxCharCount
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 177
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, calculates the maximum number of characters produced by decoding the specified number of bytes.</p>\n"
  remarks: "\n<p>To calculate the exact array size required by <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> to store the resulting characters, you should use the <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method. To calculate the maximum array size, use the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. The <xref href=\"System.Text.Encoding.GetCharCount(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method generally allows allocation of less memory, while the <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method generally executes faster.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> retrieves a worst-case number, including the worst case for the currently selected <xref href=\"System.Text.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref>. If a fallback is chosen with a potentially large string, <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> retrieves large values.</p>\n<p>In most cases, this method retrieves reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is too small. You might also want to consider a different approach using <see cref=\"Overload:System.Text.Encoding.GetCharCount\"></see> or <see cref=\"Overload:System.Text.Decoder.Convert\"></see>.</p>\n<p>\n<xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has no relation to <xref href=\"System.Text.Encoding.GetBytes(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. If you needs a similar function to use with <xref href=\"System.Text.Encoding.GetBytes(System.Char[])\" data-throw-if-not-resolved=\"false\"></xref>, you should use <xref href=\"System.Text.Encoding.GetMaxByteCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When using <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, you should allocate the output buffer based on the maximum size of the input buffer. If the output buffer is constrained in size, you might use the <see cref=\"Overload:System.Text.Decoder.Convert\"></see> method. </p>\n<p>Note that <xref href=\"System.Text.Encoding.GetMaxCharCount(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> considers the worst case for leftover bytes from a previous encoder operation. For most code pages, passing a value of 0 to this method retrieves values greater than or equal to 1.</p>\n<p>\n<code>GetMaxCharCount(N)</code> is not necessarily the same value as <code>N* GetMaxCharCount(1)</code>.</p>\n"
  example:
  - "\n<p>The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.</p>System.Text.Encoding.GetChars#1"
  syntax:
    content: public abstract int GetMaxCharCount(int byteCount)
    content.vb: Public MustOverride Function GetMaxCharCount(byteCount As Integer) As Integer
    parameters:
    - id: byteCount
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The maximum number of characters produced by decoding the specified number of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>byteCount</em> is less than zero. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetChars(System.Byte[])
    commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  - type: System.Text.Encoding.GetString(System.Byte[])
    commentId: M:System.Text.Encoding.GetString(System.Byte[])
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
- uid: System.Text.Encoding.GetPreamble
  commentId: M:System.Text.Encoding.GetPreamble
  id: GetPreamble
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetPreamble()
  fullName: System.Text.Encoding.GetPreamble()
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetPreamble
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 178
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, returns a sequence of bytes that specifies the encoding used.</p>\n"
  remarks: "\n<p>Optionally, the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object provides a preamble that is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (in Unicode, code point U+FEFF), it helps the decoder determine the byte order and the transformation format or UTF. </p>\n<p>The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal): </p>\n<ul><li>\n<p>UTF-8: EF BB BF </p>\n</li><li>\n<p>UTF-16 big endian byte order: FE FF </p>\n</li><li>\n<p>UTF-16 little endian byte order: FF FE </p>\n</li><li>\n<p>UTF-32 big endian byte order: 00 00 FE FF </p>\n</li><li>\n<p>UTF-32 little endian byte order: FF FE 00 00 </p>\n</li></ul>\n<p>You should use the BOM, because it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object, for example, untagged or improperly tagged web data or random text files stored when a business did not have international concerns or other data. Often user problems might be avoided if data is consistently and properly tagged, preferably in UTF-8 or UTF-16.  </p>\n<p>For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  </p>\n<p>There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.</p>\n<p>For more information on byte order and the byte order mark, see The Unicode Standard at the <see href=\"http://go.microsoft.com/fwlink/?LinkId=37123\">Unicode home page</see>.</p>\n<p>To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. However, most encodings do not provide a preamble. To ensure that the encoded bytes are decoded properly, you should use a Unicode encoding, that is, <xref href=\"System.Text.UTF8Encoding\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Text.UnicodeEncoding\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Text.UTF32Encoding\" data-throw-if-not-resolved=\"false\"></xref>, with a preamble.</p>\n"
  example:
  - "\n<p>The following example determines the byte order of the encoding based on the preamble.</p>System.Text.Encoding.GetPreamble Example#1"
  syntax:
    content: public virtual byte[] GetPreamble()
    content.vb: Public Overridable Function GetPreamble As Byte()
    return:
      type: System.Byte[]
      description: "\n<p>A byte array containing a sequence of bytes that specifies the encoding used.</p>\n<p>-or- </p>\n<p>A byte array of length zero, if a preamble is not required.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Text.Encoding.GetString(System.Byte*,System.Int32)
  commentId: M:System.Text.Encoding.GetString(System.Byte*,System.Int32)
  id: GetString(System.Byte*,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetString(Byte*, Int32)
  fullName: System.Text.Encoding.GetString(System.Byte*, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetString
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 179
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes a specified number of bytes starting at a specified address into a string. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Encoding.GetString(System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method is designed to optimize performance when you have a native pointer to a byte array. Instead of creating a managed byte array and then decoding it, you can instead call this method without having to create any intermediate objects. </p>\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> object returned by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method of a derived class. </p>\n<p>See the Remarks section of the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> reference topic for a discussion of decoding techniques and considerations. </p>\n<p>Note that the precise behavior of the <xref href=\"System.Text.Encoding.GetString(System.Byte*,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method for a particular <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> implementation depends on the fallback strategy defined for that <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object. For more information, see the \"Choosing a Fallback Strategy\" section of the Character Encoding in the .NET Framework topic. </p>\n"
  syntax:
    content: public string GetString(byte *bytes, int byteCount)
    content.vb: Public Function GetString(bytes As Byte *, byteCount As Integer) As String
    parameters:
    - id: bytes
      type: System.Byte*
      description: "\n<p>A pointer to a byte array. </p>\n"
    - id: byteCount
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.String
      description: "\n<p>A string that contains the results of decoding the specified sequence of bytes. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is a null pointer. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>byteCount</em> is less than zero. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A   fallback occurred (see Character Encoding in the .NET Framework for a complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetChars(System.Byte[])
    commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Text.Encoding.GetString(System.Byte[])
  commentId: M:System.Text.Encoding.GetString(System.Byte[])
  id: GetString(System.Byte[])
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetString(Byte[])
  fullName: System.Text.Encoding.GetString(System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetString
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 182
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes all the bytes in the specified byte array into a string.</p>\n"
  remarks: "\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> object returned by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method of a derived class.</p>\n<p>See the Remarks section of the <xref href=\"System.Text.Encoding.GetChars(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> reference topic for a discussion of decoding techniques and considerations.</p>\n<p>Note that the precise behavior of the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method for a particular <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> implementation depends on the fallback strategy defined for that <xref href=\"System.Text.Encoding\" data-throw-if-not-resolved=\"false\"></xref> object. For more information, see the \"Choosing a Fallback Strategy\" section of the Character Encoding in the .NET Framework topic. </p>\n"
  example:
  - "\n<p>The following example reads a UTF-8 encoded string from a binary file represented by a <xref href=\"System.IO.FileStream\" data-throw-if-not-resolved=\"false\"></xref> object. For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref href=\"System.Text.Encoding.GetString(System.Byte[])\" data-throw-if-not-resolved=\"false\"></xref> method to perform the decoding. For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref href=\"System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to determine how many characters are contained in the array, and then calls the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to perform the decoding.</p>System.Text.Encoding.GetString#2<p>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</p><pre><code>This is a UTF-8-encoded file that contains primarily Latin text, although it \ndoes list the first twelve letters of the Russian (Cyrillic) alphabet:\n\n           \n\nThe goal is to save this file, then open and decode it as a binary stream.</code></pre>"
  syntax:
    content: public virtual string GetString(byte[] bytes)
    content.vb: Public Overridable Function GetString(bytes As Byte()) As String
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    return:
      type: System.String
      description: "\n<p>A string that contains the results of decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The byte array contains invalid Unicode code points.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetChars(System.Byte[])
    commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetString(System.Byte())
  name.vb: GetString(Byte())
- uid: System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)
  id: GetString(System.Byte[],System.Int32,System.Int32)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: GetString(Byte[], Int32, Int32)
  fullName: System.Text.Encoding.GetString(System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetString
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 183
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>When overridden in a derived class, decodes a sequence of bytes from the specified byte array into a string.</p>\n"
  remarks: "\n<p>If the data to be converted is available only in sequential blocks (such as data read from a stream) or if the amount of data is so large that it needs to be divided into smaller blocks, you should use the <xref href=\"System.Text.Decoder\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Text.Encoder\" data-throw-if-not-resolved=\"false\"></xref> provided by the <xref href=\"System.Text.Encoding.GetDecoder\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Text.Encoding.GetEncoder\" data-throw-if-not-resolved=\"false\"></xref> method, respectively, of a derived class.</p>\n<p>See the Remarks section of the <xref href=\"System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> reference topic for a discussion of decoding techniques and considerations.</p>\n"
  example:
  - "\n<p>The following example reads a UTF-8 encoded string from a binary file that is represented by a <xref href=\"System.IO.FileStream\" data-throw-if-not-resolved=\"false\"></xref> object. For files that are smaller than 2,048 bytes, it reads the contents of the entire file into a byte array and calls the <xref href=\"System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to perform the decoding. For larger files, it reads 2,048 bytes at a time into a byte array, calls the <xref href=\"System.Text.Decoder.GetCharCount(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to determine how many characters are contained in the array, and then calls the <xref href=\"System.Text.Decoder.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to perform the decoding.</p>System.Text.Encoding.GetString#3<p>The example uses the following text, which should be saved to a UTF-8 encoded file named Utf8Example.txt.</p><pre><code>This is a UTF-8-encoded file that contains primarily Latin text, although it \ndoes list the first twelve letters of the Russian (Cyrillic) alphabet:\n\n           \n\nThe goal is to save this file, then open and decode it as a binary stream.</code></pre>"
  syntax:
    content: public virtual string GetString(byte[] bytes, int index, int count)
    content.vb: Public Overridable Function GetString(bytes As Byte(), index As Integer, count As Integer) As String
    parameters:
    - id: bytes
      type: System.Byte[]
      description: "\n<p>The byte array containing the sequence of bytes to decode. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the first byte to decode. </p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>The number of bytes to decode. </p>\n"
    return:
      type: System.String
      description: "\n<p>A string that contains the results of decoding the specified sequence of bytes.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The byte array contains invalid Unicode code points.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>bytes</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is less than zero.</p>\n<p>-or- </p>\n<p>\n<em>index</em> and <em>count</em> do not denote a valid range in <em>bytes</em>. </p>\n"
  - type: System.Text.DecoderFallbackException
    commentId: T:System.Text.DecoderFallbackException
    description: "\n<p>A fallback occurred (see Character Encoding in the .NET Framework for complete explanation)</p>\n<p>-and-</p>\n<p>\n<xref href=\"System.Text.Encoding.DecoderFallback\" data-throw-if-not-resolved=\"false\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Text.Encoding.GetChars(System.Byte[])
    commentId: M:System.Text.Encoding.GetChars(System.Byte[])
  - type: System.Text.Encoding.GetDecoder
    commentId: M:System.Text.Encoding.GetDecoder
  - type: System.Text.Encoding.GetCharCount(System.Byte[])
    commentId: M:System.Text.Encoding.GetCharCount(System.Byte[])
  - type: System.Text.Encoding.GetMaxCharCount(System.Int32)
    commentId: M:System.Text.Encoding.GetMaxCharCount(System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.Text.Encoding.GetString(System.Byte(), System.Int32, System.Int32)
  name.vb: GetString(Byte(), Int32, Int32)
- uid: System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)
  commentId: M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)
  id: RegisterProvider(System.Text.EncodingProvider)
  parent: System.Text.Encoding
  langs:
  - csharp
  - vb
  name: RegisterProvider(EncodingProvider)
  fullName: System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)
  type: Method
  source:
    remote:
      path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RegisterProvider
    path: src/System.Text.Encoding/ref/System.Text.Encoding.cs
    startLine: 184
  assemblies:
  - System.Text.Encoding
  namespace: System.Text
  summary: "\n<p>Registers an encoding provider. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\" data-throw-if-not-resolved=\"false\"></xref> method allows you to register a class derived from <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> that makes character encodings available on a platform that does not otherwise support them. Once the encoding provider is registered, the encodings that it supports can be retrieved by calling any <xref href=\"System.Text.Encoding.GetEncoding(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload. </p>\n<p>.NET Framework 4.6 includes one encoding provider, <xref href=\"System.Text.CodePagesEncodingProvider\" data-throw-if-not-resolved=\"false\"></xref>, that makes the encodings available that are present in the full .NET Framework but are not available in .NET Framework 4.6. By default, .NET Framework 4.6 only supports the Unicode encodings, ASCII, and code page 28591. </p>\n<p>If the same encoding provider is used in multiple calls to the <xref href=\"System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\" data-throw-if-not-resolved=\"false\"></xref> method, only the first method call registers the provider. Subsequent calls are ignored. </p>\n<p>If the <xref href=\"System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\" data-throw-if-not-resolved=\"false\"></xref> method is called to register multiple providers that handle the same encoding, the last registered provider is the used for all encoding and decoding operations. Any previously registered providers are ignored. </p>\n"
  syntax:
    content: public static void RegisterProvider(EncodingProvider provider)
    content.vb: Public Shared Sub RegisterProvider(provider As EncodingProvider)
    parameters:
    - id: provider
      type: System.Text.EncodingProvider
      description: "\n<p>A subclass of <xref href=\"System.Text.EncodingProvider\" data-throw-if-not-resolved=\"false\"></xref> that provides access to additional character encodings. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>provider</em> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Text.CodePagesEncodingProvider
    commentId: T:System.Text.CodePagesEncodingProvider
  - type: System.Text.EncodingProvider
    commentId: T:System.Text.EncodingProvider
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: System.Text
  isExternal: false
  name: System.Text
  fullName: System.Text
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Text.EncoderFallback
  parent: System.Text
  isExternal: false
  name: EncoderFallback
  fullName: System.Text.EncoderFallback
- uid: System.Text.DecoderFallback
  parent: System.Text
  isExternal: false
  name: DecoderFallback
  fullName: System.Text.DecoderFallback
- uid: System.Text.Encoding
  parent: System.Text
  isExternal: false
  name: Text.Encoding
  fullName: System.Text.Encoding
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Byte[]
  isExternal: false
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: ()
    fullName: ()
- uid: System.Char*
  isExternal: false
  name: Char*
  fullName: System.Char*
  spec.csharp:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: '*'
    fullName: '*'
  spec.vb:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: '*'
    fullName: '*'
- uid: System.Char[]
  isExternal: false
  name: Char[]
  fullName: System.Char[]
  fullname.vb: System.Char()
  name.vb: Char()
  spec.csharp:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: ()
    fullName: ()
- uid: System.Byte*
  isExternal: true
  name: Byte*
  fullName: System.Byte*
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: '*'
    fullName: '*'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
    isExternal: true
  - name: '*'
    fullName: '*'
- uid: System.Text.Decoder
  parent: System.Text
  isExternal: false
  name: Decoder
  fullName: System.Text.Decoder
- uid: System.Text.Encoder
  parent: System.Text
  isExternal: false
  name: Encoder
  fullName: System.Text.Encoder
- uid: System.Text.EncodingProvider
  parent: System.Text
  isExternal: false
  name: EncodingProvider
  fullName: System.Text.EncodingProvider
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.Text.DecoderFallbackException
  isExternal: false
  name: DecoderFallbackException
  fullName: System.Text.DecoderFallbackException
- uid: System.Text.EncoderFallbackException
  isExternal: false
  name: EncoderFallbackException
  fullName: System.Text.EncoderFallbackException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
