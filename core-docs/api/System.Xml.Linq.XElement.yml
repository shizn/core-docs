items:
- uid: System.Xml.Linq.XElement
  commentId: T:System.Xml.Linq.XElement
  id: XElement
  parent: System.Xml.Linq
  children:
  - System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)
  - System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)
  - System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)
  - System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])
  - System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)
  - System.Xml.Linq.XElement.AncestorsAndSelf
  - System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)
  - System.Xml.Linq.XElement.Attributes
  - System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)
  - System.Xml.Linq.XElement.DescendantNodesAndSelf
  - System.Xml.Linq.XElement.DescendantsAndSelf
  - System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XElement.EmptySequence
  - System.Xml.Linq.XElement.FirstAttribute
  - System.Xml.Linq.XElement.GetDefaultNamespace
  - System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)
  - System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)
  - System.Xml.Linq.XElement.HasAttributes
  - System.Xml.Linq.XElement.HasElements
  - System.Xml.Linq.XElement.IsEmpty
  - System.Xml.Linq.XElement.LastAttribute
  - System.Xml.Linq.XElement.Load(System.IO.Stream)
  - System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)
  - System.Xml.Linq.XElement.Load(System.IO.TextReader)
  - System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)
  - System.Xml.Linq.XElement.Load(System.String)
  - System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)
  - System.Xml.Linq.XElement.Load(System.Xml.XmlReader)
  - System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)
  - System.Xml.Linq.XElement.Name
  - System.Xml.Linq.XElement.NodeType
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32
  - System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64
  - System.Xml.Linq.XElement.Parse(System.String)
  - System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)
  - System.Xml.Linq.XElement.RemoveAll
  - System.Xml.Linq.XElement.RemoveAttributes
  - System.Xml.Linq.XElement.ReplaceAll(System.Object)
  - System.Xml.Linq.XElement.ReplaceAll(System.Object[])
  - System.Xml.Linq.XElement.ReplaceAttributes(System.Object)
  - System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])
  - System.Xml.Linq.XElement.Save(System.IO.Stream)
  - System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)
  - System.Xml.Linq.XElement.Save(System.IO.TextWriter)
  - System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)
  - System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)
  - System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)
  - System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
  - System.Xml.Linq.XElement.SetValue(System.Object)
  - System.Xml.Linq.XElement.Value
  - System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)
  langs:
  - csharp
  - vb
  name: XElement
  fullName: System.Xml.Linq.XElement
  type: Class
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: XElement
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.Manual.cs
    startLine: 10
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Represents an XML element.  See XElement Class Overview and the Remarks section on this page for usage information and examples.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#System.Xml.Linq/XLinq.cs#3367036406d1344a\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p></p>\n<p>This class represents an XML element, the fundamental XML construct.  See XElement Class Overview for other usage information.</p>\n<p>An element has an <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>, optionally one or more attributes, and can optionally contain content (for more information, see <xref href=\"System.Xml.Linq.XContainer.Nodes\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> can contain the following types of content: </p>\n<ul><li>\n<p>\n<xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XComment\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XProcessingInstruction\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>For details about the valid content of an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, see Valid Content of XElement and XDocument Objects.</p>\n<p>\n<xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> derives from <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref>, which derives from <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Some <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> methods can be used from XAML. For more information, see LINQ to XML Dynamic Properties.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree. The content of the new element comes from a LINQ query.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5),\nnew XElement(\"Child6\", 6)\n);\n\nXElement xmlTree2 = new XElement(\"Root\",\nfrom el in xmlTree1.Elements()\nwhere((int)el >= 3 && (int)el <= 5)\nselect el\n);\nConsole.WriteLine(xmlTree2);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _\n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n    <Child6>6</Child6>\n</Root>\n\nDim xmlTree2 As XElement = _ \n<Root>\n<%= From el In xmlTree1.Elements() _\n    Where el.Value >= 3 And el.Value <= 5 _\n    Select el %>\n</Root>\n\nConsole.WriteLine(xmlTree2)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n<p>The following is the same example, but in this case the XML is in a namespace. For more information, see Working with XML Namespaces.</p>\n<pre><code class=\"c#\">XNamespace aw = \"http://www.adventure-works.com\";\nXElement xmlTree1 = new XElement(aw + \"Root\",\nnew XElement(aw + \"Child1\", 1),\nnew XElement(aw + \"Child2\", 2),\nnew XElement(aw + \"Child3\", 3),\nnew XElement(aw + \"Child4\", 4),\nnew XElement(aw + \"Child5\", 5),\nnew XElement(aw + \"Child6\", 6)\n);\n\nXElement xmlTree2 = new XElement(aw + \"Root\",\nfrom el in xmlTree1.Elements()\nwhere((int)el >= 3 && (int)el <= 5)\nselect el\n);\nConsole.WriteLine(xmlTree2);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree1 As XElement = _\n    <Root>\n        <Child1>1</Child1>\n        <Child2>2</Child2>\n        <Child3>3</Child3>\n        <Child4>4</Child4>\n        <Child5>5</Child5>\n        <Child6>6</Child6>\n    </Root>\n\nDim xmlTree2 As XElement = _ \n    <Root>\n        <%= From el In xmlTree1.Elements() _\n            Where el.Value >= 3 And el.Value <= 5 _\n            Select el %>\n    </Root>\n\nConsole.WriteLine(xmlTree2)\nEnd SUb\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\">\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: 'public class XElement : XContainer, Serialization.IXmlSerializable'
    content.vb: >-
      Public Class XElement
          Inherits XContainer
          Implements Serialization.IXmlSerializable
  inheritance:
  - System.Object
  - System.Xml.Linq.XObject
  - System.Xml.Linq.XNode
  - System.Xml.Linq.XContainer
  implements:
  - System.Xml.Serialization.IXmlSerializable
  inheritedMembers:
  - System.Xml.Linq.XContainer.FirstNode
  - System.Xml.Linq.XContainer.LastNode
  - System.Xml.Linq.XContainer.Add(System.Object)
  - System.Xml.Linq.XContainer.Add(System.Object[])
  - System.Xml.Linq.XContainer.AddFirst(System.Object)
  - System.Xml.Linq.XContainer.AddFirst(System.Object[])
  - System.Xml.Linq.XContainer.CreateWriter
  - System.Xml.Linq.XContainer.DescendantNodes
  - System.Xml.Linq.XContainer.Descendants
  - System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)
  - System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)
  - System.Xml.Linq.XContainer.Elements
  - System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)
  - System.Xml.Linq.XContainer.Nodes
  - System.Xml.Linq.XContainer.RemoveNodes
  - System.Xml.Linq.XContainer.ReplaceNodes(System.Object)
  - System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])
  - System.Xml.Linq.XNode.DocumentOrderComparer
  - System.Xml.Linq.XNode.EqualityComparer
  - System.Xml.Linq.XNode.NextNode
  - System.Xml.Linq.XNode.PreviousNode
  - System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  - System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  - System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  - System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  - System.Xml.Linq.XNode.Ancestors
  - System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.CreateReader
  - System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  - System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.ElementsAfterSelf
  - System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.ElementsBeforeSelf
  - System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.NodesAfterSelf
  - System.Xml.Linq.XNode.NodesBeforeSelf
  - System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  - System.Xml.Linq.XNode.Remove
  - System.Xml.Linq.XNode.ReplaceWith(System.Object)
  - System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  - System.Xml.Linq.XNode.ToString
  - System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  - System.Xml.Linq.XObject.BaseUri
  - System.Xml.Linq.XObject.Document
  - System.Xml.Linq.XObject.Parent
  - System.Xml.Linq.XObject.Changed
  - System.Xml.Linq.XObject.Changing
  - System.Xml.Linq.XObject.AddAnnotation(System.Object)
  - System.Xml.Linq.XObject.Annotation(System.Type)
  - System.Xml.Linq.XObject.Annotation``1
  - System.Xml.Linq.XObject.Annotations(System.Type)
  - System.Xml.Linq.XObject.Annotations``1
  - System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  - System.Xml.Linq.XObject.RemoveAnnotations``1
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)
  commentId: M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XElement)
  id: '#ctor(System.Xml.Linq.XElement)'
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: XElement(XElement)
  fullName: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XElement)
  type: Constructor
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 202
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> class from another <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>This constructor makes a deep copy of an element.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree, creates a clone of the tree, and then calls <xref href=\"System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)\" data-throw-if-not-resolved=\"false\"></xref>, which tests whether the two XML trees are equal.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2)\n);\n\n// Create a clone of the tree.\nXElement treeClone = new XElement(xmlTree);\n\nConsole.WriteLine(\"xmlTree = treeClone: {0}\", XNode.DeepEquals(xmlTree, treeClone));\n\n// Do some work with xmlTree, perhaps pass it to other methods.\nxmlTree.Add(new XElement(\"Child3\", 3));\n\nConsole.WriteLine(\"xmlTree = treeClone: {0}\", XNode.DeepEquals(xmlTree, treeClone));</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root Att1=\"1\">\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n</Root>\n\n' Create a clone of the tree.\nDim treeClone As XElement = New XElement(xmlTree)\n\nConsole.WriteLine(\"xmlTree = treeClone: {0}\", XNode.DeepEquals(xmlTree, treeClone))\n\n' Do some work with xmlTree, perhaps pass it to other methods.\nxmlTree.Add(New XElement(\"Child3\", 3))\n\nConsole.WriteLine(\"xmlTree = treeClone: {0}\", XNode.DeepEquals(xmlTree, treeClone))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>xmlTree = treeClone: True\nxmlTree = treeClone: False</code></pre>\n"
  syntax:
    content: public XElement(XElement other)
    content.vb: Public Sub New(other As XElement)
    parameters:
    - id: other
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> object to copy from.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName)
  id: '#ctor(System.Xml.Linq.XName)'
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: XElement(XName)
  fullName: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XName)
  type: Constructor
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 203
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> class with the specified name. </p>\n"
  remarks: "\n<p>This constructor creates an element with no content and no attributes.</p>\n<p>There is an implicit conversion from string to <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. When creating an element in a namespace, typical use is to use the addition operator overload with an <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> and a string to create an <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. For more information, see Working with XML Namespaces.</p>\n"
  example:
  - "\n<p>The following example creates an element with no content.</p>\n<pre><code class=\"c#\">XElement el = new XElement(\"Root\");\nConsole.WriteLine(el);</code></pre>\n<pre><code class=\"vb\">Dim el As XElement = <Root/>\nConsole.WriteLine(el)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root /></code></pre>\n<p>The following example creates an element in a namespace with no content. For more information, see Working with XML Namespaces.</p>\n<pre><code>XNamespace aw = \"http://www.adventure-works.com\";\nXElement root = new XElement(aw + \"Root\");\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim root = <Root/>\nConsole.WriteLine(root)\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\" /></code></pre>\n"
  syntax:
    content: public XElement(XName name)
    content.vb: Public Sub New(name As XName)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the name of the element.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)
  commentId: M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object)
  id: '#ctor(System.Xml.Linq.XName,System.Object)'
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: XElement(XName, Object)
  fullName: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XName, System.Object)
  type: Constructor
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 204
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> class with the specified name and content.</p>\n"
  remarks: "\n<p>This constructor creates an element with the specified content and attributes.</p>\n<p>There is an implicit conversion from string to <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When creating an element in a namespace, typical use is to use the addition operator overload with an <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> and a string to create an <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. For more information, see Working with XML Namespaces.</p>\n<p>For details about the valid content that can be passed to this constructor, see Valid Content of XElement and XDocument Objects.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree. The content of the new element comes from a LINQ query.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5),\nnew XElement(\"Child6\", 6)\n);\n\nXElement xmlTree2 = new XElement(\"Root\",\nfrom el in xmlTree1.Elements()\nwhere((int)el >= 3 && (int)el <= 5)\nselect el\n);\nConsole.WriteLine(xmlTree2);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n    <Child6>6</Child6>\n</Root>\n\nDim xmlTree2 As XElement = _\n<Root>\n<%= From el In xmlTree1.Elements() _\n    Where el.Value >= 3 And el.Value <= 5 _\n    Select el %>\n</Root>\n\nConsole.WriteLine(xmlTree2)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n<p>The following example creates an XML tree with a variety of types of content.</p>\n<pre><code class=\"c#\">XElement root;\n\n// String content:\nroot = new XElement(\"Root\", \"Some text\");\nConsole.WriteLine(root);\n\n// XElement object content:\nroot = new XElement(\"Root\", \nnew XElement(\"NewChild\", \"n\")\n);\nConsole.WriteLine(root);\n\n// XAttribute object content:\nroot = new XElement(\"Root\", \nnew XAttribute(\"NewAttribute\", \"n\")\n);\nConsole.WriteLine(root);\n\n// Double content:\ndouble dbl = 12.345;\nroot = new XElement(\"Root\", dbl);\nConsole.WriteLine(root);\n\n// DateTime content:\nDateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);\nroot = new XElement(\"Root\", dt);\nConsole.WriteLine(root);\n\n// String array content:\n// Any collection other than a collection of XElement or XAttribute objects\n// are converted to strings. The strings are concatenated and added.\nstring[] stringArray = {\n\"abc\",\n\"def\",\n\"ghi\"\n};\nroot = new XElement(\"Root\", stringArray);\nConsole.WriteLine(root);\n\n// XElement object array content:\nXElement[] ellArray = {\nnew XElement(\"NewChild1\", 1),\nnew XElement(\"NewChild2\", 2),\nnew XElement(\"NewChild3\", 3)\n};\nroot = new XElement(\"Root\", ellArray);\nConsole.WriteLine(root);\n\n// XAttribute object array content:\nXAttribute[] attArray = {\nnew XAttribute(\"NewAtt1\", 1),\nnew XAttribute(\"NewAtt2\", 2),\nnew XAttribute(\"NewAtt3\", 3)\n};\nroot = new XElement(\"Root\", attArray);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement\n\n' String content:\nroot = <Root>Some text</Root>\nConsole.WriteLine(root)\n\n' XElement object content:\nroot = <Root>\n   <NewChild>n</NewChild>\n</Root>\nConsole.WriteLine(root)\n\n' XAttribute object content:\nroot = <Root NewAttribute=\"n\"/>\nConsole.WriteLine(root)\n\n' Double content:\nDim dbl As Double = 12.345\nroot = <Root><%= dbl %></Root>\nConsole.WriteLine(root)\n\n' DateTime content:\nDim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)\nroot = <Root><%= dt %></Root>\nConsole.WriteLine(root)\n\n' String array content:\n' Any collection other than a collection of XElement or XAttribute objects\n' are converted to strings. The strings are concatenated and added.\n\nDim stringArray As String() = { _\n\"abc\", _\n\"def\", _\n\"ghi\" _\n}\nroot = <Root><%= stringArray %></Root>\nConsole.WriteLine(root)\n\n' XElement object array content:\nDim ellArray As XElement() = { _\n<NewChild1>1</NewChild1>, _\n<NewChild2>2</NewChild2>, _\n<NewChild3>3</NewChild3> _\n}\n\nroot = <Root><%= ellArray %></Root>\nConsole.WriteLine(root)\n\n' XAttribute object array content\nDim attArray As XAttribute() = { _\nNew XAttribute(\"NewAtt1\", 1), _\nNew XAttribute(\"NewAtt2\", 2), _\nNew XAttribute(\"NewAtt3\", 3) _\n}\nroot = <Root><%= attArray %></Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>Some text</Root>\n<Root>\n<NewChild>n</NewChild>\n</Root>\n<Root NewAttribute=\"n\" />\n<Root>12.345</Root>\n<Root>2006-10-06T12:30:00</Root>\n<Root>abcdefghi</Root>\n<Root>\n<NewChild1>1</NewChild1>\n<NewChild2>2</NewChild2>\n<NewChild3>3</NewChild3>\n</Root>\n<Root NewAtt1=\"1\" NewAtt2=\"2\" NewAtt3=\"3\" /></code></pre>\n<p>The following example creates an XML tree in a namespace.</p>\n<pre><code class=\"c#\">// Create an XML tree in a namespace.\nXNamespace aw = \"http://www.adventure-works.com\";\nXElement root = new XElement(aw + \"Root\",\nnew XElement(aw + \"Child\", \"child content\")\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an XML tree in a namespace.\nDim root As XElement = _ \n<Root xmlns='http://www.adventure-works.com'>\n<Child>child content</Child>\n</Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\">\n<Child>child content</Child>\n</Root></code></pre>\n<p>The following example creates an XML tree with nested namespaces.</p>\n<pre><code class=\"c#\">// Create an XML tree with nested namespaces.\nXNamespace aw = \"http://www.adventure-works.com\";\nXNamespace fc = \"www.fourthcoffee.com\";\nXDocument root = new XDocument(\nnew XDeclaration(\"1.0\", \"utf-8\", \"yes\"),\nnew XElement(aw + \"Root\",\nnew XElement(fc + \"Child\",\n    new XElement(aw + \"DifferentChild\", \"other content\")\n)\n)\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an XML tree with nested namespaces.\nDim root As XDocument = _ \n<?xml version='1.0'?>\n<Root xmlns='http://www.adventure-works.com'>\n<Child xmlns='www.fourthcoffee.com'>\n<DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>\n</Child>\n</Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\">\n<Child xmlns=\"www.fourthcoffee.com\">\n<DifferentChild xmlns=\"http://www.adventure-works.com\">other content</DifferentChild>\n</Child>\n</Root></code></pre>\n"
  syntax:
    content: public XElement(XName name, object content)
    content.vb: Public Sub New(name As XName, content As Object)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the element name.</p>\n"
    - id: content
      type: System.Object
      description: "\n<p>The contents of the element.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])
  commentId: M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XName,System.Object[])
  id: '#ctor(System.Xml.Linq.XName,System.Object[])'
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: XElement(XName, Object[])
  fullName: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XName, System.Object[])
  type: Constructor
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 205
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> class with the specified name and content.</p>\n"
  remarks: "\n<p>This constructor creates an element with the specified content and attributes.</p>\n<p>There is an implicit conversion from string to <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When creating an element in a namespace, typical use is to use the addition operator overload with an <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> and a string to create an <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>. For more information, see Working with XML Namespaces.</p>\n<p>For details about the valid content that can be passed to this constructor, see Valid Content of XElement and XDocument Objects.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree. The content of the new element comes from a LINQ query.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5),\nnew XElement(\"Child6\", 6)\n);\n\nXElement xmlTree2 = new XElement(\"Root\",\nfrom el in xmlTree1.Elements()\nwhere((int)el >= 3 && (int)el <= 5)\nselect el\n);\nConsole.WriteLine(xmlTree2);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n    <Child6>6</Child6>\n</Root>\n\nDim xmlTree2 As XElement = _ \n<Root>\n<%= From el In xmlTree1.Elements() _\n    Where el.Value >= 3 And el.Value <= 5 _\n    Select el %>\n</Root>\n\nConsole.WriteLine(xmlTree2)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n<p>The following example creates an XML tree with a variety of types of content.</p>\n<pre><code class=\"c#\">XElement root;\n\n// String content:\nroot = new XElement(\"Root\", \"Some text\");\nConsole.WriteLine(root);\n\n// XElement object content:\nroot = new XElement(\"Root\", \nnew XElement(\"NewChild\", \"n\")\n);\nConsole.WriteLine(root);\n\n// XAttribute object content:\nroot = new XElement(\"Root\", \nnew XAttribute(\"NewAttribute\", \"n\")\n);\nConsole.WriteLine(root);\n\n// Double content:\ndouble dbl = 12.345;\nroot = new XElement(\"Root\", dbl);\nConsole.WriteLine(root);\n\n// DateTime content:\nDateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);\nroot = new XElement(\"Root\", dt);\nConsole.WriteLine(root);\n\n// String array content:\n// Any collection other than a collection of XElement or XAttribute objects\n// are converted to strings. The strings are concatenated and added.\nstring[] stringArray = {\n\"abc\",\n\"def\",\n\"ghi\"\n};\nroot = new XElement(\"Root\", stringArray);\nConsole.WriteLine(root);\n\n// XElement object array content:\nXElement[] ellArray = {\nnew XElement(\"NewChild1\", 1),\nnew XElement(\"NewChild2\", 2),\nnew XElement(\"NewChild3\", 3)\n};\nroot = new XElement(\"Root\", ellArray);\nConsole.WriteLine(root);\n\n// XAttribute object array content:\nXAttribute[] attArray = {\nnew XAttribute(\"NewAtt1\", 1),\nnew XAttribute(\"NewAtt2\", 2),\nnew XAttribute(\"NewAtt3\", 3)\n};\nroot = new XElement(\"Root\", attArray);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement\n\n' String content:\nroot = <Root>Some text</Root>\nConsole.WriteLine(root)\n\n' XElement object content:\nroot = <Root>\n   <NewChild>n</NewChild>\n</Root>\nConsole.WriteLine(root)\n\n' XAttribute object content:\nroot = <Root NewAttribute=\"n\"/>\nConsole.WriteLine(root)\n\n' Double content:\nDim dbl As Double = 12.345\nroot = <Root><%= dbl %></Root>\nConsole.WriteLine(root)\n\n' DateTime content:\nDim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)\nroot = <Root><%= dt %></Root>\nConsole.WriteLine(root)\n\n' String array content:\n' Any collection other than a collection of XElement or XAttribute objects\n' are converted to strings. The strings are concatenated and added.\n\nDim stringArray As String() = { _\n\"abc\", _\n\"def\", _\n\"ghi\" _\n}\nroot = <Root><%= stringArray %></Root>\nConsole.WriteLine(root)\n\n' XElement object array content:\nDim ellArray As XElement() = { _\n<NewChild1>1</NewChild1>, _\n<NewChild2>2</NewChild2>, _\n<NewChild3>3</NewChild3> _\n}\n\nroot = <Root><%= ellArray %></Root>\nConsole.WriteLine(root)\n\n' XAttribute object array content\nDim attArray As XAttribute() = { _\nNew XAttribute(\"NewAtt1\", 1), _\nNew XAttribute(\"NewAtt2\", 2), _\nNew XAttribute(\"NewAtt3\", 3) _\n}\nroot = <Root><%= attArray %></Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>Some text</Root>\n<Root>\n<NewChild>n</NewChild>\n</Root>\n<Root NewAttribute=\"n\" />\n<Root>12.345</Root>\n<Root>2006-10-06T12:30:00</Root>\n<Root>abcdefghi</Root>\n<Root>\n<NewChild1>1</NewChild1>\n<NewChild2>2</NewChild2>\n<NewChild3>3</NewChild3>\n</Root>\n<Root NewAtt1=\"1\" NewAtt2=\"2\" NewAtt3=\"3\" /></code></pre>\n<p>The following example creates an XML tree in a namespace.</p>\n<pre><code class=\"c#\">// Create an XML tree in a namespace.\nXNamespace aw = \"http://www.adventure-works.com\";\nXElement root = new XElement(aw + \"Root\",\nnew XElement(aw + \"Child\", \"child content\")\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an XML tree in a namespace.\nDim root As XElement = _ \n<Root xmlns='http://www.adventure-works.com'>\n<Child>child content</Child>\n</Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\">\n<Child>child content</Child>\n</Root></code></pre>\n<p>The following example creates an XML tree with nested namespaces.</p>\n<pre><code class=\"c#\">// Create an XML tree with nested namespaces.\nXNamespace aw = \"http://www.adventure-works.com\";\nXNamespace fc = \"www.fourthcoffee.com\";\nXElement root = new XElement(aw + \"Root\",\nnew XElement(fc + \"Child\",\nnew XElement(aw + \"DifferentChild\", \"other content\")\n)\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an XML tree with nested namespaces.\nDim root As XDocument = _ \n<?xml version='1.0'?>\n<Root xmlns='http://www.adventure-works.com'>\n<Child xmlns='www.fourthcoffee.com'>\n<DifferentChild xmlns='http://www.adventure-works.com'>other content</DifferentChild>\n</Child>\n</Root>\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root xmlns=\"http://www.adventure-works.com\">\n<Child xmlns=\"www.fourthcoffee.com\">\n<DifferentChild xmlns=\"http://www.adventure-works.com\">other content</DifferentChild>\n</Child>\n</Root></code></pre>\n"
  syntax:
    content: public XElement(XName name, params object[] content)
    content.vb: Public Sub New(name As XName, ParamArray content As Object())
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the element name.</p>\n"
    - id: content
      type: System.Object[]
      description: "\n<p>The initial content of the element.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XName, System.Object())
  name.vb: XElement(XName, Object())
- uid: System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)
  commentId: M:System.Xml.Linq.XElement.#ctor(System.Xml.Linq.XStreamingElement)
  id: '#ctor(System.Xml.Linq.XStreamingElement)'
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: XElement(XStreamingElement)
  fullName: System.Xml.Linq.XElement.XElement(System.Xml.Linq.XStreamingElement)
  type: Constructor
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 206
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> class from an <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>This constructor iterates through the contents of the specified <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref>, and creates an element with its contents.</p>\n"
  example:
  - "\n<p>The following example creates a source XML tree, and then creates an <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref> from a query on the source XML tree. It then serializes the <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref> to the console, adds a new element to the source XML tree, and then serializes the <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref> again. You can see that element newly added to the source XML tree is not included in the first serialization, but is included in the second.</p>\n<pre><code class=\"c#\">XElement src = new XElement(\"Root\",\n           new XElement(\"Child1\", 1),\n           new XElement(\"Child2\", 2),\n           new XElement(\"Child3\", 3)\n       );\nXStreamingElement xse = new XStreamingElement(\"NewRoot\",\n                    from el in src.Elements()\n                    where (int)el >= 2\n                    select el\n                );\nConsole.WriteLine(xse);\nsrc.Add(new XElement(\"Child4\", 4));\nConsole.WriteLine(\"----\");\nConsole.WriteLine(xse);</code></pre>\n<pre><code class=\"vb\">Dim src As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n</Root>\nDim xse As XStreamingElement = New XStreamingElement(\"NewRoot\", _\nFrom el In src.Elements() _\nWhere (CInt(el) >= 2) _\nSelect el _\n)\nConsole.WriteLine(xse)\nsrc.Add(New XElement(\"Child4\", 4))\nConsole.WriteLine(\"----\")\nConsole.WriteLine(xse)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><NewRoot>\n<Child2>2</Child2>\n<Child3>3</Child3>\n</NewRoot>\n----\n<NewRoot>\n<Child2>2</Child2>\n<Child3>3</Child3>\n<Child4>4</Child4>\n</NewRoot></code></pre>\n"
  syntax:
    content: public XElement(XStreamingElement other)
    content.vb: Public Sub New(other As XStreamingElement)
    parameters:
    - id: other
      type: System.Xml.Linq.XStreamingElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XStreamingElement\" data-throw-if-not-resolved=\"false\"></xref> that contains unevaluated queries that will be iterated for the contents of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.EmptySequence
  commentId: P:System.Xml.Linq.XElement.EmptySequence
  id: EmptySequence
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: EmptySequence
  fullName: System.Xml.Linq.XElement.EmptySequence
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EmptySequence
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 207
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets an empty collection of elements.</p>\n"
  remarks: "\n<p>This property is typically used by class implementers when writing a method that returns a collection of elements. If the method must return no elements, it can use this property to get an empty collection of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> objects.</p>\n"
  example:
  - 
  syntax:
    content: public static IEnumerable<XElement> EmptySequence { get; }
    content.vb: Public Shared ReadOnly Property EmptySequence As IEnumerable(Of XElement)
    parameters: []
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains an empty collection.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Xml.Linq.XElement.FirstAttribute
  commentId: P:System.Xml.Linq.XElement.FirstAttribute
  id: FirstAttribute
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: FirstAttribute
  fullName: System.Xml.Linq.XElement.FirstAttribute
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FirstAttribute
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 208
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the first attribute of this element.</p>\n"
  remarks: "\n<p>Attributes are stored in the element in the order that they were added to the element.</p>\n"
  example:
  - "\n<p>The following example uses this property.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3)\n);\nConsole.WriteLine(xmlTree.FirstAttribute);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root Att1=\"1\" Att2=\"2\" Att3=\"3\"/>\nConsole.WriteLine(xmlTree.FirstAttribute)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Att1=\"1\"</code></pre>\n"
  syntax:
    content: public XAttribute FirstAttribute { get; }
    content.vb: Public ReadOnly Property FirstAttribute As XAttribute
    parameters: []
    return:
      type: System.Xml.Linq.XAttribute
      description: "\n<p>An <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> that contains the first attribute of this element.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XElement.HasAttributes
  commentId: P:System.Xml.Linq.XElement.HasAttributes
  id: HasAttributes
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: HasAttributes
  fullName: System.Xml.Linq.XElement.HasAttributes
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: HasAttributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 209
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets a value indicating whether this element has at least one attribute.</p>\n"
  example:
  - "\n<p>The following example uses this property.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1)\n);\nConsole.WriteLine(xmlTree1.HasAttributes);\nXElement xmlTree2 = new XElement(\"Root\");\nConsole.WriteLine(xmlTree2.HasAttributes);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = <Root Att1=\"1\"/>\nConsole.WriteLine(xmlTree1.HasAttributes)\n\nDim xmlTree2 As XElement = <Root/>\nConsole.WriteLine(xmlTree2.HasAttributes)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>True\nFalse</code></pre>\n"
  syntax:
    content: public bool HasAttributes { get; }
    content.vb: Public ReadOnly Property HasAttributes As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this element has at least one attribute; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XElement.HasElements
  commentId: P:System.Xml.Linq.XElement.HasElements
  id: HasElements
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: HasElements
  fullName: System.Xml.Linq.XElement.HasElements
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: HasElements
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 210
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets a value indicating whether this element has at least one child element.</p>\n"
  example:
  - "\n<p>The following example uses this property.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child\", 1)\n);\nConsole.WriteLine(xmlTree1.HasElements);\nXElement xmlTree2 = new XElement(\"Root\", \"contents\");\nConsole.WriteLine(xmlTree2.HasElements);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root>\n    <Child>1</Child>\n</Root>\nConsole.WriteLine(xmlTree1.HasElements)\n\nDim xmlTree2 As XElement = <Root>contents</Root>\nConsole.WriteLine(xmlTree2.HasElements)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>True\nFalse</code></pre>\n"
  syntax:
    content: public bool HasElements { get; }
    content.vb: Public ReadOnly Property HasElements As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this element has at least one child element; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XElement.IsEmpty
  commentId: P:System.Xml.Linq.XElement.IsEmpty
  id: IsEmpty
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: IsEmpty
  fullName: System.Xml.Linq.XElement.IsEmpty
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsEmpty
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 211
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets a value indicating whether this element contains no content.</p>\n"
  remarks: "\n<p>Note that an element that contains a start and end tag with no content between the tags is not considered to be an empty element. It has content with no length. Only an element that contains only a start tag, and is expressed as a terminated empty element, is considered to be empty.</p>\n"
  example:
  - "\n<p>The following example creates a variety of XML trees, and shows the value of this property with each tree.</p>\n<pre><code class=\"c#\">XElement el1 = new XElement(\"Root\");\nConsole.WriteLine(el1);\nConsole.WriteLine(el1.IsEmpty);\nConsole.WriteLine();\nXElement el2 = new XElement(\"Root\", \"content\");\nConsole.WriteLine(el2);\nConsole.WriteLine(el2.IsEmpty);\nConsole.WriteLine();\nXElement el3 = new XElement(\"Root\", \"\");\nConsole.WriteLine(el3);\nConsole.WriteLine(el3.IsEmpty);\nConsole.WriteLine();\nel3.ReplaceAll(null);\nConsole.WriteLine(el3);\nConsole.WriteLine(el3.IsEmpty);</code></pre>\n<pre><code class=\"vb\">Dim el1 As XElement = <Root/>\nConsole.WriteLine(el1)\nConsole.WriteLine(el1.IsEmpty)\nConsole.WriteLine()\nDim el2 As XElement = <Root>content</Root>\nConsole.WriteLine(el2)\nConsole.WriteLine(el2.IsEmpty)\nConsole.WriteLine()\nDim el3 As XElement = <Root></Root>\nConsole.WriteLine(el3)\nConsole.WriteLine(el3.IsEmpty)\nConsole.WriteLine()\nel3.ReplaceAll(Nothing)\nConsole.WriteLine(el3)\nConsole.WriteLine(el3.IsEmpty)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root />\nTrue\n\n<Root>content</Root>\nFalse\n\n<Root></Root>\nFalse\n\n<Root />\nTrue</code></pre>\n"
  syntax:
    content: public bool IsEmpty { get; }
    content.vb: Public ReadOnly Property IsEmpty As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this element contains no content; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XElement.LastAttribute
  commentId: P:System.Xml.Linq.XElement.LastAttribute
  id: LastAttribute
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: LastAttribute
  fullName: System.Xml.Linq.XElement.LastAttribute
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LastAttribute
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 212
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the last attribute of this element.</p>\n"
  remarks: "\n<p>Attributes are stored in the element in the order that they were added to the element.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree with three attributes. It then writes the last attribute as output.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3)\n);\nConsole.WriteLine(xmlTree.LastAttribute);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root Att1=\"1\" Att2=\"2\" Att3=\"3\"/>\nConsole.WriteLine(xmlTree.LastAttribute)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Att3=\"3\"</code></pre>\n"
  syntax:
    content: public XAttribute LastAttribute { get; }
    content.vb: Public ReadOnly Property LastAttribute As XAttribute
    parameters: []
    return:
      type: System.Xml.Linq.XAttribute
      description: "\n<p>An <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> that contains the last attribute of this element.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XElement.Name
  commentId: P:System.Xml.Linq.XElement.Name
  id: Name
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Name
  fullName: System.Xml.Linq.XElement.Name
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Name
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 213
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets or sets the name of this element.</p>\n"
  remarks: "\n<p>Setting this property will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example uses this property to determine the name of an element.</p>\n<pre><code class=\"c#\">XElement el1 = new XElement(\"Root\", \"content\");\nConsole.WriteLine(el1.Name);\n\nXNamespace ns = \"http://www.adventure-works.com\";\nXElement el2 = new XElement(ns + \"Root\", \"content\");\nConsole.WriteLine(el2.Name);\nConsole.WriteLine(el2.Name.Namespace);\nConsole.WriteLine(el2.Name.LocalName);\nel2.Name = ns + \"NewName\";\nConsole.WriteLine(el2.Name);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim el1 As XElement = <Root>content</Root>\nConsole.WriteLine(el1.Name)\n\nDim el2 As XElement = <aw:Root>content</aw:Root>\nConsole.WriteLine(el2.Name)\nConsole.WriteLine(el2.Name.Namespace)\nConsole.WriteLine(el2.Name.LocalName)\nDim aw as XNamespace = GetXmlNamespace(aw)\nel2.Name = aw + \"NewName\"\nConsole.WriteLine(el2.Name)\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Root\n{http://www.adventure-works.com}Root\nhttp://www.adventure-works.com\nRoot\n{http://www.adventure-works.com}NewName</code></pre>\n"
  syntax:
    content: public XName Name { get; set; }
    content.vb: Public Property Name As XName
    parameters: []
    return:
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the name of this element.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.NodeType
  commentId: P:System.Xml.Linq.XElement.NodeType
  id: NodeType
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: NodeType
  fullName: System.Xml.Linq.XElement.NodeType
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NodeType
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 214
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the node type for this node.</p>\n"
  remarks: "\n<p>Because all classes that derive from <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref> contain a <xref href=\"System.Xml.Linq.XObject.NodeType\" data-throw-if-not-resolved=\"false\"></xref> property, you can write code that operates on collections of concrete subclass of <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref>. Your code can then test for the node type of each node in the collection.</p>\n"
  example:
  - "\n<p>The following example uses this property to print the node type of an element.</p>\n<pre><code class=\"c#\">XElement el1 = new XElement(\"Root\", \"content\");\nConsole.WriteLine(el1.NodeType);\nConsole.WriteLine();</code></pre>\n<pre><code class=\"vb\">Dim el1 As XElement = <Root>content</Root>\nConsole.WriteLine(el1.NodeType.ToString())\nConsole.WriteLine()</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Element</code></pre>\n"
  syntax:
    content: public override XmlNodeType NodeType { get; }
    content.vb: Public Overrides ReadOnly Property NodeType As XmlNodeType
    parameters: []
    return:
      type: System.Xml.XmlNodeType
      description: "\n<p>The node type. For <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> objects, this value is <xref href=\"System.Xml.XmlNodeType.Element\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  overridden: System.Xml.Linq.XObject.NodeType
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Xml.Linq.XElement.Value
  commentId: P:System.Xml.Linq.XElement.Value
  id: Value
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Value
  fullName: System.Xml.Linq.XElement.Value
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Value
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 215
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets or sets the concatenated text contents of this element.</p>\n"
  remarks: "\n<p>Using this property, you can get or set the value of an element.</p>\n<p>Setting this property will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>If you want to get the value of an element but you are not sure that it exists, it is more convenient to use the explicit conversion operators, and assign the element to a nullable type such as <strong>string</strong> or <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>. If the element does not exist, the nullable type is set to <strong>null</strong>. By contrast, if you want to use this property, you must make sure that the <xref href=\"System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)\" data-throw-if-not-resolved=\"false\"></xref> method does not return <strong>null</strong> before you access this property.</p>\n"
  example:
  - "\n<p>The following example uses this property to retrieve the text of an element with mixed content.</p>\n<pre><code class=\"c#\">XElement el = XElement.Parse(\"<Root>This is <b>mixed</b> content</Root>\");\nConsole.WriteLine(\"{0}\", el.Value);</code></pre>\n<pre><code class=\"vb\">Dim el As XElement = <Root>This is <b>mixed</b> content</Root>\nConsole.WriteLine(\"{0}\", el.Value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>This is mixed content</code></pre>\n"
  syntax:
    content: public string Value { get; set; }
    content.vb: Public Property Value As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that contains all of the text content of this element. If there are multiple text nodes, they will be concatenated.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.AncestorsAndSelf
  commentId: M:System.Xml.Linq.XElement.AncestorsAndSelf
  id: AncestorsAndSelf
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: AncestorsAndSelf()
  fullName: System.Xml.Linq.XElement.AncestorsAndSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AncestorsAndSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 216
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of elements that contain this element, and the ancestors of this element. </p>\n"
  remarks: "\n<p>The elements in the returned collection are in reverse document order.</p>\n<p>This method uses deferred execution.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree. It then finds the <code>GrandChild</code> element, and then prints the ancestors of it.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child\",\nnew XElement(\"GrandChild\", \"element content\")\n)\n);\nXElement gc = xmlTree.Element(\"Child\").Element(\"GrandChild\");\nIEnumerable<XElement> aas =\nfrom el in gc.AncestorsAndSelf()\nselect el;\nforeach (XElement el in aas)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n<Child>\n    <GrandChild>element content</GrandChild>\n</Child>\n</Root>\n\nDim GC As XElement = xmlTree.<Child>.<GrandChild>(0)\n\nDim aas As IEnumerable(Of XElement) = _\nFrom el In GC.AncestorsAndSelf() _\nSelect el\n\nFor Each el In aas\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>GrandChild\nChild\nRoot</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> AncestorsAndSelf()
    content.vb: Public Function AncestorsAndSelf As IEnumerable(Of XElement)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of elements that contain this element, and the ancestors of this element. </p>\n"
  seealso:
  - type: System.Xml.Linq.XNode.Ancestors
    commentId: M:System.Xml.Linq.XNode.Ancestors
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)
  id: AncestorsAndSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: AncestorsAndSelf(XName)
  fullName: System.Xml.Linq.XElement.AncestorsAndSelf(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AncestorsAndSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 217
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of elements that contain this element, and the ancestors of this element. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>The elements in the returned collection are in reverse document order.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example uses this .</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child\",\nnew XElement(\"GrandChild\", \"element content\")\n)\n);\nXElement gc = xmlTree.Element(\"Child\").Element(\"GrandChild\");\nIEnumerable<XElement> aas = gc.AncestorsAndSelf(\"Child\");\nforeach (XElement el in aas)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n<Child>\n    <GrandChild>element content</GrandChild>\n</Child>\n</Root>\n\nDim GC As XElement = xmlTree.<Child>.<GrandChild>(0)\nDim aas As IEnumerable(Of XElement) = GC.AncestorsAndSelf(\"Child\")\nFor Each el In aas\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> AncestorsAndSelf(XName name)
    content.vb: Public Function AncestorsAndSelf(name As XName) As IEnumerable(Of XElement)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contain this element, and the ancestors of this element. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  seealso:
  - type: System.Xml.Linq.XNode.Ancestors
    commentId: M:System.Xml.Linq.XNode.Ancestors
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)
  id: Attribute(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Attribute(XName)
  fullName: System.Xml.Linq.XElement.Attribute(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Attribute
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 218
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns the <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that has the specified <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Some  return collections of elements or attributes. This method returns only a single attribute. Sometimes this is referred to as a singleton (in contrast to a collection).</p>\n<p>Visual Basic users can use the integrated attribute axis to retrieve the value of an attribute with a specified name.</p>\n"
  example:
  - "\n<p>The following example creates an element with an attribute. It then retrieves the attribute using this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att\", \"attribute content\")\n);\nXAttribute att = xmlTree.Attribute(\"Att\");\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root Att=\"attribute content\"/>\n\nDim att As XAttribute = xmlTree.Attribute(\"Att\")\nConsole.WriteLine(att)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Att=\"attribute content\"</code></pre>\n<p>The following is the same example, but in this case the XML is in a namespace. For more information, see Working with XML Namespaces.</p>\n<pre><code class=\"c#\">XNamespace aw = \"http://www.adventure-works.com\";\nXElement xmlTree = new XElement(aw + \"Root\",\nnew XAttribute(XNamespace.Xmlns + \"aw\", \"http://www.adventure-works.com\"),\nnew XAttribute(aw + \"Att\", \"attribute content\")\n);\nXAttribute att = xmlTree.Attribute(aw + \"Att\");\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree As XElement = <aw:Root aw:Att=\"attribute content\"/>\n\nDim att As XAttribute = xmlTree.Attribute(GetXmlNamespace(aw) + \"Att\")\nConsole.WriteLine(att)\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>aw:Att=\"attribute content\"</code></pre>\n"
  syntax:
    content: public XAttribute Attribute(XName name)
    content.vb: Public Function Attribute(name As XName) As XAttribute
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> of the <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> to get.</p>\n"
    return:
      type: System.Xml.Linq.XAttribute
      description: "\n<p>An <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> that has the specified <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref>; <strong>null</strong> if there is no attribute with the specified name.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Attributes
  commentId: M:System.Xml.Linq.XElement.Attributes
  id: Attributes
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Attributes()
  fullName: System.Xml.Linq.XElement.Attributes()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Attributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 219
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of attributes of this element.</p>\n"
  remarks: "\n<p>The attributes in the returned collection are in the order that they were added to the element. If the XML tree was parsed from XML, the attributes are returned in document order.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an element with two attributes. It then uses this  to retrieve all attributes of the element.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", \"content1\"),\nnew XAttribute(\"Att2\", \"content2\")\n);\nIEnumerable<XAttribute> attList =\nfrom at in xmlTree.Attributes()\nselect at;\nforeach (XAttribute att in attList)\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root Att1=\"content1\" Att2=\"content2\"/>\n\nDim attList As IEnumerable(Of XAttribute) = _\nFrom at In xmlTree.Attributes() _\nSelect at\n\nFor Each att In attList\nConsole.WriteLine(att)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Att1=\"content1\"\nAtt2=\"content2\"</code></pre>\n<p>The following is the same example, but in this case the XML is in a namespace. For more information, see Working with XML Namespaces.</p>\n<pre><code class=\"c#\">XNamespace aw = \"http://www.adventure-works.com\";\nXElement xmlTree = new XElement(aw + \"Root\",\nnew XAttribute(aw + \"Att1\", \"content1\"),\nnew XAttribute(aw + \"Att2\", \"content2\"),\nnew XAttribute(XNamespace.Xmlns + \"aw\", \"http://www.adventure-works.com\")\n);\nIEnumerable<XAttribute> attList =\nfrom at in xmlTree.Attributes()\nselect at;\nforeach (XAttribute att in attList)\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree As XElement = <aw:Root aw:Att1=\"content1\" aw:Att2=\"content2\"/>\n\nDim attList As IEnumerable(Of XAttribute) = _\n    From at In xmlTree.Attributes() _\n    Select at\n\nFor Each att In attList\n    Console.WriteLine(att)\nNext\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>aw:Att1=\"content1\"\naw:Att2=\"content2\"\nxmlns:aw=\"http://www.adventure-works.com\"</code></pre>\n"
  syntax:
    content: public IEnumerable<XAttribute> Attributes()
    content.vb: Public Function Attributes As IEnumerable(Of XAttribute)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> of attributes of this element.</p>\n"
  seealso:
  - type: System.Xml.Linq.XContainer.Elements
    commentId: M:System.Xml.Linq.XContainer.Elements
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)
  id: Attributes(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Attributes(XName)
  fullName: System.Xml.Linq.XElement.Attributes(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Attributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 220
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of attributes of this element. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>Attribute names must be unique within an element. Therefore, this  can return either a collection that contains only one attribute, or it can return an empty collection.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example uses this .</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", \"content1\"),\nnew XAttribute(\"Att2\", \"content2\")\n);\nIEnumerable<XAttribute> attList = xmlTree.Attributes(\"Att1\");\nforeach (XAttribute att in attList)\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root Att1=\"content1\" Att2=\"content2\"/>\n\nDim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes(\"Att1\")\n\nFor Each att In attList\nConsole.WriteLine(att)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Att1=\"content1\"</code></pre>\n<p>The following is the same example, but in this case the XML is in a namespace. For more information, see Working with XML Namespaces.</p>\n<pre><code class=\"c#\">XNamespace aw = \"http://www.adventure-works.com\";\nXElement xmlTree = new XElement(aw + \"Root\",\nnew XAttribute(XNamespace.Xmlns + \"aw\", \"http://www.adventure-works.com\"),\nnew XAttribute(aw + \"Att1\", \"content1\"),\nnew XAttribute(aw + \"Att2\", \"content2\")\n);\nIEnumerable<XAttribute> attList = xmlTree.Attributes(aw + \"Att1\");\nforeach (XAttribute att in attList)\nConsole.WriteLine(att);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree As XElement = <aw:Root aw:Att1=\"content1\" aw:Att2=\"content2\"/>\n\nDim attList As IEnumerable(Of XAttribute) = xmlTree.Attributes(GetXmlNamespace(aw) + \"Att1\")\n\nFor Each att In attList\n    Console.WriteLine(att)\nNext\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>aw:Att1=\"content1\"</code></pre>\n"
  syntax:
    content: public IEnumerable<XAttribute> Attributes(XName name)
    content.vb: Public Function Attributes(name As XName) As IEnumerable(Of XAttribute)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> that contains the attributes of this element. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.DescendantNodesAndSelf
  commentId: M:System.Xml.Linq.XElement.DescendantNodesAndSelf
  id: DescendantNodesAndSelf
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: DescendantNodesAndSelf()
  fullName: System.Xml.Linq.XElement.DescendantNodesAndSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DescendantNodesAndSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 221
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of nodes that contain this element, and all descendant nodes of this element, in document order.</p>\n"
  remarks: "\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an XML tree, and then uses this .</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\n// Attributes are not nodes, so will not be returned by DescendantNodesAndSelf.\nnew XAttribute(\"Att1\", \"AttributeContent\"),\nnew XElement(\"Child\",\nnew XText(\"Some text\"),\nnew XElement(\"GrandChild\", \"element content\")\n)\n);\nIEnumerable<XNode> dnas =\nfrom node in xmlTree.DescendantNodesAndSelf()\nselect node;\nforeach (XNode node in dnas)\n{\nif (node is XElement)\nConsole.WriteLine((node as XElement).Name);\nelse\nConsole.WriteLine(node);\n}</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root Att1=\"AttributeContent\">\n<Child>Some text<GrandChild>element content</GrandChild>\n</Child>\n</Root>\n\nDim dnas As IEnumerable(Of XNode) = _\nFrom node In xmlTree.DescendantNodesAndSelf() _\nSelect node\n\n\nFor Each node In dnas\nIf TypeOf node Is XElement Then\nConsole.WriteLine(DirectCast(node, XElement).Name)\nElse\nConsole.WriteLine(node)\nEnd If\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Root\nChild\nSome text\nGrandChild\nelement content</code></pre>\n"
  syntax:
    content: public IEnumerable<XNode> DescendantNodesAndSelf()
    content.vb: Public Function DescendantNodesAndSelf As IEnumerable(Of XNode)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XNode}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> that contain this element, and all descendant nodes of this element, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.DescendantsAndSelf
  commentId: M:System.Xml.Linq.XElement.DescendantsAndSelf
  id: DescendantsAndSelf
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: DescendantsAndSelf()
  fullName: System.Xml.Linq.XElement.DescendantsAndSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DescendantsAndSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 222
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of elements that contain this element, and all descendant elements of this element, in document order.</p>\n"
  remarks: "\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an XML tree, and then uses this .</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", \"AttributeContent\"),\nnew XElement(\"Child\",\nnew XText(\"Some text\"),\nnew XElement(\"GrandChild\", \"element content\")\n)\n);\nIEnumerable<XElement> das =\nfrom el in xmlTree.DescendantsAndSelf()\nselect el;\nforeach (XElement el in das)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root Att1=\"AttributeContent\">\n<Child>Some text\n    <GrandChild>element content</GrandChild>\n</Child>\n</Root>\n\nDim das As IEnumerable(Of XElement) = _\nFrom el In xmlTree.DescendantsAndSelf() _\nSelect el\n\nFor Each el In das\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Root\nChild\nGrandChild</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> DescendantsAndSelf()
    content.vb: Public Function DescendantsAndSelf As IEnumerable(Of XElement)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of elements that contain this element, and all descendant elements of this element, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)
  id: DescendantsAndSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: DescendantsAndSelf(XName)
  fullName: System.Xml.Linq.XElement.DescendantsAndSelf(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DescendantsAndSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 223
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of elements that contain this element, and all descendant elements of this element, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an XML tree, and then uses this .</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XAttribute(\"Att1\", \"AttributeContent\"),\nnew XElement(\"Child\",\nnew XText(\"Some text\"),\nnew XElement(\"GrandChild\", \"element content\")\n)\n);\nIEnumerable<XElement> das = xmlTree.DescendantsAndSelf(\"Child\");\nforeach (XElement el in das)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root Att1=\"AttributeContent\">\n<Child>Some text\n    <GrandChild>element content</GrandChild>\n</Child>\n</Root>\n\nDim das As IEnumerable(Of XElement) = xmlTree.DescendantsAndSelf(\"Child\")\n\nFor Each el In das\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> DescendantsAndSelf(XName name)
    content.vb: Public Function DescendantsAndSelf(name As XName) As IEnumerable(Of XElement)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contain this element, and all descendant elements of this element, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.GetDefaultNamespace
  commentId: M:System.Xml.Linq.XElement.GetDefaultNamespace
  id: GetDefaultNamespace
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: GetDefaultNamespace()
  fullName: System.Xml.Linq.XElement.GetDefaultNamespace()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetDefaultNamespace
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 224
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the default <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Namespace declarations may be persisted as attributes in the XML tree. These special attributes declare namespaces, including default namespaces. This method finds the namespace declaration that declares the default namespace, if there is one, and returns the <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> for the default namespace.</p>\n<p>If there is no attribute that declares the default namespace, then this method returns <xref href=\"System.Xml.Linq.XNamespace.None\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When creating XML trees using C#, even if an XML tree would be serialized with a default namespace, if the namespace is not persisted in the XML tree as an attribute, this method will not report the namespace as the default namespace.</p>\n<p>When creating XML trees using Visual Basic and XML literals, if you create the XML in a default namespace using the Imports statement, then a namespace attribute will be created in the tree by the Visual Basic compiler, and this method will report that namespace.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree that has a default namespace. It then uses this method to retrieve the default namespace.</p>\n<pre><code class=\"c#\">String xml = \"<root xmlns='http://www.adventure-works.com'/>\";\nXElement e = XElement.Parse(xml);\nConsole.WriteLine(\"Default namespace: {0}\", e.GetDefaultNamespace());</code></pre>\n<pre><code class=\"vb\">Imports <xmlns=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim e As XElement = <root/>\nConsole.WriteLine(\"Default namespace: {0}\", e.GetDefaultNamespace())\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Default namespace: http://www.adventure-works.com</code></pre>\n"
  syntax:
    content: public XNamespace GetDefaultNamespace()
    content.vb: Public Function GetDefaultNamespace As XNamespace
    return:
      type: System.Xml.Linq.XNamespace
      description: "\n<p>An <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> that contains the default namespace of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)
  commentId: M:System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)
  id: GetNamespaceOfPrefix(System.String)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: GetNamespaceOfPrefix(String)
  fullName: System.Xml.Linq.XElement.GetNamespaceOfPrefix(System.String)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetNamespaceOfPrefix
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 225
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the namespace associated with a particular prefix for this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method looks through the XML tree for namespace attributes that are in scope for this element. Namespace prefixes are specified in namespace attributes that are in the XML tree.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree that has a namespace with an associated prefix. It then uses this method to retrieve the <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> for the prefix.</p>\n<pre><code class=\"c#\">XElement xmlTree = XElement.Parse(\"<Root xmlns:aw='http://www.adventure-works.com'/>\");\nXNamespace awNamespace = xmlTree.GetNamespaceOfPrefix(\"aw\");\nConsole.WriteLine(\"Namespace: {0}\", awNamespace);</code></pre>\n<p>When using Visual Basic, you would typically use the GetXmlNamespace Operator (Visual Basic) operator, as follows</p>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree As XElement = <aw:Root/>\nDim awNamespace As XNamespace = GetXmlNamespace(aw)\nConsole.WriteLine(\"Namespace: {0}\", awNamespace)\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Namespace: http://www.adventure-works.com</code></pre>\n"
  syntax:
    content: public XNamespace GetNamespaceOfPrefix(string prefix)
    content.vb: Public Function GetNamespaceOfPrefix(prefix As String) As XNamespace
    parameters:
    - id: prefix
      type: System.String
      description: "\n<p>A string that contains the namespace prefix to look up.</p>\n"
    return:
      type: System.Xml.Linq.XNamespace
      description: "\n<p>An <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> for the namespace associated with the prefix for this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)
  commentId: M:System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)
  id: GetPrefixOfNamespace(System.Xml.Linq.XNamespace)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: GetPrefixOfNamespace(XNamespace)
  fullName: System.Xml.Linq.XElement.GetPrefixOfNamespace(System.Xml.Linq.XNamespace)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetPrefixOfNamespace
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 226
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the prefix associated with a namespace for this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method looks through the XML tree for namespace attributes that are in scope for this element. Namespace prefixes are specified in namespace attributes that are in the XML tree.</p>\n<p>If the namespace is the default namespace, and there is no prefix for the namespace, then this method returns null.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree that contains a namespace with a prefix. It then uses this method to retrieve the prefix for the namespace. Notice that this example uses the implicit conversion from string to <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> when calling this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = XElement.Parse(\"<Root xmlns:aw='http://www.adventure-works.com'/>\");\nstring prefix = xmlTree.GetPrefixOfNamespace(\"http://www.adventure-works.com\");\nConsole.WriteLine(\"Prefix: {0}\", prefix);</code></pre>\n<pre><code class=\"vb\">Imports <xmlns:aw=\"http://www.adventure-works.com\">\n\nModule Module1\nSub Main()\nDim xmlTree As XElement = <aw:Root/>\nDim prefix As String = xmlTree.GetPrefixOfNamespace(\"http://www.adventure-works.com\")\nConsole.WriteLine(\"Prefix: {0}\", prefix)\nEnd Sub\nEnd Module</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Prefix: aw</code></pre>\n"
  syntax:
    content: public string GetPrefixOfNamespace(XNamespace ns)
    content.vb: Public Function GetPrefixOfNamespace(ns As XNamespace) As String
    parameters:
    - id: ns
      type: System.Xml.Linq.XNamespace
      description: "\n<p>An <xref href=\"System.Xml.Linq.XNamespace\" data-throw-if-not-resolved=\"false\"></xref> to look up.</p>\n"
    return:
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that contains the namespace prefix.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Load(System.IO.Stream)
  commentId: M:System.Xml.Linq.XElement.Load(System.IO.Stream)
  id: Load(System.IO.Stream)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(Stream)
  fullName: System.Xml.Linq.XElement.Load(System.IO.Stream)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 227
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Creates a new <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> instance by using the specified stream.</p>\n"
  remarks: "\n<p>If you want to control load options, use the <see cref=\"Overload:System.Xml.Linq.XElement.Load\"></see> overload that takes <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> as a parameter.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document. </p>\n<p>If you have to modify <xref href=\"System.Xml.XmlReaderSettings\" data-throw-if-not-resolved=\"false\"></xref>, following these steps:</p>\n<ol><li>\n<p>Create an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> by calling one of the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overloads that take <xref href=\"System.Xml.XmlReaderSettings\" data-throw-if-not-resolved=\"false\"></xref> as a parameter.</p>\n</li><li>\n<p>Pass the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> to one of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>'s <see cref=\"Overload:System.Xml.Linq.XElement.Load\"></see> overloads that takes <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> as a parameter.</p>\n</li></ol>\n"
  example:
  - 
  syntax:
    content: public static XElement Load(Stream stream)
    content.vb: Public Shared Function Load(stream As Stream) As XElement
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "\n<p>The stream that contains the XML data.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> object used to read the data that is contained in the stream.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)
  commentId: M:System.Xml.Linq.XElement.Load(System.IO.Stream,System.Xml.Linq.LoadOptions)
  id: Load(System.IO.Stream,System.Xml.Linq.LoadOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(Stream, LoadOptions)
  fullName: System.Xml.Linq.XElement.Load(System.IO.Stream, System.Xml.Linq.LoadOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 228
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Creates a new <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> instance by using the specified stream, optionally preserving white space, setting the base URI, and retaining line information.</p>\n"
  remarks: "\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document. </p>\n<p>If you have to modify <xref href=\"System.Xml.XmlReaderSettings\" data-throw-if-not-resolved=\"false\"></xref>, following these steps:</p>\n<ol><li>\n<p>Create an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> by calling one of the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overloads that take <xref href=\"System.Xml.XmlReaderSettings\" data-throw-if-not-resolved=\"false\"></xref> as a parameter.</p>\n</li><li>\n<p>Pass the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> to one of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>'s <see cref=\"Overload:System.Xml.Linq.XElement.Load\"></see> overloads that takes <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> as a parameter.</p>\n</li></ol>\n"
  example:
  - 
  syntax:
    content: public static XElement Load(Stream stream, LoadOptions options)
    content.vb: Public Shared Function Load(stream As Stream, options As LoadOptions) As XElement
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "\n<p>The stream containing the XML data.</p>\n"
    - id: options
      type: System.Xml.Linq.LoadOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> object that specifies whether to load base URI and line information.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> object used to read the data that the stream contains.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.IO.TextReader)
  commentId: M:System.Xml.Linq.XElement.Load(System.IO.TextReader)
  id: Load(System.IO.TextReader)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(TextReader)
  fullName: System.Xml.Linq.XElement.Load(System.IO.TextReader)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 229
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  remarks: "\n<p>This method reads the raw XML into the XML tree. It discards all insignificant white space in the file.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example loads an element from a <xref href=\"System.IO.StringReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">TextReader sr = new StringReader(\"<Root><Child/></Root>\");\nXElement xmlTree = XElement.Load(sr);\nsr.Close();\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim sr As TextReader = New StringReader(\"<Root><Child/></Root>\")\nDim xmlTree As XElement = XElement.Load(sr)\nsr.Close()\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child />\n</Root></code></pre>\n"
  syntax:
    content: public static XElement Load(TextReader textReader)
    content.vb: Public Shared Function Load(textReader As TextReader) As XElement
    parameters:
    - id: textReader
      type: System.IO.TextReader
      description: "\n<p>A <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> that will be read for the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> content.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the XML that was read from the specified <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)
  commentId: M:System.Xml.Linq.XElement.Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)
  id: Load(System.IO.TextReader,System.Xml.Linq.LoadOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(TextReader, LoadOptions)
  fullName: System.Xml.Linq.XElement.Load(System.IO.TextReader, System.Xml.Linq.LoadOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 230
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>, optionally preserving white space and retaining line information. </p>\n"
  remarks: "\n<p>If the source XML is indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to read all white space in the source XML. Nodes of type <xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref> are created for both significant and insignificant white space.</p>\n<p>If the source XML is indented, not setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to ignore all of the insignificant white space in the source XML. The XML tree is created without any text nodes for insignificant white space.</p>\n<p>If the source XML is not indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> has no effect. Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</p>\n<p>For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n<p>Use <see cref=\"Overload:System.Xml.Linq.XElement.Parse\"></see> to create an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a string that contains XML.</p>\n<p>Setting <xref href=\"System.Xml.Linq.LoadOptions.SetBaseUri\" data-throw-if-not-resolved=\"false\"></xref> will have no effect when loading from a <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>There is a performance penalty if you set the <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>\n<p>The line information is accurate immediately after loading the XML document. If you modify the XML tree after loading the document, the line information may become meaningless.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a <xref href=\"System.IO.StringReader\" data-throw-if-not-resolved=\"false\"></xref> in two different ways: preserving white space, and not preserving white space. It then uses a query to determine the number of white space nodes in the resulting XML tree.</p>\n<pre><code class=\"c#\">TextReader sr;\nint whiteSpaceNodes;\n\nsr = new StringReader(\"<Root> <Child> </Child> </Root>\");\nXElement xmlTree1 = XElement.Load(sr, LoadOptions.None);\nsr.Close();\nwhiteSpaceNodes = xmlTree1\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\", whiteSpaceNodes);\n\nsr = new StringReader(\"<Root> <Child> </Child> </Root>\");\nXElement xmlTree2 = XElement.Load(sr, LoadOptions.PreserveWhitespace);\nsr.Close();\nwhiteSpaceNodes = xmlTree2\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\", whiteSpaceNodes);</code></pre>\n<pre><code class=\"vb\">Dim sr As TextReader\nDim whiteSpaceNodes As Integer\n\nsr = New StringReader(\"<Root> <Child> </Child> </Root>\")\nDim xmlTree1 As XElement = XElement.Load(sr, LoadOptions.None)\nsr.Close()\nwhiteSpaceNodes = xmlTree1 _\n.DescendantNodesAndSelf() _\n.OfType(Of XText)() _\n.Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n.Count()\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\", whiteSpaceNodes)\n\nsr = New StringReader(\"<Root> <Child> </Child> </Root>\")\nDim xmlTree2 As XElement = XElement.Load(sr, LoadOptions.PreserveWhitespace)\nsr.Close()\nwhiteSpaceNodes = xmlTree2 _\n.DescendantNodesAndSelf() _\n.OfType(Of XText)() _\n.Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n.Count()\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\", whiteSpaceNodes)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Count of white space nodes (not preserving whitespace): 0\nCount of white space nodes (preserving whitespace): 3</code></pre>\n<p>The following example loads the line information as it loads from the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>. It then prints the line information.</p>\n<pre><code class=\"c#\">TextReader sr = new StringReader(\n@\"<Root>\n<Child>\n<GrandChild1/>\n<GrandChild2/>\n</Child>\n</Root>\");\nXElement po = XElement.Load(sr,\nLoadOptions.SetLineInfo);\nConsole.WriteLine(\"{0}{1}{2}\",\n\"Element Name\".PadRight(20),\n\"Line\".PadRight(5),\n\"Position\");\nConsole.WriteLine(\"{0}{1}{2}\",\n\"------------\".PadRight(20),\n\"----\".PadRight(5),\n\"--------\");\nforeach (XElement e in po.DescendantsAndSelf())\nConsole.WriteLine(\"{0}{1}{2}\",\n(\"\".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),\n((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),\n((IXmlLineInfo)e).LinePosition);</code></pre>\n<pre><code class=\"vb\">Dim sr As TextReader = New StringReader( _\n\"<Root>\" & Environment.NewLine & _\n\"  <Child>\" & Environment.NewLine & _\n\"    <GrandChild1/>\" & Environment.NewLine & _\n\"    <GrandChild2/>\" & Environment.NewLine & _\n\"  </Child>\" & Environment.NewLine & _\n\"</Root>\")\nDim po As XElement = XElement.Load(sr, LoadOptions.SetLineInfo)\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"Element Name\".PadRight(20), _\n\"Line\".PadRight(5), _\n\"Position\")\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"------------\".PadRight(20), _\n\"----\".PadRight(5), _\n\"--------\")\nFor Each e As XElement In po.DescendantsAndSelf()\nConsole.WriteLine(\"{0}{1}{2}\", _\n(\"\".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _\n(DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _\n(DirectCast(e, IXmlLineInfo)).LinePosition)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Element Name        Line Position\n------------        ---- --------\nRoot                1    2\nChild             2    4\nGrandChild1     3    6\nGrandChild2     4    6</code></pre>\n"
  syntax:
    content: public static XElement Load(TextReader textReader, LoadOptions options)
    content.vb: Public Shared Function Load(textReader As TextReader, options As LoadOptions) As XElement
    parameters:
    - id: textReader
      type: System.IO.TextReader
      description: "\n<p>A <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> that will be read for the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> content.</p>\n"
    - id: options
      type: System.Xml.Linq.LoadOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies white space behavior, and whether to load base URI and line information.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the XML that was read from the specified <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.String)
  commentId: M:System.Xml.Linq.XElement.Load(System.String)
  id: Load(System.String)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(String)
  fullName: System.Xml.Linq.XElement.Load(System.String)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 231
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a file.</p>\n"
  remarks: "\n<p>This method reads the raw XML into the XML tree. It discards all insignificant white space in the file.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree, saves it to a file, and then uses this method to load the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from the file.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child\", \"content\")\n);\nxmlTree1.Save(\"Tree.xml\");\n\nXElement xmlTree2 = XElement.Load(\"Tree.xml\");\nConsole.WriteLine(xmlTree2.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root>\n    <Child>Content</Child>\n</Root>\nxmlTree1.Save(\"Tree.xml\")\n\nDim xmlTree2 As XElement = XElement.Load(\"Tree.xml\")\nConsole.WriteLine(xmlTree2.Name)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Root</code></pre>\n"
  syntax:
    content: public static XElement Load(string uri)
    content.vb: Public Shared Function Load(uri As String) As XElement
    parameters:
    - id: uri
      type: System.String
      description: "\n<p>A URI string referencing the file to load into a new <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the contents of the specified file.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)
  commentId: M:System.Xml.Linq.XElement.Load(System.String,System.Xml.Linq.LoadOptions)
  id: Load(System.String,System.Xml.Linq.LoadOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(String, LoadOptions)
  fullName: System.Xml.Linq.XElement.Load(System.String, System.Xml.Linq.LoadOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 232
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a file, optionally preserving white space, setting the base URI, and retaining line information.</p>\n"
  remarks: "\n<p>If the source XML is indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to read all white space in the source XML. Nodes of type <xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref> are created for both significant and insignificant white space.</p>\n<p>If the source XML is indented, not setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to ignore all of the insignificant white space in the source XML. The XML tree is created without any text nodes for insignificant white space.</p>\n<p>If the source XML is not indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> has no effect. Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</p>\n<p>For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n<p>Use <see cref=\"Overload:System.Xml.Linq.XElement.Parse\"></see> to create an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a string that contains XML.</p>\n<p>There is a performance penalty if you set the <xref href=\"System.Xml.Linq.LoadOptions.SetBaseUri\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref> flags.</p>\n<p>The base URI and the line information are accurate immediately after loading the XML document. If you modify the XML tree after loading the document, the base URI and line information may become meaningless.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a file in two different ways: preserving white space, and not preserving white space. It then uses a query to determine the number of white space nodes in the resulting XML tree.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = XElement.Parse(\"<Root> <Child>  </Child> </Root>\", LoadOptions.PreserveWhitespace);\nxmlTree1.Save(\"Tree.xml\");\nConsole.WriteLine(xmlTree1);\n\nint whiteSpaceNodes;\nXElement xmlTree2 = XElement.Load(\"Tree.xml\",\nLoadOptions.None);\nwhiteSpaceNodes = xmlTree2\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\", whiteSpaceNodes);\n\nXElement xmlTree3 = XElement.Load(\"Tree.xml\",\nLoadOptions.PreserveWhitespace);\nwhiteSpaceNodes = xmlTree3\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\", whiteSpaceNodes);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = XElement.Parse(\"<Root> <Child>  </Child> </Root>\", LoadOptions.PreserveWhitespace)\nxmlTree1.Save(\"Tree.xml\")\nConsole.WriteLine(xmlTree1)\n\nDim whiteSpaceNodes As Integer\nDim xmlTree2 As XElement = XElement.Load(\"Tree.xml\", LoadOptions.None)\nwhiteSpaceNodes = xmlTree2 _\n          .DescendantNodesAndSelf() _\n          .OfType(Of XText)() _\n          .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n          .Count()\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\", whiteSpaceNodes)\n\nDim xmlTree3 As XElement = XElement.Load(\"Tree.xml\", LoadOptions.PreserveWhitespace)\nwhiteSpaceNodes = xmlTree3 _\n          .DescendantNodesAndSelf() _\n          .OfType(Of XText)() _\n          .Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n          .Count()\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\", whiteSpaceNodes)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root> <Child>  </Child> </Root>\nCount of white space nodes (not preserving whitespace): 0\nCount of white space nodes (preserving whitespace): 3</code></pre>\n<p>The following example loads the base URI and line information as it loads the file. It then prints the base URI and the line information.</p>\n<p>This example uses the following resource file: Sample XML File: Typical Purchase Order (LINQ to XML).</p>\n<pre><code class=\"c#\">XElement po = XElement.Load(\"PurchaseOrder.xml\",\nLoadOptions.SetBaseUri | LoadOptions.SetLineInfo);\nstring[] splitUri = po.BaseUri.Split('/');\nConsole.WriteLine(\"BaseUri: {0}\", splitUri[splitUri.Length - 1]);\nConsole.WriteLine();\nConsole.WriteLine(\"{0}{1}{2}\",\n\"Element Name\".PadRight(20),\n\"Line\".PadRight(5),\n\"Position\");\nConsole.WriteLine(\"{0}{1}{2}\",\n\"------------\".PadRight(20),\n\"----\".PadRight(5),\n\"--------\");\nforeach (XElement e in po.DescendantsAndSelf())\nConsole.WriteLine(\"{0}{1}{2}\",\n(\"\".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),\n((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),\n((IXmlLineInfo)e).LinePosition);</code></pre>\n<pre><code class=\"vb\">Dim po As XElement = XElement.Load(\"PurchaseOrder.xml\", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)\nDim splitUri() As String = po.BaseUri.Split(\"/\")\nConsole.WriteLine(\"BaseUri: {0}\", splitUri(splitUri.Length - 1))\nConsole.WriteLine()\nConsole.WriteLine(\"{0}{1}{2}\", _\n    \"Element Name\".PadRight(20), _\n    \"Line\".PadRight(5), _\n    \"Position\")\nConsole.WriteLine(\"{0}{1}{2}\", _\n    \"------------\".PadRight(20), _\n    \"----\".PadRight(5), _\n    \"--------\")\nFor Each e As XElement In po.DescendantsAndSelf()\n    Console.WriteLine(\"{0}{1}{2}\", _\n        (\"\".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString()).PadRight(20), _\n        (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _\n        (DirectCast(e, IXmlLineInfo)).LinePosition)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>BaseUri: PurchaseOrder.xml\n\nElement Name        Line Position\n------------        ---- --------\nPurchaseOrder       2    2\nAddress           3    4\nName            4    6\nStreet          5    6\nCity            6    6\nState           7    6\nZip             8    6\nCountry         9    6\nAddress           11   4\nName            12   6\nStreet          13   6\nCity            14   6\nState           15   6\nZip             16   6\nCountry         17   6\nDeliveryNotes     19   4\nItems             20   4\nItem            21   6\nProductName   22   8\nQuantity      23   8\nUSPrice       24   8\nComment       25   8\nItem            27   6\nProductName   28   8\nQuantity      29   8\nUSPrice       30   8\nShipDate      31   8</code></pre>\n"
  syntax:
    content: public static XElement Load(string uri, LoadOptions options)
    content.vb: Public Shared Function Load(uri As String, options As LoadOptions) As XElement
    parameters:
    - id: uri
      type: System.String
      description: "\n<p>A URI string referencing the file to load into an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: options
      type: System.Xml.Linq.LoadOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies white space behavior, and whether to load base URI and line information.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the contents of the specified file.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.Xml.XmlReader)
  commentId: M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader)
  id: Load(System.Xml.XmlReader)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(XmlReader)
  fullName: System.Xml.Linq.XElement.Load(System.Xml.XmlReader)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 233
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  remarks: "\n<p>By creating an <xref href=\"System.Xml.XmlNodeReader\" data-throw-if-not-resolved=\"false\"></xref> from a DOM document, and then using the <xref href=\"System.Xml.XmlNodeReader\" data-throw-if-not-resolved=\"false\"></xref> to create an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example creates a DOM document, creates an <xref href=\"System.Xml.XmlNodeReader\" data-throw-if-not-resolved=\"false\"></xref> from the DOM document, instantiates a tree from the reader. This code effectively copies a DOM document into a LINQ to XML tree.</p>\n<pre><code class=\"c#\">// Create a DOM document with some content.\nXmlDocument doc = new XmlDocument();\nXmlElement child = doc.CreateElement(\"Child\");\nchild.InnerText = \"child contents\";\nXmlElement root = doc.CreateElement(\"Root\");\nroot.AppendChild(child);\ndoc.AppendChild(root);\n\n// Create a reader and move to the content.\nusing (XmlNodeReader nodeReader = new XmlNodeReader(doc)) {\n// the reader must be in the Interactive state in order to\n// Create a LINQ to XML tree from it.\nnodeReader.MoveToContent();\n\nXElement xRoot = XElement.Load(nodeReader);\nConsole.WriteLine(xRoot);\n}</code></pre>\n<pre><code class=\"vb\">' Create a DOM document with some content.\nDim doc As XmlDocument = New XmlDocument()\nDim child As XmlElement = doc.CreateElement(\"Child\")\nchild.InnerText = \"child contents\"\nDim root As XmlElement = doc.CreateElement(\"Root\")\nroot.AppendChild(child)\ndoc.AppendChild(root)\n\n' Create a reader and move to the content.\nUsing nodeReader = New XmlNodeReader(doc)\n' the reader must be in the Interactive state in order to\n' Create a LINQ to XML tree from it.\nnodeReader.MoveToContent()\n\nDim xRoot As XElement = XElement.Load(nodeReader)\nConsole.WriteLine(xRoot)\nEnd Using</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child>child contents</Child>\n</Root></code></pre>\n"
  syntax:
    content: public static XElement Load(XmlReader reader)
    content.vb: Public Shared Function Load(reader As XmlReader) As XElement
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "\n<p>A <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> that will be read for the content of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the XML that was read from the specified <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)
  commentId: M:System.Xml.Linq.XElement.Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)
  id: Load(System.Xml.XmlReader,System.Xml.Linq.LoadOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Load(XmlReader, LoadOptions)
  fullName: System.Xml.Linq.XElement.Load(System.Xml.XmlReader, System.Xml.Linq.LoadOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Load
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 234
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Loads an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>, optionally preserving white space, setting the base URI, and retaining line information.</p>\n"
  remarks: "\n<p>By creating an <xref href=\"System.Xml.XmlNodeReader\" data-throw-if-not-resolved=\"false\"></xref> from a DOM document, and then using the <xref href=\"System.Xml.XmlNodeReader\" data-throw-if-not-resolved=\"false\"></xref> to create an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, this method can be used to create a copy of a DOM document in a LINQ to XML tree.</p>\n<p>Use <see cref=\"Overload:System.Xml.Linq.XElement.Parse\"></see> to create an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a string that contains XML.</p>\n<p>Setting <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> is not valid when loading from a <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> will be configured to either read whitespace or not. The LINQ to XML tree will be populated with the whitespace nodes that the reader surfaces. This will be the behavior regardless of whether <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> is set or not.</p>\n<p>The <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> may have a valid base URI or not. If you set <xref href=\"System.Xml.Linq.LoadOptions.SetBaseUri\" data-throw-if-not-resolved=\"false\"></xref>, the base URI will be set in the XML tree from the base URI that is reported by the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> may have a valid line information or not. If you set <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref>, the line information will be set in the XML tree from the line information that is reported by the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>There is a performance penalty if you set the <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>\n<p>The line information is accurate immediately after loading the XML document. If you modify the XML tree after loading the document, the line information may become meaningless.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example loads the line information that it loads from the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. It then prints the line information.</p>\n<pre><code class=\"c#\">string markup =\n@\"<Root>\n<Child>\n<GrandChild/>\n</Child>\n</Root>\";\n\n// Create a reader and move to the content.\nusing (XmlReader nodeReader = XmlReader.Create(new StringReader(markup)))\n{\n// the reader must be in the Interactive state in order to\n// Create a LINQ to XML tree from it.\nnodeReader.MoveToContent();\n\nXElement xRoot = XElement.Load(nodeReader, LoadOptions.SetLineInfo);\nConsole.WriteLine(\"{0}{1}{2}\",\n\"Element Name\".PadRight(20),\n\"Line\".PadRight(5),\n\"Position\");\nConsole.WriteLine(\"{0}{1}{2}\",\n\"------------\".PadRight(20),\n\"----\".PadRight(5),\n\"--------\");\nforeach (XElement e in xRoot.DescendantsAndSelf())\nConsole.WriteLine(\"{0}{1}{2}\",\n    (\"\".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),\n    ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),\n    ((IXmlLineInfo)e).LinePosition);\n}</code></pre>\n<pre><code class=\"vb\">Dim markup As String = _\n\"<Root>\" & Environment.NewLine & _\n\"    <Child>\" & Environment.NewLine & _\n\"        <GrandChild/>\" & Environment.NewLine & _\n\"    </Child>\" & Environment.NewLine & _\n\"</Root>\"\n\n' Create a reader and move to the content.\nUsing nodeReader As XmlReader = XmlReader.Create(New StringReader(markup))\n\n' the reader must be in the Interactive state in order to\n' Create a LINQ to XML tree from it.\nnodeReader.MoveToContent()\n\nDim xRoot As XElement = XElement.Load(nodeReader, LoadOptions.SetLineInfo)\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"Element Name\".PadRight(20), _\n\"Line\".PadRight(5), _\n\"Position\")\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"------------\".PadRight(20), _\n\"----\".PadRight(5), _\n\"--------\")\nFor Each e As XElement In xRoot.DescendantsAndSelf()\nConsole.WriteLine(\"{0}{1}{2}\", _\n    (\"\".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _\n    (DirectCast(e, IXmlLineInfo)).LineNumber.ToString().PadRight(5), _\n    (DirectCast(e, IXmlLineInfo)).LinePosition)\nNext\nEnd Using</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Element Name        Line Position\n------------        ---- --------\nRoot                1    2\nChild             2    6\nGrandChild      3    10</code></pre>\n"
  syntax:
    content: public static XElement Load(XmlReader reader, LoadOptions options)
    content.vb: Public Shared Function Load(reader As XmlReader, options As LoadOptions) As XElement
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "\n<p>A <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> that will be read for the content of the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: options
      type: System.Xml.Linq.LoadOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies white space behavior, and whether to load base URI and line information.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> that contains the XML that was read from the specified <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Boolean
  id: op_Explicit(System.Xml.Linq.XElement)~System.Boolean
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Boolean)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Boolean)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 235
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>When converting to <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element, allowed values are \"0\", \"1\", and any string that produces \"true\" or \"false\" after trimming and conversion to lower case.</p>\n"
  example:
  - "\n<p>The following example creates some elements with boolean values. It then casts them to <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"BoolValue1\", true),\nnew XElement(\"BoolValue2\", false)\n);\nbool bool1 = (bool)root.Element(\"BoolValue1\");\nbool bool2 = (bool)root.Element(\"BoolValue2\");\nConsole.WriteLine(\"(bool)BoolValue1={0}\", bool1);\nConsole.WriteLine(\"(bool)BoolValue2={0}\", bool2);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <BoolValue1>true</BoolValue1>\n    <BoolValue2>false</BoolValue2>\n</Root>\nDim bool1 As Boolean = CBool(root.Element(\"BoolValue1\"))\nDim bool2 As Boolean = CBool(root.Element(\"BoolValue2\"))\nConsole.WriteLine(\"(bool)BoolValue1={0}\", bool1)\nConsole.WriteLine(\"(bool)BoolValue2={0}\", bool2)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>(bool)BoolValue1=True\n(bool)BoolValue2=False</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator bool (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Boolean
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>A <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Boolean)
  name.vb: Narrowing(XElement to Boolean)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTime
  id: op_Explicit(System.Xml.Linq.XElement)~System.DateTime
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to DateTime)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.DateTime)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 237
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601. When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification. See the W3C specification for more details.</p>\n<p>Behavior is lax when casting to a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element. Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This conversion operator uses <xref href=\"System.Globalization.CultureInfo.InvariantCulture\" data-throw-if-not-resolved=\"false\"></xref> to convert from a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with date and time content. It then casts it to <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> to retrieve the value. </p>\n<pre><code class=\"c#\">// Behavior is strict when formatting an XML element or attribute from a DateTime,\n// but behavior is lax when casting to a DateTime from an element or attribute.\nXElement root = new XElement(\"Root\", new DateTime(2006, 10, 6, 12, 30, 0));\nConsole.WriteLine(root);\n\n// Cast from a strictly formatted XML element.\nDateTime dt = (DateTime)root;\nConsole.WriteLine(\"dt={0}\", dt);\nConsole.WriteLine(\"-----\");\n\n// If root is formatted in some different way:\nXElement dtElement = new XElement(\"OrderDate\", \"October 6, 2006\");\nConsole.WriteLine(dtElement);\nDateTime orderDate = (DateTime)dtElement;\nConsole.WriteLine(\"orderDate={0:d}\", orderDate);</code></pre>\n<pre><code class=\"vb\">' Behavior is strict when formatting an XML element or attribute from a DateTime,\n' but behavior is lax when casting to a DateTime from an element or attribute.\nDim root As XElement = <Root><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Root>\nConsole.WriteLine(root)\n\n' Cast from a strictly formatted XML element.\nDim dt As DateTime = CType(root, DateTime)\nConsole.WriteLine(\"dt={0}\", dt)\nConsole.WriteLine(\"-----\")\n\n' If root is formatted in some different way:\nDim dtElement As XElement = <OrderDate>October 6, 2006</OrderDate>\nConsole.WriteLine(dtElement)\nDim orderDate As DateTime = CType(dtElement, DateTime)\nConsole.WriteLine(\"orderDate={0:d}\", orderDate)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>2006-10-06T12:30:00</Root>\ndt=10/6/2006 12:30:00 PM\n-----\n<OrderDate>October 6, 2006</OrderDate>\norderDate=10/6/2006</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator DateTime(XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Date
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.DateTime
      description: "\n<p>A <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.DateTime)
  name.vb: Narrowing(XElement to DateTime)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset
  id: op_Explicit(System.Xml.Linq.XElement)~System.DateTimeOffset
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to DateTimeOffset)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.DateTimeOffset)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 239
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This conversion operator uses the <xref href=\"System.Xml.XmlConvert\" data-throw-if-not-resolved=\"false\"></xref> class to do the conversion.</p>\n"
  example:
  - "\n<p>The following example creates an element with date and time content. It then casts to <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> to retrieve the value.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Child\", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))\n);\nConsole.WriteLine(root);\n\nDateTimeOffset dt = (DateTimeOffset)root.Element(\"Child\");\nConsole.WriteLine(\"dt={0}\", dt);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _\n<Root>\n<Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>\n</Root>\nConsole.WriteLine(root)\n\nDim dt As DateTimeOffset = CType(root.<Child>(0), DateTimeOffset)\nConsole.WriteLine(\"dt={0}\", dt)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>\n<Child>2006-10-06T12:30:00-07:00</Child>\n</Root>\ndt=10/6/2006 12:30:00 PM -07:00</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator DateTimeOffset(XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As DateTimeOffset
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.DateTimeOffset
      description: "\n<p>A <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.DateTimeOffset)
  name.vb: Narrowing(XElement to DateTimeOffset)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Decimal
  id: op_Explicit(System.Xml.Linq.XElement)~System.Decimal
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Decimal)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Decimal)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 241
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with a decimal value. It then retrieves the value of the attribute by casting to <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \"79228162514264337593543950335\");\ndecimal value = (decimal)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>79228162514264337593543950335</Root>\nDim value As Decimal = CDec(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=79228162514264337593543950335</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator decimal (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Decimal
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Decimal
      description: "\n<p>A <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Decimal)
  name.vb: Narrowing(XElement to Decimal)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Double
  id: op_Explicit(System.Xml.Linq.XElement)~System.Double
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Double)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Double)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 243
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an attribute with <strong>double</strong> content. It then retrieves the value by casting to <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 1.79769313486231e308);\ndouble value = (double)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>1.79769313486231E+308</Root>\nDim value As Double = CDbl(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=1.79769313486231E+308</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator double (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Double
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Double
      description: "\n<p>A <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Double)
  name.vb: Narrowing(XElement to Double)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Guid
  id: op_Explicit(System.Xml.Linq.XElement)~System.Guid
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Guid)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Guid)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 245
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with a guid as content. It then retrieves the value by casting to <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", new Guid(\"3c1cc55b-baff-4b7a-9d17-077af3aa5730\"));\nGuid value = (Guid)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root><%= New Guid(\"3c1cc55b-baff-4b7a-9d17-077af3aa5730\") %></Root>\nDim value As Guid = CType(root, Guid)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=3c1cc55b-baff-4b7a-9d17-077af3aa5730</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator Guid(XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Guid
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Guid
      description: "\n<p>A <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Guid)
  name.vb: Narrowing(XElement to Guid)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int32
  id: op_Explicit(System.Xml.Linq.XElement)~System.Int32
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Int32)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Int32)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 247
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with an integer as content. It then retrieves the value by casting to <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 2147483647);\nint value = (int)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>2147483647</Root>\nDim value As Integer = CInt(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=2147483647</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator int (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Integer
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Int32)
  name.vb: Narrowing(XElement to Int32)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Int64
  id: op_Explicit(System.Xml.Linq.XElement)~System.Int64
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Int64)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Int64)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 249
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with a long integer as content. It then retrieves the value of the element by casting to <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 9223372036854775807);\nlong value = (long)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>9223372036854775807</Root>\nDim value As Long = CLng(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=9223372036854775807</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator long (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Long
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Int64
      description: "\n<p>A <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Int64)
  name.vb: Narrowing(XElement to Int64)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Boolean}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Boolean>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Boolean>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 251
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>When converting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element, allowed values are \"0\", \"1\", and any string that produces \"true\" or \"false\" after trimming and conversion to lower case.</p>\n"
  example:
  - "\n<p>The following example creates an element with boolean content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"BoolValue1\", true),\nnew XElement(\"BoolValue2\", false));\nbool? bool1 = (bool?)root.Element(\"BoolValue1\");\nbool? bool2 = (bool?)root.Element(\"BoolValue2\");\nConsole.WriteLine(\"Nullable Boolean: value1={0}\", bool1);\nConsole.WriteLine(\"Nullable Boolean: value2={0}\", bool2);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <BoolValue1>true</BoolValue1>\n    <BoolValue2>false</BoolValue2>\n</Root>\n\n\nDim value1 As Nullable(Of Boolean) = CType(root.Element(\"BoolValue1\"), Nullable(Of Boolean))\nDim value2 As Nullable(Of Boolean) = CType(root.Element(\"BoolValue2\"), Nullable(Of Boolean))\nConsole.WriteLine(\"Nullable Boolean: value1={0}\", IIf(value1.HasValue, value1.ToString(), \"null\"))\nConsole.WriteLine(\"Nullable Boolean: value2={0}\", IIf(value2.HasValue, value2.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable Boolean: value1=True\nNullable Boolean: value2=False</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator bool ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Boolean?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Boolean}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Boolean))
  name.vb: Narrowing(XElement to Nullable(Of Boolean))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTime}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<DateTime>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.DateTime>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 253
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The value space of an attribute or element that contains date and time content is closely related to the dates and times described in ISO 8601. When creating an attribute or element that contains date and time content, the attribute or element values are formatted per the W3C specification. See the W3C specification for more details.</p>\n<p>Behavior is lax when casting to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element. Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This conversion operator uses <xref href=\"System.Globalization.CultureInfo.InvariantCulture\" data-throw-if-not-resolved=\"false\"></xref> to convert from a <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with a date and time as content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Value\", new DateTime(2006, 10, 6, 12, 30, 0))\n);\nDateTime? value = (DateTime?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable DateTime: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n<Value><%= New DateTime(2006, 10, 6, 12, 30, 0) %></Value>\n</Root>\nDim value As Nullable(Of DateTime) = CType(root.Element(\"Value\"), Nullable(Of DateTime))\nConsole.WriteLine(\"Nullable DateTime: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable DateTime: value=10/6/2006 12:30:00 PM</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator DateTime? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Date?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.DateTime}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.DateTime))
  name.vb: Narrowing(XElement to Nullable(Of DateTime))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.DateTimeOffset}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<DateTimeOffset>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.DateTimeOffset>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 255
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This conversion operator uses the <xref href=\"System.Xml.XmlConvert\" data-throw-if-not-resolved=\"false\"></xref> class to do the conversion.</p>\n"
  example:
  - "\n<p>The following example creates an element with date and time content. It then casts to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> to retrieve the value.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Child\", new DateTimeOffset(new DateTime(2006, 10, 6, 12, 30, 0)))\n);\nConsole.WriteLine(root);\n\nDateTimeOffset? dt = (DateTimeOffset?)root.Element(\"Child\");\nConsole.WriteLine(\"dt={0}\", dt);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _\n<Root>\n<Child><%= New DateTimeOffset(New DateTime(2006, 10, 6, 12, 30, 0)) %></Child>\n</Root>\nConsole.WriteLine(root)\n\nDim dt As Nullable(Of DateTimeOffset) = CType(root.<Child>(0), Nullable(Of DateTimeOffset))\nConsole.WriteLine(\"dt={0}\", dt)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>\n<Child>2006-10-06T12:30:00-07:00</Child>\n</Root>\ndt=10/6/2006 12:30:00 PM -07:00</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator DateTimeOffset? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As DateTimeOffset?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to an <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.DateTimeOffset}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.DateTimeOffset))
  name.vb: Narrowing(XElement to Nullable(Of DateTimeOffset))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Decimal}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Decimal>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Decimal>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 257
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with decimal content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Value\", \"79228162514264337593543950335\")\n);\ndecimal? value = (decimal?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable decimal: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n<Value>79228162514264337593543950335</Value>\n</Root>\nDim value As Nullable(Of Decimal) = CType(root.Element(\"Value\"), Nullable(Of Decimal))\nConsole.WriteLine(\"Nullable decimal: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable decimal: value=79228162514264337593543950335</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator decimal ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Decimal?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Decimal}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Decimal\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Decimal))
  name.vb: Narrowing(XElement to Nullable(Of Decimal))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Double}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Double>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Double>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 259
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with double precision floating point content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Value\", 1.79769313486231e308)\n);\ndouble? value = (double?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable double: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _\n<Root>\n    <Value>1.79769313486231e308</Value>\n</Root>\n\nDim value As Nullable(Of Double) = CType(root.Element(\"Value\"), Nullable(Of Double))\nConsole.WriteLine(\"Nullable double: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable double: value=1.79769313486231E+308</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator double ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Double?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Double}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Double\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Double))
  name.vb: Narrowing(XElement to Nullable(Of Double))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Guid}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Guid>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Guid>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 261
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with guid content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Value\", new Guid(\"3c1cc55b-baff-4b7a-9d17-077af3aa5730\"))\n);\nGuid? value = (Guid?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable Guid: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n<Value><%= New Guid(\"3c1cc55b-baff-4b7a-9d17-077af3aa5730\") %></Value>\n</Root>\nDim value As Nullable(Of Guid) = CType(root.Element(\"Value\"), Nullable(Of Guid))\nConsole.WriteLine(\"Nullable Guid: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable Guid: value=3c1cc55b-baff-4b7a-9d17-077af3aa5730</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator Guid? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Guid?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Guid}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Guid\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Guid))
  name.vb: Narrowing(XElement to Nullable(Of Guid))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int32}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Int32>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Int32>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 263
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with unsigned integer content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"Value\", 2147483647)\n);\nint? value = (int?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable integer: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Value>2147483647</Value>\n</Root>\nDim value As Nullable(Of Integer) = CType(root.Element(\"Value\"), Nullable(Of Integer))\nConsole.WriteLine(\"Nullable integer: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable integer: value=2147483647</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator int ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Integer?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Int32}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Int32))
  name.vb: Narrowing(XElement to Nullable(Of Int32))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Int64}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Int64>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Int64>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 265
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with long integer content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",  \nnew XElement(\"Value\", 9223372036854775807)\n);\nulong? value = (ulong?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable ulong: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Value>9223372036854775807</Value>\n</Root>\nDim value As Nullable(Of ULong) = CType(root.Element(\"Value\"), Nullable(Of ULong))\nConsole.WriteLine(\"Nullable ulong: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable ulong: value=9223372036854775807</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator long ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Long?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Int64}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Int64))
  name.vb: Narrowing(XElement to Nullable(Of Int64))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.Single}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<Single>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.Single>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 267
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with single precision floating point content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"Value\", 3.402823e38)\n);\nfloat? value = (float?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable Single: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Value>3.402823e38</Value>\n</Root>\nDim value As Nullable(Of Single) = CType(root.Element(\"Value\"), Nullable(Of Single))\nConsole.WriteLine(\"Nullable Single: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable Single: value=3.402823E+38</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator float ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Single?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.Single}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.Single))
  name.vb: Narrowing(XElement to Nullable(Of Single))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.TimeSpan}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<TimeSpan>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.TimeSpan>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 269
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601. When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification. Please see the W3C specification for more details.</p>\n<p>Behavior is lax when casting to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element. Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with time span content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Value\", new TimeSpan(1, 5, 30))\n);\nTimeSpan? value = (TimeSpan?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable TimeSpan: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _\n<Root>\n<Value><%= New TimeSpan(1, 5, 30) %></Value>\n</Root>\nDim value As Nullable(Of TimeSpan) = CType(root.Element(\"Value\"), Nullable(Of TimeSpan))\nConsole.WriteLine(\"Nullable TimeSpan: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable TimeSpan: value=01:05:30</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator TimeSpan? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As TimeSpan?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.TimeSpan}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.TimeSpan))
  name.vb: Narrowing(XElement to Nullable(Of TimeSpan))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt32}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<UInt32>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.UInt32>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 271
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with unsigned integer content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"Value\", 4294967295)\n);\nuint? value = (uint?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable uint: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Value>4294967295</Value>\n</Root>\nDim value As Nullable(Of UInteger) = CType(root.Element(\"Value\"), Nullable(Of UInteger))\nConsole.WriteLine(\"Nullable uint: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable uint: value=4294967295</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator uint ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As UInteger?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.UInt32}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.UInt32))
  name.vb: Narrowing(XElement to Nullable(Of UInt32))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}
  id: op_Explicit(System.Xml.Linq.XElement)~System.Nullable{System.UInt64}
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Nullable<UInt64>)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Nullable<System.UInt64>)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 273
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with unsigned long integer content. It then retrieves the value by casting to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", \nnew XElement(\"Value\", 9223372036854775807)\n);\nulong? value = (ulong?)root.Element(\"Value\");\nConsole.WriteLine(\"Nullable ulong: value={0}\", value == null ? \"null\" : value.ToString());</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Value>9223372036854775807</Value>\n</Root>\n\nDim value As Nullable(Of ULong) = CType(root.Element(\"Value\"), Nullable(Of ULong))\nConsole.WriteLine(\"Nullable ulong: value={0}\", IIf(value.HasValue, value.ToString(), \"null\"))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Nullable ulong: value=9223372036854775807</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator ulong ? (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As ULong?
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Nullable{System.UInt64}
      description: "\n<p>A <xref href=\"System.Nullable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Nullable(Of System.UInt64))
  name.vb: Narrowing(XElement to Nullable(Of UInt64))
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.Single
  id: op_Explicit(System.Xml.Linq.XElement)~System.Single
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to Single)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.Single)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 275
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with single precision floating point content. It then retrieves the value by casting to <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 3.402823e38);\nfloat value = (float)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>3.402823E+38</Root>\nDim value As Single = CSng(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=3.402823E+38</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator float (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As Single
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Single
      description: "\n<p>A <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.Single\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.Single)
  name.vb: Narrowing(XElement to Single)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.String
  id: op_Explicit(System.Xml.Linq.XElement)~System.String
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to String)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.String)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 277
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> has children, the concatenated string value of all of the element's text and descendant's text is returned.</p>\n"
  example:
  - "\n<p>The following example creates an element with string content. It then retrieves the value by casting to <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = XElement.Parse(\"<Root>abc <b>def </b>ghi</Root>\");\nConsole.WriteLine(\"(string)root={0}\", (string)root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>abc <b>def </b>ghi</Root>\nConsole.WriteLine(\"(string)root={0}\", root.Value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>(string)root=abc def ghi</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator string (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As String
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.String)
  name.vb: Narrowing(XElement to String)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan
  id: op_Explicit(System.Xml.Linq.XElement)~System.TimeSpan
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to TimeSpan)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.TimeSpan)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 279
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The value space of an attribute or element that contains time span content is closely related to duration content as described in ISO 8601. When creating an attribute or element that contains time span content, the attribute or element values are formatted per the W3C specification. Please see the W3C specification for more details.</p>\n<p>Behavior is lax when casting to a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> from an attribute or element. Even if the attribute or element value is not formatted exactly per the W3C specification, the value is appropriately converted to a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with time span content. It then retrieves the value by casting to <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", new TimeSpan(1, 5, 30));\nTimeSpan value = (TimeSpan)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root><%= New TimeSpan(1, 5, 30) %></Root>\nDim value As TimeSpan = CType(root, TimeSpan)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=01:05:30</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator TimeSpan(XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As TimeSpan
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.TimeSpan)
  name.vb: Narrowing(XElement to TimeSpan)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt32
  id: op_Explicit(System.Xml.Linq.XElement)~System.UInt32
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to UInt32)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.UInt32)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 281
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with unsigned integer content. It then retrieves the value by casting to <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 4294967295);\nuint value = (uint)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>4294967295</Root>\nDim value As UInteger = CUInt(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=4294967295</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator uint (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As UInteger
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.UInt32
      description: "\n<p>A <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.UInt32\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.UInt32)
  name.vb: Narrowing(XElement to UInt32)
- uid: System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64
  commentId: M:System.Xml.Linq.XElement.op_Explicit(System.Xml.Linq.XElement)~System.UInt64
  id: op_Explicit(System.Xml.Linq.XElement)~System.UInt64
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Explicit(XElement to UInt64)
  fullName: System.Xml.Linq.XElement.Explicit(System.Xml.Linq.XElement to System.UInt64)
  type: Operator
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Explicit
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 283
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Cast the value of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to a <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element with unsigned long integer content. It then retrieves the value by casting to <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\", 18446744073709551615);\nulong value = (ulong)root;\nConsole.WriteLine(\"value={0}\", value);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>18446744073709551615</Root>\nDim value As ULong = CULng(root)\nConsole.WriteLine(\"value={0}\", value)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>value=18446744073709551615</code></pre>\n"
  syntax:
    content: >-
      [CLSCompliant(false)]

      public static explicit operator ulong (XElement element)
    content.vb: >-
      <CLSCompliant(False)>

      Public Shared Narrowing Operator CType(element As XElement) As ULong
    parameters:
    - id: element
      type: System.Xml.Linq.XElement
      description: "\n<p>The <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to cast to <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.UInt64
      description: "\n<p>A <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref> that contains the content of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.FormatException
    commentId: T:System.FormatException
    description: "\n<p>The element does not contain a valid <xref href=\"System.UInt64\" data-throw-if-not-resolved=\"false\"></xref> value.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>element</em> parameter is <strong>null</strong>.</p>\n"
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Xml.Linq.XElement.Narrowing(System.Xml.Linq.XElement to System.UInt64)
  name.vb: Narrowing(XElement to UInt64)
- uid: System.Xml.Linq.XElement.Parse(System.String)
  commentId: M:System.Xml.Linq.XElement.Parse(System.String)
  id: Parse(System.String)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Parse(String)
  fullName: System.Xml.Linq.XElement.Parse(System.String)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Parse
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 285
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Load an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a string that contains XML.</p>\n"
  remarks: "\n<p>This method does not preserve white space. If you want to preserve white space in the XML tree, use the overload of the <see cref=\"Overload:System.Xml.Linq.XElement.Parse\"></see> method that takes <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> as a parameter. For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example creates a string that contains XML. It then parses the string into an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">XElement xmlTree = XElement.Parse(\"<Root> <Child> </Child> </Root>\");\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = <Root><Child></Child></Root>\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child></Child>\n</Root></code></pre>\n"
  syntax:
    content: public static XElement Parse(string text)
    content.vb: Public Shared Function Parse(text As String) As XElement
    parameters:
    - id: text
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that contains XML.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> populated from the string that contains XML.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)
  commentId: M:System.Xml.Linq.XElement.Parse(System.String,System.Xml.Linq.LoadOptions)
  id: Parse(System.String,System.Xml.Linq.LoadOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Parse(String, LoadOptions)
  fullName: System.Xml.Linq.XElement.Parse(System.String, System.Xml.Linq.LoadOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Parse
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 286
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Load an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> from a string that contains XML, optionally preserving white space and retaining line information.</p>\n"
  remarks: "\n<p>If the source XML is indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to read all white space in the source XML. Nodes of type <xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref> are created for both significant and insignificant white space.</p>\n<p>If the source XML is indented, not setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> causes the reader to ignore all of the insignificant white space in the source XML. The XML tree is created without any text nodes for insignificant white space.</p>\n<p>If the source XML is not indented, setting the <xref href=\"System.Xml.Linq.LoadOptions.PreserveWhitespace\" data-throw-if-not-resolved=\"false\"></xref> flag in <em>options</em> has no effect. Significant white space is still preserved, and there are no spans of insignificant white space that could cause the creation of more white space text nodes.</p>\n<p>For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n<p>Setting <xref href=\"System.Xml.Linq.LoadOptions.SetBaseUri\" data-throw-if-not-resolved=\"false\"></xref> will have no effect when parsing from a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> may have a valid line information or not. If you set <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref>, the line information will be set in the XML tree from the line information that is reported by the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>There is a performance penalty if you set the <xref href=\"System.Xml.Linq.LoadOptions.SetLineInfo\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>\n<p>The line information is accurate immediately after loading the XML document. If you modify the XML tree after loading the document, the line information may become meaningless.</p>\n<p>LINQ to XML's loading functionality is built upon <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. Therefore, you might catch any exceptions that are thrown by the <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> overload methods and the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> methods that read and parse the document.</p>\n"
  example:
  - "\n<p>The following example parses a string into an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> in two different ways: preserving white space, and not preserving white space. It then uses a query to determine the number of white space nodes in the resulting XML tree.</p>\n<pre><code class=\"c#\">int whiteSpaceNodes;\n\nXElement xmlTree1 = XElement.Parse(\"<Root> <Child> </Child> </Root>\",\nLoadOptions.None);\nwhiteSpaceNodes = xmlTree1\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\",\nwhiteSpaceNodes);\n\nXElement xmlTree2 = XElement.Parse(\"<Root> <Child> </Child> </Root>\",\nLoadOptions.PreserveWhitespace);\nwhiteSpaceNodes = xmlTree2\n.DescendantNodesAndSelf()\n.OfType<XText>()\n.Where(tNode => tNode.ToString().Trim().Length == 0)\n.Count();\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\",\nwhiteSpaceNodes);</code></pre>\n<pre><code class=\"vb\">Dim whiteSpaceNodes As Integer\n\nDim xmlTree1 As XElement = XElement.Parse(\"<Root> <Child> </Child> </Root>\", LoadOptions.None)\nwhiteSpaceNodes = xmlTree1 _\n.DescendantNodesAndSelf() _\n.OfType(Of XText)() _\n.Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n.Count()\nConsole.WriteLine(\"Count of white space nodes (not preserving whitespace): {0}\", whiteSpaceNodes)\n\nDim xmlTree2 As XElement = XElement.Parse(\"<Root> <Child> </Child> </Root>\", LoadOptions.PreserveWhitespace)\nwhiteSpaceNodes = xmlTree2 _\n.DescendantNodesAndSelf() _\n.OfType(Of XText)() _\n.Where(Function(ByVal tNode As XNode) tNode.ToString().Trim().Length = 0) _\n.Count()\nConsole.WriteLine(\"Count of white space nodes (preserving whitespace): {0}\", whiteSpaceNodes)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Count of white space nodes (not preserving whitespace): 0\nCount of white space nodes (preserving whitespace): 3</code></pre>\n<p>The following example retains line information as it parses the string.</p>\n<pre><code class=\"c#\">string markup =\n@\"<Root>\n<Child>\n<GrandChild/>\n</Child>\n</Root>\";\n\nXElement xRoot = XElement.Parse(markup, LoadOptions.SetLineInfo);\nConsole.WriteLine(\"{0}{1}{2}\",\n\"Element Name\".PadRight(20),\n\"Line\".PadRight(5),\n\"Position\");\nConsole.WriteLine(\"{0}{1}{2}\",\n\"------------\".PadRight(20),\n\"----\".PadRight(5),\n\"--------\");\nforeach (XElement e in xRoot.DescendantsAndSelf())\nConsole.WriteLine(\"{0}{1}{2}\",\n(\"\".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),\n((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),\n((IXmlLineInfo)e).LinePosition);</code></pre>\n<pre><code class=\"vb\">Dim markup As String = _\n\"<Root>\" & Environment.NewLine & _\n\"    <Child>\" & Environment.NewLine & _\n\"        <GrandChild/>\" & Environment.NewLine & _\n\"    </Child>\" & Environment.NewLine & _\n\"</Root>\"\n\nDim xRoot As XElement = XElement.Parse(markup, LoadOptions.SetLineInfo)\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"Element Name\".PadRight(20), _\n\"Line\".PadRight(5), _\n\"Position\")\nConsole.WriteLine(\"{0}{1}{2}\", _\n\"------------\".PadRight(20), _\n\"----\".PadRight(5), _\n\"--------\")\nFor Each e As XElement In xRoot.DescendantsAndSelf()\nConsole.WriteLine(\"{0}{1}{2}\", _\n(\"\".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _\nDirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _\nDirectCast(e, IXmlLineInfo).LinePosition)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Element Name        Line Position\n------------        ---- --------\nRoot                1    2\nChild             2    6\nGrandChild      3    10</code></pre>\n"
  syntax:
    content: public static XElement Parse(string text, LoadOptions options)
    content.vb: Public Shared Function Parse(text As String, options As LoadOptions) As XElement
    parameters:
    - id: text
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> that contains XML.</p>\n"
    - id: options
      type: System.Xml.Linq.LoadOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.LoadOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies white space behavior, and whether to load base URI and line information.</p>\n"
    return:
      type: System.Xml.Linq.XElement
      description: "\n<p>An <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> populated from the string that contains XML.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XElement.RemoveAll
  commentId: M:System.Xml.Linq.XElement.RemoveAll
  id: RemoveAll
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: RemoveAll()
  fullName: System.Xml.Linq.XElement.RemoveAll()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RemoveAll
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 287
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Removes nodes and attributes from this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example creates an element with attributes and child elements. It then calls this method to remove both the attributes and the child elements.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3)\n);\nroot.RemoveAll();   // removes children elements and attributes of root\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root Attr1=\"1\" Attr2=\"2\" Attr3=\"3\">\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n</Root>\n\nroot.RemoveAll()   ' removes children elements and attributes of root\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root /></code></pre>\n"
  syntax:
    content: public void RemoveAll()
    content.vb: Public Sub RemoveAll
  seealso:
  - type: System.Xml.Linq.XElement.RemoveAttributes
    commentId: M:System.Xml.Linq.XElement.RemoveAttributes
  - type: System.Xml.Linq.XContainer.RemoveNodes
    commentId: M:System.Xml.Linq.XContainer.RemoveNodes
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.RemoveAttributes
  commentId: M:System.Xml.Linq.XElement.RemoveAttributes
  id: RemoveAttributes
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: RemoveAttributes()
  fullName: System.Xml.Linq.XElement.RemoveAttributes()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RemoveAttributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 288
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Removes the attributes of this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example creates an element with attributes and child elements. It then calls this method to remove the attributes. The child elements remain.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3)\n);\nroot.RemoveAttributes();\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root Attr1=\"1\" Attr2=\"2\" Attr3=\"3\">\n<Child1>1</Child1>\n<Child2>2</Child2>\n<Child3>3</Child3>\n</Root>\n\nroot.RemoveAttributes()\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>1</Child1>\n<Child2>2</Child2>\n<Child3>3</Child3>\n</Root> </code></pre>\n"
  syntax:
    content: public void RemoveAttributes()
    content.vb: Public Sub RemoveAttributes
  seealso:
  - type: System.Xml.Linq.XElement.RemoveAttributes
    commentId: M:System.Xml.Linq.XElement.RemoveAttributes
  - type: System.Xml.Linq.XElement.RemoveAll
    commentId: M:System.Xml.Linq.XElement.RemoveAll
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.ReplaceAll(System.Object)
  commentId: M:System.Xml.Linq.XElement.ReplaceAll(System.Object)
  id: ReplaceAll(System.Object)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: ReplaceAll(Object)
  fullName: System.Xml.Linq.XElement.ReplaceAll(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceAll
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 289
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces the child nodes and the attributes of this element with the specified content.</p>\n"
  remarks: "\n<p>This method first removes existing content and attributes. It then adds the specified <em>content</em>.</p>\n<p>This method uses snapshot semanticsthat is, it creates a separate copy of the new content before replacing the contents of the current element with the new content. This means that you can query the contents of the current element and use the results of the query as the specified new content.</p>\n<p>For details about the valid content that can be passed to this function, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Child\", \"child content\")\n);\n\n// ReplaceAll with an XElement object.\nroot.ReplaceAll(new XElement(\"NewChild\", \"n\"));\nConsole.WriteLine(root);\n\n// ReplaceAll with an XAttribute object.\nroot.ReplaceAll(new XAttribute(\"NewAttribute\", \"n\"));\nConsole.WriteLine(root);\n\n// ReplaceAll with a string.\nroot.ReplaceAll(\"Some text\");\nConsole.WriteLine(root);\n\n// ReplaceAll with a double.\ndouble dbl = 12.345;\nroot.ReplaceAll(dbl);\nConsole.WriteLine(root);\n\n// ReplaceAll with a DateTime object.\nDateTime dt = new DateTime(2006, 10, 6, 12, 30, 00);\nroot.ReplaceAll(dt);\nConsole.WriteLine(root);\n\n// ReplaceAll with a string array.\n// Any collection other than a collection of XElement or XAttribute objects\n// are converted to strings. The strings are concatenated and added.\nstring[] stringArray = {\n\"abc\",\n\"def\",\n\"ghi\"\n};\nroot.ReplaceAll(stringArray);\nConsole.WriteLine(root);\n\n// ReplaceAll with an array of XElement objects.\nXElement[] ellArray = {\nnew XElement(\"NewChild1\", 1),\nnew XElement(\"NewChild2\", 2),\nnew XElement(\"NewChild3\", 3)\n};\nroot.ReplaceAll(ellArray);\nConsole.WriteLine(root);\n\n// ReplaceAll with an array of XAttribute objects.\nXAttribute[] attArray = {\nnew XAttribute(\"NewAtt1\", 1),\nnew XAttribute(\"NewAtt2\", 2),\nnew XAttribute(\"NewAtt3\", 3)\n};\nroot.ReplaceAll(attArray);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n<Child>child content</Child>\n</Root>\n\n' ReplaceAll with an XElement object.\nroot.ReplaceAll(<NewChild>n</NewChild>)\nConsole.WriteLine(root)\n\n' ReplaceAll with an XAttribute object.\nroot.ReplaceAll(New XAttribute(\"NewAttribute\", \"n\"))\nConsole.WriteLine(root)\n\n' ReplaceAll with a string.\nroot.ReplaceAll(\"Some text\")\nConsole.WriteLine(root)\n\n' ReplaceAll with a double.\nDim dbl As Double = 12.345\nroot.ReplaceAll(dbl)\nConsole.WriteLine(root)\n\n' ReplaceAll with a DateTime object.\nDim dt As DateTime = New DateTime(2006, 10, 6, 12, 30, 0)\nroot.ReplaceAll(dt)\nConsole.WriteLine(root)\n\n' ReplaceAll with a string array.\n' Any collection other than a collection of XElement or XAttribute objects\n' are converted to strings. The strings are concatenated and added.\nDim stringArray As String() = { _\n\"abc\", _\n\"def\", _\n\"ghi\" _\n}\nroot.ReplaceAll(stringArray)\nConsole.WriteLine(root)\n\n' ReplaceAll with an array of XElement objects.\nDim ellArray As XElement() = { _\nNew XElement(\"NewChild1\", 1), _\nNew XElement(\"NewChild2\", 2), _\nNew XElement(\"NewChild3\", 3) _\n}\nroot.ReplaceAll(ellArray)\nConsole.WriteLine(root)\n\n' ReplaceAll with an array of XAttribute objects.\nDim attArray As XAttribute() = { _\nNew XAttribute(\"NewAtt1\", 1), _\nNew XAttribute(\"NewAtt2\", 2), _\nNew XAttribute(\"NewAtt3\", 3) _\n}\nroot.ReplaceAll(attArray)\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>\n<NewChild>n</NewChild>\n</Root>\n<Root NewAttribute=\"n\" />\n<Root>Some text</Root>\n<Root>12.345</Root>\n<Root>2006-10-06T12:30:00</Root>\n<Root>abcdefghi</Root>\n<Root>\n<NewChild1>1</NewChild1>\n<NewChild2>2</NewChild2>\n<NewChild3>3</NewChild3>\n</Root>\n<Root NewAtt1=\"1\" NewAtt2=\"2\" NewAtt3=\"3\" /></code></pre>\n"
  syntax:
    content: public void ReplaceAll(object content)
    content.vb: Public Sub ReplaceAll(content As Object)
    parameters:
    - id: content
      type: System.Object
      description: "\n<p>The content that will replace the child nodes and attributes of this element.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.ReplaceAll(System.Object[])
  commentId: M:System.Xml.Linq.XElement.ReplaceAll(System.Object[])
  id: ReplaceAll(System.Object[])
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: ReplaceAll(Object[])
  fullName: System.Xml.Linq.XElement.ReplaceAll(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceAll
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 290
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces the child nodes and the attributes of this element with the specified content.</p>\n"
  remarks: "\n<p>This method first removes existing content and attributes. It then adds the specified <em>content</em>.</p>\n<p>This method uses snapshot semanticsthat is, it creates a separate copy of the new content before replacing the contents of the current element with the new content. This means that you can query the contents of the current element and use the results of the query as the specified new content.</p>\n<p>For details about the valid content that can be passed to this function, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example passes the results of a LINQ query to this method, replacing the contents of an element with the query results.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5),\nnew XElement(\"Child6\", 6)\n);\n\nXElement root = new XElement(\"Root\",\nnew XElement(\"Child\", \"child content\")\n);\n\nroot.ReplaceAll(\nfrom el in xmlTree1.Elements()\nwhere((int)el >= 3 && (int)el <= 5)\nselect el\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n    <Child6>6</Child6>\n</Root>\n\nDim root As XElement = <Root>\n                   <Child>child content</Child>\n               </Root>\n\nroot.ReplaceAll( _\nFrom el In xmlTree1.Elements() _\nWhere el.Value >= 3 And el.Value <= 5 _\nSelect el _\n)\n\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void ReplaceAll(params object[] content)
    content.vb: Public Sub ReplaceAll(ParamArray content As Object())
    parameters:
    - id: content
      type: System.Object[]
      description: "\n<p>A parameter list of content objects.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XElement.ReplaceAll(System.Object())
  name.vb: ReplaceAll(Object())
- uid: System.Xml.Linq.XElement.ReplaceAttributes(System.Object)
  commentId: M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object)
  id: ReplaceAttributes(System.Object)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: ReplaceAttributes(Object)
  fullName: System.Xml.Linq.XElement.ReplaceAttributes(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceAttributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 291
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces the attributes of this element with the specified content.</p>\n"
  remarks: "\n<p>This method first removes existing attributes. It then adds the specified <em>content</em>.</p>\n<p>For details about the valid content that can be passed to this function, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example creates an element with three attributes. It then uses this method to replace all of the attributes of the element with a single attribute.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3)\n);\nroot.ReplaceAttributes(\nnew XAttribute(\"NewAtt1\", 101)\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root Att1=\"1\" Att2=\"2\" Att3=\"3\"/>\nroot.ReplaceAttributes(New XAttribute(\"NewAtt1\", 101))\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root NewAtt1=\"101\" /></code></pre>\n"
  syntax:
    content: public void ReplaceAttributes(object content)
    content.vb: Public Sub ReplaceAttributes(content As Object)
    parameters:
    - id: content
      type: System.Object
      description: "\n<p>The content that will replace the attributes of this element.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])
  commentId: M:System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])
  id: ReplaceAttributes(System.Object[])
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: ReplaceAttributes(Object[])
  fullName: System.Xml.Linq.XElement.ReplaceAttributes(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceAttributes
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 292
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces the attributes of this element with the specified content.</p>\n"
  remarks: "\n<p>This method first removes existing attributes. It then adds the specified <em>content</em>.</p>\n<p>For details about the valid content that can be passed to this function, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example creates an element with three attributes. It then replaces the attributes with other attributes.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XAttribute(\"Att3\", 3)\n);\nroot.ReplaceAttributes(\nnew XAttribute(\"NewAtt1\", 101),\nnew XAttribute(\"NewAtt2\", 102),\nnew XAttribute(\"NewAtt3\", 103)\n);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root Att1=\"1\" Att2=\"2\" Att3=\"3\"/>\nroot.ReplaceAttributes( _\nNew XAttribute(\"NewAtt1\", 101), _\nNew XAttribute(\"NewAtt2\", 102), _\nNew XAttribute(\"NewAtt3\", 103))\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root NewAtt1=\"101\" NewAtt2=\"102\" NewAtt3=\"103\" /></code></pre>\n"
  syntax:
    content: public void ReplaceAttributes(params object[] content)
    content.vb: Public Sub ReplaceAttributes(ParamArray content As Object())
    parameters:
    - id: content
      type: System.Object[]
      description: "\n<p>A parameter list of content objects.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XElement.ReplaceAttributes(System.Object())
  name.vb: ReplaceAttributes(Object())
- uid: System.Xml.Linq.XElement.Save(System.IO.Stream)
  commentId: M:System.Xml.Linq.XElement.Save(System.IO.Stream)
  id: Save(System.IO.Stream)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Save(Stream)
  fullName: System.Xml.Linq.XElement.Save(System.IO.Stream)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Save
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 293
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Outputs this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to the specified <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The serialized XML will be indented. All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented. The behavior of this method is that insignificant white space will not be preserved.</p>\n<p>If you want to control white space, use the overload of <see cref=\"Overload:System.Xml.Linq.XElement.Save\"></see> that takes <xref href=\"System.Xml.Linq.SaveOptions\" data-throw-if-not-resolved=\"false\"></xref> as a parameter. Use the <xref href=\"System.Xml.Linq.SaveOptions.DisableFormatting\" data-throw-if-not-resolved=\"false\"></xref> option to save unindented XML. This will cause the writer to write all white spaces exactly as represented in the XML tree.</p>\n<p>Use the <xref href=\"System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces\" data-throw-if-not-resolved=\"false\"></xref> option if you want to remove duplicate namespace declarations.</p>\n"
  example:
  - 
  syntax:
    content: public void Save(Stream stream)
    content.vb: Public Sub Save(stream As Stream)
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "\n<p>The stream to output this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)
  commentId: M:System.Xml.Linq.XElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)
  id: Save(System.IO.Stream,System.Xml.Linq.SaveOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Save(Stream, SaveOptions)
  fullName: System.Xml.Linq.XElement.Save(System.IO.Stream, System.Xml.Linq.SaveOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Save
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 294
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Outputs this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to the specified <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref>, optionally specifying formatting behavior.</p>\n"
  remarks: "\n<p>By default the <em>options</em> are set to <xref href=\"System.Xml.Linq.SaveOptions.None\" data-throw-if-not-resolved=\"false\"></xref>. This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented. </p>\n<p>If you want to save unindented XML, specify the <xref href=\"System.Xml.Linq.SaveOptions.DisableFormatting\" data-throw-if-not-resolved=\"false\"></xref> flag for <em>options</em>. This will cause the writer to write all white spaces exactly as represented in the XML tree.</p>\n<p>Use <xref href=\"System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces\" data-throw-if-not-resolved=\"false\"></xref> option if you want to remove duplicate namespace declarations.</p>\n"
  example:
  - 
  syntax:
    content: public void Save(Stream stream, SaveOptions options)
    content.vb: Public Sub Save(stream As Stream, options As SaveOptions)
    parameters:
    - id: stream
      type: System.IO.Stream
      description: "\n<p>The stream to output this <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to.</p>\n"
    - id: options
      type: System.Xml.Linq.SaveOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.SaveOptions\" data-throw-if-not-resolved=\"false\"></xref> object that specifies formatting behavior.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Save(System.IO.TextWriter)
  commentId: M:System.Xml.Linq.XElement.Save(System.IO.TextWriter)
  id: Save(System.IO.TextWriter)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Save(TextWriter)
  fullName: System.Xml.Linq.XElement.Save(System.IO.TextWriter)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Save
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 295
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Serialize this element to a <xref href=\"System.IO.TextWriter\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The serialized XML will be indented. All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented. The behavior of this method is that white space will not be preserved.</p>\n<p>If you want to control white space, use the overload of <see cref=\"Overload:System.Xml.Linq.XElement.Save\"></see> that allows you to specify <xref href=\"System.Xml.Linq.SaveOptions\" data-throw-if-not-resolved=\"false\"></xref> as a parameter. For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n"
  example:
  - "\n<p>The following example creates an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, saves the document to a <xref href=\"System.IO.StringWriter\" data-throw-if-not-resolved=\"false\"></xref>, and then prints the string to the console.</p>\n<pre><code class=\"c#\">XElement root = XElement.Parse(@\"<Root> <Child> Text </Child> </Root>\");\nusing (StringWriter sw = new StringWriter()) {\nroot.Save(sw);\nConsole.WriteLine(sw.ToString());\n}</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root><Child> Text </Child></Root>\nUsing sw = New StringWriter()\nroot.Save(sw)\nConsole.WriteLine(sw.ToString())\nEnd Using</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><?xml version=\"1.0\" encoding=\"utf-16\"?>\n<Root>\n<Child> Text </Child>\n</Root></code></pre>\n"
  syntax:
    content: public void Save(TextWriter textWriter)
    content.vb: Public Sub Save(textWriter As TextWriter)
    parameters:
    - id: textWriter
      type: System.IO.TextWriter
      description: "\n<p>A <xref href=\"System.IO.TextWriter\" data-throw-if-not-resolved=\"false\"></xref> that the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> will be written to.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)
  commentId: M:System.Xml.Linq.XElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)
  id: Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Save(TextWriter, SaveOptions)
  fullName: System.Xml.Linq.XElement.Save(System.IO.TextWriter, System.Xml.Linq.SaveOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Save
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 296
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Serialize this element to a <xref href=\"System.IO.TextWriter\" data-throw-if-not-resolved=\"false\"></xref>, optionally disabling formatting.</p>\n"
  remarks: "\n<p>If you want to save unindented XML, specify the <xref href=\"System.Xml.Linq.SaveOptions.DisableFormatting\" data-throw-if-not-resolved=\"false\"></xref> flag for <em>options</em>. This will cause the writer to write all white space exactly as represented in the XML tree.</p>\n<p>If you want to save indented XML, do not specify the <xref href=\"System.Xml.Linq.SaveOptions.DisableFormatting\" data-throw-if-not-resolved=\"false\"></xref> flag for <em>options</em>. This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented. This is the default behavior, and the behavior of the overloads of the <see cref=\"Overload:System.Xml.Linq.XElement.Save\"></see> methods that do not take <em>options</em> as a parameter.</p>\n<p>For more information, see Preserving White Space while Loading or Parsing XML and Preserving White Space While Serializing.</p>\n"
  example:
  - "\n<p>The following example shows two uses of this method. The first use preserves white space. The second serializes the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> with formatting. Because the document has no white space in it as constructed, preserving white space outputs the XML without any indenting.</p>\n<pre><code class=\"c#\">XElement root = XElement.Parse(@\"<Root> <Child> Text </Child> </Root>\");\n\nusing (StringWriter sw = new StringWriter())\n{\nroot.Save(sw, SaveOptions.DisableFormatting);\nConsole.WriteLine(sw.ToString());\n}\n\nConsole.WriteLine(\"=====\");\n\nusing (StringWriter sw = new StringWriter())\n{\nroot.Save(sw, SaveOptions.None);\nConsole.WriteLine(sw.ToString());\n}</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root><Child> Text </Child></Root>\n\nUsing sw = New StringWriter()\nroot.Save(sw, SaveOptions.DisableFormatting)\nConsole.WriteLine(sw.ToString())\nEnd Using\n\nConsole.WriteLine(\"=====\")\n\nUsing sw = New StringWriter()\nroot.Save(sw, SaveOptions.None)\nConsole.WriteLine(sw.ToString())\nEnd Using</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><?xml version=\"1.0\" encoding=\"utf-16\"?><Root><Child> Text </Child></Root>\n=====\n<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<Root>\n<Child> Text </Child>\n</Root></code></pre>\n"
  syntax:
    content: public void Save(TextWriter textWriter, SaveOptions options)
    content.vb: Public Sub Save(textWriter As TextWriter, options As SaveOptions)
    parameters:
    - id: textWriter
      type: System.IO.TextWriter
      description: "\n<p>The <xref href=\"System.IO.TextWriter\" data-throw-if-not-resolved=\"false\"></xref> to output the XML to.</p>\n"
    - id: options
      type: System.Xml.Linq.SaveOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.SaveOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies formatting behavior.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)
  commentId: M:System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)
  id: Save(System.Xml.XmlWriter)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: Save(XmlWriter)
  fullName: System.Xml.Linq.XElement.Save(System.Xml.XmlWriter)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Save
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 297
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Serialize this element to an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example shows how to save an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<pre><code class=\"c#\">StringBuilder sb = new StringBuilder();\nXmlWriterSettings xws = new XmlWriterSettings();\nxws.OmitXmlDeclaration = true;\nusing (XmlWriter xw = XmlWriter.Create(sb, xws)) {\nXElement root = new XElement(\"Root\",\nnew XElement(\"Child\", \"child content\")\n);\nroot.Save(xw);\n}\nConsole.WriteLine(sb.ToString());</code></pre>\n<pre><code class=\"vb\">Dim sb As StringBuilder = New StringBuilder()\nDim xws As XmlWriterSettings = New XmlWriterSettings()\nxws.OmitXmlDeclaration = True\nUsing xw = XmlWriter.Create(sb, xws)\nDim root As XElement = <Root>\n                       <Child>child content</Child>\n                   </Root>\nroot.Save(xw)\nEnd Using\nConsole.WriteLine(sb.ToString())</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root><Child>child content</Child></Root></code></pre>\n"
  syntax:
    content: public void Save(XmlWriter writer)
    content.vb: Public Sub Save(writer As XmlWriter)
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "\n<p>A <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> that the <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> will be written to.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)
  commentId: M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)
  id: SetAttributeValue(System.Xml.Linq.XName,System.Object)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: SetAttributeValue(XName, Object)
  fullName: System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetAttributeValue
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 298
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Sets the value of an attribute, adds an attribute, or removes an attribute. </p>\n"
  remarks: "\n<p>This method is designed to make it easy to maintain a list of name/value pairs as a set of attributes. When maintaining the list, you need to add pairs, modify pairs, or delete pairs. If you call this method passing a name that does not exist as an attribute, this method creates an attribute for you. If you call this method passing the name of an existing attribute, this method modifies the value of the attribute to the value that you specify. If you pass <strong>null</strong> for <em>value</em>, this method removes the attribute.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>The value is assigned to the attribute with the specified name. If no attribute with the specified name exists, a new attribute is added. If the value is <strong>null</strong>, the attribute with the specified name, if any, is deleted.</p>\n<p>For more information, see Maintaining Name/Value Pairs.</p>\n"
  example:
  - "\n<p>The following example creates an element with an attribute. It then uses this method to replace the content of the attribute.</p>\n<pre><code class=\"c#\">// Create an element with no content.\nXElement root = new XElement(\"Root\");\n\n// Add some name/value pairs.\nroot.SetAttributeValue(\"Att1\", 1);\nroot.SetAttributeValue(\"Att2\", 2);\nroot.SetAttributeValue(\"Att3\", 3);\nConsole.WriteLine(root);\n\n// Modify one of the name/value pairs.\nroot.SetAttributeValue(\"Att2\", 22);\nConsole.WriteLine(root);\n\n// Remove one of the name/value pairs.\nroot.SetAttributeValue(\"Att3\", null);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an element with no content.\nDim root As XElement = <Root/>\n\n' Add some name/value pairs.\nroot.SetAttributeValue(\"Att1\", 1)\nroot.SetAttributeValue(\"Att2\", 2)\nroot.SetAttributeValue(\"Att3\", 3)\nConsole.WriteLine(root)\n\n' Modify one of the name/value pairs.\nroot.SetAttributeValue(\"Att2\", 22)\nConsole.WriteLine(root)\n\n' Remove one of the name/value pairs.\nroot.SetAttributeValue(\"Att3\", Nothing)\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root Att1=\"1\" Att2=\"2\" Att3=\"3\" />\n<Root Att1=\"1\" Att2=\"22\" Att3=\"3\" />\n<Root Att1=\"1\" Att2=\"22\" /></code></pre>\n"
  syntax:
    content: public void SetAttributeValue(XName name, object value)
    content.vb: Public Sub SetAttributeValue(name As XName, value As Object)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the name of the attribute to change.</p>\n"
    - id: value
      type: System.Object
      description: "\n<p>The value to assign to the attribute. The attribute is removed if the value is <strong>null</strong>. Otherwise, the value is converted to its string representation and assigned to the <xref href=\"System.Xml.Linq.XAttribute.Value\" data-throw-if-not-resolved=\"false\"></xref> property of the attribute.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>value</em> is an instance of <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Xml.Linq.XAttribute.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XAttribute.SetValue(System.Object)
  - type: System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
    commentId: M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
  - type: System.Xml.Linq.XElement.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XElement.SetValue(System.Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
  commentId: M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
  id: SetElementValue(System.Xml.Linq.XName,System.Object)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: SetElementValue(XName, Object)
  fullName: System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetElementValue
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 299
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Sets the value of a child element, adds a child element, or removes a child element.</p>\n"
  remarks: "\n<p>This method is designed to make it easy to maintain a list of name/value pairs as a set of children elements. When maintaining the list, you need to add pairs, modify pairs, or delete pairs. If you call this method passing a name that does not exist as a child element, this method creates a child element for you. If you call this method passing the name of an existing child element, this method modifies the value of the child element to the value that you specify. If you pass <strong>null</strong> for <em>value</em>, this method removes the child element.</p>\n<p>This method will raise events.</p>\n<p>The value is assigned to the first child element with the specified name. If no child element with the specified name exists, a new child element is added. If the value is null, the first child element with the specified name, if any, is deleted.</p>\n<p>This method does not add child nodes or attributes to the specified child element. This method throws an exception if any object that derives from <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref> is passed as <em>value</em>.</p>\n<p>For more information, see Maintaining Name/Value Pairs.</p>\n"
  example:
  - "\n<p>The following example creates an element with a child element. It then uses this method to set the value of the child element.</p>\n<pre><code class=\"c#\">// Create an element with no content\nXElement root = new XElement(\"Root\");\n\n// Add some name/value pairs.\nroot.SetElementValue(\"Ele1\", 1);\nroot.SetElementValue(\"Ele2\", 2);\nroot.SetElementValue(\"Ele3\", 3);\nConsole.WriteLine(root);\n\n// Modify one of the name/value pairs.\nroot.SetElementValue(\"Ele2\", 22);\nConsole.WriteLine(root);\n\n// Remove one of the name/value pairs.\nroot.SetElementValue(\"Ele3\", null);\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">' Create an element with no content.\nDim root As XElement = <Root/>\n\n' Add some name/value pairs.\nroot.SetElementValue(\"Ele1\", 1)\nroot.SetElementValue(\"Ele2\", 2)\nroot.SetElementValue(\"Ele3\", 3)\nConsole.WriteLine(root)\n\n' Modify one of the name/value pairs.\nroot.SetElementValue(\"Ele2\", 22)\nConsole.WriteLine(root)\n\n' Remove one of the name/value pairs.\nroot.SetElementValue(\"Ele3\", Nothing)\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root>\n<Ele1>1</Ele1>\n<Ele2>2</Ele2>\n<Ele3>3</Ele3>\n</Root>\n<Root>\n<Ele1>1</Ele1>\n<Ele2>22</Ele2>\n<Ele3>3</Ele3>\n</Root>\n<Root>\n<Ele1>1</Ele1>\n<Ele2>22</Ele2>\n</Root></code></pre>\n"
  syntax:
    content: public void SetElementValue(XName name, object value)
    content.vb: Public Sub SetElementValue(name As XName, value As Object)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>An <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> that contains the name of the child element to change.</p>\n"
    - id: value
      type: System.Object
      description: "\n<p>The value to assign to the child element. The child element is removed if the value is <strong>null</strong>. Otherwise, the value is converted to its string representation and assigned to the <xref href=\"System.Xml.Linq.XElement.Value\" data-throw-if-not-resolved=\"false\"></xref> property of the child element.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>value</em> is an instance of <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Xml.Linq.XAttribute.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XAttribute.SetValue(System.Object)
  - type: System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
    commentId: M:System.Xml.Linq.XElement.SetElementValue(System.Xml.Linq.XName,System.Object)
  - type: System.Xml.Linq.XElement.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XElement.SetValue(System.Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.SetValue(System.Object)
  commentId: M:System.Xml.Linq.XElement.SetValue(System.Object)
  id: SetValue(System.Object)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: SetValue(Object)
  fullName: System.Xml.Linq.XElement.SetValue(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetValue
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 300
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Sets the value of this element.</p>\n"
  remarks: "\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>It is invalid to pass an instance of a class that derives from <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref>, such as <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an element that contains a child element. It then sets the value of the element using this method.</p>\n<pre><code class=\"c#\">XElement root = new XElement(\"Root\",\nnew XElement(\"Child\", \"child content\")\n);\nroot.SetValue(\"new content\");\nConsole.WriteLine(root);</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = _ \n<Root>\n    <Child>child content</Child>\n</Root>\n\nroot.SetValue(\"new content\")\nConsole.WriteLine(root)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>new content</Root></code></pre>\n"
  syntax:
    content: public void SetValue(object value)
    content.vb: Public Sub SetValue(value As Object)
    parameters:
    - id: value
      type: System.Object
      description: "\n<p>The value to assign to this element. The value is converted to its string representation and assigned to the <xref href=\"System.Xml.Linq.XElement.Value\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>value</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>value</em> is an <xref href=\"System.Xml.Linq.XObject\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Xml.Linq.XAttribute.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XAttribute.SetValue(System.Object)
  - type: System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)
    commentId: M:System.Xml.Linq.XElement.SetAttributeValue(System.Xml.Linq.XName,System.Object)
  - type: System.Xml.Linq.XElement.SetValue(System.Object)
    commentId: M:System.Xml.Linq.XElement.SetValue(System.Object)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)
  commentId: M:System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)
  id: WriteTo(System.Xml.XmlWriter)
  parent: System.Xml.Linq.XElement
  langs:
  - csharp
  - vb
  name: WriteTo(XmlWriter)
  fullName: System.Xml.Linq.XElement.WriteTo(System.Xml.XmlWriter)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteTo
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 304
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Write this element to an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example shows how to write an <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> to an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref>. Note that the example did not write an XML declaration.</p>\n<pre><code class=\"c#\">StringBuilder sb = new StringBuilder();\nXmlWriterSettings xws = new XmlWriterSettings();\nxws.OmitXmlDeclaration = true;\nxws.Indent = true;\n\nusing (XmlWriter xw = XmlWriter.Create(sb, xws)) {\nxw.WriteStartElement(\"Root\");\n\nXElement child1 = new XElement(\"Child\",\nnew XElement(\"GrandChild\", \"some content\")\n);\nchild1.WriteTo(xw);\n\nXElement child2 = new XElement(\"AnotherChild\",\nnew XElement(\"GrandChild\", \"different content\")\n);\nchild2.WriteTo(xw);\n\nxw.WriteEndElement();\n}\n\nConsole.WriteLine(sb.ToString());</code></pre>\n<pre><code class=\"vb\">Dim sb As StringBuilder = New StringBuilder()\nDim xws As XmlWriterSettings = New XmlWriterSettings()\nxws.OmitXmlDeclaration = True\nxws.Indent = True\n\nUsing xw = XmlWriter.Create(sb, xws)\nxw.WriteStartElement(\"Root\")\nDim child1 As XElement = _\n<Child>\n    <GrandChild>some content</GrandChild>\n</Child>\nchild1.WriteTo(xw)\nDim child2 As XElement = _ \n<AnotherChild>\n    <GrandChild>different content</GrandChild>\n</AnotherChild>\nchild2.WriteTo(xw)\nxw.WriteEndElement()\nEnd Using\n\nConsole.WriteLine(sb.ToString())</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child>\n<GrandChild>some content</GrandChild>\n</Child>\n<AnotherChild>\n<GrandChild>different content</GrandChild>\n</AnotherChild>\n</Root></code></pre>\n"
  syntax:
    content: public override void WriteTo(XmlWriter writer)
    content.vb: Public Overrides Sub WriteTo(writer As XmlWriter)
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "\n<p>An <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> into which this method will write.</p>\n"
  overridden: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
references:
- uid: System.Xml.Linq
  isExternal: false
  name: System.Xml.Linq
  fullName: System.Xml.Linq
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Xml.Linq.XObject
  parent: System.Xml.Linq
  isExternal: false
  name: XObject
  fullName: System.Xml.Linq.XObject
- uid: System.Xml.Linq.XNode
  parent: System.Xml.Linq
  isExternal: false
  name: XNode
  fullName: System.Xml.Linq.XNode
- uid: System.Xml.Linq.XContainer
  parent: System.Xml.Linq
  isExternal: false
  name: XContainer
  fullName: System.Xml.Linq.XContainer
- uid: System.Xml.Serialization.IXmlSerializable
  isExternal: false
  name: IXmlSerializable
  fullName: System.Xml.Serialization.IXmlSerializable
- uid: System.Xml.Linq.XContainer.FirstNode
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: FirstNode
  fullName: System.Xml.Linq.XContainer.FirstNode
- uid: System.Xml.Linq.XContainer.LastNode
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: LastNode
  fullName: System.Xml.Linq.XContainer.LastNode
- uid: System.Xml.Linq.XContainer.Add(System.Object)
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: Add(Object)
  fullName: System.Xml.Linq.XContainer.Add(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Add(System.Object)
    name: Add
    fullName: System.Xml.Linq.XContainer.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Add(System.Object)
    name: Add
    fullName: System.Xml.Linq.XContainer.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Add(System.Object[])
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: Add(Object[])
  fullName: System.Xml.Linq.XContainer.Add(System.Object[])
  fullname.vb: System.Xml.Linq.XContainer.Add(System.Object())
  name.vb: Add(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Add(System.Object[])
    name: Add
    fullName: System.Xml.Linq.XContainer.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Add(System.Object[])
    name: Add
    fullName: System.Xml.Linq.XContainer.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.AddFirst(System.Object)
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: AddFirst(Object)
  fullName: System.Xml.Linq.XContainer.AddFirst(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.AddFirst(System.Object)
    name: AddFirst
    fullName: System.Xml.Linq.XContainer.AddFirst
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.AddFirst(System.Object)
    name: AddFirst
    fullName: System.Xml.Linq.XContainer.AddFirst
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.AddFirst(System.Object[])
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: AddFirst(Object[])
  fullName: System.Xml.Linq.XContainer.AddFirst(System.Object[])
  fullname.vb: System.Xml.Linq.XContainer.AddFirst(System.Object())
  name.vb: AddFirst(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.AddFirst(System.Object[])
    name: AddFirst
    fullName: System.Xml.Linq.XContainer.AddFirst
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.AddFirst(System.Object[])
    name: AddFirst
    fullName: System.Xml.Linq.XContainer.AddFirst
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.CreateWriter
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: CreateWriter()
  fullName: System.Xml.Linq.XContainer.CreateWriter()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.CreateWriter
    name: CreateWriter
    fullName: System.Xml.Linq.XContainer.CreateWriter
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.CreateWriter
    name: CreateWriter
    fullName: System.Xml.Linq.XContainer.CreateWriter
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.DescendantNodes
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: DescendantNodes()
  fullName: System.Xml.Linq.XContainer.DescendantNodes()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.DescendantNodes
    name: DescendantNodes
    fullName: System.Xml.Linq.XContainer.DescendantNodes
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.DescendantNodes
    name: DescendantNodes
    fullName: System.Xml.Linq.XContainer.DescendantNodes
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Descendants
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Descendants()
  fullName: System.Xml.Linq.XContainer.Descendants()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Descendants
    name: Descendants
    fullName: System.Xml.Linq.XContainer.Descendants
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Descendants
    name: Descendants
    fullName: System.Xml.Linq.XContainer.Descendants
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Descendants(XName)
  fullName: System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)
    name: Descendants
    fullName: System.Xml.Linq.XContainer.Descendants
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)
    name: Descendants
    fullName: System.Xml.Linq.XContainer.Descendants
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Element(XName)
  fullName: System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)
    name: Element
    fullName: System.Xml.Linq.XContainer.Element
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)
    name: Element
    fullName: System.Xml.Linq.XContainer.Element
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Elements
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Elements()
  fullName: System.Xml.Linq.XContainer.Elements()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Elements
    name: Elements
    fullName: System.Xml.Linq.XContainer.Elements
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Elements
    name: Elements
    fullName: System.Xml.Linq.XContainer.Elements
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Elements(XName)
  fullName: System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)
    name: Elements
    fullName: System.Xml.Linq.XContainer.Elements
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)
    name: Elements
    fullName: System.Xml.Linq.XContainer.Elements
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.Nodes
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: Nodes()
  fullName: System.Xml.Linq.XContainer.Nodes()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.Nodes
    name: Nodes
    fullName: System.Xml.Linq.XContainer.Nodes
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.Nodes
    name: Nodes
    fullName: System.Xml.Linq.XContainer.Nodes
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.RemoveNodes
  parent: System.Xml.Linq.XContainer
  isExternal: false
  name: RemoveNodes()
  fullName: System.Xml.Linq.XContainer.RemoveNodes()
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.RemoveNodes
    name: RemoveNodes
    fullName: System.Xml.Linq.XContainer.RemoveNodes
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.RemoveNodes
    name: RemoveNodes
    fullName: System.Xml.Linq.XContainer.RemoveNodes
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object)
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: ReplaceNodes(Object)
  fullName: System.Xml.Linq.XContainer.ReplaceNodes(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object)
    name: ReplaceNodes
    fullName: System.Xml.Linq.XContainer.ReplaceNodes
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object)
    name: ReplaceNodes
    fullName: System.Xml.Linq.XContainer.ReplaceNodes
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])
  parent: System.Xml.Linq.XContainer
  isExternal: true
  name: ReplaceNodes(Object[])
  fullName: System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])
  fullname.vb: System.Xml.Linq.XContainer.ReplaceNodes(System.Object())
  name.vb: ReplaceNodes(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])
    name: ReplaceNodes
    fullName: System.Xml.Linq.XContainer.ReplaceNodes
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])
    name: ReplaceNodes
    fullName: System.Xml.Linq.XContainer.ReplaceNodes
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.DocumentOrderComparer
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: DocumentOrderComparer
  fullName: System.Xml.Linq.XNode.DocumentOrderComparer
- uid: System.Xml.Linq.XNode.EqualityComparer
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: EqualityComparer
  fullName: System.Xml.Linq.XNode.EqualityComparer
- uid: System.Xml.Linq.XNode.NextNode
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: NextNode
  fullName: System.Xml.Linq.XNode.NextNode
- uid: System.Xml.Linq.XNode.PreviousNode
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: PreviousNode
  fullName: System.Xml.Linq.XNode.PreviousNode
- uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: AddAfterSelf(Object)
  fullName: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
    name: AddAfterSelf
    fullName: System.Xml.Linq.XNode.AddAfterSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
    name: AddAfterSelf
    fullName: System.Xml.Linq.XNode.AddAfterSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: AddAfterSelf(Object[])
  fullName: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  fullname.vb: System.Xml.Linq.XNode.AddAfterSelf(System.Object())
  name.vb: AddAfterSelf(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
    name: AddAfterSelf
    fullName: System.Xml.Linq.XNode.AddAfterSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
    name: AddAfterSelf
    fullName: System.Xml.Linq.XNode.AddAfterSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: AddBeforeSelf(Object)
  fullName: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
    name: AddBeforeSelf
    fullName: System.Xml.Linq.XNode.AddBeforeSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
    name: AddBeforeSelf
    fullName: System.Xml.Linq.XNode.AddBeforeSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: AddBeforeSelf(Object[])
  fullName: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  fullname.vb: System.Xml.Linq.XNode.AddBeforeSelf(System.Object())
  name.vb: AddBeforeSelf(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
    name: AddBeforeSelf
    fullName: System.Xml.Linq.XNode.AddBeforeSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
    name: AddBeforeSelf
    fullName: System.Xml.Linq.XNode.AddBeforeSelf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.Ancestors
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: Ancestors()
  fullName: System.Xml.Linq.XNode.Ancestors()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.Ancestors
    name: Ancestors
    fullName: System.Xml.Linq.XNode.Ancestors
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.Ancestors
    name: Ancestors
    fullName: System.Xml.Linq.XNode.Ancestors
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: Ancestors(XName)
  fullName: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
    name: Ancestors
    fullName: System.Xml.Linq.XNode.Ancestors
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
    name: Ancestors
    fullName: System.Xml.Linq.XNode.Ancestors
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: CompareDocumentOrder(XNode, XNode)
  fullName: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode, System.Xml.Linq.XNode)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
    name: CompareDocumentOrder
    fullName: System.Xml.Linq.XNode.CompareDocumentOrder
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: ', '
    fullName: ', '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
    name: CompareDocumentOrder
    fullName: System.Xml.Linq.XNode.CompareDocumentOrder
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: ', '
    fullName: ', '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.CreateReader
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: CreateReader()
  fullName: System.Xml.Linq.XNode.CreateReader()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.CreateReader
    name: CreateReader
    fullName: System.Xml.Linq.XNode.CreateReader
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.CreateReader
    name: CreateReader
    fullName: System.Xml.Linq.XNode.CreateReader
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: CreateReader(ReaderOptions)
  fullName: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
    name: CreateReader
    fullName: System.Xml.Linq.XNode.CreateReader
  - name: (
    fullName: (
  - uid: System.Xml.Linq.ReaderOptions
    name: ReaderOptions
    fullName: System.Xml.Linq.ReaderOptions
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
    name: CreateReader
    fullName: System.Xml.Linq.XNode.CreateReader
  - name: (
    fullName: (
  - uid: System.Xml.Linq.ReaderOptions
    name: ReaderOptions
    fullName: System.Xml.Linq.ReaderOptions
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: DeepEquals(XNode, XNode)
  fullName: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode, System.Xml.Linq.XNode)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
    name: DeepEquals
    fullName: System.Xml.Linq.XNode.DeepEquals
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: ', '
    fullName: ', '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
    name: DeepEquals
    fullName: System.Xml.Linq.XNode.DeepEquals
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: ', '
    fullName: ', '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ElementsAfterSelf
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ElementsAfterSelf()
  fullName: System.Xml.Linq.XNode.ElementsAfterSelf()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ElementsAfterSelf
    name: ElementsAfterSelf
    fullName: System.Xml.Linq.XNode.ElementsAfterSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ElementsAfterSelf
    name: ElementsAfterSelf
    fullName: System.Xml.Linq.XNode.ElementsAfterSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ElementsAfterSelf(XName)
  fullName: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
    name: ElementsAfterSelf
    fullName: System.Xml.Linq.XNode.ElementsAfterSelf
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
    name: ElementsAfterSelf
    fullName: System.Xml.Linq.XNode.ElementsAfterSelf
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ElementsBeforeSelf
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ElementsBeforeSelf()
  fullName: System.Xml.Linq.XNode.ElementsBeforeSelf()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ElementsBeforeSelf
    name: ElementsBeforeSelf
    fullName: System.Xml.Linq.XNode.ElementsBeforeSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ElementsBeforeSelf
    name: ElementsBeforeSelf
    fullName: System.Xml.Linq.XNode.ElementsBeforeSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ElementsBeforeSelf(XName)
  fullName: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
    name: ElementsBeforeSelf
    fullName: System.Xml.Linq.XNode.ElementsBeforeSelf
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
    name: ElementsBeforeSelf
    fullName: System.Xml.Linq.XNode.ElementsBeforeSelf
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XName
    name: XName
    fullName: System.Xml.Linq.XName
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: IsAfter(XNode)
  fullName: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
    name: IsAfter
    fullName: System.Xml.Linq.XNode.IsAfter
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
    name: IsAfter
    fullName: System.Xml.Linq.XNode.IsAfter
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: IsBefore(XNode)
  fullName: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
    name: IsBefore
    fullName: System.Xml.Linq.XNode.IsBefore
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
    name: IsBefore
    fullName: System.Xml.Linq.XNode.IsBefore
  - name: (
    fullName: (
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.NodesAfterSelf
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: NodesAfterSelf()
  fullName: System.Xml.Linq.XNode.NodesAfterSelf()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.NodesAfterSelf
    name: NodesAfterSelf
    fullName: System.Xml.Linq.XNode.NodesAfterSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.NodesAfterSelf
    name: NodesAfterSelf
    fullName: System.Xml.Linq.XNode.NodesAfterSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.NodesBeforeSelf
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: NodesBeforeSelf()
  fullName: System.Xml.Linq.XNode.NodesBeforeSelf()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.NodesBeforeSelf
    name: NodesBeforeSelf
    fullName: System.Xml.Linq.XNode.NodesBeforeSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.NodesBeforeSelf
    name: NodesBeforeSelf
    fullName: System.Xml.Linq.XNode.NodesBeforeSelf
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: ReadFrom(XmlReader)
  fullName: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
    name: ReadFrom
    fullName: System.Xml.Linq.XNode.ReadFrom
  - name: (
    fullName: (
  - uid: System.Xml.XmlReader
    name: XmlReader
    fullName: System.Xml.XmlReader
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
    name: ReadFrom
    fullName: System.Xml.Linq.XNode.ReadFrom
  - name: (
    fullName: (
  - uid: System.Xml.XmlReader
    name: XmlReader
    fullName: System.Xml.XmlReader
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.Remove
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: Remove()
  fullName: System.Xml.Linq.XNode.Remove()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.Remove
    name: Remove
    fullName: System.Xml.Linq.XNode.Remove
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.Remove
    name: Remove
    fullName: System.Xml.Linq.XNode.Remove
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ReplaceWith(System.Object)
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: ReplaceWith(Object)
  fullName: System.Xml.Linq.XNode.ReplaceWith(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ReplaceWith(System.Object)
    name: ReplaceWith
    fullName: System.Xml.Linq.XNode.ReplaceWith
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ReplaceWith(System.Object)
    name: ReplaceWith
    fullName: System.Xml.Linq.XNode.ReplaceWith
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: ReplaceWith(Object[])
  fullName: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  fullname.vb: System.Xml.Linq.XNode.ReplaceWith(System.Object())
  name.vb: ReplaceWith(Object())
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
    name: ReplaceWith
    fullName: System.Xml.Linq.XNode.ReplaceWith
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
    name: ReplaceWith
    fullName: System.Xml.Linq.XNode.ReplaceWith
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ToString
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ToString()
  fullName: System.Xml.Linq.XNode.ToString()
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ToString
    name: ToString
    fullName: System.Xml.Linq.XNode.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ToString
    name: ToString
    fullName: System.Xml.Linq.XNode.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  parent: System.Xml.Linq.XNode
  isExternal: false
  name: ToString(SaveOptions)
  fullName: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
    name: ToString
    fullName: System.Xml.Linq.XNode.ToString
  - name: (
    fullName: (
  - uid: System.Xml.Linq.SaveOptions
    name: SaveOptions
    fullName: System.Xml.Linq.SaveOptions
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
    name: ToString
    fullName: System.Xml.Linq.XNode.ToString
  - name: (
    fullName: (
  - uid: System.Xml.Linq.SaveOptions
    name: SaveOptions
    fullName: System.Xml.Linq.SaveOptions
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.BaseUri
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: BaseUri
  fullName: System.Xml.Linq.XObject.BaseUri
- uid: System.Xml.Linq.XObject.Document
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Document
  fullName: System.Xml.Linq.XObject.Document
- uid: System.Xml.Linq.XObject.Parent
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Parent
  fullName: System.Xml.Linq.XObject.Parent
- uid: System.Xml.Linq.XObject.Changed
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Changed
  fullName: System.Xml.Linq.XObject.Changed
- uid: System.Xml.Linq.XObject.Changing
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Changing
  fullName: System.Xml.Linq.XObject.Changing
- uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: AddAnnotation(Object)
  fullName: System.Xml.Linq.XObject.AddAnnotation(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
    name: AddAnnotation
    fullName: System.Xml.Linq.XObject.AddAnnotation
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
    name: AddAnnotation
    fullName: System.Xml.Linq.XObject.AddAnnotation
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotation(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: Annotation(Type)
  fullName: System.Xml.Linq.XObject.Annotation(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotation(System.Type)
    name: Annotation
    fullName: System.Xml.Linq.XObject.Annotation
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotation(System.Type)
    name: Annotation
    fullName: System.Xml.Linq.XObject.Annotation
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotation``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Annotation<T>()
  fullName: System.Xml.Linq.XObject.Annotation<T>()
  fullname.vb: System.Xml.Linq.XObject.Annotation(Of T)()
  name.vb: Annotation(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotation``1
    name: Annotation<T>
    fullName: System.Xml.Linq.XObject.Annotation<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotation``1
    name: Annotation(Of T)
    fullName: System.Xml.Linq.XObject.Annotation(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotations(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: Annotations(Type)
  fullName: System.Xml.Linq.XObject.Annotations(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotations(System.Type)
    name: Annotations
    fullName: System.Xml.Linq.XObject.Annotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotations(System.Type)
    name: Annotations
    fullName: System.Xml.Linq.XObject.Annotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotations``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Annotations<T>()
  fullName: System.Xml.Linq.XObject.Annotations<T>()
  fullname.vb: System.Xml.Linq.XObject.Annotations(Of T)()
  name.vb: Annotations(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotations``1
    name: Annotations<T>
    fullName: System.Xml.Linq.XObject.Annotations<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotations``1
    name: Annotations(Of T)
    fullName: System.Xml.Linq.XObject.Annotations(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: RemoveAnnotations(Type)
  fullName: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
    name: RemoveAnnotations
    fullName: System.Xml.Linq.XObject.RemoveAnnotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
    name: RemoveAnnotations
    fullName: System.Xml.Linq.XObject.RemoveAnnotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.RemoveAnnotations``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: RemoveAnnotations<T>()
  fullName: System.Xml.Linq.XObject.RemoveAnnotations<T>()
  fullname.vb: System.Xml.Linq.XObject.RemoveAnnotations(Of T)()
  name.vb: RemoveAnnotations(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations``1
    name: RemoveAnnotations<T>
    fullName: System.Xml.Linq.XObject.RemoveAnnotations<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations``1
    name: RemoveAnnotations(Of T)
    fullName: System.Xml.Linq.XObject.RemoveAnnotations(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Xml.Linq.XElement
  parent: System.Xml.Linq
  isExternal: false
  name: XElement
  fullName: System.Xml.Linq.XElement
- uid: System.Xml.Linq.XName
  parent: System.Xml.Linq
  isExternal: false
  name: XName
  fullName: System.Xml.Linq.XName
- uid: System.Object[]
  isExternal: true
  name: Object[]
  fullName: System.Object[]
  fullname.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Xml.Linq.XStreamingElement
  parent: System.Xml.Linq
  isExternal: false
  name: XStreamingElement
  fullName: System.Xml.Linq.XStreamingElement
- uid: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<XElement>
  fullName: System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Xml.Linq.XElement)
  name.vb: IEnumerable(Of XElement)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Xml.Linq.XElement
    name: XElement
    fullName: System.Xml.Linq.XElement
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Xml.Linq.XElement
    name: XElement
    fullName: System.Xml.Linq.XElement
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Xml.Linq.XAttribute
  parent: System.Xml.Linq
  isExternal: false
  name: XAttribute
  fullName: System.Xml.Linq.XAttribute
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Xml.Linq.XObject.NodeType
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: NodeType
  fullName: System.Xml.Linq.XObject.NodeType
- uid: System.Xml.XmlNodeType
  parent: System.Xml
  isExternal: false
  name: XmlNodeType
  fullName: System.Xml.XmlNodeType
- uid: System.Xml
  isExternal: false
  name: System.Xml
  fullName: System.Xml
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Collections.Generic.IEnumerable{System.Xml.Linq.XAttribute}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<XAttribute>
  fullName: System.Collections.Generic.IEnumerable<System.Xml.Linq.XAttribute>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Xml.Linq.XAttribute)
  name.vb: IEnumerable(Of XAttribute)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Xml.Linq.XAttribute
    name: XAttribute
    fullName: System.Xml.Linq.XAttribute
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Xml.Linq.XAttribute
    name: XAttribute
    fullName: System.Xml.Linq.XAttribute
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Xml.Linq.XNode}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<XNode>
  fullName: System.Collections.Generic.IEnumerable<System.Xml.Linq.XNode>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Xml.Linq.XNode)
  name.vb: IEnumerable(Of XNode)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.Xml.Linq.XNamespace
  parent: System.Xml.Linq
  isExternal: false
  name: XNamespace
  fullName: System.Xml.Linq.XNamespace
- uid: System.IO.Stream
  parent: System.IO
  isExternal: false
  name: Stream
  fullName: System.IO.Stream
- uid: System.IO
  isExternal: false
  name: System.IO
  fullName: System.IO
- uid: System.Xml.Linq.LoadOptions
  parent: System.Xml.Linq
  isExternal: false
  name: LoadOptions
  fullName: System.Xml.Linq.LoadOptions
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: false
  name: TextReader
  fullName: System.IO.TextReader
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: false
  name: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.DateTime
  parent: System
  isExternal: false
  name: DateTime
  fullName: System.DateTime
- uid: System.DateTimeOffset
  parent: System
  isExternal: false
  name: DateTimeOffset
  fullName: System.DateTimeOffset
- uid: System.Decimal
  parent: System
  isExternal: false
  name: Decimal
  fullName: System.Decimal
- uid: System.Double
  parent: System
  isExternal: false
  name: Double
  fullName: System.Double
- uid: System.Guid
  parent: System
  isExternal: false
  name: Guid
  fullName: System.Guid
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Nullable{System.Boolean}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Boolean>
  fullName: System.Nullable<System.Boolean>
  fullname.vb: System.Nullable(Of System.Boolean)
  name.vb: Nullable(Of Boolean)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable`1
  parent: System
  isExternal: false
  name: Nullable<T>
  fullName: System.Nullable<T>
  fullname.vb: System.Nullable(Of T)
  name.vb: Nullable(Of T)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Nullable{System.DateTime}
  parent: System
  definition: System.Nullable`1
  name: Nullable<DateTime>
  fullName: System.Nullable<System.DateTime>
  fullname.vb: System.Nullable(Of System.DateTime)
  name.vb: Nullable(Of DateTime)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.DateTime
    name: DateTime
    fullName: System.DateTime
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.DateTime
    name: DateTime
    fullName: System.DateTime
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.DateTimeOffset}
  parent: System
  definition: System.Nullable`1
  name: Nullable<DateTimeOffset>
  fullName: System.Nullable<System.DateTimeOffset>
  fullname.vb: System.Nullable(Of System.DateTimeOffset)
  name.vb: Nullable(Of DateTimeOffset)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.DateTimeOffset
    name: DateTimeOffset
    fullName: System.DateTimeOffset
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.DateTimeOffset
    name: DateTimeOffset
    fullName: System.DateTimeOffset
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Decimal}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Decimal>
  fullName: System.Nullable<System.Decimal>
  fullname.vb: System.Nullable(Of System.Decimal)
  name.vb: Nullable(Of Decimal)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Decimal
    name: Decimal
    fullName: System.Decimal
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Decimal
    name: Decimal
    fullName: System.Decimal
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Double}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Double>
  fullName: System.Nullable<System.Double>
  fullname.vb: System.Nullable(Of System.Double)
  name.vb: Nullable(Of Double)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Double
    name: Double
    fullName: System.Double
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Double
    name: Double
    fullName: System.Double
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Guid}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Guid>
  fullName: System.Nullable<System.Guid>
  fullname.vb: System.Nullable(Of System.Guid)
  name.vb: Nullable(Of Guid)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Guid
    name: Guid
    fullName: System.Guid
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Guid
    name: Guid
    fullName: System.Guid
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Int32}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Int32>
  fullName: System.Nullable<System.Int32>
  fullname.vb: System.Nullable(Of System.Int32)
  name.vb: Nullable(Of Int32)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Int64}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Int64>
  fullName: System.Nullable<System.Int64>
  fullname.vb: System.Nullable(Of System.Int64)
  name.vb: Nullable(Of Int64)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Int64
    name: Int64
    fullName: System.Int64
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Int64
    name: Int64
    fullName: System.Int64
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.Single}
  parent: System
  definition: System.Nullable`1
  name: Nullable<Single>
  fullName: System.Nullable<System.Single>
  fullname.vb: System.Nullable(Of System.Single)
  name.vb: Nullable(Of Single)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Single
    name: Single
    fullName: System.Single
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Single
    name: Single
    fullName: System.Single
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.TimeSpan}
  parent: System
  definition: System.Nullable`1
  name: Nullable<TimeSpan>
  fullName: System.Nullable<System.TimeSpan>
  fullname.vb: System.Nullable(Of System.TimeSpan)
  name.vb: Nullable(Of TimeSpan)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.TimeSpan
    name: TimeSpan
    fullName: System.TimeSpan
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.TimeSpan
    name: TimeSpan
    fullName: System.TimeSpan
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.UInt32}
  parent: System
  definition: System.Nullable`1
  name: Nullable<UInt32>
  fullName: System.Nullable<System.UInt32>
  fullname.vb: System.Nullable(Of System.UInt32)
  name.vb: Nullable(Of UInt32)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.UInt32
    name: UInt32
    fullName: System.UInt32
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.UInt32
    name: UInt32
    fullName: System.UInt32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Nullable{System.UInt64}
  parent: System
  definition: System.Nullable`1
  name: Nullable<UInt64>
  fullName: System.Nullable<System.UInt64>
  fullname.vb: System.Nullable(Of System.UInt64)
  name.vb: Nullable(Of UInt64)
  spec.csharp:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.UInt64
    name: UInt64
    fullName: System.UInt64
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Nullable`1
    name: Nullable
    fullName: System.Nullable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.UInt64
    name: UInt64
    fullName: System.UInt64
    isExternal: true
  - name: )
    fullName: )
- uid: System.Single
  parent: System
  isExternal: false
  name: Single
  fullName: System.Single
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
- uid: System.UInt32
  parent: System
  isExternal: false
  name: UInt32
  fullName: System.UInt32
- uid: System.UInt64
  parent: System
  isExternal: false
  name: UInt64
  fullName: System.UInt64
- uid: System.Xml.Linq.SaveOptions
  parent: System.Xml.Linq
  isExternal: false
  name: SaveOptions
  fullName: System.Xml.Linq.SaveOptions
- uid: System.IO.TextWriter
  parent: System.IO
  isExternal: false
  name: TextWriter
  fullName: System.IO.TextWriter
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: false
  name: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  parent: System.Xml.Linq.XNode
  isExternal: true
  name: WriteTo(XmlWriter)
  fullName: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  spec.csharp:
  - uid: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
    name: WriteTo
    fullName: System.Xml.Linq.XNode.WriteTo
  - name: (
    fullName: (
  - uid: System.Xml.XmlWriter
    name: XmlWriter
    fullName: System.Xml.XmlWriter
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
    name: WriteTo
    fullName: System.Xml.Linq.XNode.WriteTo
  - name: (
    fullName: (
  - uid: System.Xml.XmlWriter
    name: XmlWriter
    fullName: System.Xml.XmlWriter
    isExternal: true
  - name: )
    fullName: )
- uid: System.FormatException
  parent: System
  isExternal: false
  name: FormatException
  fullName: System.FormatException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
