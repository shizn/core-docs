items:
- uid: System.Object
  commentId: T:System.Object
  id: Object
  parent: System
  children:
  - System.Object.#ctor
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.Finalize
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  langs:
  - csharp
  - vb
  name: Object
  fullName: System.Object
  type: Class
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Object
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1308
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes. This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p>Languages typically do not require a class to declare inheritance from <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> because the inheritance is implicit.</p>\n<p>Because all classes in the .NET Framework are derived from <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, every method defined in the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> class is available in all objects in the system. Derived classes can and do override some of these methods, including: </p>\n<ul><li>\n<p>\n<xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> - Supports comparisons between objects.</p>\n</li><li>\n<p>\n<xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> - Performs cleanup operations before an object is automatically reclaimed.</p>\n</li><li>\n<p>\n<xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> - Generates a number corresponding to the value of the object to support the use of a hash table.</p>\n</li><li>\n<p>\n<xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> - Manufactures a human-readable text string that describes an instance of the class.</p>\n</li></ul>\n"
  example:
  - <p>The following example defines a Point type derived from the <xref href="System.Object" data-throw-if-not-resolved="false"></xref> class and overrides many of the virtual methods of the <xref href="System.Object" data-throw-if-not-resolved="false"></xref> class. In addition, the example shows how to call many of the static and instance methods of the <xref href="System.Object" data-throw-if-not-resolved="false"></xref> class.</p>ObjectX#1
  syntax:
    content: public class Object
    content.vb: Public Class Object
  inheritance: []
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Object.#ctor
  commentId: M:System.Object.#ctor
  id: '#ctor'
  parent: System.Object
  langs:
  - csharp
  - vb
  name: Object()
  fullName: System.Object.Object()
  type: Constructor
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1310
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: public Object()
    content.vb: Public Sub New
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Object.Equals(System.Object)
  commentId: M:System.Object.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Object
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Equals
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1311
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified object is equal to the current object.</p>\n"
  remarks: "\n<p> The type of comparison between the current instance and the <em>obj</em> parameter depends on whether the current instance is a reference type or a value type. </p>\n<ul><li>\n<p>If the current instance is a reference type, the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method tests for reference equality, and a call to the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method is equivalent to a call to the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. Reference equality means that the object variables that are compared refer to the same object. The following example illustrates the result of such a comparison. It defines a <code>Person</code> class, which is a reference type, and calls the <code>Person</code> class constructor to instantiate two new <code>Person</code> objects, <code>person1a</code> and <code>person2</code>, which have the same value. It also assigns <code>person1a</code> to another object variable, <code>person1b</code>. As the output from the example shows, <code>person1a</code> and <code>person1b</code> are equal because they reference the same object. However, <code>person1a</code> and <code>person2</code> are not equal, although they have the same value.</p>System.Object.Equals#2</li><li>\n<p>If the current instance is a value type, the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method tests for value equality. Value equality means the following:</p>\n<ul><li>\n<p>The two objects are of the same type. As the following example shows, a <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> object that has a value of 12 does not equal an <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> object that has a value of 12, because the two objects have different run-time types.</p>System.Object.Equals#3</li><li>\n<p>The values of the public and private fields of the two objects are equal. The following example tests for value equality. It defines a <code>Person</code> structure, which is a value type, and calls the <code>Person</code> class constructor to instantiate two new <code>Person</code> objects, <code>person1</code> and <code>person2</code>, which have the same value. As the output from the example shows, although the two object variables refer to different objects, <code>person1</code> and <code>person2</code> are equal because they have the same value for the private <code>personName</code> field.</p>System.Object.Equals#4</li></ul>\n</li></ul>\n<p>Because the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> class is the base class for all types in the .NET Framework, the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method provides the default equality comparison for all other types. However, types often override the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to implement value equality. For more information, see the Notes for Callers and Notes for Inheritors sections. </p>\n"
  example:
  - <p>The following example shows a <code>Point</code> class that overrides the <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> method to provide value equality, and a <code>Point3D</code> class that is derived from <code>Point</code>. Because <code>Point</code> overrides <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> to test for value equality, the <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> method is not called. However, <code>Point3D.Equals</code> calls <code>Point.Equals</code> because <code>Point</code> implements <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> in a manner that provides value equality.</p>ECMA-System.Object.Equals2#1<p>The <code>Point.Equals</code> method checks to make sure that the <em>obj</em> argument is not null and that it references an instance of the same type as this object. If either check fails, the method returns <strong>false</strong>.</p><p>The <code>Point.Equals</code> method calls the <xref href="System.Object.GetType" data-throw-if-not-resolved="false"></xref> method to determine whether the run-time types of the two objects are identical. If the method used a check of the form <code>obj is Point</code> in C# or <code>TryCast(obj, Point)</code> in Visual Basic, the check would return <strong>true</strong> in cases where <em>obj</em> is an instance of a derived class of <code>Point</code>, even though <em>obj</em> and the current instance are not of the same run-time type. Having verified that both objects are of the same type, the method casts <em>obj</em> to type <code>Point</code> and returns the result of comparing the instance fields of the two objects.</p><p>In <code>Point3D.Equals</code>, the inherited <code>Point.Equals</code>  method, which overrides <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref>, is invoked before anything else is done. Because <code>Point3D</code> is a sealed class (<strong>NotInheritable</strong> in Visual Basic), a check in the form <code>obj is Point</code> in C# or <code>TryCast(obj, Point)</code> in Visual Basic is adequate to ensure that <em>obj</em> is a <code>Point3D</code> object. If it is a <code>Point3D</code> object, it is cast to a <code>Point</code> object and passed to the base class implementation of <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref>. Only when the inherited <code>Point.Equals</code> method returns <strong>true</strong> does the method compare the <code>z</code> instance fields introduced in the derived class. </p>
  - <p>The following example defines a <code>Rectangle</code> class that internally implements a rectangle as two <code>Point</code> objects. The <code>Rectangle</code> class also overrides <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> to provide for value equality.</p>ECMA-System.Object.Equals3#1
  - <p>Some languages such as C# and Visual Basic support operator overloading. When a type overloads the equality operator, it must also override the <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> method to provide the same functionality. This is typically accomplished by writing the <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> method in terms of the overloaded equality operator, as in the following example.</p>ECMA-System.Object.Equals4#1<p>Because <code>Complex</code> is a value type, it cannot be derived from.  Therefore, the override to <xref href="System.Object.Equals(System.Object)" data-throw-if-not-resolved="false"></xref> method need not call <xref href="System.Object.GetType" data-throw-if-not-resolved="false"></xref> to determine the precise run-time type of each object, but can instead use the <strong>is</strong> operator in C# or the <strong>TypeOf</strong> operator in Visual Basic to check the type of the <em>obj</em> parameter.</p>
  syntax:
    content: public virtual bool Equals(object obj)
    content.vb: Public Overridable Function Equals(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object to compare with the current object. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the specified object  is equal to the current object; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Object.ReferenceEquals(System.Object,System.Object)
    commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  - type: System.Object.GetHashCode
    commentId: M:System.Object.GetHashCode
  - type: System.ValueType
    commentId: T:System.ValueType
  - type: System.IComparable
    commentId: T:System.IComparable
  - type: System.Collections.ArrayList
    commentId: T:System.Collections.ArrayList
  - type: System.Collections.Hashtable
    commentId: T:System.Collections.Hashtable
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Object.Equals(System.Object,System.Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
  id: Equals(System.Object,System.Object)
  parent: System.Object
  langs:
  - csharp
  - vb
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Equals
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1312
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified object instances are considered equal.</p>\n"
  remarks: "\n<p>The static <xref href=\"System.Object.Equals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method indicates whether two objects, <em>objA</em> and <em> objB</em>, are equal. It also enables you to test objects whose value is null for equality. It compares <em>objA</em> and<em> objB</em> for equality as follows:</p>\n<ul><li>\n<p>It determines whether the two objects represent the same object reference. If they do, the method returns <strong>true</strong>. This test is equivalent to calling the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. In addition, if both <em>objA</em> and <em>objB</em>are null, the method returns <strong>true</strong>.</p>\n</li><li>\n<p>It determines whether either <em>objA</em> or <em>objB</em> is null. If so, it returns <strong>false</strong>.</p>\n</li><li>\n<p>If the two objects do not represent the same object reference and neither is null, it calls <em>objA</em>.<strong>Equals</strong>(<em>objB</em>) and returns the result. This means that if <em>objA</em> overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, this override is called.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example illustrates the <xref href=\"System.Object.Equals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method and compares it with the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>System.Object.Equals#1"
  syntax:
    content: public static bool Equals(object objA, object objB)
    content.vb: Public Shared Function Equals(objA As Object, objB As Object) As Boolean
    parameters:
    - id: objA
      type: System.Object
      description: "\n<p>The first object to compare. </p>\n"
    - id: objB
      type: System.Object
      description: "\n<p>The second object to compare. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the objects are considered equal; otherwise, <strong>false</strong>. If both <em>objA</em> and <em>objB</em> are null, the method returns <strong>true</strong>.</p>\n"
  seealso:
  - type: System.Object.Equals(System.Object)
    commentId: M:System.Object.Equals(System.Object)
  - type: System.Object.ReferenceEquals(System.Object,System.Object)
    commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Object.Finalize
  commentId: M:System.Object.Finalize
  id: Finalize
  parent: System.Object
  langs:
  - csharp
  - vb
  name: Finalize()
  fullName: System.Object.Finalize()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Finalize
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1313
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed. The method is protected and therefore is accessible only through this class or through a derived class.</p>\n<p>In this section:</p>\n<ul><li>\n<p>How finalization works</p>\n</li><li>\n<p>Notes for implementers</p>\n</li><li>\n<p>The SafeHandle alternative</p>\n</li></ul>\n"
  example:
  - <p>The following example verifies that the <xref href="System.Object.Finalize" data-throw-if-not-resolved="false"></xref> method is called when an object that overrides <xref href="System.Object.Finalize" data-throw-if-not-resolved="false"></xref> is destroyed. Note that, in a production application, the <xref href="System.Object.Finalize" data-throw-if-not-resolved="false"></xref> method would be overridden to release unmanaged resources held by the object. Also note that the C# example provides a destructor instead of overriding the <xref href="System.Object.Finalize" data-throw-if-not-resolved="false"></xref> method.</p>System.Object.Finalize#1<p>For an additional example that overrides the <xref href="System.Object.Finalize" data-throw-if-not-resolved="false"></xref> method, see the <xref href="System.GC.SuppressFinalize(System.Object)" data-throw-if-not-resolved="false"></xref> method. </p>
  syntax:
    content: protected void Finalize()
    content.vb: Protected Sub Finalize
  seealso:
  - type: System.GC.SuppressFinalize(System.Object)
    commentId: M:System.GC.SuppressFinalize(System.Object)
  - type: System.GC.ReRegisterForFinalize(System.Object)
    commentId: M:System.GC.ReRegisterForFinalize(System.Object)
  - type: System.GC.WaitForPendingFinalizers
    commentId: M:System.GC.WaitForPendingFinalizers
  - type: System.WeakReference
    commentId: T:System.WeakReference
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Object.GetHashCode
  commentId: M:System.Object.GetHashCode
  id: GetHashCode
  parent: System.Object
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHashCode
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1314
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Serves as the default hash function. </p>\n"
  remarks: "\n<p>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref href=\"System.Collections.Generic.Dictionary`2\" data-throw-if-not-resolved=\"false\"></xref> class, the <xref href=\"System.Collections.Hashtable\" data-throw-if-not-resolved=\"false\"></xref> class, or a type derived from the <xref href=\"System.Collections.DictionaryBase\" data-throw-if-not-resolved=\"false\"></xref> class. The <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method provides this hash code for algorithms that need quick checks of object equality. </p>\n<p>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <see href=\"http://en.wikipedia.org/wiki/Hash_function\">Hash Function</see> entry in Wikipedia. </p>\n<p>Two objects that are equal return hash codes that are equal. However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes. Furthermore, the .NET Framework does not guarantee the default implementation of the <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms. For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes. Two consequences follow from this: </p>\n<ul><li>\n<p>You should not assume that equal hash codes imply object equality. </p>\n</li><li>\n<p>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms. </p>\n</li></ul>\n<p>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table. A hash code is not a permanent value. For this reason: </p>\n<ul><li>\n<p>Do not serialize hash code values or store them in databases.</p>\n</li><li>\n<p>Do not use the hash code as the key to retrieve an object from a keyed collection. </p>\n</li><li>\n<p>Do not send hash codes across application domains or processes. In some cases, hash codes may be computed on a per-process or per-application domain basis. </p>\n</li><li>\n<p>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash. For cryptographic hashes, use a class derived from the <xref href=\"System.Security.Cryptography.HashAlgorithm\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Security.Cryptography.KeyedHashAlgorithm\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n</li><li>\n<p>Do not test for equality of hash codes to determine whether two objects are equal. (Unequal objects can have identical hash codes.) To test for equality, call the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n</li></ul>\n<p>The <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method can be overridden by a derived type. If <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> is not overridden, hash codes for reference types are computed by calling the <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref href=\"System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>. In other words, two objects for which the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method returns <strong>true</strong> have identical hash codes. If value types do not override <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.ValueType.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method of the base class uses reflection to compute the hash code based on the values of the type's fields. In other words, value types whose fields have equal values have equal hash codes. For more information about overriding <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref>, see the \"Notes to Inheritors\" section. </p>\n<p>If you override the <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method, you should also override <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, and vice versa. If your overridden <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method returns <strong>true</strong> when two objects are tested for equality, your overridden <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref> method must return the same value for the two objects. </p>\n<p>If an object that is used as a key in a hash table does not provide a useful implementation of <xref href=\"System.Object.GetHashCode\" data-throw-if-not-resolved=\"false\"></xref>, you can specify a hash code provider by supplying an <xref href=\"System.Collections.IEqualityComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation to one of the overloads of the <xref href=\"System.Collections.Hashtable\" data-throw-if-not-resolved=\"false\"></xref> class constructor. </p>\n"
  example:
  - '<p>One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref href="System.Int32" data-throw-if-not-resolved="false"></xref> type is to simply return that value. The following example shows such an implementation for a <code>Number</code> structure. </p>System.Object.GetHashCode#1<p>Frequently, a type has multiple data fields that can participate in generating the hash code. One way to generate a hash code is to combine these fields using an <strong>XOR (eXclusive OR)</strong> operation, as shown in the following example.</p>System.Object.GetHashCode#2<p>The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable. A number of solutions are available so that hash codes in these cases are not identical. One is to return the hash code of a <strong>Tuple</strong> object that reflects the order of each field. The following example shows a possible implementation that uses the <xref href="System.Tuple`2" data-throw-if-not-resolved="false"></xref> class. Note, though, that the performance overhead of instantiating a <strong>Tuple</strong> object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables. </p>System.Object.GetHashCode#3<p>A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits. Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded. Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following: </p>System.Object.GetHashCode#4<p>The following example then uses this shift-and-wrap method to compute the hash code of the <code>Point</code> structure used in the previous examples. </p>System.Object.GetHashCode#5'
  syntax:
    content: public virtual int GetHashCode()
    content.vb: Public Overridable Function GetHashCode As Integer
    return:
      type: System.Int32
      description: "\n<p>A hash code for the current object.</p>\n"
  seealso:
  - type: System.Collections.Hashtable
    commentId: T:System.Collections.Hashtable
  - type: System.Object.Equals(System.Object)
    commentId: M:System.Object.Equals(System.Object)
  - type: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)
    commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Object.GetType
  commentId: M:System.Object.GetType
  id: GetType
  parent: System.Object
  langs:
  - csharp
  - vb
  name: GetType()
  fullName: System.Object.GetType()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetType
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1315
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> of the current instance.</p>\n"
  remarks: "\n<p>Because <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is the base class for all types in the .NET Framework type system, the <xref href=\"System.Object.GetType\" data-throw-if-not-resolved=\"false\"></xref> method can be used to return <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> objects that represent all .NET Framework types. The .NET Framework recognizes the following five categories of types: </p>\n<ul><li>\n<p>Classes, which are derived from <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>,</p>\n</li><li>\n<p>Value types, which are derived from <xref href=\"System.ValueType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>Interfaces, which are derived from <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> starting with the .NET Framework 2.0. </p>\n</li><li>\n<p>Enumerations, which are derived from <xref href=\"System.Enum\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li><li>\n<p>Delegates, which are derived from <xref href=\"System.MulticastDelegate\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li></ul>\n<p>For two objects <em>x</em> and <em>y</em> that have identical runtime types, <code>Object.ReferenceEquals(x.GetType(),y.GetType())</code> returns <strong>true</strong>. The following example uses the <xref href=\"System.Object.GetType\" data-throw-if-not-resolved=\"false\"></xref> method with the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to determine whether one numeric value is the same type as two other numeric values.</p>System.Object.GetType#1<p>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct. For example, you can use the <strong>TypeOf…Is</strong> construct in Visual Basic or the <strong>is</strong> keyword in C#.</p><p>The <xref href=\"System.Object.GetType\" data-throw-if-not-resolved=\"false\"></xref> method is inherited by all types that derive from <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>. This means that, in addition to using your own language's comparison keyword, you can use the <xref href=\"System.Object.GetType\" data-throw-if-not-resolved=\"false\"></xref> method to determine the type of a particular object, as the following example shows. </p>System.Object.GetType#2<p>The <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object exposes the metadata associated with the class of the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.</p>"
  example:
  - "\n<p>The following code example demonstrates that <xref href=\"System.Object.GetType\" data-throw-if-not-resolved=\"false\"></xref> returns the runtime type of the current instance.</p>ECMA-System.Object.GetType#1"
  syntax:
    content: public Type GetType()
    content.vb: Public Function GetType As Type
    return:
      type: System.Type
      description: "\n<p>The exact runtime type of the current instance.</p>\n"
  seealso:
  - type: System.Type
    commentId: T:System.Type
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Object.MemberwiseClone
  commentId: M:System.Object.MemberwiseClone
  id: MemberwiseClone
  parent: System.Object
  langs:
  - csharp
  - vb
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MemberwiseClone
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1316
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates a shallow copy of the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object. If a field is a value type, a bit-by-bit copy of the field is performed. If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</p>\n<p>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</p>\n<p>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method does not meet your needs. These include the following:</p>\n<ul><li>\n<p>Call a class constructor of the object to be copied to create a second object with property values taken from the first object. This assumes that the values of an object are entirely defined by its class constructor.</p>\n</li><li>\n<p>Call the <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types. The <code>DeepCopy</code> method in the example illustrates this approach. </p>\n</li><li>\n<p>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</p>\n</li><li>\n<p>Use reflection with recursion to perform the deep copy operation. </p>\n</li></ul>\n"
  example:
  - "\n<p>The following example illustrates the <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method. It defines a <code>ShallowCopy</code> method that calls the <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method to perform a shallow copy operation on a <code>Person</code> object. It also defines a <code>DeepCopy</code> method that performs a deep copy operation on a <code>Person</code> object.</p>System.Object.MemberwiseClone#1<p>In this example, the <code>Person.IdInfo</code> property returns an <code>IdInfo</code> object. As the output from the example shows, when a <code>Person</code> object is cloned by calling the <xref href=\"System.Object.MemberwiseClone\" data-throw-if-not-resolved=\"false\"></xref> method, the cloned <code>Person</code> object is an independent copy of the original object, except that they share the same <code>Person.IdInfo</code> object reference. As a result, modifying the clone's <code>Person.IdInfo</code> property changes the original object's <code>Person.IdInfo</code> property. On the other hand, when a deep copy operation is performed, the cloned <code>Person</code> object, including its <code>Person.IdInfo</code> property, can be modified without affecting the original object.</p>"
  syntax:
    content: protected object MemberwiseClone()
    content.vb: Protected Function MemberwiseClone As Object
    return:
      type: System.Object
      description: "\n<p>A shallow copy of the current <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
  id: ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  langs:
  - csharp
  - vb
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReferenceEquals
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1317
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> instances are the same instance.</p>\n"
  remarks: "\n<p>\n    Unlike the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method and the equality operator, the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method cannot be overridden. Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <strong>Equals</strong> method, you can call the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>However, the return value of the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method may appear to be anomalous in these two scenarios: </p>\n<ul><li>\n<p>When comparing value types. If <em>objA</em> and <em>objB</em> are value types, they are boxed before they are passed to the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. This means that if both <em>objA</em> and <em>objB</em> represent the same instance of a value type, the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method nevertheless returns <strong>false</strong>, as the following example shows.</p>System.Object.ReferenceEquals#1<p>For information on boxing value types, see Boxing and Unboxing (C# Programming Guide). </p></li><li>\n<p>When comparing strings. If <em>objA</em> and <em>objB</em> are strings, the <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method returns <strong>true</strong> if the string is interned. It does not perform a test for value equality.  In the following example, <em>s1</em> and <em>s2</em> are equal because they are two instances of a single interned string. However, <em>s3</em> and <em>s4</em> are not equal, because although they are have identical string values, that string is not interned. </p>System.Object.ReferenceEquals#2<p>For more information about string interning, see <xref href=\"System.String.IsInterned(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. </p></li></ul>\n"
  example:
  - "\n<p>The following example uses <xref href=\"System.Object.ReferenceEquals(System.Object,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to determine if two objects are the same instance.</p>ECMA-System.Object.ReferenceEquals#1"
  syntax:
    content: public static bool ReferenceEquals(object objA, object objB)
    content.vb: Public Shared Function ReferenceEquals(objA As Object, objB As Object) As Boolean
    parameters:
    - id: objA
      type: System.Object
      description: "\n<p>The first object to compare. </p>\n"
    - id: objB
      type: System.Object
      description: "\n<p>The second object  to compare. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>objA</em> is the same instance as <em>objB</em> or if both are null; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Object.Equals(System.Object)
    commentId: M:System.Object.Equals(System.Object)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Object.ToString
  commentId: M:System.Object.ToString
  id: ToString
  parent: System.Object
  langs:
  - csharp
  - vb
  name: ToString()
  fullName: System.Object.ToString()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ToString
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 1318
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns a string that represents the current object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> is the major formatting method in the .NET Framework. It converts an object to its string representation so that it is suitable for display. (For information about formatting support in the .NET Framework, see Formatting Types in the .NET Framework.) Default implementations of the <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> method return the fully qualified name of the object's type. </p>\n<p>You may have reached this page by following the link from the member list of another type. That is because that type does not override <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref>. Instead, it inherits the functionality of the <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n<p>Types frequently override the <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> method to provide a more suitable string representation of a particular type. Types also frequently overload the <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> method to provide support for format strings or culture-sensitive formatting. </p>\n<p>In this section:</p>\n<p>The default Object.ToString() methodOverriding the Object.ToString() methodOverloading the ToString methodExtending the Object.ToString methodNotes for the Windows Runtime</p>\n"
  syntax:
    content: public virtual string ToString()
    content.vb: Public Overridable Function ToString As String
    return:
      type: System.String
      description: "\n<p>A string that represents the current object.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
references:
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  fullName: System.Type
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
