items:
- uid: System.Threading.EventWaitHandle
  commentId: T:System.Threading.EventWaitHandle
  id: EventWaitHandle
  parent: System.Threading
  children:
  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)
  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)
  - System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)
  - System.Threading.EventWaitHandle.OpenExisting(System.String)
  - System.Threading.EventWaitHandle.Reset
  - System.Threading.EventWaitHandle.Set
  - System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)
  langs:
  - csharp
  - vb
  name: EventWaitHandle
  fullName: System.Threading.EventWaitHandle
  type: Class
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EventWaitHandle
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 96
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Represents a thread synchronization event.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class allows threads to communicate with each other by signaling. Typically, one or more threads block on an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> until an unblocked thread calls the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> method, releasing one or more of the blocked threads. A thread can signal an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> and then block on it, by calling the <strong>static</strong> (<strong>Shared</strong> in Visual Basic) <see cref=\"Overload:System.Threading.WaitHandle.SignalAndWait\"></see> method.</p>\n<p>The <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class provides access to named system synchronization events.</p>\n<p>The behavior of an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> that has been signaled depends on its reset mode. An <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref> flag resets automatically when signaled, after releasing a single waiting thread. An <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag remains signaled until its <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n<p>Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.</p>\n<p>Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.</p>\n<p>\n<xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> objects can be used with the <strong>static</strong>(<strong>Shared</strong> in Visual Basic) <see cref=\"Overload:System.Threading.WaitHandle.WaitAll\"></see>Â and <see cref=\"Overload:System.Threading.WaitHandle.WaitAny\"></see> methods.</p>\n<p>For more information about thread synchronization mechanisms, see EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent.</p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\" data-throw-if-not-resolved=\"false\"></xref> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</p>\n<p>The example starts five threads and allows them to block on an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>System.Threading.WaitHandle.SignalAndWait#1"
  syntax:
    content: 'public class EventWaitHandle : WaitHandle'
    content.vb: >-
      Public Class EventWaitHandle
          Inherits WaitHandle
  seealso:
  - type: System.Threading.WaitHandle
    commentId: T:System.Threading.WaitHandle
  - type: System.Threading.AutoResetEvent
    commentId: T:System.Threading.AutoResetEvent
  - type: System.Threading.ManualResetEvent
    commentId: T:System.Threading.ManualResetEvent
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)
  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)
  id: '#ctor(System.Boolean,System.Threading.EventResetMode)'
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: EventWaitHandle(Boolean, EventResetMode)
  fullName: System.Threading.EventWaitHandle.EventWaitHandle(System.Boolean, System.Threading.EventResetMode)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 98
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</p>\n"
  remarks: "\n<p>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag is specified for <em>mode</em>, threads that wait on the event will not block. If the initial state is signaled, and <em>mode</em> is <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\" data-throw-if-not-resolved=\"false\"></xref> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</p>\n<p>The example starts five threads and allows them to block on an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref> flag, then releases one thread each time the user presses ENTER key. The example then queues another five threads and releases them all using an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>System.Threading.WaitHandle.SignalAndWait#1"
  syntax:
    content: public EventWaitHandle(bool initialState, EventResetMode mode)
    content.vb: Public Sub New(initialState As Boolean, mode As EventResetMode)
    parameters:
    - id: initialState
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to set the initial state to signaled; <strong>false</strong> to set it to nonsignaled.</p>\n"
    - id: mode
      type: System.Threading.EventResetMode
      description: "\n<p>One of the <xref href=\"System.Threading.EventResetMode\" data-throw-if-not-resolved=\"false\"></xref> values that determines whether the event resets automatically or manually.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)
  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)
  id: '#ctor(System.Boolean,System.Threading.EventResetMode,System.String)'
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: EventWaitHandle(Boolean, EventResetMode, String)
  fullName: System.Threading.EventWaitHandle.EventWaitHandle(System.Boolean, System.Threading.EventResetMode, System.String)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 99
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</p>\n"
  remarks: "\n<p>If <em>name</em> is <strong>null</strong> or an empty string, a local <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> is created.</p>\n<p>If a system event with the name specified for the <em>name</em> parameter already exists, the <em>initialState</em> parameter is ignored.</p>\n<p>When using this constructor for named system events, specify <strong>false</strong> for <em>initialState</em>. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <xref href=\"System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> constructor or the <xref href=\"System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\" data-throw-if-not-resolved=\"false\"></xref> constructor.</p>\n<p>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag is specified for <em>mode</em>, threads that wait on the event will not block. If the initial state is signaled, and <em>mode</em> is <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n"
  example:
  - 
  syntax:
    content: public EventWaitHandle(bool initialState, EventResetMode mode, string name)
    content.vb: Public Sub New(initialState As Boolean, mode As EventResetMode, name As String)
    parameters:
    - id: initialState
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to set the initial state to signaled if the named event is created as a result of this call; <strong>false</strong> to set it to nonsignaled.</p>\n"
    - id: mode
      type: System.Threading.EventResetMode
      description: "\n<p>One of the <xref href=\"System.Threading.EventResetMode\" data-throw-if-not-resolved=\"false\"></xref> values that determines whether the event resets automatically or manually.</p>\n"
    - id: name
      type: System.String
      description: "\n<p>The name of a system-wide synchronization event.</p>\n"
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)
  commentId: M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)
  id: '#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)'
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: EventWaitHandle(Boolean, EventResetMode, String, out Boolean)
  fullName: System.Threading.EventWaitHandle.EventWaitHandle(System.Boolean, System.Threading.EventResetMode, System.String, out System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 101
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</p>\n"
  remarks: "\n<p>If a system event with the name specified for the <em>name</em> parameter already exists, the <em>initialState</em> parameter is ignored. After calling this constructor, use the value in the variable specified for the <strong>ref</strong> parameter (<strong>ByRef</strong> parameter in Visual Basic)<em>createdNew</em> to determine whether the named system event already existed or was created.</p>\n<p>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag is specified for <em>mode</em>, threads that wait on the event will not block. If the initial state is signaled, and <em>mode</em> is <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n"
  example:
  - 
  syntax:
    content: public EventWaitHandle(bool initialState, EventResetMode mode, string name, out bool createdNew)
    content.vb: Public Sub New(initialState As Boolean, mode As EventResetMode, name As String, ByRef createdNew As Boolean)
    parameters:
    - id: initialState
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to set the initial state to signaled if the named event is created as a result of this call; <strong>false</strong> to set it to nonsignaled.</p>\n"
    - id: mode
      type: System.Threading.EventResetMode
      description: "\n<p>One of the <xref href=\"System.Threading.EventResetMode\" data-throw-if-not-resolved=\"false\"></xref> values that determines whether the event resets automatically or manually.</p>\n"
    - id: name
      type: System.String
      description: "\n<p>The name of a system-wide synchronization event.</p>\n"
    - id: createdNew
      type: System.Boolean
      description: "\n<p>When this method returns, contains <strong>true</strong>if a local event was created (that is, if <em>name</em> is <strong>null</strong> or an empty string) or if the specified named system event was created; <strong>false</strong> if the specified named system event already existed. This parameter is passed uninitialized.</p>\n"
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named event exists and has access control security, but the user does not have <xref href=\"System.Security.AccessControl.EventWaitHandleRights.FullControl\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.EventWaitHandle.EventWaitHandle(System.Boolean, System.Threading.EventResetMode, System.String, ByRef System.Boolean)
  name.vb: EventWaitHandle(Boolean, EventResetMode, String, ByRef Boolean)
- uid: System.Threading.EventWaitHandle.OpenExisting(System.String)
  commentId: M:System.Threading.EventWaitHandle.OpenExisting(System.String)
  id: OpenExisting(System.String)
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: OpenExisting(String)
  fullName: System.Threading.EventWaitHandle.OpenExisting(System.String)
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OpenExisting
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 103
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Opens the specified named synchronization event, if it already exists.</p>\n"
  remarks: "\n<p>The <see cref=\"Overload:System.Threading.EventWaitHandle.OpenExisting\"></see> method tries to open the specified named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <xref href=\"System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\" data-throw-if-not-resolved=\"false\"></xref> constructors that has a <em>name</em> parameter. </p>\n<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> object, even though the objects that are returned represent the same named system event.  </p>\n<p>This method overload is equivalent to calling the <xref href=\"System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights, combined by using the bitwise OR operation.</p>\n<p>Specifying the <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to wait on the named system event, and specifying the <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to call the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <xref href=\"System.Threading.EventWaitHandle.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method overload to test for the existence of a named event.</p>\n<p>If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event. </p>\n<p>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref href=\"System.Threading.EventWaitHandle.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. The exception is caught, and the example uses the <xref href=\"System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\" data-throw-if-not-resolved=\"false\"></xref> method overload to wait on the event with the rights needed to read and change the permissions. </p>\n<p>After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.</p>System.Threading.EventWaitHandle.ctor named 5#1"
  syntax:
    content: public static EventWaitHandle OpenExisting(string name)
    content.vb: Public Shared Function OpenExisting(name As String) As EventWaitHandle
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the system synchronization event to open.</p>\n"
    return:
      type: System.Threading.EventWaitHandle
      description: "\n<p>An  object that represents the named system event.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is an empty string. </p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named system event does not exist.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named event exists, but the user does not have the security access required to use it.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.EventWaitHandle.Reset
  commentId: M:System.Threading.EventWaitHandle.Reset
  id: Reset
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: Reset()
  fullName: System.Threading.EventWaitHandle.Reset()
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Reset
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 105
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets the state of the event to nonsignaled, causing threads to block.</p>\n"
  example:
  - 
  syntax:
    content: public bool Reset()
    content.vb: Public Function Reset As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the operation succeeds; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.EventWaitHandle.Set
  commentId: M:System.Threading.EventWaitHandle.Set
  id: Set
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: Set()
  fullName: System.Threading.EventWaitHandle.Set()
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Set
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 106
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</p>\n"
  remarks: "\n<p>For an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> with <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref> (including <xref href=\"System.Threading.AutoResetEvent\" data-throw-if-not-resolved=\"false\"></xref>), the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n<p>There is no guarantee that every call to the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> method will release a thread from an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> whose reset mode is <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> is called when there are no threads waiting and the <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> is already signaled, the call has no effect. </p>\n<p>For an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> with <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> (including <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref>), calling the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> method leaves the wait handle in a signaled state until its <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n"
  example:
  - "\n<p>The following code example uses the <xref href=\"System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\" data-throw-if-not-resolved=\"false\"></xref> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.</p>\n<p>The example starts five threads and allows them to block on an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.AutoReset\" data-throw-if-not-resolved=\"false\"></xref> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> created with the <xref href=\"System.Threading.EventResetMode.ManualReset\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>System.Threading.WaitHandle.SignalAndWait#1"
  syntax:
    content: public bool Set()
    content.vb: Public Function Set As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the operation succeeds; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.WaitHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method was previously called on this <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)
  commentId: M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)
  id: TryOpenExisting(System.String,System.Threading.EventWaitHandle@)
  parent: System.Threading.EventWaitHandle
  langs:
  - csharp
  - vb
  name: TryOpenExisting(String, out EventWaitHandle)
  fullName: System.Threading.EventWaitHandle.TryOpenExisting(System.String, out System.Threading.EventWaitHandle)
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryOpenExisting
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 107
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n"
  remarks: "\n<p>If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <xref href=\"System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)\" data-throw-if-not-resolved=\"false\"></xref> constructors that has a <em>name</em> parameter.</p>\n<p>If you are uncertain whether a named synchronization event exists, use this method overload instead of the <xref href=\"System.Threading.EventWaitHandle.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method overload, which throws an exception if the synchronization event does not exist.</p>\n<p>This method overload is equivalent to calling the <xref href=\"System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights, combined by using the bitwise OR operation. Specifying the <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to wait on the named system event, and specifying the <xref href=\"System.Security.AccessControl.EventWaitHandleRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to call the <xref href=\"System.Threading.EventWaitHandle.Set\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Threading.EventWaitHandle.Reset\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> object, even though the objects that are returned represent the same named system event.  </p>\n"
  syntax:
    content: public static bool TryOpenExisting(string name, out EventWaitHandle result)
    content.vb: Public Shared Function TryOpenExisting(name As String, ByRef result As EventWaitHandle) As Boolean
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the system synchronization event to open.</p>\n"
    - id: result
      type: System.Threading.EventWaitHandle
      description: "\n<p>When this method returns, contains a <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> object that represents the named synchronization event if the call succeeded, or <strong>null</strong> if the call failed. This parameter is treated as uninitialized.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the named synchronization event was opened successfully; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is an empty string.</p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named event exists, but the user does not have the desired security access.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.EventWaitHandle.TryOpenExisting(System.String, ByRef System.Threading.EventWaitHandle)
  name.vb: TryOpenExisting(String, ByRef EventWaitHandle)
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Threading.EventResetMode
  parent: System.Threading
  isExternal: false
  name: EventResetMode
  fullName: System.Threading.EventResetMode
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Threading.EventWaitHandle
  parent: System.Threading
  isExternal: false
  name: EventWaitHandle
  fullName: System.Threading.EventWaitHandle
- uid: System.IO.IOException
  parent: System.IO
  isExternal: false
  name: IOException
  fullName: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: false
  name: UnauthorizedAccessException
  fullName: System.UnauthorizedAccessException
- uid: System.Threading.WaitHandleCannotBeOpenedException
  isExternal: false
  name: WaitHandleCannotBeOpenedException
  fullName: System.Threading.WaitHandleCannotBeOpenedException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
