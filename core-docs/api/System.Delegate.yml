items:
- uid: System.Delegate
  commentId: T:System.Delegate
  id: Delegate
  parent: System
  children:
  - System.Delegate.Combine(System.Delegate,System.Delegate)
  - System.Delegate.Combine(System.Delegate[])
  - System.Delegate.DynamicInvoke(System.Object[])
  - System.Delegate.Equals(System.Object)
  - System.Delegate.GetHashCode
  - System.Delegate.GetInvocationList
  - System.Delegate.op_Equality(System.Delegate,System.Delegate)
  - System.Delegate.op_Inequality(System.Delegate,System.Delegate)
  - System.Delegate.Remove(System.Delegate,System.Delegate)
  - System.Delegate.RemoveAll(System.Delegate,System.Delegate)
  - System.Delegate.Target
  langs:
  - csharp
  - vb
  name: Delegate
  fullName: System.Delegate
  type: Class
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Delegate
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 722
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Delegate\" data-throw-if-not-resolved=\"false\"></xref> class is the base class for delegate types. However, only the system and compilers can derive explicitly from the <xref href=\"System.Delegate\" data-throw-if-not-resolved=\"false\"></xref> class or from the <xref href=\"System.MulticastDelegate\" data-throw-if-not-resolved=\"false\"></xref> class. It is also not permissible to derive a new type from a delegate type. The <xref href=\"System.Delegate\" data-throw-if-not-resolved=\"false\"></xref> class is not considered a delegate type; it is a class used to derive delegate types.</p>\n<p>Most languages implement a <strong>delegate</strong> keyword, and compilers for those languages are able to derive from the <xref href=\"System.MulticastDelegate\" data-throw-if-not-resolved=\"false\"></xref> class; therefore, users should use the <strong>delegate</strong> keyword provided by the language.</p>\n<p>The common language runtime provides an <strong>Invoke</strong> method for each delegate type, with the same signature as the delegate. You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically. The <strong>Invoke</strong> method is useful in reflection when you want to find the signature of the delegate type.</p>\n<p>The common language runtime provides each delegate type with <strong>BeginInvoke</strong> and <strong>EndInvoke</strong> methods, to enable asynchronous invocation of the delegate. For more information about these methods, see Calling Synchronous Methods Asynchronously.</p>\n<p>The declaration of a delegate type establishes a contract that specifies the signature of one or more methods. A delegate is an instance of a delegate type that has references to: </p>\n<ul><li>\n<p>An instance method of a type and a target object assignable to that type. </p>\n</li><li>\n<p>An instance method of a type, with the hidden <em>this</em> parameter exposed in the formal parameter list. The delegate is said to be an open instance delegate.</p>\n</li><li>\n<p>A static method.</p>\n</li><li>\n<p>A static method and a target object assignable to the first parameter of the method. The delegate is said to be closed over its first argument.</p>\n</li></ul>\n<p>For more information on delegate binding, see the <xref href=\"System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method overload. </p>\n<p>In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type. Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</p>\n<p>When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method. When a delegate represents an open instance method, it stores a reference to the method's entry point. The delegate signature must include the hidden <em>this</em> parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked. </p>\n<p>When a delegate represents a static method, the delegate stores a reference to the method's entry point. When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument. When the delegate is invoked, the first argument of the static method receives the target object.</p>\n<p>The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate. An invocation list can contain duplicate methods. During an invocation, methods are invoked in the order in which they appear in the invocation list. A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list. Delegates are immutable; once created, the invocation list of a delegate does not change.</p>\n<p>Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations. </p>\n<p>Combining operations, such as <xref href=\"System.Delegate.Combine(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Delegate.Remove(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref>, do not alter existing delegates. Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or <strong>null</strong>. A combining operation returns <strong>null</strong> when the result of the operation is a delegate that does not reference at least one method. A combining operation returns an unchanged delegate when the requested operation has no effect.</p>\n<p>Managed languages use the <xref href=\"System.Delegate.Combine(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Delegate.Remove(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> methods to implement delegate operations. Examples include the <strong>AddHandler</strong> and <strong>RemoveHandler</strong> statements in Visual Basic and the += and -= operators on delegate types in C#. </p>\n<p>Starting with the .NET FrameworkÂ 4, generic delegate types can have variant type parameters. Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type. This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in Covariance and Contravariance in Generics.</p>\n<p>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named <code>Derived</code> is derived from a class named <code>Base</code>. A delegate of type <code>Action<Base></code> (<code>Action(Of Base)</code> in Visual Basic) can be assigned to a variable of type <code>Action<Derived></code>, but the two delegates cannot be combined because the types do not match exactly.</p>\n<p>If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked. Catching the exception in the caller does not alter this behavior.</p>\n<p>When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list. When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</p>\n<p>The closest equivalent of a delegate in C or C++ is a function pointer. A delegate can represent a static method or an instance method. When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance. Unlike function pointers, delegates are object oriented and type safe.</p>\n"
  example:
  - "\n<p>The following example shows how to define a delegate named <code>myMethodDelegate</code>. Instances of this delegate are created for an instance method and a static method of the nested <code>mySampleClass</code> class. The delegate for the instance method requires an instance of <code>mySampleClass</code>. The <code>mySampleClass</code> instance is saved in a variable named <code>mySC</code>. </p>Classic Delegate Example#1"
  syntax:
    content: public abstract class Delegate
    content.vb: Public MustInherit Class Delegate
  seealso:
  - type: System.MulticastDelegate
    commentId: T:System.MulticastDelegate
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.GetType
  - System.Object.MemberwiseClone
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.ToString
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Delegate.Target
  commentId: P:System.Delegate.Target
  id: Target
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Target
  fullName: System.Delegate.Target
  type: Property
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Target
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 725
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the class instance on which the current delegate invokes the instance method.</p>\n"
  remarks: "\n<p>An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</p>\n<p>If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</p>\n"
  syntax:
    content: public object Target { get; }
    content.vb: Public ReadOnly Property Target As Object
    parameters: []
    return:
      type: System.Object
      description: "\n<p>The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <strong>null</strong> if the delegate represents a static method.</p>\n"
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Delegate.Combine(System.Delegate,System.Delegate)
  commentId: M:System.Delegate.Combine(System.Delegate,System.Delegate)
  id: Combine(System.Delegate,System.Delegate)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Combine(Delegate, Delegate)
  fullName: System.Delegate.Combine(System.Delegate, System.Delegate)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Combine
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 726
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Concatenates the invocation lists of two delegates.</p>\n"
  remarks: "\n<p>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</p>\n<p>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named <code>Derived</code> is derived from a class named <code>Base</code>. A delegate of type <code>Action<Base></code> (<code>Action(Of Base)</code> in Visual Basic) can be assigned to a variable of type <code>Action<Derived></code>, as explained in Covariance and Contravariance in Generics, but the two delegates cannot be combined because the types do not match exactly.</p>\n<p>\n<xref href=\"System.Delegate.Combine(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> is useful for creating event handlers that call multiple methods each time an event occurs.</p>\n"
  syntax:
    content: public static Delegate Combine(Delegate a, Delegate b)
    content.vb: 'Public Shared Function Combine(a As  Delegate, b As  Delegate) As '
    parameters:
    - id: a
      type: System.Delegate
      description: "\n<p>The delegate whose invocation list comes first. </p>\n"
    - id: b
      type: System.Delegate
      description: "\n<p>The delegate whose invocation list comes last. </p>\n"
    return:
      type: System.Delegate
      description: "\n<p>A new delegate with an invocation list that concatenates the invocation lists of <em>a</em> and <em>b</em> in that order. Returns <em>a</em> if <em>b</em> is <strong>null</strong>, returns <em>b</em> if <em>a</em> is a null reference, and returns a null reference if both <em>a</em> and <em>b</em> are null references.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Both <em>a</em> and <em>b</em> are not <strong>null</strong>, and <em>a</em> and <em>b</em> are not instances of the same delegate type. </p>\n"
  seealso:
  - type: System.MulticastDelegate
    commentId: T:System.MulticastDelegate
  - type: System.Delegate.CombineImpl(System.Delegate)
    commentId: M:System.Delegate.CombineImpl(System.Delegate)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Delegate.Combine(System.Delegate[])
  commentId: M:System.Delegate.Combine(System.Delegate[])
  id: Combine(System.Delegate[])
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Combine(Delegate[])
  fullName: System.Delegate.Combine(System.Delegate[])
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Combine
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 727
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Concatenates the invocation lists of an array of delegates.</p>\n"
  remarks: "\n<p>If the <em>delegates</em> array contains entries that are <strong>null</strong>, those entries are ignored.</p>\n<p>The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</p>\n<p>Generic delegates that are assignment-compatible because of variance are not necessarily combinable. To be combinable, the types must match exactly. For example, suppose that a class named <code>Derived</code> is derived from a class named <code>Base</code>. A delegate of type <code>Action<Base></code> (<code>Action(Of Base)</code> in Visual Basic) can be assigned to a variable of type <code>Action<Derived></code>, as explained in Covariance and Contravariance in Generics, but the two delegates cannot be combined because the types do not match exactly.</p>\n<p>\n<xref href=\"System.Delegate.Combine(System.Delegate,System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> is useful for creating event handlers that call multiple methods each time an event occurs.</p>\n"
  syntax:
    content: public static Delegate Combine(params Delegate[] delegates)
    content.vb: 'Public Shared Function Combine(ParamArray delegates As  Delegate ()) As '
    parameters:
    - id: delegates
      type: System.Delegate[]
      description: "\n<p>The array of delegates to combine. </p>\n"
    return:
      type: System.Delegate
      description: "\n<p>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <em>delegates</em> array. Returns <strong>null</strong> if <em>delegates</em> is <strong>null</strong>, if <em>delegates</em> contains zero elements, or if every entry in <em>delegates</em> is <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Not all the non-null entries in <em>delegates</em> are instances of the same delegate type. </p>\n"
  seealso:
  - type: System.MulticastDelegate
    commentId: T:System.MulticastDelegate
  - type: System.Delegate.CombineImpl(System.Delegate)
    commentId: M:System.Delegate.CombineImpl(System.Delegate)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Delegate.Combine(System.Delegate())
  name.vb: Combine(Delegate())
- uid: System.Delegate.DynamicInvoke(System.Object[])
  commentId: M:System.Delegate.DynamicInvoke(System.Object[])
  id: DynamicInvoke(System.Object[])
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: DynamicInvoke(Object[])
  fullName: System.Delegate.DynamicInvoke(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DynamicInvoke
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 728
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Dynamically invokes (late-bound) the method represented by the current delegate.</p>\n"
  remarks: "\n<p>This method calls the <xref href=\"System.Delegate.DynamicInvokeImpl(System.Object[])\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public object DynamicInvoke(params object[] args)
    content.vb: Public Function DynamicInvoke(ParamArray args As Object()) As Object
    parameters:
    - id: args
      type: System.Object[]
      description: "\n<p>An array of objects that are the arguments to pass to the method represented by the current delegate.</p>\n<p>-or- </p>\n<p>\n<strong>null</strong>, if the method represented by the current delegate does not require arguments. </p>\n"
    return:
      type: System.Object
      description: "\n<p>The object returned by the method represented by the delegate.</p>\n"
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "\n<p>The caller does not have access to the method represented by the delegate (for example, if the method is private).</p>\n<p>-or- </p>\n<p>The number, order, or type of parameters listed in <em>args</em> is invalid. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The method represented by the delegate is invoked on an object or a class that does not support it. </p>\n"
  - type: System.Reflection.TargetInvocationException
    commentId: T:System.Reflection.TargetInvocationException
    description: "\n<p>The method represented by the delegate is an instance method and the target object is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>One of the encapsulated methods throws an exception. </p>\n"
  seealso:
  - type: System.Delegate.DynamicInvokeImpl(System.Object[])
    commentId: M:System.Delegate.DynamicInvokeImpl(System.Object[])
  - type: System.Object
    commentId: T:System.Object
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Delegate.DynamicInvoke(System.Object())
  name.vb: DynamicInvoke(Object())
- uid: System.Delegate.Equals(System.Object)
  commentId: M:System.Delegate.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.Delegate.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Equals
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 729
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</p>\n"
  remarks: "\n<p>If the two delegates are not of the same type, they are not considered equal.</p>\n<p>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</p>\n<p>The methods and targets are compared for equality as follows: </p>\n<ul><li>\n<p>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</p>\n</li></ul>\n<p>Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</p>\n"
  syntax:
    content: public override bool Equals(object obj)
    content.vb: Public Overrides Function Equals(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object to compare with the current delegate. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>obj</em> and the current delegate have the same targets, methods, and invocation list; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Object.Equals(System.Object)
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "\n<p>The caller does not have access to the method represented by the delegate (for example, if the method is private). </p>\n"
  seealso:
  - type: System.Object
    commentId: T:System.Object
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Delegate.GetHashCode
  commentId: M:System.Delegate.GetHashCode
  id: GetHashCode
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.Delegate.GetHashCode()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHashCode
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 730
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns a hash code for the delegate.</p>\n"
  remarks: "\n<p>The return value of this method must not be persisted for two reasons. First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless. Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</p>\n"
  syntax:
    content: public override int GetHashCode()
    content.vb: Public Overrides Function GetHashCode As Integer
    return:
      type: System.Int32
      description: "\n<p>A hash code for the delegate.</p>\n"
  overridden: System.Object.GetHashCode
  seealso:
  - type: System.Object.GetHashCode
    commentId: M:System.Object.GetHashCode
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Delegate.GetInvocationList
  commentId: M:System.Delegate.GetInvocationList
  id: GetInvocationList
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: GetInvocationList()
  fullName: System.Delegate.GetInvocationList()
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetInvocationList
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 731
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns the invocation list of the delegate.</p>\n"
  remarks: "\n<p>Each delegate in the array represents exactly one method.</p>\n<p>The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</p>\n"
  example:
  - "\n<p>The following example assigns three methods to a delegate. It then calls the  <xref href=\"System.Delegate.GetInvocationList\" data-throw-if-not-resolved=\"false\"></xref> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring \"File\". </p>System.Delegate.GetInvocationList#1"
  syntax:
    content: public virtual Delegate[] GetInvocationList()
    content.vb: 'Public Overridable Function GetInvocationList As '
    return:
      type: System.Delegate[]
      description: "\n<p>An array of delegates representing the invocation list of the current delegate.</p>\n"
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Delegate.op_Equality(System.Delegate,System.Delegate)
  commentId: M:System.Delegate.op_Equality(System.Delegate,System.Delegate)
  id: op_Equality(System.Delegate,System.Delegate)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Equality(Delegate, Delegate)
  fullName: System.Delegate.Equality(System.Delegate, System.Delegate)
  type: Operator
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Equality
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 732
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified delegates are equal.</p>\n"
  remarks: "\n<p>Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</p>\n<p>If the two delegates are not of the same type, they are not considered equal.</p>\n<p>In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</p>\n<p>The methods and targets are compared for equality as follows: </p>\n<ul><li>\n<p>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</p>\n</li></ul>\n<p>Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</p>\n"
  syntax:
    content: public static bool operator ==(Delegate d1, Delegate d2)
    content.vb: Public Shared Operator =(d1 As  Delegate, d2 As  Delegate) As Boolean
    parameters:
    - id: d1
      type: System.Delegate
      description: "\n<p>The first delegate to compare. </p>\n"
    - id: d2
      type: System.Delegate
      description: "\n<p>The second delegate to compare. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>d1</em> is equal to <em>d2</em>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Delegate.Equals(System.Object)
    commentId: M:System.Delegate.Equals(System.Object)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Delegate.op_Inequality(System.Delegate,System.Delegate)
  commentId: M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)
  id: op_Inequality(System.Delegate,System.Delegate)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Inequality(Delegate, Delegate)
  fullName: System.Delegate.Inequality(System.Delegate, System.Delegate)
  type: Operator
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: op_Inequality
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 733
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified delegates are not equal.</p>\n"
  remarks: "\n<p>Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</p>\n<p>If the two delegates are not of the same type, they are not considered equal.</p>\n<p>In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</p>\n<p>The methods and targets are compared for equality as follows: </p>\n<ul><li>\n<p>If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</p>\n</li><li>\n<p>Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</p>\n</li></ul>\n<p>Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</p>\n"
  syntax:
    content: public static bool operator !=(Delegate d1, Delegate d2)
    content.vb: Public Shared Operator <>(d1 As  Delegate, d2 As  Delegate) As Boolean
    parameters:
    - id: d1
      type: System.Delegate
      description: "\n<p>The first delegate to compare. </p>\n"
    - id: d2
      type: System.Delegate
      description: "\n<p>The second delegate to compare. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>d1</em> is not equal to <em>d2</em>; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Delegate.Equals(System.Object)
    commentId: M:System.Delegate.Equals(System.Object)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Delegate.Remove(System.Delegate,System.Delegate)
  commentId: M:System.Delegate.Remove(System.Delegate,System.Delegate)
  id: Remove(System.Delegate,System.Delegate)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: Remove(Delegate, Delegate)
  fullName: System.Delegate.Remove(System.Delegate, System.Delegate)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Remove
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 734
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</p>\n"
  remarks: "\n<p>If the invocation list of <em>value</em> matches a contiguous set of elements in the invocation list of <em>source</em>, then the invocation list of <em>value</em> is said to occur within the invocation list of <em>source</em>. If the invocation list of <em>value</em> occurs more than once in the invocation list of <em>source</em>, the last occurrence is removed.</p>\n"
  syntax:
    content: public static Delegate Remove(Delegate source, Delegate value)
    content.vb: 'Public Shared Function Remove(source As  Delegate, value As  Delegate) As '
    parameters:
    - id: source
      type: System.Delegate
      description: "\n<p>The delegate from which to remove the invocation list of <em>value</em>. </p>\n"
    - id: value
      type: System.Delegate
      description: "\n<p>The delegate that supplies the invocation list to remove from the invocation list of <em>source</em>. </p>\n"
    return:
      type: System.Delegate
      description: "\n<p>A new delegate with an invocation list formed by taking the invocation list of <em>source</em> and removing the last occurrence of the invocation list of <em>value</em>, if the invocation list of <em>value</em> is found within the invocation list of <em>source</em>. Returns <em>source</em> if <em>value</em> is <strong>null</strong> or if the invocation list of <em>value</em> is not found within the invocation list of <em>source</em>. Returns a null reference if the invocation list of <em>value</em> is equal to the invocation list of <em>source</em> or if <em>source</em> is a null reference.</p>\n"
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "\n<p>The caller does not have access to the method represented by the delegate (for example, if the method is private). </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The delegate types do not match.</p>\n"
  seealso:
  - type: System.Delegate.RemoveAll(System.Delegate,System.Delegate)
    commentId: M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)
  - type: System.Delegate.RemoveImpl(System.Delegate)
    commentId: M:System.Delegate.RemoveImpl(System.Delegate)
  - type: System.Delegate.Equals(System.Object)
    commentId: M:System.Delegate.Equals(System.Object)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Delegate.RemoveAll(System.Delegate,System.Delegate)
  commentId: M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)
  id: RemoveAll(System.Delegate,System.Delegate)
  parent: System.Delegate
  langs:
  - csharp
  - vb
  name: RemoveAll(Delegate, Delegate)
  fullName: System.Delegate.RemoveAll(System.Delegate, System.Delegate)
  type: Method
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RemoveAll
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 735
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</p>\n"
  remarks: "\n<p>If the invocation list of <em>value</em> matches a contiguous set of elements in the invocation list of <em>source</em>, then the invocation list of <em>value</em> is said to occur within the invocation list of <em>source</em>. If the invocation list of <em>value</em> occurs more than once in the invocation list of <em>source</em>, all occurrences are removed.</p>\n"
  syntax:
    content: public static Delegate RemoveAll(Delegate source, Delegate value)
    content.vb: 'Public Shared Function RemoveAll(source As  Delegate, value As  Delegate) As '
    parameters:
    - id: source
      type: System.Delegate
      description: "\n<p>The delegate from which to remove the invocation list of <em>value</em>. </p>\n"
    - id: value
      type: System.Delegate
      description: "\n<p>The delegate that supplies the invocation list to remove from the invocation list of <em>source</em>. </p>\n"
    return:
      type: System.Delegate
      description: "\n<p>A new delegate with an invocation list formed by taking the invocation list of <em>source</em> and removing all occurrences of the invocation list of <em>value</em>, if the invocation list of <em>value</em> is found within the invocation list of <em>source</em>. Returns <em>source</em> if <em>value</em> is <strong>null</strong> or if the invocation list of <em>value</em> is not found within the invocation list of <em>source</em>. Returns a null reference if the invocation list of <em>value</em> is equal to the invocation list of <em>source</em>, if <em>source</em> contains only a series of invocation lists that are equal to the invocation list of <em>value</em>, or if <em>source</em> is a null reference.</p>\n"
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "\n<p>The caller does not have access to the method represented by the delegate (for example, if the method is private). </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The delegate types do not match.</p>\n"
  seealso:
  - type: System.Delegate.Remove(System.Delegate,System.Delegate)
    commentId: M:System.Delegate.Remove(System.Delegate,System.Delegate)
  - type: System.Delegate.RemoveImpl(System.Delegate)
    commentId: M:System.Delegate.RemoveImpl(System.Delegate)
  - type: System.Delegate.Equals(System.Object)
    commentId: M:System.Delegate.Equals(System.Object)
  see:
  - type: System.Security.Permissions.ReflectionPermission
    commentId: T:System.Security.Permissions.ReflectionPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: false
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: false
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: false
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: false
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Object.ToString
  parent: System.Object
  isExternal: false
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Delegate
  parent: System
  isExternal: false
  name: Delegate
  fullName: System.Delegate
- uid: System.Delegate[]
  isExternal: false
  name: Delegate[]
  fullName: System.Delegate[]
  fullname.vb: System.Delegate()
  name.vb: Delegate()
  spec.csharp:
  - uid: System.Delegate
    name: Delegate
    fullName: System.Delegate
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Delegate
    name: Delegate
    fullName: System.Delegate
  - name: ()
    fullName: ()
- uid: System.Object[]
  isExternal: false
  name: Object[]
  fullName: System.Object[]
  fullname.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ()
    fullName: ()
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: false
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: false
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.MemberAccessException
  parent: System
  isExternal: false
  name: MemberAccessException
  fullName: System.MemberAccessException
- uid: System.Reflection.TargetInvocationException
  isExternal: false
  name: TargetInvocationException
  fullName: System.Reflection.TargetInvocationException
