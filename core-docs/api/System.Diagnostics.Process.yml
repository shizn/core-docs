items:
- uid: System.Diagnostics.Process
  commentId: T:System.Diagnostics.Process
  id: Process
  parent: System.Diagnostics
  children:
  - System.Diagnostics.Process.#ctor
  - System.Diagnostics.Process.BasePriority
  - System.Diagnostics.Process.BeginErrorReadLine
  - System.Diagnostics.Process.BeginOutputReadLine
  - System.Diagnostics.Process.CancelErrorRead
  - System.Diagnostics.Process.CancelOutputRead
  - System.Diagnostics.Process.Dispose
  - System.Diagnostics.Process.Dispose(System.Boolean)
  - System.Diagnostics.Process.EnableRaisingEvents
  - System.Diagnostics.Process.EnterDebugMode
  - System.Diagnostics.Process.ErrorDataReceived
  - System.Diagnostics.Process.ExitCode
  - System.Diagnostics.Process.Exited
  - System.Diagnostics.Process.ExitTime
  - System.Diagnostics.Process.GetCurrentProcess
  - System.Diagnostics.Process.GetProcessById(System.Int32)
  - System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - System.Diagnostics.Process.GetProcesses
  - System.Diagnostics.Process.GetProcesses(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String)
  - System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  - System.Diagnostics.Process.HasExited
  - System.Diagnostics.Process.Id
  - System.Diagnostics.Process.Kill
  - System.Diagnostics.Process.LeaveDebugMode
  - System.Diagnostics.Process.MachineName
  - System.Diagnostics.Process.MainModule
  - System.Diagnostics.Process.MaxWorkingSet
  - System.Diagnostics.Process.MinWorkingSet
  - System.Diagnostics.Process.Modules
  - System.Diagnostics.Process.NonpagedSystemMemorySize64
  - System.Diagnostics.Process.OnExited
  - System.Diagnostics.Process.OutputDataReceived
  - System.Diagnostics.Process.PagedMemorySize64
  - System.Diagnostics.Process.PagedSystemMemorySize64
  - System.Diagnostics.Process.PeakPagedMemorySize64
  - System.Diagnostics.Process.PeakVirtualMemorySize64
  - System.Diagnostics.Process.PeakWorkingSet64
  - System.Diagnostics.Process.PriorityBoostEnabled
  - System.Diagnostics.Process.PriorityClass
  - System.Diagnostics.Process.PrivateMemorySize64
  - System.Diagnostics.Process.PrivilegedProcessorTime
  - System.Diagnostics.Process.ProcessName
  - System.Diagnostics.Process.ProcessorAffinity
  - System.Diagnostics.Process.Refresh
  - System.Diagnostics.Process.SafeHandle
  - System.Diagnostics.Process.SessionId
  - System.Diagnostics.Process.StandardError
  - System.Diagnostics.Process.StandardInput
  - System.Diagnostics.Process.StandardOutput
  - System.Diagnostics.Process.Start
  - System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  - System.Diagnostics.Process.Start(System.String)
  - System.Diagnostics.Process.Start(System.String,System.String)
  - System.Diagnostics.Process.StartInfo
  - System.Diagnostics.Process.StartTime
  - System.Diagnostics.Process.Threads
  - System.Diagnostics.Process.TotalProcessorTime
  - System.Diagnostics.Process.UserProcessorTime
  - System.Diagnostics.Process.VirtualMemorySize64
  - System.Diagnostics.Process.WaitForExit
  - System.Diagnostics.Process.WaitForExit(System.Int32)
  - System.Diagnostics.Process.WorkingSet64
  langs:
  - csharp
  - vb
  name: Process
  fullName: System.Diagnostics.Process
  type: Class
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Process
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 20
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Provides access to local and remote processes and enables you to start and stop local system processes.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p>A <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component provides access to a process that is running on a computer. A process, in the simplest terms, is a running app. A thread is the basic unit to which the operating system allocates processor time. A thread can execute any part of the code of the process, including parts currently being executed by another thread.</p>\n<p>The <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component is a useful tool for starting, stopping, controlling, and monitoring apps. You can use the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, to obtain a list of the processes that are running, or you can start a new process. A <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component is used to access system processes. After a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component has been initialized, it can be used to obtain information about the running process. Such information includes the set of threads, the loaded modules (.dll and .exe files), and performance information such as the amount of memory the process is using.</p>\n<p>This type implements the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref href=\"System.IDisposable.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method in a <strong>try</strong>/<strong>catch</strong> block. To dispose of it indirectly, use a language construct such as <strong>using</strong> (in C#) or <strong>Using</strong> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface topic.</p>\n<p>32-bit processes cannot access the modules of a 64-bit process. If you try to get information about a 64-bit process from a 32-bit process, you will get a <xref href=\"System.ComponentModel.Win32Exception\" data-throw-if-not-resolved=\"false\"></xref> exception. A 64-bit process, on the other hand, can access the modules of a 32-bit process.</p>\n<p>The process component obtains information about a group of properties all at once. After the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component has obtained information about one member of any group, it will cache the values for the other properties in that group and not obtain new information about the other members of the group until you call the <xref href=\"System.Diagnostics.Process.Refresh\" data-throw-if-not-resolved=\"false\"></xref> method. Therefore, a property value is not guaranteed to be any newer than the last call to the <xref href=\"System.Diagnostics.Process.Refresh\" data-throw-if-not-resolved=\"false\"></xref> method. The group breakdowns are operating-system dependent.</p>\n<p>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if <code>c:\\mypath</code> is not in your path, and you add it using quotation marks: <code>path = %path%;\"c:\\mypath\"</code>, you must fully qualify any process in <code>c:\\mypath</code> when starting it.</p>\n<p>A system process is uniquely identified on the system by its process identifier. Like many Windows resources, a process is also identified by its handle, which might not be unique on the computer. A handle is the generic term for an identifier of a resource. The operating system persists the process handle, which is accessed through the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> property of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, even when the process has exited. Thus, you can get the process's administrative information, such as the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> (usually either zero for success or a nonzero error code) and the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref>. Handles are an extremely valuable resource, so leaking handles is more virulent than leaking memory.</p>\n<p>This class contains a link demand and an inheritance demand at the class level that applies to all members. A <xref href=\"System.Security.SecurityException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when either the immediate caller or the derived class does not have full-trust permission. For details about security demands, see Link Demands.</p>\n"
  example:
  - <p>The following example uses an instance of the <xref href="System.Diagnostics.Process" data-throw-if-not-resolved="false"></xref> class to start a process.</p>Process.Start_instance#1<p>The following example uses the <xref href="System.Diagnostics.Process" data-throw-if-not-resolved="false"></xref> class itself and a static <xref href="System.Diagnostics.Process.Start" data-throw-if-not-resolved="false"></xref> method to start a process.</p>Process.Start_static#1
  - '<p>The following F# example defines a <code>runProc</code> function that starts a process, captures all output and error information, and records the number of milliseconds that the process has run.  The <code>runProc</code> function has three parameters: the name of application to launch, the arguments to supply to the application, and the starting directory. </p>System.Diagnostics.Process#1<p>The code for the <code>runProc</code> function was written by <see href="http://fssnip.net/authors/ImaginaryDevelopment">ImaginaryDevelopment</see>  and is available under the <see href="http://opensource.org/licenses/ms-pl">Microsoft Public License</see>. </p>'
  syntax:
    content: 'public class Process : IDisposable'
    content.vb: >-
      Public Class Process
          Implements IDisposable
  seealso:
  - type: System.Diagnostics.Process.Start
    commentId: M:System.Diagnostics.Process.Start
  - type: System.Diagnostics.ProcessStartInfo
    commentId: T:System.Diagnostics.ProcessStartInfo
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  - type: System.Diagnostics.ProcessThread
    commentId: T:System.Diagnostics.ProcessThread
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  - type: System.Security.Permissions.SecurityAction.InheritanceDemand
    commentId: F:System.Security.Permissions.SecurityAction.InheritanceDemand
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Diagnostics.Process.#ctor
  commentId: M:System.Diagnostics.Process.#ctor
  id: '#ctor'
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Process()
  fullName: System.Diagnostics.Process.Process()
  type: Constructor
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 93
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>If you do not specify the <xref href=\"System.Diagnostics.Process.MachineName\" data-throw-if-not-resolved=\"false\"></xref> property, the default is the local computer, (\".\").</p>\n<p>You have two options for associating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component with a process on the computer. The first option is to use the constructor to create the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, set the appropriate members of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property and call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> to associate the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> with a new system process. The second option is to associate the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> with a running system process by using <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> or one of the <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref> return values.</p>\n<p>If you use a <strong>static</strong> overload of the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method to start a new system process, the method creates a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component and associates it with the process.</p>\n<p>When the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property is set to its default value, <strong>true</strong>, you can start applications and documents in a way that is similar to using the <strong>Run</strong> dialog box of the Windows <strong>Start</strong> menu. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, you can start only executables.</p>\n<p>Any executable file that you can call from the command line can be started in one of two ways: by setting the appropriate members of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property and calling the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method with no parameters, or by passing the appropriate parameter to the <strong>static</strong><xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> member.</p>\n<p>You can create a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component by using the constructor, one of the static <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> overloads, or any of the <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods. After you have done so, you have a view into the associated process. This is not a dynamic view that updates itself automatically when the process properties have changed in memory. Instead, you must call <xref href=\"System.Diagnostics.Process.Refresh\" data-throw-if-not-resolved=\"false\"></xref> for the component to update the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> property information in your application.</p>\n"
  syntax:
    content: public Process()
    content.vb: Public Sub New
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.BasePriority
  commentId: P:System.Diagnostics.Process.BasePriority
  id: BasePriority
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: BasePriority
  fullName: System.Diagnostics.Process.BasePriority
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: BasePriority
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 150
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the base priority of the associated process.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> of the process is the starting priority for threads created within the associated process. You can view information about the base priority through the System Monitor's Priority Base counter.</p>\n<p>Based on the time elapsed or other boosts, the operating system can change the base priority when a process should be placed ahead of others.</p>\n<p>The <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> property lets you view the starting priority assigned to a process. However, because it is read-only, you cannot use the <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> to set the priority of the process. To change the priority, use the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> property. The <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> is viewable using the System Monitor, while the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> is not. Both the <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> can be viewed programmatically. The following table shows the relationship between <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> values and <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n<p>BasePriority </p>\n<p>PriorityClass </p>\n<table><tbody><tr><td>\n<p>4 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.Idle\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>8 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.Normal\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>13 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.High\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>24 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.RealTime\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr></tbody></table>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public int BasePriority { get; }
    content.vb: Public ReadOnly Property BasePriority As Integer
    parameters: []
    return:
      type: System.Int32
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process has exited.</p>\n<p>-or- </p>\n<p>The process has not started, so there is no process ID. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.PriorityClass
    commentId: P:System.Diagnostics.Process.PriorityClass
  - type: System.Diagnostics.ProcessPriorityClass
    commentId: T:System.Diagnostics.ProcessPriorityClass
  - type: System.Diagnostics.ThreadPriorityLevel
    commentId: T:System.Diagnostics.ThreadPriorityLevel
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.EnableRaisingEvents
  commentId: P:System.Diagnostics.Process.EnableRaisingEvents
  id: EnableRaisingEvents
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: EnableRaisingEvents
  fullName: System.Diagnostics.Process.EnableRaisingEvents
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnableRaisingEvents
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 553
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets whether the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event should be raised when the process terminates.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property indicates whether the component should be notified when the operating system has shut down a process. The <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property is used in asynchronous processing to notify your application that a process has exited. To force your application to synchronously wait for an exit event (which interrupts processing of the application until the exit event has occurred), use the <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If you are using Visual Studio and double-click a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component in your project, an <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event delegate and event handler are automatically generated. Additional code sets the <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong>. You must change this property to <strong>true</strong> for your event handler to be executed when the associated process exits.</p>\n<p>When an associated process exits after being shut down by the operating system either through a normal or abnormal termination, the operating system notifies each process component to which the process was associated, as long as the component's <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> value is <strong>true</strong>. If a component started the process, the component can then access the administrative information for the associated process, which is still being stored by the operating system. Such information includes the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref>, and the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>After the associated process exits, the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> of the component no longer points to an existing process resource. Instead, it can be used only to access the operating system's information about the process resource. The operating system is aware that there are handles to exited processes that have not been released by <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components, so it keeps the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> information in memory.</p>\n<p>There is a cost associated with watching for a process to exit. If <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>, the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event is raised when the associated process terminates. The procedures that you have specified for the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event run at that time.</p>\n<p>Sometimes, your application starts a process but does not need to be notified of its closure. For example, your application can start Notepad to allow the user to perform text editing, but make no further use of the Notepad application. You can choose to not be notified when the process exits, because it is not relevant to the continued operation of your application. Setting <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> saves system resources.</p>\n"
  example:
  - "\n<p>The following code example creates a process that prints a file. It sets the <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property to cause the process to raise the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event when it exits. The <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event handler displays process information.</p>System.Diagnostics.Process.EnableExited#1"
  syntax:
    content: public bool EnableRaisingEvents { get; set; }
    content.vb: Public Property EnableRaisingEvents As Boolean
    parameters: []
    return:
      type: System.Boolean
  seealso:
  - type: System.Diagnostics.Process.WaitForExit(System.Int32)
    commentId: M:System.Diagnostics.Process.WaitForExit(System.Int32)
  - type: System.Diagnostics.Process.Exited
    commentId: E:System.Diagnostics.Process.Exited
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  - type: System.Diagnostics.Process.Handle
    commentId: P:System.Diagnostics.Process.Handle
  - type: System.Diagnostics.Process.ExitTime
    commentId: P:System.Diagnostics.Process.ExitTime
  - type: System.Diagnostics.Process.HasExited
    commentId: P:System.Diagnostics.Process.HasExited
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.ExitCode
  commentId: P:System.Diagnostics.Process.ExitCode
  id: ExitCode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: ExitCode
  fullName: System.Diagnostics.Process.ExitCode
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExitCode
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 166
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the value that the associated process specified when it terminated.</p>\n"
  remarks: "\n<p>Use <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> to get the status that the system process returned when it exited. You can use the exit code much like an integer return value from a <code>main()</code> procedure. </p>\n<p>The <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> value for a process reflects the specific convention implemented by the application developer for that process. If you use the exit code value to make decisions in your code, be sure that you know the exit code convention used by the application process.</p>\n<p>Developers usually indicate a successful exit by an <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> value of zero, and designate errors by nonzero values that the calling method can use to identify the cause of an abnormal process termination. It is not necessary to follow these guidelines, but they are the convention.</p>\n<p>If you try to get the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> before the process has exited, the attempt throws an exception. Examine the <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property first to verify whether the associated process has terminated.</p>\n<p>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>true</strong>. To ensure that asynchronous event handling has been completed, call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> overload that takes no parameter before checking <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You can use the <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or the <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> method to cause an associated process to exit.</p>\n<p>There are two ways of being notified when the associated process exits: synchronously and asynchronously. Synchronous notification relies on calling the <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to pause the processing of your application until the associated component exits. Asynchronous notification relies on the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event. When using asynchronous notification, <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> must be set to <strong>true</strong> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component to receive notification that the process has exited.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public int ExitCode { get; }
    content.vb: Public ReadOnly Property ExitCode As Integer
    parameters: []
    return:
      type: System.Int32
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process has not exited.</p>\n<p>-or- </p>\n<p>The process <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> is not valid. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.HasExited
    commentId: P:System.Diagnostics.Process.HasExited
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  - type: System.Diagnostics.Process.WaitForExit(System.Int32)
    commentId: M:System.Diagnostics.Process.WaitForExit(System.Int32)
  - type: System.Diagnostics.Process.EnableRaisingEvents
    commentId: P:System.Diagnostics.Process.EnableRaisingEvents
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.ExitTime
  commentId: P:System.Diagnostics.Process.ExitTime
  id: ExitTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: ExitTime
  fullName: System.Diagnostics.Process.ExitTime
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExitTime
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 203
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the time that the associated process exited.</p>\n"
  remarks: "\n<p>If the process has not terminated, attempting to retrieve the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> property throws an exception. Use <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> before getting the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether the associated process has terminated.</p>\n"
  example:
  - "\n<p>The following code example creates a process that prints a file. The process raises the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event when it exits, and the event handler displays the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> property and other process information.</p>System.Diagnostics.Process.EnableExited#1"
  syntax:
    content: public DateTime ExitTime { get; }
    content.vb: Public ReadOnly Property ExitTime As Date
    parameters: []
    return:
      type: System.DateTime
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.Handle
    commentId: P:System.Diagnostics.Process.Handle
  - type: System.Diagnostics.Process.ExitCode
    commentId: P:System.Diagnostics.Process.ExitCode
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.HasExited
  commentId: P:System.Diagnostics.Process.HasExited
  id: HasExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: HasExited
  fullName: System.Diagnostics.Process.HasExited
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: HasExited
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 181
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets a value indicating whether the associated process has been terminated.</p>\n"
  remarks: "\n<p>A value of <strong>true</strong> for <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> indicates that the associated process has terminated, either normally or abnormally. You can request or force the associated process to exit by calling <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. If a handle is open to the process, the operating system releases the process memory when the process has exited, but retains administrative information about the process, such as the handle, exit code, and exit time. To get this information, you can use the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> properties. These properties are populated automatically for processes that were started by this component. The administrative information is released when all the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components that are associated with the system process are destroyed and hold no more handles to the exited process.</p>\n<p>A process can terminate independently of your code. If you started the process using this component, the system updates the value of <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> automatically, even if the associated process exits independently.</p>\n<p>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this property returns <strong>true</strong>. To ensure that asynchronous event handling has been completed, call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> overload that takes no parameter before checking <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.</p>process_refresh#1"
  syntax:
    content: public bool HasExited { get; }
    content.vb: Public ReadOnly Property HasExited As Boolean
    parameters: []
    return:
      type: System.Boolean
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There is no process associated with the object. </p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>The exit code for the process could not be retrieved. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.ExitCode
    commentId: P:System.Diagnostics.Process.ExitCode
  - type: System.Diagnostics.Process.ExitTime
    commentId: P:System.Diagnostics.Process.ExitTime
  - type: System.Diagnostics.Process.WaitForExit(System.Int32)
    commentId: M:System.Diagnostics.Process.WaitForExit(System.Int32)
  - type: System.Diagnostics.Process.EnableRaisingEvents
    commentId: P:System.Diagnostics.Process.EnableRaisingEvents
  - type: System.Diagnostics.Process.OnExited
    commentId: M:System.Diagnostics.Process.OnExited
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.Id
  commentId: P:System.Diagnostics.Process.Id
  id: Id
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Id
  fullName: System.Diagnostics.Process.Id
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Id
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 223
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the unique identifier for the associated process.</p>\n"
  remarks: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not valid if the associated process is not running. Therefore, you should ensure that the process is running before attempting to retrieve the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property. Until the process terminates, the process identifier uniquely identifies the process throughout the system.</p>\n<p>You can connect a process that is running on a local or remote computer to a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance by passing the process identifier to the <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> is a <strong>static</strong> method that creates a new component and sets the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property for the new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance automatically.</p>\n<p>Process identifiers can be reused by the system. The <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property value is unique only while the associated process is running. After the process has terminated, the system can reuse the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property value for an unrelated process.</p>\n<p>Because the identifier is unique on the system, you can pass it to other threads as an alternative to passing a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. This action can save system resources yet guarantee that the process is correctly identified.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to obtain the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> for all running instances of an application. The code creates a new instance of Notepad, lists all the instances of Notepad, and then allows the user to enter the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> number to remove a specific instance.</p>System.Diagnostics.Process.Id#1"
  syntax:
    content: public int Id { get; }
    content.vb: Public ReadOnly Property Id As Integer
    parameters: []
    return:
      type: System.Int32
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process's <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property has not been set.</p>\n<p>-or- </p>\n<p>There is no process associated with this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set the <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.Handle
    commentId: P:System.Diagnostics.Process.Handle
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.MachineName
  commentId: P:System.Diagnostics.Process.MachineName
  id: MachineName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: MachineName
  fullName: System.Diagnostics.Process.MachineName
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MachineName
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 238
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the name of the computer the associated process is running on.</p>\n"
  remarks: "\n<p>You can view statistical data and process information for processes running on remote computers but you cannot call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> on remote computers.</p>\n<p>When the associated process is executing on the local machine, this property returns a period (\".\") for the machine name. You should use the <xref href=\"System.Environment.MachineName\" data-throw-if-not-resolved=\"false\"></xref> property to get the correct machine name. </p>\n"
  example:
  - "\n<p>To use the following example you must first start at least one instance of Notepad on a remote computer. The example requests the name of the remote computer on which Notepad is running, and then displays the respective <xref href=\"System.Diagnostics.Process.ProcessName\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Diagnostics.Process.MachineName\" data-throw-if-not-resolved=\"false\"></xref> properties for each instance.</p>process_GetProcessesByName2_2#2"
  syntax:
    content: public string MachineName { get; }
    content.vb: Public ReadOnly Property MachineName As String
    parameters: []
    return:
      type: System.String
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There is no process associated with this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.MainModule
  commentId: P:System.Diagnostics.Process.MainModule
  id: MainModule
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: MainModule
  fullName: System.Diagnostics.Process.MainModule
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MainModule
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 34
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the main module for the associated process.</p>\n"
  remarks: "\n<p>A process module represents a.dll or .exe file that is loaded into a particular process. The <xref href=\"System.Diagnostics.Process.MainModule\" data-throw-if-not-resolved=\"false\"></xref> property lets you view information about the executable used to start the process, including the module name, file name, and module memory details.</p>\n"
  syntax:
    content: public ProcessModule MainModule { get; }
    content.vb: Public ReadOnly Property MainModule As ProcessModule
    parameters: []
    return:
      type: System.Diagnostics.ProcessModule
      description: "\n<p>The <xref href=\"System.Diagnostics.ProcessModule\" data-throw-if-not-resolved=\"false\"></xref> that was used to start the process.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.MainModule\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>A 32-bit process is trying to access the modules of a 64-bit process.</p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n<p>-or- </p>\n<p>The process has exited. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.Modules
    commentId: P:System.Diagnostics.Process.Modules
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.MaxWorkingSet
  commentId: P:System.Diagnostics.Process.MaxWorkingSet
  id: MaxWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: MaxWorkingSet
  fullName: System.Diagnostics.Process.MaxWorkingSet
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MaxWorkingSet
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 253
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the maximum allowable working set size, in bytes, for the associated process.</p>\n"
  remarks: "\n<p>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</p>\n<p>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files. As the working set size increases, memory demand increases.</p>\n<p>A process has minimum and maximum working set sizes. Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process. The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</p>\n<p>The system sets the default working set sizes. You can modify these sizes using the <xref href=\"System.Diagnostics.Process.MaxWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.MinWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> members. However, setting these values does not guarantee that the memory will be reserved or resident.</p>\n<p>When you increase the working set size of a process, you take physical memory away from the rest of the system. Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</p>\n"
  syntax:
    content: public IntPtr MaxWorkingSet { get; set; }
    content.vb: Public Property MaxWorkingSet As IntPtr
    parameters: []
    return:
      type: System.IntPtr
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The maximum working set size is invalid. It must be greater than or equal to the minimum working set size.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>Working set information cannot be retrieved from the associated process resource.</p>\n<p>-or- </p>\n<p>The process identifier or process handle is zero because the process has not been started. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.MaxWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n<p>-or- </p>\n<p>The process has exited. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.MinWorkingSet
    commentId: P:System.Diagnostics.Process.MinWorkingSet
  - type: System.Diagnostics.Process.WorkingSet64
    commentId: P:System.Diagnostics.Process.WorkingSet64
  - type: System.Diagnostics.Process.PeakWorkingSet64
    commentId: P:System.Diagnostics.Process.PeakWorkingSet64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.MinWorkingSet
  commentId: P:System.Diagnostics.Process.MinWorkingSet
  id: MinWorkingSet
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: MinWorkingSet
  fullName: System.Diagnostics.Process.MinWorkingSet
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MinWorkingSet
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 272
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the minimum allowable working set size, in bytes, for the associated process.</p>\n"
  remarks: "\n<p>The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</p>\n<p>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that your application executes, including the pages in your .dll files and the system.dll files. As the working set size increases, memory demand increases.</p>\n<p>A process has minimum and maximum working set sizes. Each time a process resource is created, the system reserves an amount of memory equal to the minimum working set size for the process. The virtual memory manager attempts to keep at least the minimum amount of memory resident when the process is active, but it never keeps more than the maximum size.</p>\n<p>The system sets the default working set sizes. You can modify these sizes using the <xref href=\"System.Diagnostics.Process.MaxWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.MinWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> members. However, setting these values does not guarantee that the memory will be reserved or resident.</p>\n<p>When you increase the working set size of a process, you take physical memory away from the rest of the system. Ensure that you do not request a minimum or maximum working set size that is too large, because doing so can degrade system performance.</p>\n"
  syntax:
    content: public IntPtr MinWorkingSet { get; set; }
    content.vb: Public Property MinWorkingSet As IntPtr
    parameters: []
    return:
      type: System.IntPtr
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The minimum working set size is invalid. It must be less than or equal to the maximum working set size.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>Working set information cannot be retrieved from the associated process resource.</p>\n<p>-or- </p>\n<p>The process identifier or process handle is zero because the process has not been started. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are trying to access the <xref href=\"System.Diagnostics.Process.MinWorkingSet\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n<p>-or- </p>\n<p>The process has exited.</p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.MaxWorkingSet
    commentId: P:System.Diagnostics.Process.MaxWorkingSet
  - type: System.Diagnostics.Process.WorkingSet64
    commentId: P:System.Diagnostics.Process.WorkingSet64
  - type: System.Diagnostics.Process.PeakWorkingSet64
    commentId: P:System.Diagnostics.Process.PeakWorkingSet64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Modules
  commentId: P:System.Diagnostics.Process.Modules
  id: Modules
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Modules
  fullName: System.Diagnostics.Process.Modules
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Modules
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 285
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the modules that have been loaded by the associated process.</p>\n"
  remarks: "\n<p>A process module represents a.dll or .exe file that is loaded into a particular process. A <xref href=\"System.Diagnostics.ProcessModule\" data-throw-if-not-resolved=\"false\"></xref> instance lets you view information about a module, including the module name, file name, and module memory details.</p>\n<p>A process can load multiple modules into memory. For example,.exe files that load additional .dll files have multiple modules.</p>\n<p>After starting the process, this collection is empty until the system has loaded the process. If the process has a main window, you can call <xref href=\"System.Diagnostics.Process.WaitForInputIdle(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> before retrieving this property to ensure that the collection is nonempty when you get the list.</p>\n"
  syntax:
    content: public ProcessModuleCollection Modules { get; }
    content.vb: Public ReadOnly Property Modules As ProcessModuleCollection
    parameters: []
    return:
      type: System.Diagnostics.ProcessModuleCollection
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.Modules\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.Modules\" data-throw-if-not-resolved=\"false\"></xref> property for either the system process or the idle process. These processes do not have modules.</p>\n"
  seealso:
  - type: System.Diagnostics.ProcessModule
    commentId: T:System.Diagnostics.ProcessModule
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.NonpagedSystemMemorySize64
  commentId: P:System.Diagnostics.Process.NonpagedSystemMemorySize64
  id: NonpagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: NonpagedSystemMemorySize64
  fullName: System.Diagnostics.Process.NonpagedSystemMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NonpagedSystemMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 305
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of nonpaged system memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the current size of nonpaged system memory used by the process, in bytes. System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools. Nonpaged memory allocations remain in system memory and are not paged out to the virtual memory paging file.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Pool Nonpaged Bytes performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long NonpagedSystemMemorySize64 { get; }
    content.vb: Public ReadOnly Property NonpagedSystemMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PagedSystemMemorySize64
    commentId: P:System.Diagnostics.Process.PagedSystemMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PagedMemorySize64
  commentId: P:System.Diagnostics.Process.PagedMemorySize64
  id: PagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PagedMemorySize64
  fullName: System.Diagnostics.Process.PagedMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PagedMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 314
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of paged memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the current size of memory in the virtual memory paging file used by the process, in bytes. The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk. To obtain the size of memory used by the operating system for the process, use the <xref href=\"System.Diagnostics.Process.PagedSystemMemorySize64\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Page File Bytes performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application, and then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PagedMemorySize64 { get; }
    content.vb: Public ReadOnly Property PagedMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PeakPagedMemorySize64
    commentId: P:System.Diagnostics.Process.PeakPagedMemorySize64
  - type: System.Diagnostics.Process.PagedSystemMemorySize64
    commentId: P:System.Diagnostics.Process.PagedSystemMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PagedSystemMemorySize64
  commentId: P:System.Diagnostics.Process.PagedSystemMemorySize64
  id: PagedSystemMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PagedSystemMemorySize64
  fullName: System.Diagnostics.Process.PagedSystemMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PagedSystemMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 323
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of pageable system memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property value represents the current size of pageable system memory used by the process, in bytes. System memory is the physical memory used by the operating system, and is divided into paged and nonpaged pools. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk. To obtain the size of the application memory used by the process, use the <xref href=\"System.Diagnostics.Process.PagedMemorySize64\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Pool Paged Bytes performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PagedSystemMemorySize64 { get; }
    content.vb: Public ReadOnly Property PagedSystemMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PagedSystemMemorySize64
    commentId: P:System.Diagnostics.Process.PagedSystemMemorySize64
  - type: System.Diagnostics.Process.NonpagedSystemMemorySize64
    commentId: P:System.Diagnostics.Process.NonpagedSystemMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PeakPagedMemorySize64
  commentId: P:System.Diagnostics.Process.PeakPagedMemorySize64
  id: PeakPagedMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PeakPagedMemorySize64
  fullName: System.Diagnostics.Process.PeakPagedMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PeakPagedMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 332
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the maximum amount of memory in the virtual memory paging file, in bytes, used by the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property value represents the maximum size of memory in the virtual memory paging file used by the process since it started, in bytes. The operating system uses the virtual memory paging file in conjunction with physical memory to manage the virtual address space for each process. When pageable memory is not in use, it can be transferred to the virtual memory paging file on disk.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Page File Bytes Peak performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PeakPagedMemorySize64 { get; }
    content.vb: Public ReadOnly Property PeakPagedMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PagedMemorySize64
    commentId: P:System.Diagnostics.Process.PagedMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PeakVirtualMemorySize64
  commentId: P:System.Diagnostics.Process.PeakVirtualMemorySize64
  id: PeakVirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PeakVirtualMemorySize64
  fullName: System.Diagnostics.Process.PeakVirtualMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PeakVirtualMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 350
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the maximum amount of virtual memory, in bytes, used by the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the maximum size of virtual memory used by the process since it started, in bytes. The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Virtual Bytes Peak performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PeakVirtualMemorySize64 { get; }
    content.vb: Public ReadOnly Property PeakVirtualMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.VirtualMemorySize64
    commentId: P:System.Diagnostics.Process.VirtualMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PeakWorkingSet64
  commentId: P:System.Diagnostics.Process.PeakWorkingSet64
  id: PeakWorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PeakWorkingSet64
  fullName: System.Diagnostics.Process.PeakWorkingSet64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PeakWorkingSet64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 341
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the maximum amount of physical memory, in bytes, used by the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the maximum size of working set memory used by the process since it started, in bytes. The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</p>\n<p>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including instructions from the process modules and the system libraries.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Working Set Peak performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PeakWorkingSet64 { get; }
    content.vb: Public ReadOnly Property PeakWorkingSet64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.WorkingSet64
    commentId: P:System.Diagnostics.Process.WorkingSet64
  - type: System.Diagnostics.Process.MinWorkingSet
    commentId: P:System.Diagnostics.Process.MinWorkingSet
  - type: System.Diagnostics.Process.MaxWorkingSet
    commentId: P:System.Diagnostics.Process.MaxWorkingSet
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PriorityBoostEnabled
  commentId: P:System.Diagnostics.Process.PriorityBoostEnabled
  id: PriorityBoostEnabled
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PriorityBoostEnabled
  fullName: System.Diagnostics.Process.PriorityBoostEnabled
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PriorityBoostEnabled
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 366
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets a value indicating whether the associated process priority should temporarily be boosted by the operating system when the main window has the focus.</p>\n"
  remarks: "\n<p>When a thread runs in a process for which the priority class has one of the dynamic priority enumeration values (<xref href=\"System.Diagnostics.ProcessPriorityClass.Normal\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessPriorityClass.High\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.ProcessPriorityClass.RealTime\" data-throw-if-not-resolved=\"false\"></xref>), the system temporarily boosts the thread's priority when it is taken out of a wait state. This action prevents other processes from interrupting the processing of the current thread. The <xref href=\"System.Diagnostics.Process.PriorityBoostEnabled\" data-throw-if-not-resolved=\"false\"></xref> setting affects all the existing threads and any threads subsequently created by the process. To restore normal behavior, set the <xref href=\"System.Diagnostics.Process.PriorityBoostEnabled\" data-throw-if-not-resolved=\"false\"></xref> property to <strong>false</strong>.</p>\n<p>Boosting the priority too high can drain resources from essential operating system and network functions, causing problems with other operating system tasks.</p>\n"
  syntax:
    content: public bool PriorityBoostEnabled { get; set; }
    content.vb: Public Property PriorityBoostEnabled As Boolean
    parameters: []
    return:
      type: System.Boolean
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>Priority boost information could not be retrieved from the associated process resource. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n<p>-or- </p>\n<p>The process identifier or process handle is zero. (The process has not been started.) </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.PriorityBoostEnabled\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PriorityClass
    commentId: P:System.Diagnostics.Process.PriorityClass
  - type: System.Diagnostics.Process.BasePriority
    commentId: P:System.Diagnostics.Process.BasePriority
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.PriorityClass
  commentId: P:System.Diagnostics.Process.PriorityClass
  id: PriorityClass
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PriorityClass
  fullName: System.Diagnostics.Process.PriorityClass
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PriorityClass
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 391
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the overall priority category for the associated process.</p>\n"
  remarks: "\n<p>A process priority class encompasses a range of thread priority levels. Threads with different priorities that are running in the process run relative to the priority class of the process. Win32 uses four priority classes with seven base priority levels per class. These process priority classes are captured in the <xref href=\"System.Diagnostics.ProcessPriorityClass\" data-throw-if-not-resolved=\"false\"></xref> enumeration, which lets you set the process priority to <xref href=\"System.Diagnostics.ProcessPriorityClass.Idle\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessPriorityClass.Normal\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessPriorityClass.High\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessPriorityClass.AboveNormal\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessPriorityClass.BelowNormal\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.ProcessPriorityClass.RealTime\" data-throw-if-not-resolved=\"false\"></xref>. Based on the time elapsed or other boosts, the base priority level can be changed by the operating system when a process needs to be put ahead of others for access to the processor. In addition, you can set the <xref href=\"System.Diagnostics.Process.PriorityBoostEnabled\" data-throw-if-not-resolved=\"false\"></xref> to temporarily boost the priority level of threads that have been taken out of the wait state. The priority is reset when the process returns to the wait state.</p>\n<p>The <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> property lets you view the starting priority that is assigned to a process. However, because it is read-only, you cannot use the <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> property to set the priority of a process. To change the priority, use the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> property, which gets or sets the overall priority category for the process.</p>\n<p>The priority class cannot be viewed using System Monitor. The following table shows the relationship between the <xref href=\"System.Diagnostics.Process.BasePriority\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n<p>BasePriority </p>\n<p>PriorityClass </p>\n<table><tbody><tr><td>\n<p>4 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.Idle\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>8 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.Normal\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>13 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.High\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>24 </p>\n</td><td>\n<p>\n<xref href=\"System.Diagnostics.ProcessPriorityClass.RealTime\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr></tbody></table>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public ProcessPriorityClass PriorityClass { get; set; }
    content.vb: Public Property PriorityClass As ProcessPriorityClass
    parameters: []
    return:
      type: System.Diagnostics.ProcessPriorityClass
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>Process priority information could not be set or retrieved from the associated process resource.</p>\n<p>-or- </p>\n<p>The process identifier or process handle is zero. (The process has not been started.) </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is not available.</p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>You have set the <xref href=\"System.Diagnostics.Process.PriorityClass\" data-throw-if-not-resolved=\"false\"></xref> to <strong>AboveNormal</strong> or <strong>BelowNormal</strong> when using Windows 98 or Windows Millennium Edition (Windows Me). These platforms do not support those values for the priority class. </p>\n"
  - type: System.ComponentModel.InvalidEnumArgumentException
    commentId: T:System.ComponentModel.InvalidEnumArgumentException
    description: "\n<p>Priority class cannot be set because it does not use a valid value, as defined in the <xref href=\"System.Diagnostics.ProcessPriorityClass\" data-throw-if-not-resolved=\"false\"></xref> enumeration.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.BasePriority
    commentId: P:System.Diagnostics.Process.BasePriority
  - type: System.Diagnostics.Process.PriorityBoostEnabled
    commentId: P:System.Diagnostics.Process.PriorityBoostEnabled
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.PrivateMemorySize64
  commentId: P:System.Diagnostics.Process.PrivateMemorySize64
  id: PrivateMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PrivateMemorySize64
  fullName: System.Diagnostics.Process.PrivateMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PrivateMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 415
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of private memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the current size of memory used by the process, in bytes, that cannot be shared with other processes.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Private Bytes performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long PrivateMemorySize64 { get; }
    content.vb: Public ReadOnly Property PrivateMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.PrivilegedProcessorTime
  commentId: P:System.Diagnostics.Process.PrivilegedProcessorTime
  id: PrivilegedProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: PrivilegedProcessorTime
  fullName: System.Diagnostics.Process.PrivilegedProcessorTime
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PrivilegedProcessorTime
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 47
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the privileged processor time for this process.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public TimeSpan PrivilegedProcessorTime { get; }
    content.vb: Public ReadOnly Property PrivilegedProcessorTime As TimeSpan
    parameters: []
    return:
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that indicates the amount of time that the process has spent running code inside the operating system core.</p>\n"
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.PrivilegedProcessorTime\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.UserProcessorTime
    commentId: P:System.Diagnostics.Process.UserProcessorTime
  - type: System.Diagnostics.Process.PrivilegedProcessorTime
    commentId: P:System.Diagnostics.Process.PrivilegedProcessorTime
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.ProcessName
  commentId: P:System.Diagnostics.Process.ProcessName
  id: ProcessName
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: ProcessName
  fullName: System.Diagnostics.Process.ProcessName
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ProcessName
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 430
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the name of the process.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.ProcessName\" data-throw-if-not-resolved=\"false\"></xref> property holds an executable file name, such as Outlook, that does not include the .exe extension or the path. It is helpful for getting and manipulating all the processes that are associated with the same executable file.</p>\n<p>On Windows 2000 operating systems, the <xref href=\"System.Diagnostics.Process.ProcessName\" data-throw-if-not-resolved=\"false\"></xref> property may be truncated to 15 characters if the process module information cannot be obtained.</p>\n<p>You can call <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, passing it an executable file name, to retrieve an array that contains every running instance on the specified computer. You can use this array, for example, to shut down all the running instances of the executable file.</p>\n"
  syntax:
    content: public string ProcessName { get; }
    content.vb: Public ReadOnly Property ProcessName As String
    parameters: []
    return:
      type: System.String
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process does not have an identifier, or no process is associated with the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or- </p>\n<p>The associated process has exited. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The process is not on this computer.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.ProcessorAffinity
  commentId: P:System.Diagnostics.Process.ProcessorAffinity
  id: ProcessorAffinity
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: ProcessorAffinity
  fullName: System.Diagnostics.Process.ProcessorAffinity
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ProcessorAffinity
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 445
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the processors on which the threads in this process can be scheduled to run.</p>\n"
  remarks: "\n<p>In Windows 2000 and later, a thread in a process can migrate from processor to processor, with each migration reloading the processor cache. Under heavy system loads, specifying which processor should run a specific thread can improve performance by reducing the number of times the processor cache is reloaded. The association between a processor and a thread is called the processor affinity.</p>\n<p>Each processor is represented as a bit. Bit 0 is processor one, bit 1 is processor two, and so forth. If you set a bit to the value 1, the corresponding processor is selected for thread assignment. When you set the <xref href=\"System.Diagnostics.Process.ProcessorAffinity\" data-throw-if-not-resolved=\"false\"></xref> value to zero, the operating system's scheduling algorithms set the thread's affinity. When the <xref href=\"System.Diagnostics.Process.ProcessorAffinity\" data-throw-if-not-resolved=\"false\"></xref> value is set to any nonzero value, the value is interpreted as a bitmask that specifies those processors eligible for selection.</p>\n<p>The following table shows a selection of <xref href=\"System.Diagnostics.Process.ProcessorAffinity\" data-throw-if-not-resolved=\"false\"></xref> values for an eight-processor system.</p>\n<p>Bitmask </p>\n<p>Binary value </p>\n<p>Eligible processors </p>\n"
  syntax:
    content: public IntPtr ProcessorAffinity { get; set; }
    content.vb: Public Property ProcessorAffinity As IntPtr
    parameters: []
    return:
      type: System.IntPtr
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>\n<xref href=\"System.Diagnostics.Process.ProcessorAffinity\" data-throw-if-not-resolved=\"false\"></xref> information could not be set or retrieved from the associated process resource.</p>\n<p>-or- </p>\n<p>The process identifier or process handle is zero. (The process has not been started.) </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.ProcessorAffinity\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> was not available.</p>\n<p>-or- </p>\n<p>The process has exited. </p>\n"
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.SafeHandle
  commentId: P:System.Diagnostics.Process.SafeHandle
  id: SafeHandle
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: SafeHandle
  fullName: System.Diagnostics.Process.SafeHandle
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SafeHandle
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 126
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the native handle to this process.</p>\n"
  remarks: "\n<p>The handle is only available if the calling component started the process.</p>\n"
  syntax:
    content: public SafeProcessHandle SafeHandle { get; }
    content.vb: Public ReadOnly Property SafeHandle As SafeProcessHandle
    parameters: []
    return:
      type: Microsoft.Win32.SafeHandles.SafeProcessHandle
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.SessionId
  commentId: P:System.Diagnostics.Process.SessionId
  id: SessionId
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: SessionId
  fullName: System.Diagnostics.Process.SessionId
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SessionId
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 464
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the Terminal Services session identifier for the associated process.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.SessionId\" data-throw-if-not-resolved=\"false\"></xref> property identifies the session in which the application is currently running.</p>\n"
  syntax:
    content: public int SessionId { get; }
    content.vb: Public ReadOnly Property SessionId As Integer
    parameters: []
    return:
      type: System.Int32
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>There is no session associated with this process.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There is no process associated with this session identifier.</p>\n<p>-or-</p>\n<p>The associated process is not on this machine. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.SessionId\" data-throw-if-not-resolved=\"false\"></xref> property is not supported on Windows 98.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.StandardError
  commentId: P:System.Diagnostics.Process.StandardError
  id: StandardError
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: StandardError
  fullName: System.Diagnostics.Process.StandardError
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StandardError
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 625
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets a stream used to read the error output of the application.</p>\n"
  remarks: "\n<p>When a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes text to its standard error stream, that text is normally displayed on the console. By redirecting the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, you can manipulate or suppress the error output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</p>\n<p>To use <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref>, you must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong>, and you must set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, reading from the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n<p>The redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the error output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>Synchronous read operations introduce a dependency between the caller reading from the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream and the child process writing to that stream. These dependencies can result in deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits on the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits on the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed. You can avoid deadlocks by evaluating dependencies between the caller and child process.</p>\n<p>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</p>\n<pre><code>// Start the child process.\nProcess p = new Process();\n// Redirect the error stream of the child process.\np.StartInfo.UseShellExecute = false;\np.StartInfo.RedirectStandardError = true;\np.StartInfo.FileName = \"Write500Lines.exe\";\np.Start();\n// Do not wait for the child process to exit before\n// reading to the end of its redirected error stream.\n// p.WaitForExit();\n// Read the error stream first and then wait.\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids a deadlock condition by calling <code>p.StandardError.ReadToEnd</code> before <code>p.WaitForExit</code>. A deadlock condition can result if the parent process calls <code>p.WaitForExit</code> before <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>There is a similar issue when you read all text from both the standard output and standard error streams. The following C# code, for example, performs a read operation on both streams.</p>\n<pre><code> // Do not perform a synchronous read to the end of both \n// redirected streams.\n// string output = p.StandardOutput.ReadToEnd();\n// string error = p.StandardError.ReadToEnd();\n// p.WaitForExit();\n// Use asynchronous read operations on at least one of the streams.\np.BeginOutputReadLine();\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids the deadlock condition by performing asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. A deadlock condition results if the parent process calls <code>p.StandardOutput.ReadToEnd</code> followed by <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</p>\n<p>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> with a call to <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> and then call <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  example:
  - "\n<p>The following example uses the <strong>net use</strong> command together with a user supplied argument to map a network resource. It then reads the standard error stream of the net command and writes it to console.</p>Process_StandardError#1"
  syntax:
    content: public StreamReader StandardError { get; }
    content.vb: Public ReadOnly Property StandardError As StreamReader
    parameters: []
    return:
      type: System.IO.StreamReader
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream has not been defined for redirection; ensure <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> is set to <strong>true</strong> and <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is set to <strong>false</strong>.</p>\n<p>- or - </p>\n<p>The <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream has been opened for asynchronous read operations with <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.StandardInput
    commentId: P:System.Diagnostics.Process.StandardInput
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardError
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.StandardInput
  commentId: P:System.Diagnostics.Process.StandardInput
  id: StandardInput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: StandardInput
  fullName: System.Diagnostics.Process.StandardInput
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StandardInput
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 584
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets a stream used to write the input of the application.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> can read input text from its standard input stream, typically the keyboard. By redirecting the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream, you can programmatically specify the input. For example, instead of using keyboard input, you can provide text from the contents of a designated file or output from another application.</p>\n<p>To use <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref>, you must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong>, and you must set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, writing to the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n"
  example:
  - "\n<p>The following example illustrates how to redirect the <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream of a process. The example starts the <strong>sort</strong> command with redirected input. It then prompts the user for text, and passes that to the <strong>sort</strong> process by means of the redirected <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream. The <strong>sort</strong> results are displayed to the user on the console.</p>Process_StandardInput#1"
  syntax:
    content: public StreamWriter StandardInput { get; }
    content.vb: Public ReadOnly Property StandardInput As StreamWriter
    parameters: []
    return:
      type: System.IO.StreamWriter
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardInput\" data-throw-if-not-resolved=\"false\"></xref> stream has not been defined because <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref> is set to <strong>false</strong>. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardInput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.StandardOutput
  commentId: P:System.Diagnostics.Process.StandardOutput
  id: StandardOutput
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: StandardOutput
  fullName: System.Diagnostics.Process.StandardOutput
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StandardOutput
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 600
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets a stream used to read the textual output of the application.</p>\n"
  remarks: "\n<p>When a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes text to its standard stream, that text is normally displayed on the console. By redirecting the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, you can manipulate or suppress the output of a process. For example, you can filter the text, format it differently, or write the output to both the console and a designated log file.</p>\n<p>To use <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref>, you must set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong>, and you must set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>. Otherwise, reading from the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream throws an exception.</p>\n<p>The redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>Synchronous read operations introduce a dependency between the caller reading from the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream and the child process writing to that stream. These dependencies can result in deadlock conditions. When the caller reads from the redirected stream of a child process, it is dependent on the child. The caller waits on the read operation until the child writes to the stream or closes the stream. When the child process writes enough data to fill its redirected stream, it is dependent on the parent. The child process waits on the next write operation until the parent reads from the full stream or closes the stream. The deadlock condition results when the caller and child process wait on each other to complete an operation, and neither can proceed. You can avoid deadlocks by evaluating dependencies between the caller and child process.</p>\n<p>The following C# code, for example, shows how to read from a redirected stream and wait for the child process to exit.</p>\n<pre><code> Process p = new Process();\np.StartInfo.UseShellExecute = false;\np.StartInfo.RedirectStandardOutput = true;\np.StartInfo.FileName = \"Write500Lines.exe\";\np.Start();\n\n// To avoid deadlocks, always read the output stream first and then wait.\nstring output = p.StandardOutput.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids a deadlock condition by calling <code>p.StandardOutput.ReadToEnd</code> before <code>p.WaitForExit</code>. A deadlock condition can result if the parent process calls <code>p.WaitForExit</code> before <code>p.StandardOutput.ReadToEnd</code> and the child process writes enough text to fill the redirected stream. The parent process would wait indefinitely for the child process to exit. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>There is a similar issue when you read all text from both the standard output and standard error streams. The following C# code, for example, performs a read operation on both streams.</p>\n<pre><code> // To avoid deadlocks, use asynchronous read operations on at least one of the streams.\n// Do not perform a synchronous read to the end of both redirected streams.\np.BeginOutputReadLine();\nstring error = p.StandardError.ReadToEnd();\np.WaitForExit();</code></pre>\n<p>The code example avoids the deadlock condition by performing asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. A deadlock condition results if the parent process calls <code>p.StandardOutput.ReadToEnd</code> followed by <code>p.StandardError.ReadToEnd</code> and the child process writes enough text to fill its error stream. The parent process would wait indefinitely for the child process to close its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. The child process would wait indefinitely for the parent to read from the full <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can use asynchronous read operations to avoid these dependencies and their deadlock potential. Alternately, you can avoid the deadlock condition by creating two threads and reading the output of each stream on a separate thread.</p>\n<p>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> with a call to <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> and then call <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  example:
  - "\n<p>The following example runs the ipconfig.exe command and redirects its standard output to the example’s console window. </p>Process_StandardOutput#2"
  syntax:
    content: public StreamReader StandardOutput { get; }
    content.vb: Public ReadOnly Property StandardOutput As StreamReader
    parameters: []
    return:
      type: System.IO.StreamReader
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream has not been defined for redirection; ensure <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> is set to <strong>true</strong> and <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is set to <strong>false</strong>.</p>\n<p>- or - </p>\n<p>The <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream has been opened for asynchronous read operations with <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.StandardInput
    commentId: P:System.Diagnostics.Process.StandardInput
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.StartInfo
  commentId: P:System.Diagnostics.Process.StartInfo
  id: StartInfo
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: StartInfo
  fullName: System.Diagnostics.Process.StartInfo
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StartInfo
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 479
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets or sets the properties to pass to the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> represents the set of parameters to use to start a process. When <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> is called, the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> is used to specify the process to start. The only necessary <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> member to set is the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property. Starting a process by specifying the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property is similar to typing the information in the Run dialog box of the Windows Start menu. Therefore, the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the Run dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> member. For example, you can set the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property to either \"Notepad.exe\" or \"Notepad\". </p>\n<p>You can start a ClickOnce application by setting the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</p>\n<p>If the file name involves a nonexecutable file, such as a .doc file, you can include a verb specifying what action to take on the file. For example, you could set the <xref href=\"System.Diagnostics.ProcessStartInfo.Verb\" data-throw-if-not-resolved=\"false\"></xref> to \"Print\" for a file ending in the .doc extension. The file name specified in the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property does not need to have an extension if you manually enter a value for the <xref href=\"System.Diagnostics.ProcessStartInfo.Verb\" data-throw-if-not-resolved=\"false\"></xref> property. However, if you use the <xref href=\"System.Diagnostics.ProcessStartInfo.Verbs\" data-throw-if-not-resolved=\"false\"></xref> property to determine what verbs are available, you must include the extension.</p>\n<p>You can change the parameters specified in the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property up to the time that you call the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method on the process. After you start the process, changing the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> values does not affect or restart the associated process. If you call the <xref href=\"System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)\" data-throw-if-not-resolved=\"false\"></xref> method with the <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.ProcessStartInfo.Password\" data-throw-if-not-resolved=\"false\"></xref> properties set, the unmanaged CreateProcessWithLogonW function is called, which starts the process in a new window even if the <xref href=\"System.Diagnostics.ProcessStartInfo.CreateNoWindow\" data-throw-if-not-resolved=\"false\"></xref> property value is <strong>true</strong> or the <xref href=\"System.Diagnostics.ProcessStartInfo.WindowStyle\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Diagnostics.ProcessWindowStyle.Hidden\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you did not use the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method to start a process, the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property does not reflect the parameters used to start the process. For example, if you use <see cref=\"Overload:System.Diagnostics.Process.GetProcesses\"></see> to get an array of processes running on the computer, the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property of each <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> does not contain the original file name or arguments used to start the process.</p>\n<p>When the process is started, the file name is the file that populates the (read-only) <xref href=\"System.Diagnostics.Process.MainModule\" data-throw-if-not-resolved=\"false\"></xref> property. If you want to retrieve the executable file that is associated with the process after the process has started, use the <xref href=\"System.Diagnostics.Process.MainModule\" data-throw-if-not-resolved=\"false\"></xref> property. If you want to set the executable file of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance for which an associated process has not been started, use the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property's <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> member. Because the members of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property are arguments that are passed to the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method of a process, changing the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property after the associated process has started will not reset the <xref href=\"System.Diagnostics.Process.MainModule\" data-throw-if-not-resolved=\"false\"></xref> property. These properties are used only to initialize the associated process.</p>\n"
  example:
  - "\n<p>The following example populates a <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> with the file to execute, the action performed on it and whether it should displays a user interface. For additional examples, refer to the reference pages for properties of the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Process.Start_instance#1"
  syntax:
    content: public ProcessStartInfo StartInfo { get; set; }
    content.vb: Public Property StartInfo As ProcessStartInfo
    parameters: []
    return:
      type: System.Diagnostics.ProcessStartInfo
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The value that specifies the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.Start
    commentId: M:System.Diagnostics.Process.Start
  - type: System.Diagnostics.ProcessStartInfo.FileName
    commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.StartTime
  commentId: P:System.Diagnostics.Process.StartTime
  id: StartTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: StartTime
  fullName: System.Diagnostics.Process.StartTime
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StartTime
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 56
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the time that the associated process was started.</p>\n"
  syntax:
    content: public DateTime StartTime { get; }
    content.vb: Public ReadOnly Property StartTime As Date
    parameters: []
    return:
      type: System.DateTime
      description: "\n<p>An object  that indicates when the process started. An exception is thrown if the process is not running.</p>\n"
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.StartTime\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process has exited.</p>\n<p>-or-</p>\n<p>The process has not been started.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>An error occurred in the call to the Windows function.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.Threads
  commentId: P:System.Diagnostics.Process.Threads
  id: Threads
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Threads
  fullName: System.Diagnostics.Process.Threads
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Threads
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 516
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the set of threads that are running in the associated process.</p>\n"
  remarks: "\n<p>A thread executes code in a process. Each process is started with a single thread, its primary thread. Any thread can create additional threads. Threads within a process share the address space of the process.</p>\n<p>Use <xref href=\"System.Diagnostics.ProcessThread\" data-throw-if-not-resolved=\"false\"></xref> to get all the threads associated with the current process. The primary thread is not necessarily at index zero in the array.</p>\n"
  syntax:
    content: public ProcessThreadCollection Threads { get; }
    content.vb: Public ReadOnly Property Threads As ProcessThreadCollection
    parameters: []
    return:
      type: System.Diagnostics.ProcessThreadCollection
  exceptions:
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "\n<p>The process does not have an <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref>, or no process is associated with the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n<p>-or- </p>\n<p>The associated process has exited. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me); set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong> to access this property on Windows 98 and Windows Me.</p>\n"
  seealso:
  - type: System.Diagnostics.ProcessThread
    commentId: T:System.Diagnostics.ProcessThread
  - type: System.Diagnostics.Process.BasePriority
    commentId: P:System.Diagnostics.Process.BasePriority
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.TotalProcessorTime
  commentId: P:System.Diagnostics.Process.TotalProcessorTime
  id: TotalProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: TotalProcessorTime
  fullName: System.Diagnostics.Process.TotalProcessorTime
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TotalProcessorTime
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 58
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the total processor time for this process.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public TimeSpan TotalProcessorTime { get; }
    content.vb: Public ReadOnly Property TotalProcessorTime As TimeSpan
    parameters: []
    return:
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that indicates the amount of time that the associated process has spent utilizing the CPU. This value is the sum of the <xref href=\"System.Diagnostics.Process.UserProcessorTime\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Diagnostics.Process.PrivilegedProcessorTime\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.TotalProcessorTime\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.UserProcessorTime
    commentId: P:System.Diagnostics.Process.UserProcessorTime
  - type: System.Diagnostics.Process.PrivilegedProcessorTime
    commentId: P:System.Diagnostics.Process.PrivilegedProcessorTime
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.UserProcessorTime
  commentId: P:System.Diagnostics.Process.UserProcessorTime
  id: UserProcessorTime
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: UserProcessorTime
  fullName: System.Diagnostics.Process.UserProcessorTime
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UserProcessorTime
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 59
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the user processor time for this process.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays the process's exit code.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public TimeSpan UserProcessorTime { get; }
    content.vb: Public ReadOnly Property UserProcessorTime As TimeSpan
    parameters: []
    return:
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that indicates the amount of time that the associated process has spent running code inside the application portion of the process (not inside the operating system core).</p>\n"
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to access the <xref href=\"System.Diagnostics.Process.UserProcessorTime\" data-throw-if-not-resolved=\"false\"></xref> property for a process that is running on a remote computer. This property is available only for processes that are running on the local computer. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.UserProcessorTime
    commentId: P:System.Diagnostics.Process.UserProcessorTime
  - type: System.Diagnostics.Process.PrivilegedProcessorTime
    commentId: P:System.Diagnostics.Process.PrivilegedProcessorTime
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.VirtualMemorySize64
  commentId: P:System.Diagnostics.Process.VirtualMemorySize64
  id: VirtualMemorySize64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: VirtualMemorySize64
  fullName: System.Diagnostics.Process.VirtualMemorySize64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: VirtualMemorySize64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 537
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of the virtual memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the current size of virtual memory used by the process, in bytes. The operating system maps the virtual address space for each process either to pages loaded in physical memory, or to pages stored in the virtual memory paging file on disk.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Virtual Bytes performance counter for the process. </p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long VirtualMemorySize64 { get; }
    content.vb: Public ReadOnly Property VirtualMemorySize64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.PeakVirtualMemorySize64
    commentId: P:System.Diagnostics.Process.PeakVirtualMemorySize64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.WorkingSet64
  commentId: P:System.Diagnostics.Process.WorkingSet64
  id: WorkingSet64
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: WorkingSet64
  fullName: System.Diagnostics.Process.WorkingSet64
  type: Property
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WorkingSet64
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 647
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets the amount of physical memory, in bytes, allocated for the associated process.</p>\n"
  remarks: "\n<p>The value returned by this property represents the current size of working set memory used by the process, in bytes. The working set of a process is the set of memory pages currently visible to the process in physical RAM memory. These pages are resident and available for an application to use without triggering a page fault.</p>\n<p>The working set includes both shared and private data. The shared data includes the pages that contain all the instructions that the process executes, including instructions in the process modules and the system libraries.</p>\n<p>This property can be used to monitor memory usage on computers with 32-bit processors or 64-bit processors. The property value is equivalent to the Working Set performance counter for the process.</p>\n"
  example:
  - "\n<p>The following code example starts an instance of the Notepad application. The example then retrieves and displays various properties of the associated process. The example detects when the process exits, and displays its exit code and peak memory statistics.</p>Diag_Process_MemoryProperties64#1"
  syntax:
    content: public long WorkingSet64 { get; }
    content.vb: Public ReadOnly Property WorkingSet64 As Long
    parameters: []
    return:
      type: System.Int64
  exceptions:
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The platform is Windows 98 or Windows Millennium Edition (Windows Me), which does not support this property.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.MinWorkingSet
    commentId: P:System.Diagnostics.Process.MinWorkingSet
  - type: System.Diagnostics.Process.MaxWorkingSet
    commentId: P:System.Diagnostics.Process.MaxWorkingSet
  - type: System.Diagnostics.Process.PeakWorkingSet64
    commentId: P:System.Diagnostics.Process.PeakWorkingSet64
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Diagnostics.Process.ErrorDataReceived
  commentId: E:System.Diagnostics.Process.ErrorDataReceived
  id: ErrorDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: ErrorDataReceived
  fullName: System.Diagnostics.Process.ErrorDataReceived
  type: Event
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ErrorDataReceived
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 72
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Occurs when an application writes to its redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.ErrorDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event indicates that the associated process has written to its redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>The event only occurs during asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref>. To start asynchronous read operations, you must redirect the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>, add your event handler to the <xref href=\"System.Diagnostics.Process.ErrorDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event, and call <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref>. Thereafter, the <xref href=\"System.Diagnostics.Process.ErrorDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event signals each time the process writes a line to the redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, until the process exits or calls <xref href=\"System.Diagnostics.Process.CancelErrorRead\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The application that is processing the asynchronous output should call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> method to ensure that the output buffer has been flushed.</p>\n"
  example:
  - "\n<p>The following example uses the <strong>net view</strong> command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.</p>Process_AsyncStreams#2"
  syntax:
    content: public event DataReceivedEventHandler ErrorDataReceived
    content.vb: Public Event ErrorDataReceived As DataReceivedEventHandler
    return:
      type: System.Diagnostics.DataReceivedEventHandler
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardError
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  - type: System.Diagnostics.Process.BeginErrorReadLine
    commentId: M:System.Diagnostics.Process.BeginErrorReadLine
  - type: System.Diagnostics.Process.CancelErrorRead
    commentId: M:System.Diagnostics.Process.CancelErrorRead
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Exited
  commentId: E:System.Diagnostics.Process.Exited
  id: Exited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Exited
  fullName: System.Diagnostics.Process.Exited
  type: Event
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Exited
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 656
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Occurs when a process exits.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event indicates that the associated process exited. This occurrence means either that the process terminated (aborted) or successfully closed. This event can occur only if the value of the <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>.</p>\n<p>There are two ways of being notified when the associated process exits: synchronously and asynchronously. Synchronous notification means calling the <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to block the current thread until the process exits. Asynchronous notification uses the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event, which allows the calling thread to continue execution in the meantime. In the latter case, <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> must be set to <strong>true</strong> for the calling application to receive the Exited event.</p>\n<p>When the operating system shuts down a process, it notifies all other processes that have registered handlers for the Exited event. At this time, the handle of the process that just exited can be used to access some properties such as  <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> that the operating system maintains until it releases that handle completely.</p>\n<p>Even if you have a handle to an exited process, you cannot call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> again to reconnect to the same process. Calling <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> automatically releases the associated process and connects to a process with the same file but an entirely new <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>For more information about the use of the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event in Windows Forms applications, see the <xref href=\"System.Diagnostics.Process.SynchronizingObject\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  example:
  - "\n<p>The following code example creates a process that prints a file. It raises the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event when the process exits because the <xref href=\"System.Diagnostics.Process.EnableRaisingEvents\" data-throw-if-not-resolved=\"false\"></xref> property was set when the process was created. The <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event handler displays process information.</p>System.Diagnostics.Process.EnableExited#1"
  syntax:
    content: public event EventHandler Exited
    content.vb: Public Event Exited As EventHandler
    return:
      type: System.EventHandler
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.OutputDataReceived
  commentId: E:System.Diagnostics.Process.OutputDataReceived
  id: OutputDataReceived
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: OutputDataReceived
  fullName: System.Diagnostics.Process.OutputDataReceived
  type: Event
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OutputDataReceived
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 71
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Occurs each time an application writes a line to its redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event indicates that the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> has written a line, terminating with a newline character, to its redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>The event is enabled during asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref>. To start asynchronous read operations, you must redirect the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>, add your event handler to the <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event, and call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref>. Thereafter, the <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event signals each time the process writes a line to the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, until the process exits or calls <xref href=\"System.Diagnostics.Process.CancelOutputRead\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The application that is processing the asynchronous output should call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> method to ensure that the output buffer has been flushed.</p>\n"
  example:
  - "\n<p>The following example illustrates how to perform asynchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream of the <strong>ipconfig</strong> command.</p>\n<p>The example creates an event delegate for the <code>OutputHandler</code> event handler and associates it with the <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event. The event handler receives text lines from the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, formats the text, and saves it in an output string that’s later shown in the example’s console window.</p>Process_AsyncStreams#4"
  syntax:
    content: public event DataReceivedEventHandler OutputDataReceived
    content.vb: Public Event OutputDataReceived As DataReceivedEventHandler
    return:
      type: System.Diagnostics.DataReceivedEventHandler
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  - type: System.Diagnostics.Process.BeginOutputReadLine
    commentId: M:System.Diagnostics.Process.BeginOutputReadLine
  - type: System.Diagnostics.Process.CancelOutputRead
    commentId: M:System.Diagnostics.Process.CancelOutputRead
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.BeginErrorReadLine
  commentId: M:System.Diagnostics.Process.BeginErrorReadLine
  id: BeginErrorReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: BeginErrorReadLine()
  fullName: System.Diagnostics.Process.BeginErrorReadLine()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: BeginErrorReadLine
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1268
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Begins asynchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream of the application.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the error output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables the designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>Follow these steps to perform asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> for a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> : </p>\n<ol><li>\n<p>Set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong>.</p>\n</li><li>\n<p>Set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>.</p>\n</li><li>\n<p>Add your event handler to the <xref href=\"System.Diagnostics.Process.ErrorDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event. The event handler must match the <xref href=\"System.Diagnostics.DataReceivedEventHandler\" data-throw-if-not-resolved=\"false\"></xref> delegate signature.</p>\n</li><li>\n<p>Start the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>Call <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>. This call starts asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li></ol>\n<p>When asynchronous read operations start, the event handler is called each time the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes a line of text to its <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can cancel an asynchronous read operation by calling <xref href=\"System.Diagnostics.Process.CancelErrorRead\" data-throw-if-not-resolved=\"false\"></xref>. The read operation can be canceled by the caller or by the event handler. After canceling, you can call <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> again to resume asynchronous read operations.</p>\n<p>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> with a call to <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> and then call <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  example:
  - "\n<p>The following example uses the <strong>net view</strong> command to list the available network resources on a remote computer. The user supplies the target computer name as a command-line argument. The user can also supply a file name for error output. The example collects the output of the net command, waits for the process to finish, and then writes the output results to the console. If the user supplies the optional error file, the example writes errors to the file.</p>Process_AsyncStreams#2"
  syntax:
    content: public void BeginErrorReadLine()
    content.vb: Public Sub BeginErrorReadLine
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n<p>- or - </p>\n<p>An asynchronous read operation is already in progress on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>- or - </p>\n<p>The <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream has been used by a synchronous read operation. </p>\n"
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardError
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  - type: System.Diagnostics.Process.ErrorDataReceived
    commentId: E:System.Diagnostics.Process.ErrorDataReceived
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  - type: System.Diagnostics.Process.CancelErrorRead
    commentId: M:System.Diagnostics.Process.CancelErrorRead
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.BeginOutputReadLine
  commentId: M:System.Diagnostics.Process.BeginOutputReadLine
  id: BeginOutputReadLine
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: BeginOutputReadLine()
  fullName: System.Diagnostics.Process.BeginOutputReadLine()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: BeginOutputReadLine
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1230
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Begins asynchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream of the application.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream can be read synchronously or asynchronously. Methods such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> perform synchronous read operations on the output stream of the process. These synchronous read operations do not complete until the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes to its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, or closes the stream.</p>\n<p>In contrast, <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts asynchronous read operations on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. This method enables a designated event handler for the stream output and immediately returns to the caller, which can perform other work while the stream output is directed to the event handler.</p>\n<p>Follow these steps to perform asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> for a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> : </p>\n<ol><li>\n<p>Set <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> to <strong>false</strong>.</p>\n</li><li>\n<p>Set <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> to <strong>true</strong>.</p>\n</li><li>\n<p>Add your event handler to the <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event. The event handler must match the <xref href=\"System.Diagnostics.DataReceivedEventHandler\" data-throw-if-not-resolved=\"false\"></xref> delegate signature.</p>\n</li><li>\n<p>Start the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>Call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref>. This call starts asynchronous read operations on <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li></ol>\n<p>When asynchronous read operations start, the event handler is called each time the associated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> writes a line of text to its <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>You can cancel an asynchronous read operation by calling <xref href=\"System.Diagnostics.Process.CancelOutputRead\" data-throw-if-not-resolved=\"false\"></xref>. The read operation can be canceled by the caller or by the event handler. After canceling, you can call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> again to resume asynchronous read operations.</p>\n<p>You cannot mix asynchronous and synchronous read operations on a redirected stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. For example, do not follow <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> with a call to <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, or vice versa. However, you can read two different streams in different modes. For example, you can call <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> and then call <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n"
  example:
  - "\n<p>The following example illustrates how to perform asynchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream of the <strong>sort</strong> command. The <strong>sort</strong> command is a console application that reads and sorts text input.</p>\n<p>The example creates an event delegate for the <code>SortOutputHandler</code> event handler and associates it with the <xref href=\"System.Diagnostics.Process.OutputDataReceived\" data-throw-if-not-resolved=\"false\"></xref> event. The event handler receives text lines from the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream, formats the text, and writes the text to the screen.</p>Process_AsyncStreams#1"
  syntax:
    content: public void BeginOutputReadLine()
    content.vb: Public Sub BeginOutputReadLine
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n<p>- or - </p>\n<p>An asynchronous read operation is already in progress on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream.</p>\n<p>- or - </p>\n<p>The <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream has been used by a synchronous read operation. </p>\n"
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  - type: System.Diagnostics.Process.OutputDataReceived
    commentId: E:System.Diagnostics.Process.OutputDataReceived
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  - type: System.Diagnostics.Process.CancelOutputRead
    commentId: M:System.Diagnostics.Process.CancelOutputRead
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.CancelErrorRead
  commentId: M:System.Diagnostics.Process.CancelErrorRead
  id: CancelErrorRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: CancelErrorRead()
  fullName: System.Diagnostics.Process.CancelErrorRead()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CancelErrorRead
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1325
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Cancels the asynchronous read operation on the redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream of an application.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts an asynchronous read operation on the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream. <xref href=\"System.Diagnostics.Process.CancelErrorRead\" data-throw-if-not-resolved=\"false\"></xref> ends the asynchronous read operation.</p>\n<p>After canceling, you can resume the asynchronous read operation by calling <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> again.</p>\n<p>When you call <xref href=\"System.Diagnostics.Process.CancelErrorRead\" data-throw-if-not-resolved=\"false\"></xref>, all in-progress read operations for <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> are completed and then the event handler is disabled. All further redirected output to <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> is saved in a buffer. If you re-enable the event handler with a call to <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref>, the saved output is sent to the event handler and asynchronous read operations resume. If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler: </p>\n<pre><code>    // At this point the DataReceivedEventHandler(ErrorHandler1) \n// has executed a CancelErrorRead.\n\n// Remove the prior event handler.\nprocess.ErrorDataReceived -= \nnew DataReceivedEventHandler(ErrorHandler1);\n\n// Register a new event handler.\nprocess.ErrorDataReceived += \nnew DataReceivedEventHandler(ErrorHandler2);\n\n// Call the corresponding BeginErrorReadLine.\nprocess.BeginErrorReadLine();</code></pre>\n<p>You cannot mix asynchronous and synchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. If you cancel an asynchronous read operation on <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> and then need to read from the stream again, you must use <xref href=\"System.Diagnostics.Process.BeginErrorReadLine\" data-throw-if-not-resolved=\"false\"></xref> to resume asynchronous read operations. Do not follow <xref href=\"System.Diagnostics.Process.CancelErrorRead\" data-throw-if-not-resolved=\"false\"></xref> with a call to the synchronous read methods of <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example starts the <strong>nmake</strong> command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</p>Process_AsyncStreams#3"
  syntax:
    content: public void CancelErrorRead()
    content.vb: Public Sub CancelErrorRead
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> stream is not enabled for asynchronous read operations. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.BeginErrorReadLine
    commentId: M:System.Diagnostics.Process.BeginErrorReadLine
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardError
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardError
  - type: System.Diagnostics.Process.StandardError
    commentId: P:System.Diagnostics.Process.StandardError
  - type: System.Diagnostics.Process.ErrorDataReceived
    commentId: E:System.Diagnostics.Process.ErrorDataReceived
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.CancelOutputRead
  commentId: M:System.Diagnostics.Process.CancelOutputRead
  id: CancelOutputRead
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: CancelOutputRead()
  fullName: System.Diagnostics.Process.CancelOutputRead()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CancelOutputRead
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1305
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Cancels the asynchronous read operation on the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream of an application.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> starts an asynchronous read operation on the <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. <xref href=\"System.Diagnostics.Process.CancelOutputRead\" data-throw-if-not-resolved=\"false\"></xref> ends the asynchronous read operation.</p>\n<p>After canceling, you can resume asynchronous read operations by calling <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> again.</p>\n<p>When you call <xref href=\"System.Diagnostics.Process.CancelOutputRead\" data-throw-if-not-resolved=\"false\"></xref>, all in-progress read operations for <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> are completed and then the event handler is disabled. All further redirected output to <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> is saved in a buffer. If you re-enable the event handler with a call to <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref>, the saved output is sent to the event handler and asynchronous read operations resume. If you want to change the event handler before resuming asynchronous read operations, you must remove the existing event handler before adding the new event handler: </p>\n<pre><code>    // At this point the DataReceivedEventHandler(OutputHandler1) \n// has executed a CancelOutputRead.\n\n// Remove the prior event handler.\nprocess.OutputDataReceived -= \nnew DataReceivedEventHandler(OutputHandler1);\n\n// Register a new event handler.\nprocess.OutputDataReceived += \nnew DataReceivedEventHandler(OutputHandler2);\n\n// Call the corresponding BeginOutputReadLine.\nprocess.BeginOutputReadLine();</code></pre>\n<p>You cannot mix asynchronous and synchronous read operations on the redirected <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream. Once the redirected stream of a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> is opened in either asynchronous or synchronous mode, all further read operations on that stream must be in the same mode. If you cancel an asynchronous read operation on <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> and then need to read from the stream again, you must use <xref href=\"System.Diagnostics.Process.BeginOutputReadLine\" data-throw-if-not-resolved=\"false\"></xref> to resume asynchronous read operations. Do not follow <xref href=\"System.Diagnostics.Process.CancelOutputRead\" data-throw-if-not-resolved=\"false\"></xref> with a call to the synchronous read methods of <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> such as <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example starts the <strong>nmake</strong> command with user supplied arguments. The error and output streams are read asynchronously; the collected text lines are displayed to the console as well as written to a log file. If the command output exceeds a specified number of lines, the asynchronous read operations are canceled.</p>Process_AsyncStreams#3"
  syntax:
    content: public void CancelOutputRead()
    content.vb: Public Sub CancelOutputRead
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Diagnostics.Process.StandardOutput\" data-throw-if-not-resolved=\"false\"></xref> stream is not enabled for asynchronous read operations. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.BeginOutputReadLine
    commentId: M:System.Diagnostics.Process.BeginOutputReadLine
  - type: System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
    commentId: P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput
  - type: System.Diagnostics.Process.StandardOutput
    commentId: P:System.Diagnostics.Process.StandardOutput
  - type: System.Diagnostics.Process.OutputDataReceived
    commentId: E:System.Diagnostics.Process.OutputDataReceived
  - type: System.Diagnostics.DataReceivedEventHandler
    commentId: T:System.Diagnostics.DataReceivedEventHandler
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.EnterDebugMode
  commentId: M:System.Diagnostics.Process.EnterDebugMode
  id: EnterDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: EnterDebugMode()
  fullName: System.Diagnostics.Process.EnterDebugMode()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnterDebugMode
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 69
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Puts a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component in state to interact with operating system processes that run in a special mode by enabling the native property <strong>SeDebugPrivilege</strong> on the current thread.</p>\n"
  remarks: "\n<p>Some operating system processes run in a special mode. Attempting to read properties of or attach to these processes is not possible unless you have called <xref href=\"System.Diagnostics.Process.EnterDebugMode\" data-throw-if-not-resolved=\"false\"></xref> on the component. Call <xref href=\"System.Diagnostics.Process.LeaveDebugMode\" data-throw-if-not-resolved=\"false\"></xref> when you no longer need access to these processes that run in special mode.</p>\n"
  syntax:
    content: public static void EnterDebugMode()
    content.vb: Public Shared Sub EnterDebugMode
  seealso:
  - type: System.Diagnostics.Process.LeaveDebugMode
    commentId: M:System.Diagnostics.Process.LeaveDebugMode
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetCurrentProcess
  commentId: M:System.Diagnostics.Process.GetCurrentProcess
  id: GetCurrentProcess
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetCurrentProcess()
  fullName: System.Diagnostics.Process.GetCurrentProcess()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetCurrentProcess
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 959
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Gets a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component and associates it with the currently active process.</p>\n"
  remarks: "\n<p>Use this method to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance and associate it with the process resource on the local computer.</p>\n<p>Like the similar <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref> methods, <xref href=\"System.Diagnostics.Process.GetCurrentProcess\" data-throw-if-not-resolved=\"false\"></xref> associates an existing resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process GetCurrentProcess()
    content.vb: Public Shared Function GetCurrentProcess As Process
    return:
      type: System.Diagnostics.Process
  seealso:
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcessById(System.Int32)
  commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32)
  id: GetProcessById(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcessById(Int32)
  fullName: System.Diagnostics.Process.GetProcessById(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcessById
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 892
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Returns a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, given the identifier of a process on the local computer.</p>\n"
  remarks: "\n<p>Use this method to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component and associate it with a process resource on the local computer. The process resource must already exist on the computer, because <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> does not create a system resource, but rather associates a resource with an application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. A process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> can be retrieved only for a process that is currently running on the computer. After the process terminates, <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> throws an exception if you pass it an expired identifier.</p>\n<p>On any particular computer, the identifier of a process is unique. <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns one process at most. If you want to get all the processes running a particular application, use <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. If multiple processes exist on the computer running the specified application, <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns an array containing all the associated processes. You can query each of these processes in turn for its identifier. The process identifier can be viewed in the <strong>Processes</strong> panel of the Windows Task Manager. The <strong>PID</strong> column displays the process identifier that is assigned to a process.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process GetProcessById(int processId)
    content.vb: Public Shared Function GetProcessById(processId As Integer) As Process
    parameters:
    - id: processId
      type: System.Int32
    return:
      type: System.Diagnostics.Process
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The process specified by the <em>processId</em> parameter is not running. The identifier might be expired. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process was not started by this object.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.Id
    commentId: P:System.Diagnostics.Process.Id
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  id: GetProcessById(System.Int32,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcessById(Int32, String)
  fullName: System.Diagnostics.Process.GetProcessById(System.Int32, System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcessById
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 876
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Returns a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component, given a process identifier and the name of a computer on the network.</p>\n"
  remarks: "\n<p>Use this method to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component and associate it with a process resource on a remote computer on the network. The process resource must already exist on the specified computer, because <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> does not create a system resource, but rather associates a resource with an application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. A process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> can be retrieved only for a process that is currently running on the computer. After the process terminates, <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> throws an exception if you pass it an expired identifier.</p>\n<p>On any particular computer, the identifier of a process is unique. <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns one process at most. If you want to get all the processes running a particular application, use <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref>. If multiple processes exist on the computer running the specified application, <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns an array containing all the associated processes. You can query each of these processes in turn for its identifier. The process identifier can be viewed in the <strong>Processes</strong> panel of the Windows Task Manager. The <strong>PID</strong> column displays the process identifier that is assigned to a process.</p>\n<p>If you do not specify a <em>machineName</em>, the local computer is used. Alternatively, you can specify the local computer by setting <em>machineName</em> to the value \".\" or to an empty string (\"\").</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process GetProcessById(int processId, string machineName)
    content.vb: Public Shared Function GetProcessById(processId As Integer, machineName As String) As Process
    parameters:
    - id: processId
      type: System.Int32
    - id: machineName
      type: System.String
    return:
      type: System.Diagnostics.Process
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The process specified by the <em>processId</em> parameter is not running. The identifier might be expired.</p>\n<p>-or- </p>\n<p>The <em>machineName</em> parameter syntax is invalid. The name might have length zero (0). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>machineName</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process was not started by this object.</p>\n"
  seealso:
  - type: System.Diagnostics.Process.Id
    commentId: P:System.Diagnostics.Process.Id
  - type: System.Diagnostics.Process.MachineName
    commentId: P:System.Diagnostics.Process.MachineName
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcesses
  commentId: M:System.Diagnostics.Process.GetProcesses
  id: GetProcesses
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcesses()
  fullName: System.Diagnostics.Process.GetProcesses()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcesses
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 916
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Creates a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component for each process resource on the local computer.</p>\n"
  remarks: "\n<p>Use this method to create an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associate them with all the process resources on the local computer. The process resources must already exist on the local computer, because <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref> does not create system resources but rather associates resources with application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components. Because the operating system itself is running background processes, this array is never empty. </p>\n<p>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> creates a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component that is associated with the process identified on the system by the process identifier that you pass to the method. <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> creates an array of <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components whose associated process resources share the executable file you pass to the method.</p>\n<p>Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe). GetProcesses does not identify those individual services; for that, see <xref href=\"System.ServiceProcess.ServiceController.GetServices\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process[] GetProcesses()
    content.vb: Public Shared Function GetProcesses As Process()
    return:
      type: System.Diagnostics.Process[]
  seealso:
  - type: System.Diagnostics.Process.MachineName
    commentId: P:System.Diagnostics.Process.MachineName
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcesses(System.String)
  commentId: M:System.Diagnostics.Process.GetProcesses(System.String)
  id: GetProcesses(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcesses(String)
  fullName: System.Diagnostics.Process.GetProcesses(System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcesses
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 928
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Creates a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component for each process resource on the specified computer.</p>\n"
  remarks: "\n<p>Use this method to create an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associate them with all the process resources on the specified (usually remote) computer. The process resources must already exist on the local computer, because <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref> does not create system resources but rather associates resources with application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components. Because the operating system itself is running background processes, this array is never empty.</p>\n<p>If you do not want to retrieve all the processes running on the computer, you can restrict their number by using the <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method. <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> creates a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component that is associated with the process identified on the system by the process identifier that you pass to the method. <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> creates an array of <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components whose associated process resources share the executable file you pass to the method.</p>\n<p>This overload of the <xref href=\"System.Diagnostics.Process.GetProcesses\" data-throw-if-not-resolved=\"false\"></xref> method is generally used to retrieve the list of process resources running on a remote computer on the network, but you can specify the local computer by passing \".\".</p>\n<p>Multiple Windows services can be loaded within the same instance of the Service Host process (svchost.exe). GetProcesses does not identify those individual services; for that, see <xref href=\"System.ServiceProcess.ServiceController.GetServices\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process[] GetProcesses(string machineName)
    content.vb: Public Shared Function GetProcesses(machineName As String) As Process()
    parameters:
    - id: machineName
      type: System.String
    return:
      type: System.Diagnostics.Process[]
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>machineName</em> parameter syntax is invalid. It might have length zero (0). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>machineName</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The operating system platform does not support this operation on remote computers. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP. </p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>A problem occurred accessing an underlying system API. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.MachineName
    commentId: P:System.Diagnostics.Process.MachineName
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcessesByName(System.String)
    commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcessesByName(System.String)
  commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String)
  id: GetProcessesByName(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcessesByName(String)
  fullName: System.Diagnostics.Process.GetProcessesByName(System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcessesByName
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 905
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Creates an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associates them with all the process resources on the local computer that share the specified process name.</p>\n"
  remarks: "\n<p>Use this method to create an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associate them with all the process resources that are running the same executable file on the local computer. The process resources must already exist on the computer, because <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> does not create system resources but rather associates them with application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components. A <em>processName</em> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</p>\n<p>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path. <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is helpful for getting and manipulating all the processes that are associated with the same executable file. For example, you can pass an executable file name as the <em>processName</em> parameter, in order to shut down all the running instances of that executable file.</p>\n<p>Although a process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <em>processName</em> parameter. Therefore, <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns one process at most, but <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns an array containing all the associated processes. If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier. You cannot access process resources through the process name alone but, once you have retrieved an array of <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process[] GetProcessesByName(string processName)
    content.vb: Public Shared Function GetProcessesByName(processName As String) As Process()
    parameters:
    - id: processName
      type: System.String
    return:
      type: System.Diagnostics.Process[]
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.ProcessName
    commentId: P:System.Diagnostics.Process.ProcessName
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  commentId: M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)
  id: GetProcessesByName(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: GetProcessesByName(String, String)
  fullName: System.Diagnostics.Process.GetProcessesByName(System.String, System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetProcessesByName
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 76
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Creates an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associates them with all the process resources on a remote computer that share the specified process name.</p>\n"
  remarks: "\n<p>Use this method to create an array of new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components and associate them with all the process resources that are running the same executable file on the specified computer. The process resources must already exist on the computer, because <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> does not create system resources but rather associates them with application-generated <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components. A <em>processName</em> can be specified for an executable file that is not currently running on the local computer, so the array the method returns can be empty.</p>\n<p>The process name is a friendly name for the process, such as Outlook, that does not include the .exe extension or the path. <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is helpful for getting and manipulating all the processes that are associated with the same executable file. For example, you can pass an executable file name as the <em>processName</em> parameter, in order to shut down all the running instances of that executable file.</p>\n<p>Although a process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> is unique to a single process resource on the system, multiple processes on the local computer can be running the application specified by the <em>processName</em> parameter. Therefore, <xref href=\"System.Diagnostics.Process.GetProcessById(System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns one process at most, but <xref href=\"System.Diagnostics.Process.GetProcessesByName(System.String)\" data-throw-if-not-resolved=\"false\"></xref> returns an array containing all the associated processes. If you need to manipulate the process using standard API calls, you can query each of these processes in turn for its identifier. You cannot access process resources through the process name alone but, once you have retrieved an array of <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</p>\n<p>You can use this overload to get processes on the local computer as well as on a remote computer. Use \".\" to specify the local computer. Another overload exists that uses the local computer by default.</p>\n<p>You can access processes on remote computers only to view information, such as statistics, about the processes. You cannot close, terminate (using <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>), or start processes on remote computers.</p>\n"
  example:
  - "\n<p>The following example retrieves information of the current process, processes running on the local computer, all instances of Notepad running on the local computer, and a specific process on the local computer. It then retrieves information for the same processes on a remote computer.</p>Process.GetProcesses_noexception#1"
  syntax:
    content: public static Process[] GetProcessesByName(string processName, string machineName)
    content.vb: Public Shared Function GetProcessesByName(processName As String, machineName As String) As Process()
    parameters:
    - id: processName
      type: System.String
      description: "\n<p>The friendly name of the process. </p>\n"
    - id: machineName
      type: System.String
      description: "\n<p>The name of a computer on the network. </p>\n"
    return:
      type: System.Diagnostics.Process[]
      description: "\n<p>An array of type <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> that represents the process resources running the specified application or file.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>machineName</em> parameter syntax is invalid. It might have length zero (0). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>machineName</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The operating system platform does not support this operation on remote computers. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP. </p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>A problem occurred accessing an underlying system API. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.ProcessName
    commentId: P:System.Diagnostics.Process.ProcessName
  - type: System.Diagnostics.Process.MachineName
    commentId: P:System.Diagnostics.Process.MachineName
  - type: System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
    commentId: M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)
  - type: System.Diagnostics.Process.GetProcesses
    commentId: M:System.Diagnostics.Process.GetProcesses
  - type: System.Diagnostics.Process.GetCurrentProcess
    commentId: M:System.Diagnostics.Process.GetCurrentProcess
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.Kill
  commentId: M:System.Diagnostics.Process.Kill
  id: Kill
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Kill()
  fullName: System.Diagnostics.Process.Kill()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Kill
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 77
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Immediately stops the associated process.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> forces a termination of the process, while <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> only requests a termination. When a process with a graphical interface is executing, its message loop is in a wait state. The message loop executes every time a Windows message is sent to the process by the operating system. Calling <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> sends a request to close to the main window, which, in a well-formed application, closes child windows and revokes all running message loops for the application. The request to exit the process by calling <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> does not force the application to quit. The application can ask for user verification before quitting, or it can refuse to quit. To force the application to quit, use the <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> method. The behavior of <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> is identical to that of a user closing an application's main window using the system menu. Therefore, the request to exit the process by closing the main window does not force the application to quit immediately.</p>\n<p>The <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> method executes asynchronously. After calling the <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> method, call the <see cref=\"Overload:System.Diagnostics.Process.WaitForExit\"></see> method to wait for the process to exit, or check the <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property to determine if the process has exited.</p>\n<p>Data edited by the process or resources allocated to the process can be lost if you call <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> causes an abnormal process termination and should be used only when necessary. <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> enables an orderly termination of the process and closes all windows, so it is preferable for applications with an interface. If <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> fails, you can use <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> to terminate the process. <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> is the only way to terminate processes that do not have graphical interfaces.</p>\n<p>You can call <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> only for processes that are running on the local computer. You cannot cause processes on remote computers to exit. You can only view information for processes running on remote computers.</p>\n<p>If the call to the <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> method is made while the process is currently terminating, a <xref href=\"System.ComponentModel.Win32Exception\" data-throw-if-not-resolved=\"false\"></xref> is thrown for Access Denied.</p>\n"
  syntax:
    content: public void Kill()
    content.vb: Public Sub Kill
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>The associated process could not be terminated. </p>\n<p>-or-</p>\n<p>The process is terminating.</p>\n<p>-or- </p>\n<p>The associated process is a Win16 executable.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>You are attempting to call <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref> for a process that is running on a remote computer. The method is available only for processes running on the local computer.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The process has already exited. </p>\n<p>-or-</p>\n<p>There is no process associated with this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  seealso:
  - type: System.Environment.Exit(System.Int32)
    commentId: M:System.Environment.Exit(System.Int32)
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Start
    commentId: M:System.Diagnostics.Process.Start
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.LeaveDebugMode
  commentId: M:System.Diagnostics.Process.LeaveDebugMode
  id: LeaveDebugMode
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: LeaveDebugMode()
  fullName: System.Diagnostics.Process.LeaveDebugMode()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LeaveDebugMode
    path: src/System.Diagnostics.Process/ref/4.0/System.Diagnostics.Process.cs
    startLine: 78
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Takes a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component out of the state that lets it interact with operating system processes that run in a special mode.</p>\n"
  remarks: "\n<p>Some operating system processes run in a special mode. Attempting to read properties of or attach to these processes is not possible unless you have called <xref href=\"System.Diagnostics.Process.EnterDebugMode\" data-throw-if-not-resolved=\"false\"></xref> on the component. Call <xref href=\"System.Diagnostics.Process.LeaveDebugMode\" data-throw-if-not-resolved=\"false\"></xref> when you no longer need access to these processes that run in special mode.</p>\n"
  syntax:
    content: public static void LeaveDebugMode()
    content.vb: Public Shared Sub LeaveDebugMode
  seealso:
  - type: System.Diagnostics.Process.EnterDebugMode
    commentId: M:System.Diagnostics.Process.EnterDebugMode
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.OnExited
  commentId: M:System.Diagnostics.Process.OnExited
  id: OnExited
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: OnExited()
  fullName: System.Diagnostics.Process.OnExited()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OnExited
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 969
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Raises the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref> is the API method that raises the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event. Calling <xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref> causes the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event to occur and is the only way to raise the event using the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. <xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref> is primarily used when deriving classes from the component.</p>\n<p>As an alternative to <xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref>, you can write your own event handler. You create your own event handler delegate and your own event-handling method.</p>\n<p>If you are using the Visual Studio environment, an event handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are created for you when you drag a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component onto a form and double-click the icon. The code you create to run when the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event occurs is entered into the Process1_Exited procedure. You do not need to create the <xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref> member, because it is implemented for you.</p>\n<p>Raising an event invokes the event handler through a delegate. For an overview, see Handling and Raising Events.</p>\n"
  example:
  - "\n<p>The following example shows how to use the <xref href=\"System.Diagnostics.Process.OnExited\" data-throw-if-not-resolved=\"false\"></xref> method in a derived class.</p>OnExitSample#1"
  syntax:
    content: protected void OnExited()
    content.vb: Protected Sub OnExited
  seealso:
  - type: System.Diagnostics.Process.Exited
    commentId: E:System.Diagnostics.Process.Exited
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Diagnostics.Process.Refresh
  commentId: M:System.Diagnostics.Process.Refresh
  id: Refresh
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Refresh()
  fullName: System.Diagnostics.Process.Refresh()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Refresh
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1005
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Discards any information about the associated process that has been cached inside the process component.</p>\n"
  remarks: "\n<p>After <xref href=\"System.Diagnostics.Process.Refresh\" data-throw-if-not-resolved=\"false\"></xref> is called, the first request for information about each property causes the process component to obtain a new value from the associated process.</p>\n<p>When a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component is associated with a process resource, the property values of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> are immediately populated according to the status of the associated process. If the information about the associated process subsequently changes, those changes are not reflected in the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component's cached values. The <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component is a snapshot of the process resource at the time they are associated. To view the current values for the associated process, call the <xref href=\"System.Diagnostics.Process.Refresh\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - "\n<p>The following example starts an instance of Notepad. It then retrieves the physical memory usage of the associated process at 2 second intervals for a maximum of 10 seconds. The example detects whether the process exits before 10 seconds have elapsed. The example closes the process if it is still running after 10 seconds.</p>process_refresh#1"
  syntax:
    content: public void Refresh()
    content.vb: Public Sub Refresh
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Start
  commentId: M:System.Diagnostics.Process.Start
  id: Start
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Start()
  fullName: System.Diagnostics.Process.Start()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1075
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Starts (or reuses) the process resource that is specified by the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property of this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component and associates it with the component.</p>\n"
  remarks: "\n<p>Use this overload to start a process resource and associate it with the current <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component. The return value <strong>true</strong> indicates that a new process resource was started. If the process resource specified by the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> member of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property is already running on the computer, no additional process resource is started. Instead, the running process resource is reused and <strong>false</strong> is returned.</p>\n<p>You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</p>\n<p>If you are using Visual Studio, this overload of the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method is the one that you insert into your code after you drag a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component onto the designer. Use the <strong>Properties</strong> window to expand the <strong>StartInfo</strong> category and write the appropriate value into the <strong>FileName</strong> property. Your changes will appear in the form's <strong>InitializeComponent</strong> procedure.</p>\n<p>This overload of <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> is not a <strong>static</strong> method. You must call it from an instance of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> class. Before calling <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref>, you must first specify <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property information for this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, because that information is used to determine the process resource to start.</p>\n<p>The other overloads of the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method are <strong>static</strong> members. You do not need to create an instance of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component before you call those overloads of the method. Instead, you can call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> class itself, and a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component is created if the process was started. Or, <strong>null</strong> is returned if a process was reused. The process resource is automatically associated with the new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component that is returned by the <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> members can be used to duplicate the functionality of the <strong>Run</strong> dialog box of the Windows <strong>Start</strong> menu. Anything that can be typed into a command line can be started by setting the appropriate values in the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property. The only <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property that must be set is the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property. The <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property does not have to be an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word.</p>\n<p>In the command line, you can specify actions to take for certain types of files. For example, you can print documents or edit text files. Specify these actions using the <xref href=\"System.Diagnostics.ProcessStartInfo.Verb\" data-throw-if-not-resolved=\"false\"></xref> member of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property. For other types of files, you can specify command-line arguments when you start the file from the <strong>Run</strong> dialog box. For example, you can pass a URL as an argument if you specify your browser as the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref>. These arguments can be specified in the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property's <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> member.</p>\n<p>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if <code>c:\\mypath</code> is not in your path, and you add it using quotation marks: <code>path = %path%;\"c:\\mypath\"</code>, you must fully qualify any process in <code>c:\\mypath</code> when starting it.</p>\n<p>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</p>\n<p>Whenever you use <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. You can check whether a process has already been closed by using its <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>A note about apartment states in managed threads is necessary here. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong> on the process component's <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property, make sure you have set a threading model on your application by setting the attribute <code>[STAThread]</code> on the <code>main()</code> method. Otherwise, a managed thread can be in an <strong>unknown</strong> state or put in the <strong>MTA</strong> state, the latter of which conflicts with <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> being <strong>true</strong>. Some methods require that the apartment state not be <strong>unknown</strong>. If the state is not explicitly set, when the application encounters such a method, it defaults to <strong>MTA</strong>, and once set, the apartment state cannot be changed. However, <strong>MTA</strong> causes an exception to be thrown when the operating system shell is managing the thread.</p>\n"
  example:
  - "\n<p>The following example uses an instance of the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> class to start a process.</p>Process.Start_instance#1"
  syntax:
    content: public bool Start()
    content.vb: Public Function Start As Boolean
    return:
      type: System.Boolean
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>No file name was specified in the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component's <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> member of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong> while <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong>. </p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>There was an error in opening the associated file. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The process object has already been disposed. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.StartInfo
    commentId: P:System.Diagnostics.Process.StartInfo
  - type: System.Diagnostics.ProcessStartInfo.FileName
    commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  - type: System.Diagnostics.ProcessStartInfo
    commentId: T:System.Diagnostics.ProcessStartInfo
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  commentId: M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  id: Start(System.Diagnostics.ProcessStartInfo)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Start(ProcessStartInfo)
  fullName: System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1135
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Starts the process resource that is specified by the parameter containing process start information (for example, the file name of the process to start) and associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component.</p>\n"
  remarks: "\n<p>Use this overload to start a process resource by specifying a <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> instance. The overload associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>If the address of the executable file to start is a URL, the process is not started and <strong>null</strong> is returned.</p>\n<p>This overload lets you start a process without first creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. Using this overload with a <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> parameter is an alternative to the explicit steps of creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, setting its <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> properties, and calling <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n<p>Using a <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> instance as the parameter lets you call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> with the most control over what is passed into the call to start the process. If you need to pass only a file name or a file name and arguments, it is not necessary to create a new <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> instance, although that is an option. The only <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property that must be set is the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property. The <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application that is installed on the system. For example, the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc extension if you have associated.doc files with a word processing tool, such as Microsoft Word. </p>\n<p>You can start a ClickOnce application by specifying the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</p>\n<p>If the <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.ProcessStartInfo.Password\" data-throw-if-not-resolved=\"false\"></xref> properties of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> instance are set, the unmanaged CreateProcessWithLogonW function is called, which starts the process in a new window even if the <xref href=\"System.Diagnostics.ProcessStartInfo.CreateNoWindow\" data-throw-if-not-resolved=\"false\"></xref> property value is <strong>true</strong> or the <xref href=\"System.Diagnostics.ProcessStartInfo.WindowStyle\" data-throw-if-not-resolved=\"false\"></xref> property value is <xref href=\"System.Diagnostics.ProcessWindowStyle.Hidden\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Unlike the other overloads, the overload of <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> that has no parameters is not a <strong>static</strong> member. Use that overload when you have already created a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. Use one of the <strong>static</strong> overloads when you want to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the start information for the process resource by using a <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n<p>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if <code>c:\\mypath</code> is not in your path, and you add it using quotation marks: <code>path = %path%;\"c:\\mypath\"</code>, you must fully qualify any process in <code>c:\\mypath</code> when starting it.</p>\n<p>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</p>\n<p>Whenever you use <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. You can check whether a process has already been closed by using its <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>A note about apartment states in managed threads is necessary here. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong> on the <em>startInfo</em> parameter, make sure you have set a threading model on your application by setting the attribute <code>[STAThread]</code> on the <code>main()</code> method. Otherwise, a managed thread can be in an <strong>unknown</strong> state or put in the <strong>MTA</strong> state, the latter of which conflicts with <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> being <strong>true</strong>. Some methods require that the apartment state not be <strong>unknown</strong>. If the state is not explicitly set, when the application encounters such a method, it defaults to <strong>MTA</strong>, and once set, the apartment state cannot be changed. However, <strong>MTA</strong> causes an exception to be thrown when the operating system shell is managing the thread.</p>\n"
  example:
  - "\n<p>The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</p>\n<p>For additional examples of other uses of this method, refer to the individual properties of the <xref href=\"System.Diagnostics.ProcessStartInfo\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Process.Start_static#1"
  syntax:
    content: public static Process Start(ProcessStartInfo startInfo)
    content.vb: Public Shared Function Start(startInfo As ProcessStartInfo) As Process
    parameters:
    - id: startInfo
      type: System.Diagnostics.ProcessStartInfo
    return:
      type: System.Diagnostics.Process
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>No file name was specified in the <em>startInfo</em> parameter's <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property of the <em>startInfo</em> parameter is <strong>true</strong> and the <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardInput\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardOutput\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Diagnostics.ProcessStartInfo.RedirectStandardError\" data-throw-if-not-resolved=\"false\"></xref> property is also <strong>true</strong>.</p>\n<p>-or-</p>\n<p>The <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> property of the <em>startInfo</em> parameter is <strong>true</strong> and the <xref href=\"System.Diagnostics.ProcessStartInfo.UserName\" data-throw-if-not-resolved=\"false\"></xref> property is not <strong>null</strong> or empty or the <xref href=\"System.Diagnostics.ProcessStartInfo.Password\" data-throw-if-not-resolved=\"false\"></xref> property is not <strong>null</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>startInfo</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The process object has already been disposed. </p>\n"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "\n<p>The file specified in the <em>startInfo</em> parameter's <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> property could not be found.</p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>An error occurred when opening the associated file. </p>\n<p>-or-</p>\n<p>The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: \"The data area passed to a system call is too small.\" or \"Access is denied.\"</p>\n"
  seealso:
  - type: System.Diagnostics.Process.StartInfo
    commentId: P:System.Diagnostics.Process.StartInfo
  - type: System.Diagnostics.ProcessStartInfo.FileName
    commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  - type: System.Diagnostics.ProcessStartInfo
    commentId: T:System.Diagnostics.ProcessStartInfo
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.Start(System.String)
  commentId: M:System.Diagnostics.Process.Start(System.String)
  id: Start(System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Start(String)
  fullName: System.Diagnostics.Process.Start(System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1109
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Starts a process resource by specifying the name of a document or application file and associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component.</p>\n"
  remarks: "\n<p>Use this overload to start a process resource by specifying its file name. The overload associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>If the address of the executable file to start is a URL, the process is not started and <strong>null</strong> is returned.</p>\n<p>This overload lets you start a process without first creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. The overload is an alternative to the explicit steps of creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, setting the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> member of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property, and calling <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. </p>\n<p>You can start a ClickOnce application by setting the <em>fileName</em> parameter to the location (for example, a Web address) from which you originally installed the application. Do not start a ClickOnce application by specifying its installed location on your hard drive.</p>\n<p>Starting a process by specifying its file name is similar to typing the information in the <strong>Run</strong> dialog box of the Windows <strong>Start</strong> menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the <strong>Run</strong> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <em>fileName</em> parameter. For example, you can set the <em>fileName</em> parameter to either \"Notepad.exe\" or \"Notepad\".</p>\n<p>This overload does not allow command-line arguments for the process. If you need to specify one or more command-line arguments for the process, use the <xref href=\"System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Start(System.String,System.String)\" data-throw-if-not-resolved=\"false\"></xref> overloads.</p>\n<p>Unlike the other overloads, the overload of <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> that has no parameters is not a <strong>static</strong> member. Use that overload when you have already created a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. Use one of the <strong>static</strong> overloads when you want to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start.</p>\n<p>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if <code>c:\\mypath</code> is not in your path, and you add it using quotation marks: <code>path = %path%;\"c:\\mypath\"</code>, you must fully qualify any process in <code>c:\\mypath</code> when starting it.</p>\n<p>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</p>\n<p>Whenever you use <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. You can check whether a process has already been closed by using its <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>A note about apartment states in managed threads is necessary here. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong> on the process component's <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property, make sure you have set a threading model on your application by setting the attribute <code>[STAThread]</code> on the <code>main()</code> method. Otherwise, a managed thread can be in an <strong>unknown</strong> state or put in the <strong>MTA</strong> state, the latter of which conflicts with <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> being <strong>true</strong>. Some methods require that the apartment state not be <strong>unknown</strong>. If the state is not explicitly set, when the application encounters such a method, it defaults to <strong>MTA</strong>, and once set, the apartment state cannot be changed. However, <strong>MTA</strong> causes an exception to be thrown when the operating system shell is managing the thread.</p>\n"
  example:
  - "\n<p>The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</p>Process.Start_static#1"
  syntax:
    content: public static Process Start(string fileName)
    content.vb: Public Shared Function Start(fileName As String) As Process
    parameters:
    - id: fileName
      type: System.String
    return:
      type: System.Diagnostics.Process
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>An error occurred when opening the associated file. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The process object has already been disposed. </p>\n"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "\n<p>The PATH environment variable has a string containing quotes.</p>\n"
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.FileName
    commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  - type: System.Diagnostics.Process.StartInfo
    commentId: P:System.Diagnostics.Process.StartInfo
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.Start(System.String,System.String)
  commentId: M:System.Diagnostics.Process.Start(System.String,System.String)
  id: Start(System.String,System.String)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Start(String, String)
  fullName: System.Diagnostics.Process.Start(System.String, System.String)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1122
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Starts a process resource by specifying the name of an application and a set of command-line arguments, and associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component.</p>\n"
  remarks: "\n<p>Use this overload to start a process resource by specifying its file name and command-line arguments. The overload associates the resource with a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>If the address of the executable file to start is a URL, the process is not started and <strong>null</strong> is returned.</p>\n<p>This overload lets you start a process without first creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. The overload is an alternative to the explicit steps of creating a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, setting the <xref href=\"System.Diagnostics.ProcessStartInfo.FileName\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.ProcessStartInfo.Arguments\" data-throw-if-not-resolved=\"false\"></xref> members of the <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property, and calling <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n<p>Starting a process by specifying its file name and arguments is similar to typing the file name and command-line arguments in the <strong>Run</strong> dialog box of the Windows <strong>Start</strong> menu. Therefore, the file name does not need to represent an executable file. It can be of any file type for which the extension has been associated with an application installed on the system. For example the file name can have a .txt extension if you have associated text files with an editor, such as Notepad, or it can have a .doc if you have associated.doc files with a word processing tool, such as Microsoft Word. Similarly, in the same way that the <strong>Run</strong> dialog box can accept an executable file name with or without the .exe extension, the .exe extension is optional in the <em>fileName</em> parameter. For example, you can set the <em>fileName</em> parameter to either \"Notepad.exe\" or \"Notepad\". If the <em>fileName</em> parameter represents an executable file, the <em>arguments</em> parameter might represent a file to act upon, such as the text file in <code>Notepad.exe myfile.txt</code>. If the <em>fileName</em> parameter represents a command (.cmd) file, the <em>arguments</em> parameter must include either a \"<code>/c</code>\" or \"<code>/k</code>\" argument to specify whether the command window exits or remains after completion.</p>\n<p>Unlike the other overloads, the overload of <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> that has no parameters is not a <strong>static</strong> member. Use that overload when you have already created a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, specified start information (including the file name), and want to start a process resource and associate it with the existing <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance. Use one of the <strong>static</strong> overloads when you want to create a new <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component rather than start a process for an existing component. Both this overload and the overload that has no parameters allow you to specify the file name of the process resource to start and command-line arguments to pass.</p>\n<p>If you have a path variable declared in your system using quotes, you must fully qualify that path when starting any process found in that location. Otherwise, the system will not find the path. For example, if <code>c:\\mypath</code> is not in your path, and you add it using quotation marks: <code>path = %path%;\"c:\\mypath\"</code>, you must fully qualify any process in <code>c:\\mypath</code> when starting it.</p>\n<p>ASP.NET Web page and server control code executes in the context of the ASP.NET worker process on the Web server.  If you use the <see cref=\"Overload:System.Diagnostics.Process.Start\"></see> method in an ASP.NET Web page or server control, the new process executes on the Web server with restricted permissions. The process does not start in the same context as the client browser, and does not have access to the user desktop.</p>\n<p>Whenever you use <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> to start a process, you might need to close it or you risk losing system resources. Close processes using <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Diagnostics.Process.Kill\" data-throw-if-not-resolved=\"false\"></xref>. You can check whether a process has already been closed by using its <xref href=\"System.Diagnostics.Process.HasExited\" data-throw-if-not-resolved=\"false\"></xref> property..</p>\n<p>A note about apartment states in managed threads is necessary here. When <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> is <strong>true</strong> on the process component's <xref href=\"System.Diagnostics.Process.StartInfo\" data-throw-if-not-resolved=\"false\"></xref> property, make sure you have set a threading model on your application by setting the attribute <code>[STAThread]</code> on the <code>main()</code> method. Otherwise, a managed thread can be in an <strong>unknown</strong> state or put in the <strong>MTA</strong> state, the latter of which conflicts with <xref href=\"System.Diagnostics.ProcessStartInfo.UseShellExecute\" data-throw-if-not-resolved=\"false\"></xref> being <strong>true</strong>. Some methods require that the apartment state not be <strong>unknown</strong>. If the state is not explicitly set, when the application encounters such a method, it defaults to <strong>MTA</strong>, and once set, the apartment state cannot be changed. However, <strong>MTA</strong> causes an exception to be thrown when the operating system shell is managing the thread.</p>\n"
  example:
  - "\n<p>The following example first spawns an instance of Internet Explorer and displays the contents of the Favorites folder in the browser. It then starts some other instances of Internet Explorer and displays some specific pages or sites. Finally it starts Internet Explorer with the window being minimized while navigating to a specific site.</p>Process.Start_static#1"
  syntax:
    content: public static Process Start(string fileName, string arguments)
    content.vb: Public Shared Function Start(fileName As String, arguments As String) As Process
    parameters:
    - id: fileName
      type: System.String
    - id: arguments
      type: System.String
    return:
      type: System.Diagnostics.Process
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>fileName</em> or <em>arguments</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>An error occurred when opening the associated file. </p>\n<p>-or-</p>\n<p>The sum of the length of the arguments and the length of the full path to the process exceeds 2080. The error message associated with this exception can be one of the following: \"The data area passed to a system call is too small.\" or \"Access is denied.\"</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The process object has already been disposed. </p>\n"
  - type: System.IO.FileNotFoundException
    commentId: T:System.IO.FileNotFoundException
    description: "\n<p>The PATH environment variable has a string containing quotes.</p>\n"
  seealso:
  - type: System.Diagnostics.ProcessStartInfo.FileName
    commentId: P:System.Diagnostics.ProcessStartInfo.FileName
  - type: System.Diagnostics.Process.StartInfo
    commentId: P:System.Diagnostics.Process.StartInfo
  - type: System.Diagnostics.ProcessStartInfo
    commentId: T:System.Diagnostics.ProcessStartInfo
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Diagnostics.Process.WaitForExit
  commentId: M:System.Diagnostics.Process.WaitForExit
  id: WaitForExit
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: WaitForExit()
  fullName: System.Diagnostics.Process.WaitForExit()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitForExit
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1203
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Instructs the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component to wait indefinitely for the associated process to exit.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> makes the current thread wait until the associated process terminates.  It should be called after all other methods are called on the process. To avoid blocking the current thread, use the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>This method instructs the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component to wait an infinite amount of time for the process and event handlers to exit. This can cause an application to stop responding. For example, if you call <xref href=\"System.Diagnostics.Process.CloseMainWindow\" data-throw-if-not-resolved=\"false\"></xref> for a process that has a user interface, the request to the operating system to terminate the associated process might not be handled if the process is written to never enter its message loop.</p>\n<p>In the .NET Framework 3.5 and earlier versions, the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> overload waited for <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds (approximately 24 days), not indefinitely. Also, previous versions did not wait for the event handlers to exit if the full <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> time was reached.</p>\n<p>This overload ensures that all processing has been completed, including the handling of asynchronous events for redirected standard output. You should use this overload after a call to the <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload when standard output has been redirected to asynchronous event handlers.</p>\n<p>When an associated process exits (that is, when it is shut down by the operation system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component can then access the information, which includes the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref>, by using the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> to the exited process.</p>\n<p>Because the associated process has exited, the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> property of the component no longer points to an existing process resource. Instead, the handle can be used only to access the operating system's information about the process resource. The system is aware of handles to exited processes that have not been released by <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components, so it keeps the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> information in memory until the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component specifically frees the resources. For this reason, any time you call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, call <xref href=\"System.Diagnostics.Process.Close\" data-throw-if-not-resolved=\"false\"></xref> when the associated process has terminated and you no longer need any administrative information about it. <xref href=\"System.Diagnostics.Process.Close\" data-throw-if-not-resolved=\"false\"></xref> frees the memory allocated to the exited process.</p>\n"
  example:
  - "\n<p>See the Remarks section of the <xref href=\"System.Diagnostics.Process.StandardError\" data-throw-if-not-resolved=\"false\"></xref> property reference page.</p>\n"
  syntax:
    content: public void WaitForExit()
    content.vb: Public Sub WaitForExit
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>The wait setting could not be accessed. </p>\n"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "\n<p>No process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> has been set, and a <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> from which the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property can be determined does not exist.</p>\n<p>-or- </p>\n<p>There is no process associated with this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>-or- </p>\n<p>You are attempting to call <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  - type: System.Diagnostics.Process.Handle
    commentId: P:System.Diagnostics.Process.Handle
  - type: System.Diagnostics.Process.ExitTime
    commentId: P:System.Diagnostics.Process.ExitTime
  - type: System.Diagnostics.Process.EnableRaisingEvents
    commentId: P:System.Diagnostics.Process.EnableRaisingEvents
  - type: System.Diagnostics.Process.HasExited
    commentId: P:System.Diagnostics.Process.HasExited
  - type: System.Diagnostics.Process.Exited
    commentId: E:System.Diagnostics.Process.Exited
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.WaitForExit(System.Int32)
  commentId: M:System.Diagnostics.Process.WaitForExit(System.Int32)
  id: WaitForExit(System.Int32)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: WaitForExit(Int32)
  fullName: System.Diagnostics.Process.WaitForExit(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitForExit
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1212
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Instructs the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component to wait the specified number of milliseconds for the associated process to exit.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> makes the current thread wait until the associated process terminates. It should be called after all other methods are called on the process. To avoid blocking the current thread, use the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event.</p>\n<p>This method instructs the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component to wait a finite amount of time for the process to exit. If the associated process does not exit by the end of the interval because the request to terminate is denied, <strong>false</strong> is returned to the calling procedure. You can specify a negative number (<xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) for <em>milliseconds</em>, and <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will behave the same as the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> overload. If you pass 0 (zero) to the method, it returns <strong>true</strong> only if the process has already exited; otherwise, it immediately returns <strong>false</strong>.</p>\n<p>In the .NET Framework 3.5 and earlier versions, if <em>milliseconds</em> was -1, the <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload waited for <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds (approximately 24 days), not indefinitely. </p>\n<p>When standard output has been redirected to asynchronous event handlers, it is possible that output processing will not have completed when this method returns. To ensure that asynchronous event handling has been completed, call the <xref href=\"System.Diagnostics.Process.WaitForExit\" data-throw-if-not-resolved=\"false\"></xref> overload that takes no parameter after receiving a <strong>true</strong> from this overload. To help ensure that the <xref href=\"System.Diagnostics.Process.Exited\" data-throw-if-not-resolved=\"false\"></xref> event is handled correctly in Windows Forms applications, set the <xref href=\"System.Diagnostics.Process.SynchronizingObject\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>When an associated process exits (is shut down by the operating system through a normal or abnormal termination), the system stores administrative information about the process and returns to the component that had called <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component can then access the information, which includes the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref>, by using the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> to the exited process.</p>\n<p>Because the associated process has exited, the <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> property of the component no longer points to an existing process resource. Instead, the handle can be used only to access the operating system's information about the process resource. The system is aware of handles to exited processes that have not been released by <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> components, so it keeps the <xref href=\"System.Diagnostics.Process.ExitTime\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> information in memory until the <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> component specifically frees the resources. For this reason, any time you call <xref href=\"System.Diagnostics.Process.Start\" data-throw-if-not-resolved=\"false\"></xref> for a <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> instance, call <xref href=\"System.Diagnostics.Process.Close\" data-throw-if-not-resolved=\"false\"></xref> when the associated process has terminated and you no longer need any administrative information about it. <xref href=\"System.Diagnostics.Process.Close\" data-throw-if-not-resolved=\"false\"></xref> frees the memory allocated to the exited process.</p>\n"
  example:
  - "\n<p>See the code example for the <xref href=\"System.Diagnostics.Process.ExitCode\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n"
  syntax:
    content: public bool WaitForExit(int milliseconds)
    content.vb: Public Function WaitForExit(milliseconds As Integer) As Boolean
    parameters:
    - id: milliseconds
      type: System.Int32
    return:
      type: System.Boolean
  exceptions:
  - type: System.ComponentModel.Win32Exception
    commentId: T:System.ComponentModel.Win32Exception
    description: "\n<p>The wait setting could not be accessed. </p>\n"
  - type: System.SystemException
    commentId: T:System.SystemException
    description: "\n<p>No process <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> has been set, and a <xref href=\"System.Diagnostics.Process.Handle\" data-throw-if-not-resolved=\"false\"></xref> from which the <xref href=\"System.Diagnostics.Process.Id\" data-throw-if-not-resolved=\"false\"></xref> property can be determined does not exist.</p>\n<p>-or- </p>\n<p>There is no process associated with this <xref href=\"System.Diagnostics.Process\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>-or- </p>\n<p>You are attempting to call <xref href=\"System.Diagnostics.Process.WaitForExit(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> for a process that is running on a remote computer. This method is available only for processes that are running on the local computer. </p>\n"
  seealso:
  - type: System.Diagnostics.Process.CloseMainWindow
    commentId: M:System.Diagnostics.Process.CloseMainWindow
  - type: System.Diagnostics.Process.Kill
    commentId: M:System.Diagnostics.Process.Kill
  - type: System.Diagnostics.Process.Handle
    commentId: P:System.Diagnostics.Process.Handle
  - type: System.Diagnostics.Process.ExitTime
    commentId: P:System.Diagnostics.Process.ExitTime
  - type: System.Diagnostics.Process.EnableRaisingEvents
    commentId: P:System.Diagnostics.Process.EnableRaisingEvents
  - type: System.Diagnostics.Process.HasExited
    commentId: P:System.Diagnostics.Process.HasExited
  - type: System.Diagnostics.Process.Exited
    commentId: E:System.Diagnostics.Process.Exited
  - type: System.Diagnostics.Process.SynchronizingObject
    commentId: P:System.Diagnostics.Process.SynchronizingObject
  see:
  - type: System.Security.Permissions.SecurityAction.LinkDemand
    commentId: F:System.Security.Permissions.SecurityAction.LinkDemand
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Dispose
  commentId: M:System.Diagnostics.Process.Dispose
  id: Dispose
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Diagnostics.Process.Dispose()
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 1361
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Diagnostics.Process.Dispose(System.Boolean)
  commentId: M:System.Diagnostics.Process.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Diagnostics.Process
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Diagnostics.Process.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
    startLine: 706
  assemblies:
  - System.Diagnostics.Process
  namespace: System.Diagnostics
  summary: "\n<p>Release all resources used by this process.</p>\n"
  syntax:
    content: protected virtual void Dispose(bool disposing)
    content.vb: Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
references:
- uid: System.Diagnostics
  isExternal: false
  name: System.Diagnostics
  fullName: System.Diagnostics
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.DateTime
  parent: System
  isExternal: false
  name: DateTime
  fullName: System.DateTime
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Diagnostics.ProcessModule
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModule
  fullName: System.Diagnostics.ProcessModule
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Diagnostics.ProcessModuleCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessModuleCollection
  fullName: System.Diagnostics.ProcessModuleCollection
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Diagnostics.ProcessPriorityClass
  parent: System.Diagnostics
  isExternal: false
  name: ProcessPriorityClass
  fullName: System.Diagnostics.ProcessPriorityClass
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
- uid: Microsoft.Win32.SafeHandles.SafeProcessHandle
  parent: Microsoft.Win32.SafeHandles
  isExternal: false
  name: SafeProcessHandle
  fullName: Microsoft.Win32.SafeHandles.SafeProcessHandle
- uid: Microsoft.Win32.SafeHandles
  isExternal: false
  name: Microsoft.Win32.SafeHandles
  fullName: Microsoft.Win32.SafeHandles
- uid: System.IO.StreamReader
  parent: System.IO
  isExternal: false
  name: StreamReader
  fullName: System.IO.StreamReader
- uid: System.IO
  isExternal: false
  name: System.IO
  fullName: System.IO
- uid: System.IO.StreamWriter
  parent: System.IO
  isExternal: false
  name: StreamWriter
  fullName: System.IO.StreamWriter
- uid: System.Diagnostics.ProcessStartInfo
  parent: System.Diagnostics
  isExternal: false
  name: ProcessStartInfo
  fullName: System.Diagnostics.ProcessStartInfo
- uid: System.Diagnostics.ProcessThreadCollection
  parent: System.Diagnostics
  isExternal: false
  name: ProcessThreadCollection
  fullName: System.Diagnostics.ProcessThreadCollection
- uid: System.Diagnostics.DataReceivedEventHandler
  parent: System.Diagnostics
  isExternal: false
  name: DataReceivedEventHandler
  fullName: System.Diagnostics.DataReceivedEventHandler
- uid: System.EventHandler
  parent: System
  isExternal: false
  name: EventHandler
  fullName: System.EventHandler
- uid: System.Diagnostics.Process
  parent: System.Diagnostics
  isExternal: false
  name: Process
  fullName: System.Diagnostics.Process
- uid: System.Diagnostics.Process[]
  isExternal: false
  name: Process[]
  fullName: System.Diagnostics.Process[]
  fullname.vb: System.Diagnostics.Process()
  name.vb: Process()
  spec.csharp:
  - uid: System.Diagnostics.Process
    name: Process
    fullName: System.Diagnostics.Process
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Diagnostics.Process
    name: Process
    fullName: System.Diagnostics.Process
  - name: ()
    fullName: ()
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.PlatformNotSupportedException
  isExternal: false
  name: PlatformNotSupportedException
  fullName: System.PlatformNotSupportedException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ComponentModel.Win32Exception
  isExternal: false
  name: Win32Exception
  fullName: System.ComponentModel.Win32Exception
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ComponentModel.InvalidEnumArgumentException
- uid: System.NullReferenceException
  isExternal: false
  name: NullReferenceException
  fullName: System.NullReferenceException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.SystemException
  parent: System
  isExternal: true
  name: SystemException
  fullName: System.SystemException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.IO.FileNotFoundException
  isExternal: false
  name: FileNotFoundException
  fullName: System.IO.FileNotFoundException
