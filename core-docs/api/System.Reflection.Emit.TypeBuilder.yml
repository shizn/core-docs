items:
- uid: System.Reflection.Emit.TypeBuilder
  commentId: T:System.Reflection.Emit.TypeBuilder
  id: TypeBuilder
  parent: System.Reflection.Emit
  children:
  - System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  - System.Reflection.Emit.TypeBuilder.Assembly
  - System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  - System.Reflection.Emit.TypeBuilder.Attributes
  - System.Reflection.Emit.TypeBuilder.BaseType
  - System.Reflection.Emit.TypeBuilder.ContainsGenericParameters
  - System.Reflection.Emit.TypeBuilder.CreateTypeInfo
  - System.Reflection.Emit.TypeBuilder.DeclaringMethod
  - System.Reflection.Emit.TypeBuilder.DeclaringType
  - System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  - System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  - System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)
  - System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  - System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  - System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  - System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  - System.Reflection.Emit.TypeBuilder.FullName
  - System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  - System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  - System.Reflection.Emit.TypeBuilder.GenericTypeArguments
  - System.Reflection.Emit.TypeBuilder.GetArrayRank
  - System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  - System.Reflection.Emit.TypeBuilder.GetElementType
  - System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  - System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints
  - System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  - System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  - System.Reflection.Emit.TypeBuilder.GUID
  - System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)
  - System.Reflection.Emit.TypeBuilder.IsCreated
  - System.Reflection.Emit.TypeBuilder.IsEnum
  - System.Reflection.Emit.TypeBuilder.IsGenericParameter
  - System.Reflection.Emit.TypeBuilder.IsGenericType
  - System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  - System.Reflection.Emit.TypeBuilder.IsSerializable
  - System.Reflection.Emit.TypeBuilder.MakeArrayType
  - System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  - System.Reflection.Emit.TypeBuilder.MakeByRefType
  - System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  - System.Reflection.Emit.TypeBuilder.MakePointerType
  - System.Reflection.Emit.TypeBuilder.Module
  - System.Reflection.Emit.TypeBuilder.Name
  - System.Reflection.Emit.TypeBuilder.Namespace
  - System.Reflection.Emit.TypeBuilder.PackingSize
  - System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  - System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  - System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  - System.Reflection.Emit.TypeBuilder.Size
  - System.Reflection.Emit.TypeBuilder.ToString
  - System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  langs:
  - csharp
  - vb
  name: TypeBuilder
  fullName: System.Reflection.Emit.TypeBuilder
  type: Class
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TypeBuilder
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 20
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines and creates new instances of classes during run time.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> is the root class used to control the creation of dynamic classes in the runtime. It provides a set of routines that are used to define classes, add methods and fields, and create the class inside a module. A new <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> can be created from a dynamic module by calling the <xref href=\"System.Reflection.Emit.ModuleBuilder.DefineType(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, which returns a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>Reflection emit provides the following options for defining types: </p>\n<ul><li>\n<p>Define a class or interface with the given name.</p>\n</li><li>\n<p>Define a class or interface with the given name and attributes. </p>\n</li><li>\n<p>Define a class with the given name, attributes, and base class. </p>\n</li><li>\n<p>Define a class with the given name, attributes, base class, and the set of interfaces that the class implements. </p>\n</li><li>\n<p>Define a class with the given name, attributes, base class, and packing size. </p>\n</li><li>\n<p>Define a class with the given name, attributes, base class, and the class size as a whole. </p>\n</li><li>\n<p>Define a class with the given name, attributes, base class, packing size, and the class size as a whole. </p>\n</li></ul>\n<p>To create an array type, pointer type, or byref type for an incomplete type that is represented by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object, use the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeArrayType\" data-throw-if-not-resolved=\"false\"></xref> method, <xref href=\"System.Reflection.Emit.TypeBuilder.MakePointerType\" data-throw-if-not-resolved=\"false\"></xref> method, or <xref href=\"System.Reflection.Emit.TypeBuilder.MakeByRefType\" data-throw-if-not-resolved=\"false\"></xref> method, respectively.</p>\n<p>Before a type is used, the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method must be called. <strong>CreateType</strong> completes the creation of the type. Following the call to <strong>CreateType</strong>, the caller can instantiate the type by using the <see cref=\"Overload:System.Activator.CreateInstance\"></see> method, and invoke members of the type by using the <see cref=\"Overload:System.Type.InvokeMember\"></see> method. It is an error to invoke methods that change the implementation of a type after <strong>CreateType</strong> has been called. For example, the common language runtime throws an exception if the caller tries to add new members to a type. </p>\n<p>A class initializer is created by using the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineTypeInitializer\" data-throw-if-not-resolved=\"false\"></xref> method. <strong>DefineTypeInitializer </strong>returns a <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>Nested types are defined by calling one of the <see cref=\"Overload:System.Reflection.Emit.TypeBuilder.DefineNestedType\"></see> methods. </p>\n"
  example:
  - >-
    <p>This section contains two code examples. The first example shows how to create a dynamic type with a field, constructor, property, and method. The second example builds a method dynamically from user input. </p>

    <p>Example one</p>

    <p>The following code example shows how to define a dynamic assembly with one module. The module in the example assembly contains one type, <code>MyDynamicType</code>, which has a private field, a property that gets and sets the private field, constructors that initialize the private field, and a method that multiplies a user-supplied number by the private field value and returns the result. </p>

    <p>The <xref href="System.Reflection.Emit.AssemblyBuilderAccess.RunAndSave" data-throw-if-not-resolved="false"></xref> field is specified when the assembly is created. The assembly code is used immediately, and the assembly is also saved to disk so that it can be examined with Ildasm.exe (IL Disassembler) or used in another program. </p>AssemblyBuilderClass#1<p>Example two</p><p>The following code sample demonstrates how to build a dynamic type by using <strong>TypeBuilder</strong>.</p>System.Reflection.Emit ILGenerator Example#1
  syntax:
    content: 'public sealed class TypeBuilder : TypeInfo, TypeInfo'
    content.vb: >-
      Public NotInheritable Class TypeBuilder
          Inherits TypeInfo
          Implements TypeInfo
  inheritance:
  - System.Object
  implements:
  - System.Reflection.TypeInfo
  modifiers.csharp:
  - public
  - sealed
  - class
  modifiers.vb:
  - Public
  - NotInheritable
  - Class
- uid: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  commentId: F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  id: UnspecifiedTypeSize
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: UnspecifiedTypeSize
  fullName: System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize
  type: Field
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UnspecifiedTypeSize
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 193
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Represents that total size for the type is not specified.</p>\n"
  syntax:
    content: public const int UnspecifiedTypeSize = null
    content.vb: Public Const UnspecifiedTypeSize As Integer = Nothing
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - const
  modifiers.vb:
  - Public
  - Const
- uid: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  commentId: P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  id: AssemblyQualifiedName
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: AssemblyQualifiedName
  fullName: System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AssemblyQualifiedName
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 194
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the full name of this type qualified by the display name of the assembly.</p>\n"
  remarks: "\n<p>The format of the returned string is the concatenation of the full name of the type (<xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref>) and the display name of the assembly (<xref href=\"System.Reflection.AssemblyName.FullName\" data-throw-if-not-resolved=\"false\"></xref>), separated by a comma and a space. </p>\n<p>See <xref href=\"System.Reflection.AssemblyName\" data-throw-if-not-resolved=\"false\"></xref> for a description of the format of the display name of an assembly.</p>\n"
  example:
  - 
  syntax:
    content: public override string AssemblyQualifiedName { get; }
    content.vb: Public Overrides ReadOnly Property AssemblyQualifiedName As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>Read-only. The full name of this type qualified by the display name of the assembly.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.FullName
  commentId: P:System.Reflection.Emit.TypeBuilder.FullName
  id: FullName
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: FullName
  fullName: System.Reflection.Emit.TypeBuilder.FullName
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FullName
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 195
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the full path of this type.</p>\n"
  remarks: "\n<p>The returned format is \"enclosingTypeFullName+nestedTypeName\" for nested types and \"typeName\" for non-nested types.</p>\n"
  syntax:
    content: public override string FullName { get; }
    content.vb: Public Overrides ReadOnly Property FullName As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>Read-only. Retrieves the full path of this type.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.IsGenericParameter
  commentId: P:System.Reflection.Emit.TypeBuilder.IsGenericParameter
  id: IsGenericParameter
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsGenericParameter
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericParameter
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsGenericParameter
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 196
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a value indicating whether the current type is a generic type parameter.</p>\n"
  remarks: "\n<p>When emitting code, a generic type parameter is represented by a <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object rather than by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  syntax:
    content: public override bool IsGenericParameter { get; }
    content.vb: Public Overrides ReadOnly Property IsGenericParameter As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic type parameter; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.Name
  commentId: P:System.Reflection.Emit.TypeBuilder.Name
  id: Name
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Name
  fullName: System.Reflection.Emit.TypeBuilder.Name
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Name
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 197
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the name of this type.</p>\n"
  syntax:
    content: public override string Name { get; }
    content.vb: Public Overrides ReadOnly Property Name As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>Read-only. Retrieves the <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> name of this type.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.PackingSize
  commentId: P:System.Reflection.Emit.TypeBuilder.PackingSize
  id: PackingSize
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: PackingSize
  fullName: System.Reflection.Emit.TypeBuilder.PackingSize
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PackingSize
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 198
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the packing size of this type.</p>\n"
  syntax:
    content: public PackingSize PackingSize { get; }
    content.vb: Public ReadOnly Property PackingSize As PackingSize
    parameters: []
    return:
      type: System.Reflection.Emit.PackingSize
      description: "\n<p>Read-only. Retrieves the packing size of this type.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.Size
  commentId: P:System.Reflection.Emit.TypeBuilder.Size
  id: Size
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Size
  fullName: System.Reflection.Emit.TypeBuilder.Size
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Size
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 199
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the total size of a type.</p>\n"
  syntax:
    content: public int Size { get; }
    content.vb: Public ReadOnly Property Size As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>Read-only. Retrieves this type’s total size.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  commentId: M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  id: AddInterfaceImplementation(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: AddInterfaceImplementation(Type)
  fullName: System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddInterfaceImplementation
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 200
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds an interface that this type implements.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates the implementation of an interface on a dynamically created type using <strong>AddInterfaceImplementation</strong>.</p>TypeBuilder_Sample_4#3"
  syntax:
    content: public void AddInterfaceImplementation(Type interfaceType)
    content.vb: Public Sub AddInterfaceImplementation(interfaceType As Type)
    parameters:
    - id: interfaceType
      type: System.Type
      description: "\n<p>The interface that this type implements. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>interfaceType</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.CreateTypeInfo
  commentId: M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo
  id: CreateTypeInfo
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: CreateTypeInfo()
  fullName: System.Reflection.Emit.TypeBuilder.CreateTypeInfo()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateTypeInfo
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 201
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a <xref href=\"System.Reflection.TypeInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents this type.</p>\n"
  syntax:
    content: public TypeInfo CreateTypeInfo()
    content.vb: Public Function CreateTypeInfo As TypeInfo
    return:
      type: System.Reflection.TypeInfo
      description: "\n<p>An object that represents this type.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  id: DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineConstructor(MethodAttributes, CallingConventions, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineConstructor
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 202
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new constructor to the type, with the given attributes and signature.</p>\n"
  remarks: "\n<p>If you do not define a constructor for your dynamic type, a default constructor is provided automatically, and it calls the default constructor of the base class.</p>\n<p>If you define a constructor for your dynamic type, a default constructor is not provided. You have the following options for providing a default constructor in addition to the constructor you defined:</p>\n<ul><li>\n<p>If you want a default constructor that simply calls the default constructor of the base class, you can use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)\" data-throw-if-not-resolved=\"false\"></xref> method to create one (and optionally restrict access to it). Do not provide an implementation for this default constructor. If you do, an exception is thrown when you try to use the constructor. No exception is thrown when the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n</li><li>\n<p>If you want a default constructor that does something more than simply calling the default constructor of the base class, or that calls another constructor of the base class, or that does something else entirely, you must use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method to create one, and provide your own implementation. </p>\n</li></ul>\n"
  example:
  - "\n<p>The following code sample demonstrates the use of <strong>DefineConstructor</strong> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> for MSIL population.</p>TypeBuilder_Sample_4#2"
  syntax:
    content: public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes)
    content.vb: Public Function DefineConstructor(attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type()) As ConstructorBuilder
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the constructor. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the constructor. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The parameter types of the constructor. </p>\n"
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: "\n<p>The defined constructor.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type())
  name.vb: DefineConstructor(MethodAttributes, CallingConventions, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  id: DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineConstructor(MethodAttributes, CallingConventions, Type[], Type[][], Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type[], System.Type[][], System.Type[][])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineConstructor
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 203
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new constructor to the type, with the given attributes, signature, and custom modifiers.</p>\n"
  remarks: "\n<p>This overload is provided for designers of managed compilers.</p>\n<p>For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n"
  syntax:
    content: public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers)
    content.vb: Public Function DefineConstructor(attributes As MethodAttributes, callingConvention As CallingConventions, parameterTypes As Type(), requiredCustomModifiers As Type()(), optionalCustomModifiers As Type()()) As ConstructorBuilder
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the constructor. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the constructor. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The parameter types of the constructor. </p>\n"
    - id: requiredCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no required custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have required custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    - id: optionalCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no optional custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have optional custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: "\n<p>The defined constructor.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The size of <em>requiredCustomModifiers</em> or <em>optionalCustomModifiers</em> does not equal the size of <em>parameterTypes</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type(), System.Type()(), System.Type()())
  name.vb: DefineConstructor(MethodAttributes, CallingConventions, Type(), Type()(), Type()())
- uid: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  id: DefineDefaultConstructor(System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineDefaultConstructor(MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineDefaultConstructor
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 204
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines the default constructor. The constructor defined here will simply call the default constructor of the parent.</p>\n"
  remarks: "\n<p>Because the default constructor is automatically defined, it is necessary to call this method only in the following situations:</p>\n<ul><li>\n<p>You have defined another constructor and you also want a default constructor that simply calls the base class constructor.</p>\n</li><li>\n<p>You want to set the attributes on the default constructor to something other than <xref href=\"System.Reflection.MethodAttributes.PrivateScope\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodAttributes.Public\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodAttributes.HideBySig\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.MethodAttributes.SpecialName\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.MethodAttributes.RTSpecialName\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n</li></ul>\n"
  example:
  - "\n<p>The following code sample demonstrates the use of <strong>DefineConstructor</strong> to set a constructor's particular signature and attributes on a dynamic type and return a corresponding <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> for MSIL population.</p>TypeBuilder_Sample_4#2"
  syntax:
    content: public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes)
    content.vb: Public Function DefineDefaultConstructor(attributes As MethodAttributes) As ConstructorBuilder
    parameters:
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>A <strong>MethodAttributes</strong> object representing the attributes to be applied to the constructor. </p>\n"
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: "\n<p>Returns the constructor.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The parent type (base type) does not have a default constructor. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  id: DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineEvent(String, EventAttributes, Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineEvent(System.String, System.Reflection.EventAttributes, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineEvent
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 205
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new event to the type, with the given name, attributes and event type.</p>\n"
  syntax:
    content: public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype)
    content.vb: Public Function DefineEvent(name As String, attributes As EventAttributes, eventtype As Type) As EventBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the event. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.EventAttributes
      description: "\n<p>The attributes of the event. </p>\n"
    - id: eventtype
      type: System.Type
      description: "\n<p>The type of the event. </p>\n"
    return:
      type: System.Reflection.Emit.EventBuilder
      description: "\n<p>The defined event.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>\n<em>eventtype</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  id: DefineField(System.String,System.Type,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineField(String, Type, FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(System.String, System.Type, System.Reflection.FieldAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineField
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 206
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new field to the type, with the given name, attributes, and field type.</p>\n"
  syntax:
    content: public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes)
    content.vb: Public Function DefineField(fieldName As String, type As Type, attributes As FieldAttributes) As FieldBuilder
    parameters:
    - id: fieldName
      type: System.String
      description: "\n<p>The name of the field. <em>fieldName</em> cannot contain embedded nulls. </p>\n"
    - id: type
      type: System.Type
      description: "\n<p>The type of the field </p>\n"
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: "\n<p>The attributes of the field. </p>\n"
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: "\n<p>The defined field.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>fieldName</em> is zero.</p>\n<p>-or- </p>\n<p>\n<em>type</em> is System.Void.</p>\n<p>-or- </p>\n<p>A total size was specified for the parent class of this field. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>fieldName</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  id: DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineField(String, Type, Type[], Type[], FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineField(System.String, System.Type, System.Type[], System.Type[], System.Reflection.FieldAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineField
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 207
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new field to the type, with the given name, attributes, field type, and custom modifiers.</p>\n"
  remarks: "\n<p>This overload is provided for designers of managed compilers.</p>\n"
  syntax:
    content: public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes)
    content.vb: Public Function DefineField(fieldName As String, type As Type, requiredCustomModifiers As Type(), optionalCustomModifiers As Type(), attributes As FieldAttributes) As FieldBuilder
    parameters:
    - id: fieldName
      type: System.String
      description: "\n<p>The name of the field. <em>fieldName</em> cannot contain embedded nulls. </p>\n"
    - id: type
      type: System.Type
      description: "\n<p>The type of the field </p>\n"
    - id: requiredCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the required custom modifiers for the field, such as <xref href=\"Microsoft.VisualC.IsConstModifier\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: optionalCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the optional custom modifiers for the field, such as <xref href=\"Microsoft.VisualC.IsConstModifier\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: "\n<p>The attributes of the field. </p>\n"
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: "\n<p>The defined field.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>fieldName</em> is zero.</p>\n<p>-or- </p>\n<p>\n<em>type</em> is System.Void.</p>\n<p>-or- </p>\n<p>A total size was specified for the parent class of this field. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>fieldName</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineField(System.String, System.Type, System.Type(), System.Type(), System.Reflection.FieldAttributes)
  name.vb: DefineField(String, Type, Type(), Type(), FieldAttributes)
- uid: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  id: DefineGenericParameters(System.String[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineGenericParameters(String[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineGenericParameters
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 208
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines the generic type parameters for the current type, specifying their number and their names, and returns an array of <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> objects that can be used to set their constraints.</p>\n"
  remarks: "\n<p>Calling this method makes the current type a generic type. If the method is called again on the same type, an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n"
  example:
  - "\n<p>The following code example creates a generic type with two type parameters and saves them in the assembly GenericEmitExample1.dll. You can use the Ildasm.exe (IL Disassembler) to view the generated types. For a more detailed explanation of the steps involved in defining a dynamic generic type, see How to: Define a Generic Type with Reflection Emit. </p>EmitGenericType#1"
  syntax:
    content: public GenericTypeParameterBuilder[] DefineGenericParameters(params string[] names)
    content.vb: Public Function DefineGenericParameters(ParamArray names As String()) As GenericTypeParameterBuilder()
    parameters:
    - id: names
      type: System.String[]
      description: "\n<p>An array of names for the generic type parameters.</p>\n"
    return:
      type: System.Reflection.Emit.GenericTypeParameterBuilder[]
      description: "\n<p>An array of <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> objects that can be used to define the constraints of the generic type parameters for the current type.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Generic type parameters have already been defined for this type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>names</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>An element of <em>names</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>names</em> is an empty array.</p>\n"
  seealso:
  - type: System.Reflection.Emit.GenericTypeParameterBuilder
    commentId: T:System.Reflection.Emit.GenericTypeParameterBuilder
  - type: System.Reflection.Emit.TypeBuilder.IsGenericType
    commentId: P:System.Reflection.Emit.TypeBuilder.IsGenericType
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String())
  name.vb: DefineGenericParameters(String())
- uid: System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  id: DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineInitializedData(String, Byte[], FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String, System.Byte[], System.Reflection.FieldAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineInitializedData
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 209
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines initialized data field in the .sdata section of the portable executable (PE) file.</p>\n"
  remarks: "\n<p>The field that you create with this method will be <strong>static</strong>, even if you do not include <strong>FieldAttributes.Static</strong> in the <em>attributes</em> parameter.</p>\n"
  syntax:
    content: public FieldBuilder DefineInitializedData(string name, byte[] data, FieldAttributes attributes)
    content.vb: Public Function DefineInitializedData(name As String, data As Byte(), attributes As FieldAttributes) As FieldBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name used to refer to the data. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: data
      type: System.Byte[]
      description: "\n<p>The blob of data. </p>\n"
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: "\n<p>The attributes for the field. </p>\n"
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: "\n<p>A field to reference the data.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The size of the data is less than or equal to zero, or greater than or equal to 0x3f0000. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> or <em>data</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> has been previously called. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String, System.Byte(), System.Reflection.FieldAttributes)
  name.vb: DefineInitializedData(String, Byte(), FieldAttributes)
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)
  id: DefineMethod(System.String,System.Reflection.MethodAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethod(String, MethodAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 210
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new method to the type, with the specified name and method attributes.</p>\n"
  remarks: "\n<p>Use this method overload when you do not know the method signature at the time you define the method. For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type. The parameters and return type of the method can be set later using the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>This method overload defines a method with <xref href=\"System.Reflection.CallingConventions.Standard\" data-throw-if-not-resolved=\"false\"></xref>. If you need to define a method without a signature, with a different calling convention, use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)\" data-throw-if-not-resolved=\"false\"></xref> method overload.  </p>\n"
  example:
  - "\n<p>The following code example defines a generic method named <code>DemoMethod</code> whose parameter type and return type are specified by its generic type parameters. The method is defined without a signature, using the standard calling convention. The <xref href=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method is used to make <code>DemoMethod</code> a generic method, and the newly defined type parameters are then used for the signature and return type. </p>\n<p>This code example is part of a larger example provided for the <xref href=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method.</p>GenericMethodBuilder#4,3,5"
  syntax:
    content: public MethodBuilder DefineMethod(string name, MethodAttributes attributes)
    content.vb: Public Function DefineMethod(name As String, attributes As MethodAttributes) As MethodBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the method. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the method. </p>\n"
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: "\n<p>A <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> representing the newly defined method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The type of the parent of this method is an interface, and this method is not virtual (<strong>Overridable</strong> in Visual Basic). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  seealso:
  - type: System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])
    commentId: M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethod(String, MethodAttributes, CallingConventions)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 211
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new method to the type, with the specified name, method attributes, and calling convention.</p>\n"
  remarks: "\n<p>Use this method overload when you do not know the method signature at the time you define the method. For example, the parameter types and return type of a generic method might be specified by the method's generic type parameters, which must be defined after the method has been added to the type. The parameters and return type of the method can be set later using the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - 
  syntax:
    content: public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention)
    content.vb: Public Function DefineMethod(name As String, attributes As MethodAttributes, callingConvention As CallingConventions) As MethodBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the method. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the method. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the method. </p>\n"
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: "\n<p>A <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> representing the newly defined method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The type of the parent of this method is an interface and this method is not virtual (<strong>Overridable</strong> in Visual Basic). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  seealso:
  - type: System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])
    commentId: M:System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethod(String, MethodAttributes, CallingConventions, Type, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 212
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new method to the type, with the specified name, method attributes, calling convention, and method signature.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates the use of <strong>DefineMethod</strong> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> for MSIL population.</p>TypeBuilder_DefineNestedType1#2"
  syntax:
    content: public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
    content.vb: Public Function DefineMethod(name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As MethodBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the method. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the method. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the method. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the method. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the method. </p>\n"
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: "\n<p>A <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> representing the newly defined method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The type of the parent of this method is an interface, and this method is not virtual (<strong>Overridable</strong> in Visual Basic). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type())
  name.vb: DefineMethod(String, MethodAttributes, CallingConventions, Type, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethod(String, MethodAttributes, CallingConventions, Type, Type[], Type[], Type[], Type[][], Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type[], System.Type[], System.Type[], System.Type[][], System.Type[][])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 213
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new method to the type, with the specified name, method attributes, calling convention, method signature, and custom modifiers.</p>\n"
  remarks: "\n<p>Use this overload if you need to specify custom modifiers. If you need to specify custom modifiers after the method has been created, as you would, for example, with a generic method whose parameter types are specified by its generic type parameters, you can use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)\" data-throw-if-not-resolved=\"false\"></xref> method overloads to define the method and then use the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method to define the parameter and return types with custom modifiers.</p>\n<p>For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n"
  example:
  - 
  syntax:
    content: public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
    content.vb: Public Function DefineMethod(name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As MethodBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the method. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the method. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the method. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the method. </p>\n"
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the required custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the method. If the return type has no required custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the optional custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the method. If the return type has no optional custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the method.</p>\n"
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no required custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have required custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no optional custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have optional custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: "\n<p>A <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> object representing the newly added method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The type of the parent of this method is an interface, and this method is not virtual (<strong>Overridable</strong> in Visual Basic). </p>\n<p>-or-</p>\n<p>The size of <em>parameterTypeRequiredCustomModifiers</em> or <em>parameterTypeOptionalCustomModifiers</em> does not equal the size of <em>parameterTypes</em>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type(), System.Type(), System.Type(), System.Type()(), System.Type()())
  name.vb: DefineMethod(String, MethodAttributes, CallingConventions, Type, Type(), Type(), Type(), Type()(), Type()())
- uid: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  id: DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethod(String, MethodAttributes, Type, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Type, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 214
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new method to the type, with the specified name, method attributes, and method signature.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates the use of <strong>DefineMethod</strong> to set a constructor's particular signature and attributes on a dynamic type and to return a corresponding <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> for MSIL population.</p>TypeBuilder_DefineNestedType1#2"
  syntax:
    content: public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes)
    content.vb: Public Function DefineMethod(name As String, attributes As MethodAttributes, returnType As Type, parameterTypes As Type()) As MethodBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the method. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.MethodAttributes
      description: "\n<p>The attributes of the method. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the method. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the method. </p>\n"
    return:
      type: System.Reflection.Emit.MethodBuilder
      description: "\n<p>The defined method.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>The type of the parent of this method is an interface, and this method is not virtual (<strong>Overridable</strong> in Visual Basic). </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineMethod(System.String, System.Reflection.MethodAttributes, System.Type, System.Type())
  name.vb: DefineMethod(String, MethodAttributes, Type, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  id: DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineMethodOverride(MethodInfo, MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo, System.Reflection.MethodInfo)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineMethodOverride
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 215
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Specifies a given method body that implements a given method declaration, potentially with a different name.</p>\n"
  remarks: "\n<p>Do not use this method to emit method overrides or interface implementations. To override a method of a base class or to implement a method of an interface, simply emit a method with the same name and signature as the method to be overridden or implemented, as demonstrated in the code example.</p>\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is used when a method body and a method declaration have different names. For example, a class might override a base class method and also provide a separate implementation for an interface member with the same name, as demonstrated in the code example. </p>\n<p>\n<strong>DefineMethodOverride</strong> defines a <strong>methodimpl</strong>, which consists of a pair of metadata tokens. One token points to an implementation, and the other token points to a declaration that the body implements. The body must be defined on the type the method impl is defined on, and the body must be virtual (<strong>Overridable</strong> in Visual Basic). The declaration can be made to a method defined on an interface implemented by the type, a method on a derived class, or a method defined in the type. If the declaration is on an interface only, the slot defined for the interface is altered. If the declaration is made to a method on a base type, the slot for the method is overridden and any duplicates for the overridden method are also replaced. The overridden method cannot be the actual method that is declared. If the method is on the same type, the slot is replaced and any duplicates for the replaced methods are overridden.</p>\n<p>For more information about method impls, see <strong>MethodImpl</strong> in the ECMA Partition II Metadata documentation. The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n<p>After the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is called, some features of <em>methodInfoBody</em> cannot be changed. For example, you cannot apply an attribute to a generic type parameter of <em>methodInfoBody</em> by using the <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes)\" data-throw-if-not-resolved=\"false\"></xref> method. If you must use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method, do so after all characteristics of <em>methodInfoBody</em> have been defined.</p>\n"
  example:
  - "\n<p>The following code example contains an interface <code>I</code> with a method <code>M()</code>, a base class <code>A</code> that implements the interface, and a derived class <code>C</code> that overrides the base class implementation of <code>M()</code> and also provides a separate explicit implementation of <code>I.M()</code>. </p>\n<p>The <code>main()</code> method of the code example shows how to emit the derived class <code>C</code>. The override of <code>A.M()</code> is accomplished simply by emitting a method <code>M()</code> with the same signature. However, to provide a separate implementation of <code>I.M()</code>, you must define a method body and then use the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method to associate that method body with a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> representing <code>I.M()</code>. The name of the method body does not matter.</p>\n<p>The code example creates an instance of the emitted class. It obtains a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object for <code>I.M()</code>, and uses it to invoke the emitted class's explicit interface implementation. It then obtains a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object for <code>A.M()</code>, and uses it to invoke the emitted class's override of that method.</p>TypeBuilder.DefineMethodOverride#1"
  syntax:
    content: public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration)
    content.vb: Public Sub DefineMethodOverride(methodInfoBody As MethodInfo, methodInfoDeclaration As MethodInfo)
    parameters:
    - id: methodInfoBody
      type: System.Reflection.MethodInfo
      description: "\n<p>The method body to be used. This should be a <strong>MethodBuilder</strong> object. </p>\n"
    - id: methodInfoDeclaration
      type: System.Reflection.MethodInfo
      description: "\n<p>The method whose declaration is to be used. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>methodInfoBody</em> does not belong to this class. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>methodInfoBody</em> or <em>methodInfoDeclaration</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or- </p>\n<p>The declaring type of <em>methodInfoBody</em> is not the type represented by this <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  id: DefineNestedType(System.String)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 216
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name)
    content.vb: Public Function DefineNestedType(name As String) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 217
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name and attributes.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The nested attribute is not specified.</p>\n<p>-or- </p>\n<p>This type is sealed.</p>\n<p>-or- </p>\n<p>This type is an array.</p>\n<p>-or- </p>\n<p>This type is an interface, but the nested type is not an interface.</p>\n<p>-or- </p>\n<p>The length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes, Type)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 218
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name, attributes, and the type that it extends.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes, parent As Type) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type. </p>\n"
    - id: parent
      type: System.Type
      description: "\n<p>The type that the nested type extends. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The nested attribute is not specified.</p>\n<p>-or- </p>\n<p>This type is sealed.</p>\n<p>-or- </p>\n<p>This type is an array.</p>\n<p>-or- </p>\n<p>This type is an interface, but the nested type is not an interface.</p>\n<p>-or- </p>\n<p>The length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes, Type, Int32)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 219
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name, attributes, the total size of the type, and the type that it extends.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes, parent As Type, typeSize As Integer) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type. </p>\n"
    - id: parent
      type: System.Type
      description: "\n<p>The type that the nested type extends. </p>\n"
    - id: typeSize
      type: System.Int32
      description: "\n<p>The total size of the type. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The nested attribute is not specified.</p>\n<p>-or- </p>\n<p>This type is sealed.</p>\n<p>-or- </p>\n<p>This type is an array.</p>\n<p>-or- </p>\n<p>This type is an interface, but the nested type is not an interface.</p>\n<p>-or- </p>\n<p>The length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes, Type, PackingSize)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type, System.Reflection.Emit.PackingSize)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 220
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name, attributes, the type that it extends, and the packing size.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type. </p>\n"
    - id: parent
      type: System.Type
      description: "\n<p>The type that the nested type extends. </p>\n"
    - id: packSize
      type: System.Reflection.Emit.PackingSize
      description: "\n<p>The packing size of the type. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The nested attribute is not specified.</p>\n<p>-or- </p>\n<p>This type is sealed.</p>\n<p>-or- </p>\n<p>This type is an array.</p>\n<p>-or- </p>\n<p>This type is an interface, but the nested type is not an interface.</p>\n<p>-or- </p>\n<p>The length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes, Type, PackingSize, Int32)
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type, System.Reflection.Emit.PackingSize, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 221
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name, attributes, size, and the type that it extends.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes, parent As Type, packSize As PackingSize, typeSize As Integer) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded null values.</p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type.</p>\n"
    - id: parent
      type: System.Type
      description: "\n<p>The type that the nested type extends.</p>\n"
    - id: packSize
      type: System.Reflection.Emit.PackingSize
      description: "\n<p>The packing size of the type.</p>\n"
    - id: typeSize
      type: System.Int32
      description: "\n<p>The total size of the type.</p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  id: DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineNestedType(String, TypeAttributes, Type, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineNestedType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 222
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines a nested type, given its name, attributes, the type that it extends, and the interfaces that it implements.</p>\n"
  remarks: "\n<p>This method can be used to create nested types even after the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called on the enclosing type. </p>\n<p>The nested type needs to be complete before you can reflect on it using <xref href=\"System.Type.GetMembers\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Type.GetNestedType(System.String)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Type.GetNestedTypes\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>See the description of <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> for the order in which nested types and nesting types should be completed.</p>\n<p>A duplicate name is not necessarily created if <em>name</em> is identical to the name of a previously defined type or nested type. To be duplicates, the full names must be the same, including the namespace and all nesting types.</p>\n"
  syntax:
    content: public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces)
    content.vb: Public Function DefineNestedType(name As String, attr As TypeAttributes, parent As Type, interfaces As Type()) As TypeBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The short name of the type. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attr
      type: System.Reflection.TypeAttributes
      description: "\n<p>The attributes of the type. </p>\n"
    - id: parent
      type: System.Type
      description: "\n<p>The type that the nested type extends. </p>\n"
    - id: interfaces
      type: System.Type[]
      description: "\n<p>The interfaces that the nested type implements. </p>\n"
    return:
      type: System.Reflection.Emit.TypeBuilder
      description: "\n<p>The defined nested type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The nested attribute is not specified.</p>\n<p>-or- </p>\n<p>This type is sealed.</p>\n<p>-or- </p>\n<p>This type is an array.</p>\n<p>-or- </p>\n<p>This type is an interface, but the nested type is not an interface.</p>\n<p>-or- </p>\n<p>The length of <em>name</em> is zero or greater than 1023. </p>\n<p>-or-</p>\n<p>This operation would create a type with a duplicate <xref href=\"System.Reflection.Emit.TypeBuilder.FullName\" data-throw-if-not-resolved=\"false\"></xref> in the current assembly.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>An element of the <em>interfaces</em> array is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String, System.Reflection.TypeAttributes, System.Type, System.Type())
  name.vb: DefineNestedType(String, TypeAttributes, Type, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineProperty(String, PropertyAttributes, CallingConventions, Type, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Reflection.CallingConventions, System.Type, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineProperty
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 223
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new property to the type, with the given name, attributes, calling convention, and property signature.</p>\n"
  syntax:
    content: public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes)
    content.vb: Public Function DefineProperty(name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type()) As PropertyBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the property. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: "\n<p>The attributes of the property. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the property accessors. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the property. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the property.</p>\n"
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: "\n<p>The defined property.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n<p>-or- </p>\n<p>Any of the elements of the <em>parameterTypes</em> array is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Reflection.CallingConventions, System.Type, System.Type())
  name.vb: DefineProperty(String, PropertyAttributes, CallingConventions, Type, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineProperty(String, PropertyAttributes, CallingConventions, Type, Type[], Type[], Type[], Type[][], Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Reflection.CallingConventions, System.Type, System.Type[], System.Type[], System.Type[], System.Type[][], System.Type[][])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineProperty
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 224
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new property to the type, with the given name, calling convention, property signature, and custom modifiers.</p>\n"
  remarks: "\n<p>This overload is provided for designers of managed compilers.</p>\n<p>For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n<p>This method overload is introduced in the .NET Framework 3.5 or later.</p>\n"
  syntax:
    content: public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
    content.vb: Public Function DefineProperty(name As String, attributes As PropertyAttributes, callingConvention As CallingConventions, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the property. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: "\n<p>The attributes of the property. </p>\n"
    - id: callingConvention
      type: System.Reflection.CallingConventions
      description: "\n<p>The calling convention of the property accessors. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the property. </p>\n"
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the required custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the property. If the return type has no required custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the optional custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the property. If the return type has no optional custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the property. </p>\n"
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no required custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have required custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no optional custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have optional custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: "\n<p>The defined property.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n<p>-or- </p>\n<p>Any of the elements of the <em>parameterTypes</em> array is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Reflection.CallingConventions, System.Type, System.Type(), System.Type(), System.Type(), System.Type()(), System.Type()())
  name.vb: DefineProperty(String, PropertyAttributes, CallingConventions, Type, Type(), Type(), Type(), Type()(), Type()())
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineProperty(String, PropertyAttributes, Type, Type[])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Type, System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineProperty
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 225
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new property to the type, with the given name and property signature.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates how to define a dynamic property and obtain a <xref href=\"System.Reflection.Emit.PropertyBuilder\" data-throw-if-not-resolved=\"false\"></xref> for specification. Note that a <strong>PropertyBuilder</strong> must also have a corresponding <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref>, which will house the IL logic for the property.</p>System.Reflection.Emit.PropertyBuilder Example#1"
  syntax:
    content: public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes)
    content.vb: Public Function DefineProperty(name As String, attributes As PropertyAttributes, returnType As Type, parameterTypes As Type()) As PropertyBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the property. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: "\n<p>The attributes of the property. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the property. </p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the property. </p>\n"
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: "\n<p>The defined property.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n<p>-or- </p>\n<p>Any of the elements of the <em>parameterTypes</em> array is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Type, System.Type())
  name.vb: DefineProperty(String, PropertyAttributes, Type, Type())
- uid: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  id: DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineProperty(String, PropertyAttributes, Type, Type[], Type[], Type[], Type[][], Type[][])
  fullName: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Type, System.Type[], System.Type[], System.Type[], System.Type[][], System.Type[][])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineProperty
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 226
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Adds a new property to the type, with the given name, property signature, and custom modifiers.</p>\n"
  remarks: "\n<p>This overload is provided for designers of managed compilers.</p>\n<p>For more information on custom modifiers, see the ECMA Partition II Metadata documentation. The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n"
  syntax:
    content: public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers)
    content.vb: Public Function DefineProperty(name As String, attributes As PropertyAttributes, returnType As Type, returnTypeRequiredCustomModifiers As Type(), returnTypeOptionalCustomModifiers As Type(), parameterTypes As Type(), parameterTypeRequiredCustomModifiers As Type()(), parameterTypeOptionalCustomModifiers As Type()()) As PropertyBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the property. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: attributes
      type: System.Reflection.PropertyAttributes
      description: "\n<p>The attributes of the property. </p>\n"
    - id: returnType
      type: System.Type
      description: "\n<p>The return type of the property. </p>\n"
    - id: returnTypeRequiredCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the required custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the property. If the return type has no required custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: returnTypeOptionalCustomModifiers
      type: System.Type[]
      description: "\n<p>An array of types representing the optional custom modifiers, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>, for the return type of the property. If the return type has no optional custom modifiers, specify <strong>null</strong>.</p>\n"
    - id: parameterTypes
      type: System.Type[]
      description: "\n<p>The types of the parameters of the property. </p>\n"
    - id: parameterTypeRequiredCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no required custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have required custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    - id: parameterTypeOptionalCustomModifiers
      type: System.Type[][]
      description: "\n<p>An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <xref href=\"System.Runtime.CompilerServices.IsConst\" data-throw-if-not-resolved=\"false\"></xref>. If a particular parameter has no optional custom modifiers, specify <strong>null</strong> instead of an array of types. If none of the parameters have optional custom modifiers, specify <strong>null</strong> instead of an array of arrays.</p>\n"
    return:
      type: System.Reflection.Emit.PropertyBuilder
      description: "\n<p>The defined property.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The length of <em>name</em> is zero. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong></p>\n<p>-or- </p>\n<p>Any of the elements of the <em>parameterTypes</em> array is <strong>null</strong></p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.DefineProperty(System.String, System.Reflection.PropertyAttributes, System.Type, System.Type(), System.Type(), System.Type(), System.Type()(), System.Type()())
  name.vb: DefineProperty(String, PropertyAttributes, Type, Type(), Type(), Type(), Type()(), Type()())
- uid: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer
  id: DefineTypeInitializer
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineTypeInitializer()
  fullName: System.Reflection.Emit.TypeBuilder.DefineTypeInitializer()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineTypeInitializer
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 227
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines the initializer for this type.</p>\n"
  remarks: "\n<p>The initializer created is always public.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates how to create an initialization constructor using <strong>DefineTypeInitializer</strong>.</p>TypeBuilder_Properties1#3"
  syntax:
    content: public ConstructorBuilder DefineTypeInitializer()
    content.vb: Public Function DefineTypeInitializer As ConstructorBuilder
    return:
      type: System.Reflection.Emit.ConstructorBuilder
      description: "\n<p>Returns a type initializer.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The containing type has been previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  commentId: M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  id: DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DefineUninitializedData(String, Int32, FieldAttributes)
  fullName: System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String, System.Int32, System.Reflection.FieldAttributes)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DefineUninitializedData
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 228
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Defines an uninitialized data field in the <strong>.sdata</strong> section of the portable executable (PE) file.</p>\n"
  remarks: "\n<p>The field that you create with this method will be <strong>static</strong>, even if you do not include <strong>FieldAttributes.Static</strong> in the <em>attributes</em> parameter.</p>\n"
  example:
  - "\n<p>The following code sample demonstrates the use of <strong>DefineUninitializedData</strong> to create an uninitialized data field in a dynamic type: </p>TypeBuilder_DefineUninitializedData#1"
  syntax:
    content: public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes)
    content.vb: Public Function DefineUninitializedData(name As String, size As Integer, attributes As FieldAttributes) As FieldBuilder
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name used to refer to the data. <em>name</em> cannot contain embedded nulls. </p>\n"
    - id: size
      type: System.Int32
      description: "\n<p>The size of the data field. </p>\n"
    - id: attributes
      type: System.Reflection.FieldAttributes
      description: "\n<p>The attributes for the field. </p>\n"
    return:
      type: System.Reflection.Emit.FieldBuilder
      description: "\n<p>A field to reference the data.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Length of <em>name</em> is zero.</p>\n<p>-or- </p>\n<p>\n<em>size</em> is less than or equal to zero, or greater than or equal to 0x003f0000. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  commentId: M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  id: GetConstructor(System.Type,System.Reflection.ConstructorInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetConstructor(Type, ConstructorInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type, System.Reflection.ConstructorInfo)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetConstructor
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 229
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the constructor of the specified constructed generic type that corresponds to the specified constructor of the generic type definition. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to get a <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents a constructor of a constructed generic type whose generic type definition is represented by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>For example, suppose you have a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents the type <code>G<T></code> in C# syntax (<code>G(Of T)</code> in Visual Basic, <code>generic <T> ref class G</code> in C++) and a <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents a constructor of <code>G<T></code>. Suppose that <code>G<T></code> has a generic method with type parameter <code>U</code> that creates an instance of the constructed type <code>G<U></code>. In order to emit the code to create an instance of the constructed type, you need a <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents the constructor of this constructed type — in other words, that creates an instance of <code>G<U></code>. To do this, first call the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method on the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object, specifying the <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>U</code> as the type argument. Then call the <xref href=\"System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)\" data-throw-if-not-resolved=\"false\"></xref> method with the return value of the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method as parameter <em>type</em> and the <xref href=\"System.Reflection.Emit.ConstructorBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents the constructor of <code>G<U></code> as parameter <em>constructor</em>. The return value is the <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> object you need to emit the function call. The code example demonstrates this scenario.</p>\n"
  example:
  - "\n<p>The following code example contains source code for a generic class named <code>Sample</code> that has a type parameter named <code>T</code>. The class has a field named <code>Field</code>, of type <code>T</code>, and a generic method named <code>GM</code> with its own type parameter, named <code>U</code>. Method <code>GM</code> creates an instance of <code>Sample</code>, substituting its own type parameter <code>U</code> for the type parameter of <code>Sample</code>, and stores its input parameter in <code>Field</code>. This source code is compiled but not used; you can view it with the Ildasm.exe (IL Disassembler) and compare it to the code emitted by class <code>Example</code>.</p>\n<p>The code in class <code>Example</code> demonstrates the use of the <xref href=\"System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)\" data-throw-if-not-resolved=\"false\"></xref> method to emit generic code. The <code>Main</code> method of class <code>Example</code> creates a dynamic assembly containing a class named <code>Sample</code> and uses the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method to make it generic by adding a type parameter named <code>T</code>. A default constructor and a field named <code>Field</code>, of type <code>T</code>, are added to class <code>Sample</code>. A method <code>GM</code> is added and turned into a generic method by using the <xref href=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method. The type parameter of <code>GM</code> is named <code>U</code>. After the type parameter is defined, the signature of <code>GM</code> is added by using the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method. There is no return type and no required or custom modifiers, so all the parameters of this method are <strong>null</strong> except <em>parameterTypes</em>; <em>parameterTypes</em> sets the type of the method's only parameter to <code>U</code>, the method's generic type parameter. The body of the method creates an instance of the constructed type <code>Sample<U></code> (<code>Sample(Of U)</code> in Visual Basic), assigns the method's parameter to <code>Field</code>, and then prints the value of <code>Field</code>. The <xref href=\"System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is used to create a <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> that represents the default constructor of the constructed generic type <code>Sample<U></code> in the <xref href=\"System.Reflection.Emit.OpCodes.Newobj\" data-throw-if-not-resolved=\"false\"></xref> instruction that creates the instance.</p>\n<p>A dummy type is defined to hold the entry-point method <code>Main</code>. In the body of <code>Main</code>, the static <code>GM</code> method is invoked on the constructed generic type <code>Sample<int></code> (<code>Sample(Of Integer)</code> in Visual Basic), with type <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> substituted for <code>U</code>.</p>\n<p>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the Ildasm.exe (IL Disassembler) to compare the emitted code with the code for the <code>Sample</code> class that is compiled into the code example itself.</p>TypeBuilder.GetField_Generic#1"
  syntax:
    content: public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor)
    content.vb: Public Shared Function GetConstructor(type As Type, constructor As ConstructorInfo) As ConstructorInfo
    parameters:
    - id: type
      type: System.Type
      description: "\n<p>The constructed generic type whose constructor is returned.</p>\n"
    - id: constructor
      type: System.Reflection.ConstructorInfo
      description: "\n<p>A constructor on the generic type definition of <em>type</em>, which specifies which constructor of <em>type</em> to return.</p>\n"
    return:
      type: System.Reflection.ConstructorInfo
      description: "\n<p>A <xref href=\"System.Reflection.ConstructorInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents the constructor of <em>type</em> corresponding to <em>constructor</em>, which specifies a constructor belonging to the generic type definition of <em>type</em>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>type</em> does not represent a generic type. </p>\n<p>-or-</p>\n<p>\n<em>type</em> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The declaring type of <em>constructor</em> is not a generic type definition. </p>\n<p>-or-</p>\n<p>The declaring type of <em>constructor</em> is not the generic type definition of <em>type</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  commentId: M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)
  id: GetField(System.Type,System.Reflection.FieldInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetField(Type, FieldInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetField(System.Type, System.Reflection.FieldInfo)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetField
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 230
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the field of the specified constructed generic type that corresponds to the specified field of the generic type definition. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to get a <xref href=\"System.Reflection.FieldInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents a field of a constructed generic type whose generic type definition is represented by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>For example, suppose you have a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents the type <code>G<T></code> in C# syntax (<code>G(Of T)</code> in Visual Basic, <code>generic <T> ref class G</code> in C++) and a <xref href=\"System.Reflection.Emit.FieldBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents a field <code>public T F</code> in C# syntax (<code>Public F As T</code> in Visual Basic, <code>public: T F</code> in C++) that is defined by <code>G<T></code>. Suppose that <code>G<T></code> has a generic method with type parameter <code>U</code> that creates an instance of the constructed type <code>G<U></code> and calls field <code>F</code> on that instance. In order to emit the function call, you need a <xref href=\"System.Reflection.FieldInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>F</code> on the constructed type — in other words, that is of type <code>U</code> rather than type <code>T</code>. To do this, first call the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method on the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object, specifying the <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>U</code> as the type argument. Then call the <xref href=\"System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)\" data-throw-if-not-resolved=\"false\"></xref> method with the return value of the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method as parameter <em>type</em> and the <xref href=\"System.Reflection.Emit.FieldBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>F</code> as parameter <em>field</em>. The return value is the <xref href=\"System.Reflection.FieldInfo\" data-throw-if-not-resolved=\"false\"></xref> object you need to emit the function call. The code example demonstrates this scenario.</p>\n"
  example:
  - "\n<p>The following code example contains source code for a generic class named Sample that has a type parameter named <code>T</code>. The class has a field named <code>Field</code>, of type <code>T</code>, and a generic method named <code>GM</code> with its own type parameter, named <code>U</code>. Method <code>GM</code> creates an instance of <code>Sample</code>, substituting its own type parameter <code>U</code> for the type parameter of <code>Sample</code>, and stores its input parameter in <code>Field</code>. This source code is compiled but not used; you can view it with the Ildasm.exe (IL Disassembler) and compare it to the code emitted by class <code>Example</code>.</p>\n<p>The code in class <code>Example</code> demonstrates the use of the <xref href=\"System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)\" data-throw-if-not-resolved=\"false\"></xref> method to emit generic code. The <code>Main</code> method of class <code>Example</code> creates a dynamic assembly containing a class named <code>Sample</code>, and uses the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method to make it generic by adding a type parameter named <code>T</code>. A default constructor and a field named <code>Field</code>, of type <code>T</code>, are added to class <code>Sample</code>. A method <code>GM</code> is added and turned into a generic method by using the <xref href=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method. The type parameter of <code>GM</code> is named <code>U</code>. After the type parameter is defined, the signature of <code>GM</code> is added by using the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method. There is no return type and no required or custom modifiers, so all the parameters of this method are <strong>null</strong> except <em>parameterTypes</em>; <em>parameterTypes</em> sets the type of the method's only parameter to <code>U</code>, the method's generic type parameter. The body of the method creates an instance of the constructed type <code>Sample<U></code> (<code>Sample(Of U)</code> in Visual Basic), assigns the method's parameter to <code>Field</code>, and then prints the value of <code>Field</code>. The <xref href=\"System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is used to create a <xref href=\"System.Reflection.FieldInfo\" data-throw-if-not-resolved=\"false\"></xref> that represents the field of the constructed generic type <code>Sample<U></code> in the <xref href=\"System.Reflection.Emit.OpCodes.Stfld\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Reflection.Emit.OpCodes.Ldfld\" data-throw-if-not-resolved=\"false\"></xref> instructions.</p>\n<p>A dummy type is defined to hold the entry-point method <code>Main</code>. In the body of <code>Main</code>, the static <code>GM</code> method is invoked on the constructed generic type <code>Sample<int></code> (<code>Sample(Of Integer)</code> in Visual Basic), with type <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> substituted for <code>U</code>.</p>\n<p>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the Ildasm.exe (IL Disassembler) to compare the emitted code with the code for the <code>Sample</code> class that is compiled into the code example itself.</p>TypeBuilder.GetField_Generic#1"
  syntax:
    content: public static FieldInfo GetField(Type type, FieldInfo field)
    content.vb: Public Shared Function GetField(type As Type, field As FieldInfo) As FieldInfo
    parameters:
    - id: type
      type: System.Type
      description: "\n<p>The constructed generic type whose field is returned.</p>\n"
    - id: field
      type: System.Reflection.FieldInfo
      description: "\n<p>A field on the generic type definition of <em>type</em>, which specifies which field of <em>type</em> to return.</p>\n"
    return:
      type: System.Reflection.FieldInfo
      description: "\n<p>A <xref href=\"System.Reflection.FieldInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents the field of <em>type</em> corresponding to <em>field</em>, which specifies a field belonging to the generic type definition of <em>type</em>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>type</em> does not represent a generic type. </p>\n<p>-or-</p>\n<p>\n<em>type</em> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The declaring type of <em>field</em> is not a generic type definition. </p>\n<p>-or-</p>\n<p>The declaring type of <em>field</em> is not the generic type definition of <em>type</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  commentId: M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  id: GetGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetGenericTypeDefinition()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetGenericTypeDefinition
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 231
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents a generic type definition from which the current type can be obtained.</p>\n"
  remarks: "\n<p>If you call the <xref href=\"System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> method on a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object for which the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>, the <xref href=\"System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property returns the current instance. A <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> that represents a generic type is always a generic type definition.</p>\n<p>If you used the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method to construct a generic type from a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents a generic type definition, using the <xref href=\"System.Type.GetGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> method on the constructed type gets back the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents the generic type definition.</p>\n"
  syntax:
    content: public override Type GetGenericTypeDefinition()
    content.vb: Public Overrides Function GetGenericTypeDefinition As Type
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object representing a generic type definition from which the current type can be obtained.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current type is not generic. That is, <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Type.IsGenericType
    commentId: P:System.Type.IsGenericType
  - type: System.Type.GetGenericTypeDefinition
    commentId: M:System.Type.GetGenericTypeDefinition
  - type: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  commentId: M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)
  id: GetMethod(System.Type,System.Reflection.MethodInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetMethod(Type, MethodInfo)
  fullName: System.Reflection.Emit.TypeBuilder.GetMethod(System.Type, System.Reflection.MethodInfo)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 232
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the method of the specified constructed generic type that corresponds to the specified method of the generic type definition. </p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to get a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents a method of a constructed generic type whose generic type definition is represented by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n<p>For example, suppose you have a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents the type <code>G<T></code> in C# syntax (<code>G(Of T)</code> in Visual Basic, <code>generic <T> ref class G</code> in C++) and a <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents a method <code>T M()</code> in C# syntax (<code>Function M() As T</code> in Visual Basic, <code>T M()</code> in C++) that is defined by <code>G<T></code>. Suppose that <code>G<T></code> has a generic method with type parameter <code>U</code> that creates an instance of the constructed type <code>G<U></code> and calls method <code>M</code> on that instance. In order to emit the function call, you need a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>M</code> on the constructed type — in other words, that returns type <code>U</code> rather than type <code>T</code>. To do this, first call the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method on the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object, specifying the <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>U</code> as the type argument. Then call the <xref href=\"System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method with the return value of the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method as parameter <em>type</em> and the <xref href=\"System.Reflection.Emit.MethodBuilder\" data-throw-if-not-resolved=\"false\"></xref> object that represents <code>T M()</code> as parameter <em>method</em>. The return value is the <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object you need to emit the function call. The code example demonstrates a scenario similar to this.</p>\n"
  example:
  - "\n<p>The following code example contains source code for a generic class named <code>Sample</code> that has a type parameter named <code>T</code>. The class has a field named <code>Field</code>, of type <code>T</code>, and a generic method named <code>GM</code> with its own type parameter, named <code>U</code>. Method <code>GM</code> creates an instance of <code>Sample</code>, substituting its own type parameter <code>U</code> for the type parameter of <code>Sample</code>, and stores its input parameter in <code>Field</code>. This source code is compiled but not used; you can view it with the Ildasm.exe (IL Disassembler) and compare it to the code emitted by class <code>Example</code>.</p>\n<p>The code in class <code>Example</code> demonstrates the use of the <xref href=\"System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method to emit generic code. The <code>Main</code> method of class <code>Example</code> creates a dynamic assembly containing a class named <code>Sample</code> and uses the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method to make it generic by adding a type parameter named <code>T</code>. A default constructor and a field named <code>Field</code>, of type <code>T</code>, are added to class <code>Sample</code>. A method <code>GM</code> is added and turned into a generic method by using the <xref href=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method. The type parameter of <code>GM</code> is named <code>U</code>. After the type parameter is defined, the signature of <code>GM</code> is added by using the <xref href=\"System.Reflection.Emit.MethodBuilder.SetSignature(System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])\" data-throw-if-not-resolved=\"false\"></xref> method. There is no return type and no required or custom modifiers, so all the parameters of this method are <strong>null</strong> except <em>parameterTypes</em>; <em>parameterTypes</em> sets the type of the method's only parameter to <code>U</code>, the method's generic type parameter. The body of the method creates an instance of the constructed type <code>Sample<U></code> (<code>Sample(Of U)</code> in Visual Basic), assigns the method's parameter to <code>Field</code>, and then prints the value of <code>Field</code>. A dummy type is defined to hold the entry-point method <code>Main</code>. In the body of <code>Main</code>, the static <code>GM</code> method is invoked on the constructed generic type <code>Sample<int></code> (<code>Sample(Of Integer)</code> in Visual Basic), with type <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> substituted for <code>U</code>. The <xref href=\"System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref> method is used to create a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> for the static <code>GM</code> method of the constructed generic type <code>Sample<U></code>, and the <xref href=\"System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method is then used to create a <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> that can emitted in a method call.</p>\n<p>When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the Ildasm.exe (IL Disassembler) to compare the emitted code with the code for the <code>Sample</code> class that is compiled into the code example itself.</p>TypeBuilder.GetField_Generic#1"
  syntax:
    content: public static MethodInfo GetMethod(Type type, MethodInfo method)
    content.vb: Public Shared Function GetMethod(type As Type, method As MethodInfo) As MethodInfo
    parameters:
    - id: type
      type: System.Type
      description: "\n<p>The constructed generic type whose method is returned.</p>\n"
    - id: method
      type: System.Reflection.MethodInfo
      description: "\n<p>A method on the generic type definition of <em>type</em>, which specifies which method of <em>type</em> to return.</p>\n"
    return:
      type: System.Reflection.MethodInfo
      description: "\n<p>A <xref href=\"System.Reflection.MethodInfo\" data-throw-if-not-resolved=\"false\"></xref> object that represents the method of <em>type</em> corresponding to <em>method</em>, which specifies a method belonging to the generic type definition of <em>type</em>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>method</em> is a generic method that is not a generic method definition.</p>\n<p>-or-</p>\n<p>\n<em>type</em> does not represent a generic type.</p>\n<p>-or-</p>\n<p>\n<em>type</em> is not of type <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The declaring type of <em>method</em> is not a generic type definition. </p>\n<p>-or-</p>\n<p>The declaring type of <em>method</em> is not the generic type definition of <em>type</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)
  commentId: M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)
  id: IsAssignableFrom(System.Reflection.TypeInfo)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsAssignableFrom(TypeInfo)
  fullName: System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAssignableFrom
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 233
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a value that indicates whether a specified <xref href=\"System.Reflection.TypeInfo\" data-throw-if-not-resolved=\"false\"></xref> object can be assigned to this object.</p>\n"
  syntax:
    content: public override bool IsAssignableFrom(TypeInfo typeInfo)
    content.vb: Public Overrides Function IsAssignableFrom(typeInfo As TypeInfo) As Boolean
    parameters:
    - id: typeInfo
      type: System.Reflection.TypeInfo
      description: "\n<p>The object to test.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if <em>typeInfo</em> can be assigned to this object; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.IsCreated
  commentId: M:System.Reflection.Emit.TypeBuilder.IsCreated
  id: IsCreated
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsCreated()
  fullName: System.Reflection.Emit.TypeBuilder.IsCreated()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsCreated
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 234
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a value that indicates whether the current dynamic type has been created.</p>\n"
  remarks: "\n<p>After the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called, the type represented by the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object is complete. Exceptions are thrown on any further attempts to add members or change other characteristics of the type.</p>\n"
  syntax:
    content: public bool IsCreated()
    content.vb: Public Function IsCreated As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method has been called; otherwise, <strong>false</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType
  commentId: M:System.Reflection.Emit.TypeBuilder.MakeArrayType
  id: MakeArrayType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: MakeArrayType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MakeArrayType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 235
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents a one-dimensional array of the current type, with a lower bound of zero.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.MakeArrayType\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to generate an array type with any possible element type, including generic types.</p>\n"
  example:
  - "\n<p>The following code example creates a dynamic module, an abstract type named <code>Sample</code>, and an abstract method named <code>TestMethod</code>. <code>TestMethod</code> takes a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) of type <code>Sample</code>, a pointer to type <code>Sample</code>, and an array of type <code>Sample</code>. It returns a two-dimensional array of type <code>Sample</code>. The code example saves the dynamic module to disk, so you can examine it with the Ildasm.exe (IL Disassembler).</p>MakeXxxTypeBuilder#1"
  syntax:
    content: public override Type MakeArrayType()
    content.vb: Public Overrides Function MakeArrayType As Type
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.</p>\n"
  seealso:
  - type: System.Reflection.Emit.TypeBuilder.MakeByRefType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeByRefType
  - type: System.Reflection.Emit.TypeBuilder.MakePointerType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakePointerType
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  commentId: M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  id: MakeArrayType(System.Int32)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: MakeArrayType(Int32)
  fullName: System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MakeArrayType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 236
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents an array of the current type, with the specified number of dimensions.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.MakeArrayType\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to generate an array type with any possible element type, including generic types.</p>\n"
  example:
  - "\n<p>The following code example creates a dynamic module, an abstract type named <code>Sample</code>, and an abstract method named <code>TestMethod</code>. <code>TestMethod</code> takes a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) of type <code>Sample</code>, a pointer to type <code>Sample</code>, and an array of type <code>Sample</code>. It returns a two-dimensional array of type <code>Sample</code>. The code example saves the dynamic module to disk, so you can examine it with the Ildasm.exe (IL Disassembler).</p>MakeXxxTypeBuilder#1"
  syntax:
    content: public override Type MakeArrayType(int rank)
    content.vb: Public Overrides Function MakeArrayType(rank As Integer) As Type
    parameters:
    - id: rank
      type: System.Int32
      description: "\n<p>The number of dimensions for the array. </p>\n"
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents a one-dimensional array of the current type.</p>\n"
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>rank</em> is not a valid array dimension.</p>\n"
  seealso:
  - type: System.Reflection.Emit.TypeBuilder.MakeByRefType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeByRefType
  - type: System.Reflection.Emit.TypeBuilder.MakePointerType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakePointerType
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.MakeByRefType
  commentId: M:System.Reflection.Emit.TypeBuilder.MakeByRefType
  id: MakeByRefType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: MakeByRefType()
  fullName: System.Reflection.Emit.TypeBuilder.MakeByRefType()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MakeByRefType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 237
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents the current type when passed as a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic).</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.MakeByRefType\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to generate <strong>ref</strong> types (<strong>ByRef</strong> in Visual Basic) for parameter lists.</p>\n<p>Using Microsoft intermediate language (MSIL) syntax, if the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> represents <code>MyType</code>, then the type returned by this method would be <code>MyType&</code>.</p>\n"
  example:
  - "\n<p>The following code example creates a dynamic module, an abstract type named <code>Sample</code>, and an abstract method named <code>TestMethod</code>. <code>TestMethod</code> takes a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) of type <code>Sample</code>, a pointer to type <code>Sample</code>, and an array of type <code>Sample</code>. It returns a two-dimensional array of type <code>Sample</code>. The code example saves the dynamic module to disk, so you can examine it with the Ildasm.exe (IL Disassembler).</p>MakeXxxTypeBuilder#1"
  syntax:
    content: public override Type MakeByRefType()
    content.vb: Public Overrides Function MakeByRefType As Type
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents the current type when passed as a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic).</p>\n"
  seealso:
  - type: System.Reflection.Emit.TypeBuilder.MakePointerType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakePointerType
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  commentId: M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  id: MakeGenericType(System.Type[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: MakeGenericType(Type[])
  fullName: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MakeGenericType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 238
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns the resulting constructed type.</p>\n"
  remarks: "\n<p>Use this method when your emitted code requires a type constructed from the current generic type definition. It is not necessary to call the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method before calling the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method on a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> that represents a generic type definition. If the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> does not represent the definition of a generic type, an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>The object returned by this method functions as a placeholder for a constructed generic type in your emitted code. It is an instance of a class derived from <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> that has limited capabilities. In particular:</p>\n<ul><li>\n<p>To get methods, fields, and constructors for these constructed generic types, use the <xref href=\"System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)\" data-throw-if-not-resolved=\"false\"></xref> method overloads.</p>\n</li><li>\n<p>Two instances that represent the same constructed type do not compare as equal. For example, in the following code <code>t1.Equals(t2)</code> returns <strong>false</strong>:</p>\n</li></ul>System.Reflection.Emit.TypeBuilder.MakeGenericType#1<p></p>"
  syntax:
    content: public override Type MakeGenericType(params Type[] typeArguments)
    content.vb: Public Overrides Function MakeGenericType(ParamArray typeArguments As Type()) As Type
    parameters:
    - id: typeArguments
      type: System.Type[]
      description: "\n<p>An array of types to be substituted for the type parameters of the current generic type definition.</p>\n"
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> representing the constructed type formed by substituting the elements of <em>typeArguments</em> for the type parameters of the current generic type. </p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current type does not represent the definition of a generic type. That is, <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong>. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>typeArguments</em> is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>Any element of <em>typeArguments</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <xref href=\"System.Type.Module\" data-throw-if-not-resolved=\"false\"></xref> property of any element of <em>typeArguments</em> is <strong>null</strong>. </p>\n<p>-or- </p>\n<p>The <xref href=\"System.Reflection.Module.Assembly\" data-throw-if-not-resolved=\"false\"></xref> property of the module of any element of <em>typeArguments</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
  fullName.vb: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type())
  name.vb: MakeGenericType(Type())
- uid: System.Reflection.Emit.TypeBuilder.MakePointerType
  commentId: M:System.Reflection.Emit.TypeBuilder.MakePointerType
  id: MakePointerType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: MakePointerType()
  fullName: System.Reflection.Emit.TypeBuilder.MakePointerType()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MakePointerType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 239
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns a <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents the type of an unmanaged pointer to the current type.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.MakePointerType\" data-throw-if-not-resolved=\"false\"></xref> method provides a way to generate pointer types for parameter lists.</p>\n<p>Using Microsoft intermediate language (MSIL) syntax, if the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> represents <code>MyType</code>, then the type returned by this method would be <code>MyType*</code>.</p>\n"
  example:
  - "\n<p>The following code example creates a dynamic module, an abstract type named <code>Sample</code>, and an abstract method named <code>TestMethod</code>. <code>TestMethod</code> takes a <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) of type <code>Sample</code>, a pointer to type <code>Sample</code>, and an array of type <code>Sample</code>. It returns a two-dimensional array of type <code>Sample</code>. The code example saves the dynamic module to disk, so you can examine it with the Ildasm.exe (IL Disassembler).</p>MakeXxxTypeBuilder#1"
  syntax:
    content: public override Type MakePointerType()
    content.vb: Public Overrides Function MakePointerType As Type
    return:
      type: System.Type
      description: "\n<p>A <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object that represents the type of an unmanaged pointer to the current type.</p>\n"
  seealso:
  - type: System.Reflection.Emit.TypeBuilder.MakeByRefType
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeByRefType
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  commentId: M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  id: SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: SetCustomAttribute(ConstructorInfo, Byte[])
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo, System.Byte[])
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetCustomAttribute
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 240
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Sets a custom attribute using a specified custom attribute blob.</p>\n"
  remarks: "\n<p>For more information on how to format <em>binaryAttribute</em>, see the Common Language Infrastructure (CLI) documentation, especially \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see <see href=\"http://go.microsoft.com/fwlink/?LinkID=99212\">ECMA C# and Common Language Infrastructure Standards</see> on MSDN and <see href=\"http://go.microsoft.com/fwlink/?LinkID=65552\">Standard ECMA-335 - Common Language Infrastructure (CLI)</see> on the Ecma International Web site.</p>\n<p>Starting with the .NET Framework 2.0 Service Pack 1, this member no longer requires <xref href=\"System.Security.Permissions.ReflectionPermission\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit\" data-throw-if-not-resolved=\"false\"></xref> flag. (See Security Issues in Reflection Emit.) To use this functionality, your application should target the .NET Framework 3.5 or later.</p>\n"
  syntax:
    content: public void SetCustomAttribute(ConstructorInfo con, byte[] binaryAttribute)
    content.vb: Public Sub SetCustomAttribute(con As ConstructorInfo, binaryAttribute As Byte())
    parameters:
    - id: con
      type: System.Reflection.ConstructorInfo
      description: "\n<p>The constructor for the custom attribute. </p>\n"
    - id: binaryAttribute
      type: System.Byte[]
      description: "\n<p>A byte blob representing the attributes. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>con</em> or <em>binaryAttribute</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo, System.Byte())
  name.vb: SetCustomAttribute(ConstructorInfo, Byte())
- uid: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  commentId: M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  id: SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: SetCustomAttribute(CustomAttributeBuilder)
  fullName: System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetCustomAttribute
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 241
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Set a custom attribute using a custom attribute builder.</p>\n"
  remarks: "\n<p>Starting with the .NET Framework 2.0 Service Pack 1, this member no longer requires <xref href=\"System.Security.Permissions.ReflectionPermission\" data-throw-if-not-resolved=\"false\"></xref> with the <xref href=\"System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit\" data-throw-if-not-resolved=\"false\"></xref> flag. (See Security Issues in Reflection Emit.) To use this functionality, your application should target the .NET Framework 3.5 or later.</p>\n"
  syntax:
    content: public void SetCustomAttribute(CustomAttributeBuilder customBuilder)
    content.vb: Public Sub SetCustomAttribute(customBuilder As CustomAttributeBuilder)
    parameters:
    - id: customBuilder
      type: System.Reflection.Emit.CustomAttributeBuilder
      description: "\n<p>An instance of a helper class to define the custom attribute. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>customBuilder</em> is <strong>null</strong>. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  commentId: M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  id: SetParent(System.Type)
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: SetParent(Type)
  fullName: System.Reflection.Emit.TypeBuilder.SetParent(System.Type)
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetParent
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 242
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Sets the base type of the type currently under construction.</p>\n"
  remarks: "\n<p>If <em>parent</em> is <strong>null</strong>, <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is used as the base type.</p>\n<p>In the .NET Framework versions 1.0 and 1.1, no exception is thrown if <em>parent</em> is an interface type, but a <xref href=\"System.TypeLoadException\" data-throw-if-not-resolved=\"false\"></xref> is thrown when the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method is called.</p>\n<p>The <xref href=\"System.Reflection.Emit.TypeBuilder.SetParent(System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method does not check for most invalid parent types. For example, it does not reject a parent type that has no default constructor when the current type has a default constructor, it does not reject sealed types, and it does not reject the <xref href=\"System.Delegate\" data-throw-if-not-resolved=\"false\"></xref> type. In all these cases, exceptions are thrown by the <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public void SetParent(Type parent)
    content.vb: Public Sub SetParent(parent As Type)
    parameters:
    - id: parent
      type: System.Type
      description: "\n<p>The new base type. </p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The type was previously created using <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>\n<em>parent</em> is <strong>null</strong>, and the current instance represents an interface whose attributes do not include <xref href=\"System.Reflection.TypeAttributes.Abstract\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>For the current dynamic type, the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>true</strong>, but the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>false</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>parent</em> is an interface. This exception condition is new in the .NET Framework version 2.0. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Reflection.Emit.TypeBuilder.ToString
  commentId: M:System.Reflection.Emit.TypeBuilder.ToString
  id: ToString
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: ToString()
  fullName: System.Reflection.Emit.TypeBuilder.ToString()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ToString
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.cs
    startLine: 243
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the name of the type excluding the namespace.</p>\n"
  syntax:
    content: public override string ToString()
    content.vb: Public Overrides Function ToString As String
    return:
      type: System.String
      description: "\n<p>Read-only. The name of the type excluding the namespace.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.Attributes
  commentId: P:System.Reflection.Emit.TypeBuilder.Attributes
  id: Attributes
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Attributes
  fullName: System.Reflection.Emit.TypeBuilder.Attributes
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Attributes
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 23
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override TypeAttributes Attributes { get; }
    content.vb: Public Overrides ReadOnly Property Attributes As TypeAttributes
    parameters: []
    return:
      type: System.Reflection.TypeAttributes
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.Assembly
  commentId: P:System.Reflection.Emit.TypeBuilder.Assembly
  id: Assembly
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Assembly
  fullName: System.Reflection.Emit.TypeBuilder.Assembly
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Assembly
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 24
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the dynamic assembly that contains this type definition.</p>\n"
  syntax:
    content: public override Assembly Assembly { get; }
    content.vb: Public Overrides ReadOnly Property Assembly As Assembly
    parameters: []
    return:
      type: Assembly
      description: "\n<p>Read-only. Retrieves the dynamic assembly that contains this type definition.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.BaseType
  commentId: P:System.Reflection.Emit.TypeBuilder.BaseType
  id: BaseType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: BaseType
  fullName: System.Reflection.Emit.TypeBuilder.BaseType
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: BaseType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 25
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the base type of this type.</p>\n"
  syntax:
    content: public override Type BaseType { get; }
    content.vb: Public Overrides ReadOnly Property BaseType As Type
    parameters: []
    return:
      type: Type
      description: "\n<p>Read-only. Retrieves the base type of this type.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.DeclaringMethod
  commentId: P:System.Reflection.Emit.TypeBuilder.DeclaringMethod
  id: DeclaringMethod
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DeclaringMethod
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringMethod
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DeclaringMethod
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 26
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets the method that declared the current generic type parameter.</p>\n"
  remarks: "\n<p>When emitting code, a generic type parameter is represented by a <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object rather than by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  syntax:
    content: public override MethodBase DeclaringMethod { get; }
    content.vb: Public Overrides ReadOnly Property DeclaringMethod As MethodBase
    parameters: []
    return:
      type: MethodBase
      description: "\n<p>A <xref href=\"System.Reflection.MethodBase\" data-throw-if-not-resolved=\"false\"></xref> that represents the method that declared the current type, if the current type is a generic type parameter; otherwise, <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  commentId: P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  id: GenericParameterAttributes
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GenericParameterAttributes
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterAttributes
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GenericParameterAttributes
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 27
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a value that indicates the covariance and special constraints of the current generic type parameter. </p>\n"
  remarks: "\n<p>When emitting code, a generic type parameter is represented by a <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object rather than by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  syntax:
    content: public override GenericParameterAttributes GenericParameterAttributes { get; }
    content.vb: Public Overrides ReadOnly Property GenericParameterAttributes As GenericParameterAttributes
    parameters: []
    return:
      type: GenericParameterAttributes
      description: "\n<p>A bitwise combination of <xref href=\"System.Reflection.GenericParameterAttributes\" data-throw-if-not-resolved=\"false\"></xref> values that describes the covariance and special constraints of the current generic type parameter.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.Module
  commentId: P:System.Reflection.Emit.TypeBuilder.Module
  id: Module
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Module
  fullName: System.Reflection.Emit.TypeBuilder.Module
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Module
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 28
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the dynamic module that contains this type definition.</p>\n"
  syntax:
    content: public override Module Module { get; }
    content.vb: 'Public Overrides ReadOnly Property Module As '
    parameters: []
    return:
      type: Module
      description: "\n<p>Read-only. Retrieves the dynamic module that contains this type definition.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.GetArrayRank
  commentId: M:System.Reflection.Emit.TypeBuilder.GetArrayRank
  id: GetArrayRank
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetArrayRank()
  fullName: System.Reflection.Emit.TypeBuilder.GetArrayRank()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetArrayRank
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 30
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override int GetArrayRank()
    content.vb: Public Overrides Function GetArrayRank As Integer
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.GetElementType
  commentId: M:System.Reflection.Emit.TypeBuilder.GetElementType
  id: GetElementType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetElementType()
  fullName: System.Reflection.Emit.TypeBuilder.GetElementType()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetElementType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 31
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Calling this method always throws <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Retrieve the type using <xref href=\"System.Type.GetType\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Assembly.GetType(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and use reflection on the retrieved type.</p>\n"
  syntax:
    content: public override Type GetElementType()
    content.vb: Public Overrides Function GetElementType As Type
    return:
      type: Type
      description: "\n<p>This method is not supported. No value is returned.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is not supported. </p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints
  commentId: M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints
  id: GetGenericParameterConstraints
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GetGenericParameterConstraints()
  fullName: System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints()
  type: Method
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetGenericParameterConstraints
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 32
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override Type[] GetGenericParameterConstraints()
    content.vb: Public Overrides Function GetGenericParameterConstraints As Type()
    return:
      type: System.Type[]
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Reflection.Emit.TypeBuilder.GenericTypeArguments
  commentId: P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments
  id: GenericTypeArguments
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GenericTypeArguments
  fullName: System.Reflection.Emit.TypeBuilder.GenericTypeArguments
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GenericTypeArguments
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 33
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override Type[] GenericTypeArguments { get; }
    content.vb: Public Overrides ReadOnly Property GenericTypeArguments As Type()
    parameters: []
    return:
      type: System.Type[]
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.ContainsGenericParameters
  commentId: P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters
  id: ContainsGenericParameters
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: ContainsGenericParameters
  fullName: System.Reflection.Emit.TypeBuilder.ContainsGenericParameters
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ContainsGenericParameters
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 34
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override bool ContainsGenericParameters { get; }
    content.vb: Public Overrides ReadOnly Property ContainsGenericParameters As Boolean
    parameters: []
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  commentId: P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  id: GenericParameterPosition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GenericParameterPosition
  fullName: System.Reflection.Emit.TypeBuilder.GenericParameterPosition
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GenericParameterPosition
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 35
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets the position of a type parameter in the type parameter list of the generic type that declared the parameter.</p>\n"
  remarks: "\n<p>When emitting code, a generic type parameter is represented by a <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\" data-throw-if-not-resolved=\"false\"></xref> object rather than by a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>If the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> does not represent a generic type parameter, the value of this property is undefined. Use the <xref href=\"System.Reflection.Emit.TypeBuilder.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> represents a generic type parameter.</p>\n"
  syntax:
    content: public override int GenericParameterPosition { get; }
    content.vb: Public Overrides ReadOnly Property GenericParameterPosition As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>If the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic type parameter, the position of the type parameter in the type parameter list of the generic type that declared the parameter; otherwise, undefined.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.GUID
  commentId: P:System.Reflection.Emit.TypeBuilder.GUID
  id: GUID
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: GUID
  fullName: System.Reflection.Emit.TypeBuilder.GUID
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GUID
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 36
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the GUID of this type.</p>\n"
  remarks: "\n<p>Retrieve the type using <xref href=\"System.Type.GetType\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Reflection.Assembly.GetType(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and use reflection on the retrieved type.</p>\n"
  syntax:
    content: public override Guid GUID { get; }
    content.vb: Public Overrides ReadOnly Property GUID As Guid
    parameters: []
    return:
      type: Guid
      description: "\n<p>Read-only. Retrieves the GUID of this type </p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is not currently supported for incomplete types. </p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.IsEnum
  commentId: P:System.Reflection.Emit.TypeBuilder.IsEnum
  id: IsEnum
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsEnum
  fullName: System.Reflection.Emit.TypeBuilder.IsEnum
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsEnum
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 37
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override bool IsEnum { get; }
    content.vb: Public Overrides ReadOnly Property IsEnum As Boolean
    parameters: []
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.IsGenericType
  commentId: P:System.Reflection.Emit.TypeBuilder.IsGenericType
  id: IsGenericType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsGenericType
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericType
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsGenericType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 38
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a value indicating whether the current type is a generic type. </p>\n"
  remarks: "\n<p>A <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic type definition if the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method has been used to give it generic type parameters. An instance of the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> class that is generic is always a generic type definition.</p>\n<p>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public override bool IsGenericType { get; }
    content.vb: Public Overrides ReadOnly Property IsGenericType As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the type represented by the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object is generic; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Type.IsGenericType
    commentId: P:System.Type.IsGenericType
  - type: System.Type.GetGenericTypeDefinition
    commentId: M:System.Type.GetGenericTypeDefinition
  - type: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  commentId: P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  id: IsGenericTypeDefinition
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsGenericTypeDefinition
  fullName: System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsGenericTypeDefinition
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 39
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Gets a value indicating whether the current <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> represents a generic type definition from which other generic types can be constructed.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic type definition if the <xref href=\"System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])\" data-throw-if-not-resolved=\"false\"></xref> method has been used to give it generic type parameters. An instance of the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> class that is generic is always a generic type definition.</p>\n<p>A <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> can be used to build generic type definitions, but not constructed generic types. To get a constructed generic type, call the <xref href=\"System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])\" data-throw-if-not-resolved=\"false\"></xref> method on a <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> that represents a generic type definition.</p>\n<p>For more information on generic types in reflection and a list of the invariant conditions for terms used in generic reflection, see the <xref href=\"System.Type.IsGenericType\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n"
  syntax:
    content: public override bool IsGenericTypeDefinition { get; }
    content.vb: Public Overrides ReadOnly Property IsGenericTypeDefinition As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> object represents a generic type definition; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
    commentId: M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition
  - type: System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
    commentId: M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])
  - type: System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
    commentId: M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])
  - type: System.Type.IsGenericType
    commentId: P:System.Type.IsGenericType
  - type: System.Type.IsGenericTypeDefinition
    commentId: P:System.Type.IsGenericTypeDefinition
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.IsSerializable
  commentId: P:System.Reflection.Emit.TypeBuilder.IsSerializable
  id: IsSerializable
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: IsSerializable
  fullName: System.Reflection.Emit.TypeBuilder.IsSerializable
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsSerializable
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 40
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  syntax:
    content: public override bool IsSerializable { get; }
    content.vb: Public Overrides ReadOnly Property IsSerializable As Boolean
    parameters: []
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.Namespace
  commentId: P:System.Reflection.Emit.TypeBuilder.Namespace
  id: Namespace
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: Namespace
  fullName: System.Reflection.Emit.TypeBuilder.Namespace
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Namespace
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 41
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Retrieves the namespace where this <strong>TypeBuilder</strong> is defined.</p>\n"
  syntax:
    content: public override string Namespace { get; }
    content.vb: Public Overrides ReadOnly Property Namespace As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>Read-only. Retrieves the namespace where this <strong>TypeBuilder</strong> is defined.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Reflection.Emit.TypeBuilder.DeclaringType
  commentId: P:System.Reflection.Emit.TypeBuilder.DeclaringType
  id: DeclaringType
  parent: System.Reflection.Emit.TypeBuilder
  langs:
  - csharp
  - vb
  name: DeclaringType
  fullName: System.Reflection.Emit.TypeBuilder.DeclaringType
  type: Property
  source:
    remote:
      path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DeclaringType
    path: src/System.Reflection.Emit/ref/System.Reflection.Emit.Manual.cs
    startLine: 43
  assemblies:
  - System.Reflection.Emit
  namespace: System.Reflection.Emit
  summary: "\n<p>Returns the type that declared this type.</p>\n"
  syntax:
    content: public override Type DeclaringType { get; }
    content.vb: Public Overrides ReadOnly Property DeclaringType As Type
    parameters: []
    return:
      type: Type
      description: "\n<p>Read-only. The type that declared this type.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
references:
- uid: System.Reflection.Emit
  isExternal: false
  name: System.Reflection.Emit
  fullName: System.Reflection.Emit
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Reflection.TypeInfo
  parent: System.Reflection
  isExternal: false
  name: TypeInfo
  fullName: System.Reflection.TypeInfo
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Reflection
  isExternal: false
  name: System.Reflection
  fullName: System.Reflection
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Reflection.Emit.PackingSize
  parent: System.Reflection.Emit
  isExternal: false
  name: PackingSize
  fullName: System.Reflection.Emit.PackingSize
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  fullName: System.Type
- uid: System.Reflection.MethodAttributes
  parent: System.Reflection
  isExternal: false
  name: MethodAttributes
  fullName: System.Reflection.MethodAttributes
- uid: System.Reflection.CallingConventions
  parent: System.Reflection
  isExternal: false
  name: CallingConventions
  fullName: System.Reflection.CallingConventions
- uid: System.Type[]
  isExternal: false
  name: Type[]
  fullName: System.Type[]
  fullname.vb: System.Type()
  name.vb: Type()
  spec.csharp:
  - uid: System.Type
    name: Type
    fullName: System.Type
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Type
    name: Type
    fullName: System.Type
  - name: ()
    fullName: ()
- uid: System.Reflection.Emit.ConstructorBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: ConstructorBuilder
  fullName: System.Reflection.Emit.ConstructorBuilder
- uid: System.Type[][]
  isExternal: true
  name: Type[][]
  fullName: System.Type[][]
  fullname.vb: System.Type()()
  name.vb: Type()()
  spec.csharp:
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: '[]'
    fullName: '[]'
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: ()
    fullName: ()
  - name: ()
    fullName: ()
- uid: System.Reflection.EventAttributes
  parent: System.Reflection
  isExternal: false
  name: EventAttributes
  fullName: System.Reflection.EventAttributes
- uid: System.Reflection.Emit.EventBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: EventBuilder
  fullName: System.Reflection.Emit.EventBuilder
- uid: System.Reflection.FieldAttributes
  parent: System.Reflection
  isExternal: false
  name: FieldAttributes
  fullName: System.Reflection.FieldAttributes
- uid: System.Reflection.Emit.FieldBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: FieldBuilder
  fullName: System.Reflection.Emit.FieldBuilder
- uid: System.String[]
  isExternal: false
  name: String[]
  fullName: System.String[]
  fullname.vb: System.String()
  name.vb: String()
  spec.csharp:
  - uid: System.String
    name: String
    fullName: System.String
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.String
    name: String
    fullName: System.String
  - name: ()
    fullName: ()
- uid: System.Reflection.Emit.GenericTypeParameterBuilder[]
  isExternal: false
  name: GenericTypeParameterBuilder[]
  fullName: System.Reflection.Emit.GenericTypeParameterBuilder[]
  fullname.vb: System.Reflection.Emit.GenericTypeParameterBuilder()
  name.vb: GenericTypeParameterBuilder()
  spec.csharp:
  - uid: System.Reflection.Emit.GenericTypeParameterBuilder
    name: GenericTypeParameterBuilder
    fullName: System.Reflection.Emit.GenericTypeParameterBuilder
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Reflection.Emit.GenericTypeParameterBuilder
    name: GenericTypeParameterBuilder
    fullName: System.Reflection.Emit.GenericTypeParameterBuilder
  - name: ()
    fullName: ()
- uid: System.Byte[]
  isExternal: false
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: ()
    fullName: ()
- uid: System.Reflection.Emit.MethodBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: MethodBuilder
  fullName: System.Reflection.Emit.MethodBuilder
- uid: System.Reflection.MethodInfo
  parent: System.Reflection
  isExternal: false
  name: Reflection.MethodInfo
  fullName: System.Reflection.MethodInfo
- uid: System.Reflection.Emit.TypeBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: TypeBuilder
  fullName: System.Reflection.Emit.TypeBuilder
- uid: System.Reflection.TypeAttributes
  parent: System.Reflection
  isExternal: false
  name: TypeAttributes
  fullName: System.Reflection.TypeAttributes
- uid: System.Reflection.PropertyAttributes
  parent: System.Reflection
  isExternal: false
  name: PropertyAttributes
  fullName: System.Reflection.PropertyAttributes
- uid: System.Reflection.Emit.PropertyBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: PropertyBuilder
  fullName: System.Reflection.Emit.PropertyBuilder
- uid: System.Reflection.ConstructorInfo
  parent: System.Reflection
  isExternal: false
  name: Reflection.ConstructorInfo
  fullName: System.Reflection.ConstructorInfo
- uid: System.Reflection.FieldInfo
  parent: System.Reflection
  isExternal: false
  name: Reflection.FieldInfo
  fullName: System.Reflection.FieldInfo
- uid: System.Reflection.Emit.CustomAttributeBuilder
  parent: System.Reflection.Emit
  isExternal: false
  name: CustomAttributeBuilder
  fullName: System.Reflection.Emit.CustomAttributeBuilder
- uid: Assembly
  isExternal: true
  name: Assembly
  fullName: Assembly
- uid: Type
  isExternal: true
  name: Type
  fullName: Type
- uid: MethodBase
  isExternal: true
  name: MethodBase
  fullName: MethodBase
- uid: GenericParameterAttributes
  isExternal: true
  name: GenericParameterAttributes
  fullName: GenericParameterAttributes
- uid: Module
  isExternal: true
  name: Module
  fullName: Module
- uid: Guid
  isExternal: true
  name: Guid
  fullName: Guid
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.IndexOutOfRangeException
  isExternal: false
  name: IndexOutOfRangeException
  fullName: System.IndexOutOfRangeException
