items:
- uid: System.Runtime.CompilerServices.IsExplicitlyDereferenced
  commentId: T:System.Runtime.CompilerServices.IsExplicitlyDereferenced
  id: IsExplicitlyDereferenced
  parent: System.Runtime.CompilerServices
  children: []
  langs:
  - csharp
  - vb
  name: IsExplicitlyDereferenced
  fullName: System.Runtime.CompilerServices.IsExplicitlyDereferenced
  type: Class
  source:
    remote:
      path: src/System.Runtime.CompilerServices.VisualC/ref/System.Runtime.CompilerServices.VisualC.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsExplicitlyDereferenced
    path: src/System.Runtime.CompilerServices.VisualC/ref/System.Runtime.CompilerServices.VisualC.cs
    startLine: 41
  assemblies:
  - System.Runtime.CompilerServices.VisualC
  namespace: System.Runtime.CompilerServices
  summary: "\n<p>Indicates that a managed pointer represents a pointer parameter within a method signature. This class cannot be inherited.</p>\n"
  remarks: "\n<p>In C++, managed pointers and managed references are emitted into metadata as pointers.  To distinguish between the two types in metadata, the Microsoft  C++ compiler applies this modifier to managed pointers.  It emits no modifier on managed reference types.  Compilers need to know the correct calling syntax when importing a method from metadata scope.  The <xref href=\"System.Runtime.CompilerServices.IsExplicitlyDereferenced\" data-throw-if-not-resolved=\"false\"></xref> class and its partner, the <xref href=\"System.Runtime.CompilerServices.IsImplicitlyDereferenced\" data-throw-if-not-resolved=\"false\"></xref> class, disambiguate reference parameters from pointer parameters.</p>\n<p>Compilers emit custom modifiers within metadata to change the way that the just-in-time (JIT) compiler handles values when the default behavior is not appropriate.  When the JIT compiler encounters a custom modifier, it handles the value in the way that the modifier specifies.  Compilers can apply custom modifiers to methods, parameters, and return values.  The JIT compiler must respond to required modifiers but can ignore optional modifiers.  </p>\n<p>You can emit custom modifiers into metadata using one of the following techniques:</p>\n<ul><li>\n<p>Using methods in the <xref href=\"System.Reflection.Emit.TypeBuilder\" data-throw-if-not-resolved=\"false\"></xref> class such as <see cref=\"Overload:System.Reflection.Emit.TypeBuilder.DefineMethod\"></see>, <see cref=\"Overload:System.Reflection.Emit.TypeBuilder.DefineField\"></see>, <see cref=\"Overload:System.Reflection.Emit.TypeBuilder.DefineConstructor\"></see>, and <see cref=\"Overload:System.Reflection.Emit.TypeBuilder.DefineProperty\"></see>.</p>\n</li><li>\n<p>Generating a Microsoft intermediate language (MSIL) instruction file that contains calls to <strong>modopt</strong> and <strong>modreq</strong>, and assembling the file with the Ilasm.exe (IL Assembler).</p>\n</li><li>\n<p>Using the unmanaged reflection API.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example demonstrates how to emit an <xref href=\"System.Runtime.CompilerServices.IsExplicitlyDereferenced\" data-throw-if-not-resolved=\"false\"></xref> object into an assembly using reflection.  </p>Runtime.CompilerServices.IsExplicitlyDereferenced#1"
  syntax:
    content: 'public class IsExplicitlyDereferenced : object'
    content.vb: >-
      Public Class IsExplicitlyDereferenced
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
references:
- uid: System.Runtime.CompilerServices
  isExternal: false
  name: System.Runtime.CompilerServices
  fullName: System.Runtime.CompilerServices
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
