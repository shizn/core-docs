items:
- uid: System.Net.Sockets.TcpClient
  commentId: T:System.Net.Sockets.TcpClient
  id: TcpClient
  parent: System.Net.Sockets
  children:
  - System.Net.Sockets.TcpClient.#ctor
  - System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)
  - System.Net.Sockets.TcpClient.Active
  - System.Net.Sockets.TcpClient.Available
  - System.Net.Sockets.TcpClient.Client
  - System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)
  - System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)
  - System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)
  - System.Net.Sockets.TcpClient.Connected
  - System.Net.Sockets.TcpClient.Dispose
  - System.Net.Sockets.TcpClient.Dispose(System.Boolean)
  - System.Net.Sockets.TcpClient.ExclusiveAddressUse
  - System.Net.Sockets.TcpClient.Finalize
  - System.Net.Sockets.TcpClient.GetStream
  - System.Net.Sockets.TcpClient.LingerState
  - System.Net.Sockets.TcpClient.NoDelay
  - System.Net.Sockets.TcpClient.ReceiveBufferSize
  - System.Net.Sockets.TcpClient.ReceiveTimeout
  - System.Net.Sockets.TcpClient.SendBufferSize
  - System.Net.Sockets.TcpClient.SendTimeout
  langs:
  - csharp
  - vb
  name: TcpClient
  fullName: System.Net.Sockets.TcpClient
  type: Class
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TcpClient
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 416
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Provides client connections for TCP network services.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class provides simple methods for connecting, sending, and receiving stream data over a network in synchronous blocking mode.</p>\n<p>In order for <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> to connect and exchange data, a <xref href=\"System.Net.Sockets.TcpListener\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> created with the TCP <xref href=\"System.Net.Sockets.ProtocolType\" data-throw-if-not-resolved=\"false\"></xref> must be listening for incoming connection requests. You can connect to this listener in one of the following two ways: </p>\n<ul><li>\n<p>Create a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> and call one of the three available <xref href=\"System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n</li><li>\n<p>Create a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> using the host name and port number of the remote host. This constructor will automatically attempt a connection.</p>\n</li></ul>\n<p>If you want to send connectionless datagrams in synchronous blocking mode, use the <xref href=\"System.Net.Sockets.UdpClient\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - "\n<p>The following code example establishes a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> connection.</p>System.Net.Sockets.TcpClient#1"
  syntax:
    content: 'public class TcpClient : IDisposable'
    content.vb: >-
      Public Class TcpClient
          Implements IDisposable
  seealso:
  - type: System.Net.Sockets.TcpListener
    commentId: T:System.Net.Sockets.TcpListener
  - type: System.Net.Sockets.NetworkStream
    commentId: T:System.Net.Sockets.NetworkStream
  - type: System.Net.Sockets.Socket
    commentId: T:System.Net.Sockets.Socket
  - type: System.Net.Sockets.ProtocolType
    commentId: T:System.Net.Sockets.ProtocolType
  - type: System.Net.IPEndPoint
    commentId: T:System.Net.IPEndPoint
  - type: System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
    commentId: M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
  - type: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - type: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  see:
  - type: System.Net.SocketPermission
    commentId: T:System.Net.SocketPermission
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Net.Sockets.TcpClient.#ctor
  commentId: M:System.Net.Sockets.TcpClient.#ctor
  id: '#ctor'
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: TcpClient()
  fullName: System.Net.Sockets.TcpClient.TcpClient()
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 418
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>This constructor creates a new <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> and allows the underlying service provider to assign the most appropriate local IP address and port number. You must first call the <xref href=\"System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method before sending and receiving data.</p>\n<p>This constructor works only with IPv4 address types.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to use the default constructor to create a new <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#4"
  syntax:
    content: public TcpClient()
    content.vb: Public Sub New
  seealso:
  - type: System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
    commentId: M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)
  commentId: M:System.Net.Sockets.TcpClient.#ctor(System.Net.Sockets.AddressFamily)
  id: '#ctor(System.Net.Sockets.AddressFamily)'
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: TcpClient(AddressFamily)
  fullName: System.Net.Sockets.TcpClient.TcpClient(System.Net.Sockets.AddressFamily)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 419
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class with the specified family.</p>\n"
  remarks: "\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to create an instance of the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#15"
  syntax:
    content: public TcpClient(AddressFamily family)
    content.vb: Public Sub New(family As AddressFamily)
    parameters:
    - id: family
      type: System.Net.Sockets.AddressFamily
      description: "\n<p>The <xref href=\"System.Net.IPAddress.AddressFamily\" data-throw-if-not-resolved=\"false\"></xref> of the IP protocol. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>family</em> parameter is not equal to AddressFamily.InterNetwork </p>\n<p>-or- </p>\n<p>The <em>family</em> parameter is not equal to AddressFamily.InterNetworkV6 </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.Active
  commentId: P:System.Net.Sockets.TcpClient.Active
  id: Active
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Active
  fullName: System.Net.Sockets.TcpClient.Active
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Active
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 420
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or set a value that indicates whether a connection has been made.</p>\n"
  remarks: "\n<p>Classes deriving from <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> can use this property to determine if a connection attempt has succeeded. It does not monitor the ongoing connection state of <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>. If the remote host closes the connection, <xref href=\"System.Net.Sockets.TcpClient.Active\" data-throw-if-not-resolved=\"false\"></xref> will not be updated. If you are deriving from <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> and require closer attention to the connection state, use the <xref href=\"System.Net.Sockets.Socket.Connected\" data-throw-if-not-resolved=\"false\"></xref> property of the <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> returned by the <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: protected bool Active { get; set; }
    content.vb: Protected Property Active As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the connection has been made; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connected
    commentId: P:System.Net.Sockets.Socket.Connected
  - type: System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
    commentId: M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
  modifiers.csharp:
  - protected
  - get
  - set
  modifiers.vb:
  - Protected
- uid: System.Net.Sockets.TcpClient.Available
  commentId: P:System.Net.Sockets.TcpClient.Available
  id: Available
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Available
  fullName: System.Net.Sockets.TcpClient.Available
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Available
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 421
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets the amount of data that has been received from the network and is available to be read.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.TcpClient.Available\" data-throw-if-not-resolved=\"false\"></xref> is a way to determine whether data is queued for reading. If data is available, call <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to get the data. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref href=\"System.Net.Sockets.TcpClient.Available\" data-throw-if-not-resolved=\"false\"></xref> returns 0.</p>\n<p>If the remote host shuts down or closes the connection, <xref href=\"System.Net.Sockets.TcpClient.Available\" data-throw-if-not-resolved=\"false\"></xref> may throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <see href=\"http://msdn.microsoft.com/library\">http://msdn.microsoft.com/library</see> for a detailed description of the error.</p>\n"
  example:
  - "\n<p>The following code example shows the use of the <xref href=\"System.Net.Sockets.TcpClient.Available\" data-throw-if-not-resolved=\"false\"></xref> property.</p>System.Net.Sockets.TcpClient1#1"
  syntax:
    content: public int Available { get; }
    content.vb: Public ReadOnly Property Available As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The number of bytes of data received from the network and available to be read.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.TcpClient.Client
  commentId: P:System.Net.Sockets.TcpClient.Client
  id: Client
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Client
  fullName: System.Net.Sockets.TcpClient.Client
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Client
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 422
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> creates a <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to send and receive data over a network. Classes deriving from <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> can use this property to get or set this <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. Use the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> returned from <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> if you require access beyond that which <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> provides. You can also use <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> to set the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> to an existing <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>. This might be useful if you want to take advantage of the simplicity of <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> using a pre-existing <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the use of the <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> property. In this example, the receive buffer size of the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> is changed.</p>TcpClientProtectedMethodsAndPropertiesExample#1"
  syntax:
    content: public Socket Client { get; set; }
    content.vb: Public Property Client As Socket
    parameters: []
    return:
      type: System.Net.Sockets.Socket
      description: "\n<p>The underlying network <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Net.Sockets.Socket
    commentId: T:System.Net.Sockets.Socket
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.Connected
  commentId: P:System.Net.Sockets.TcpClient.Connected
  id: Connected
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Connected
  fullName: System.Net.Sockets.TcpClient.Connected
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Connected
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 423
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets a value indicating whether the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> for a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> is connected to a remote host.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.Connected\" data-throw-if-not-resolved=\"false\"></xref> property gets the connection state of the <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> socket as of the last I/O operation. When it returns <strong>false</strong>, the <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> socket was either never connected, or is no longer connected.</p>\n<p>Because the <xref href=\"System.Net.Sockets.TcpClient.Connected\" data-throw-if-not-resolved=\"false\"></xref> property only reflects the state of the connection as of the most recent operation, you should attempt to send or receive a message to determine the current state. After the message send fails, this property no longer returns <strong>true</strong>. Note that this behavior is by design. You cannot reliably test the state of the connection because, in the time between the test and a send/receive, the connection could have been lost. Your code should assume the socket is connected, and gracefully handle failed transmissions.</p>\n"
  example:
  - "\n<p>The following code example connects to a remote endpoint and then verifies the connection.</p>System.Net.Sockets.TcpClient1#2"
  syntax:
    content: public bool Connected { get; }
    content.vb: Public ReadOnly Property Connected As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.TcpClient.Client\" data-throw-if-not-resolved=\"false\"></xref> socket was connected to a remote resource as of the most recent operation; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Net.Sockets.TcpClient.ExclusiveAddressUse
  commentId: P:System.Net.Sockets.TcpClient.ExclusiveAddressUse
  id: ExclusiveAddressUse
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ExclusiveAddressUse
  fullName: System.Net.Sockets.TcpClient.ExclusiveAddressUse
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExclusiveAddressUse
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 424
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> allows only one client to use a port.</p>\n"
  remarks: "\n<p>By default, multiple clients can use a specific port; however, only one of the clients can perform operations on the network traffic sent to the port. You can use the <xref href=\"System.Net.Sockets.TcpClient.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property to prevent multiple clients from using a specific port.</p>\n<p>This property must be set before the underlying socket is bound to a client port. If you call <see cref=\"Overload:System.Net.Sockets.TcpClient.Connect\"></see>, <see cref=\"Overload:System.Net.Sockets.TcpClient.BeginConnect\"></see>, <xref href=\"System.Net.Sockets.TcpClient.#ctor(System.Net.IPEndPoint)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Net.Sockets.TcpClient.#ctor(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, the client port is bound as a side effect of the method, and you cannot subsequently set the <xref href=\"System.Net.Sockets.TcpClient.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property </p>\n"
  example:
  - "\n<p>The following code example creates a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> and gets and sets the value of the <xref href=\"System.Net.Sockets.TcpClient.ExclusiveAddressUse\" data-throw-if-not-resolved=\"false\"></xref> property.</p>System.Net.Sockets.TcpClient1#3"
  syntax:
    content: public bool ExclusiveAddressUse { get; set; }
    content.vb: Public Property ExclusiveAddressUse As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> allows only one client to use a specific port; otherwise, <strong>false</strong>. The default is <strong>true</strong> for Windows Server 2003 and Windows XP Service Pack 2 and later, and <strong>false</strong> for all other versions.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the underlying socket.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.LingerState
  commentId: P:System.Net.Sockets.TcpClient.LingerState
  id: LingerState
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: LingerState
  fullName: System.Net.Sockets.TcpClient.LingerState
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: LingerState
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 425
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets information about the linger state of the associated socket.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property changes the way <xref href=\"System.Net.Sockets.Socket.Close\" data-throw-if-not-resolved=\"false\"></xref> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior. </p>\n<p>This property controls the length of time that the TCP connection will remain open after a call to <xref href=\"System.Net.Sockets.TcpClient.Close\" data-throw-if-not-resolved=\"false\"></xref> when data remains to be sent. When you call the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref href=\"System.Net.Sockets.TcpClient.Close\" data-throw-if-not-resolved=\"false\"></xref> method drops the connection. </p>\n<p>To enable lingering, create a <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref> instance containing the desired values, and set the <xref href=\"System.Net.Sockets.TcpClient.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property to this instance.</p>\n<p>The following table describes the behavior of the <xref href=\"System.Net.Sockets.TcpClient.Close\" data-throw-if-not-resolved=\"false\"></xref> method for the possible values of the <xref href=\"System.Net.Sockets.LingerOption.Enabled\" data-throw-if-not-resolved=\"false\"></xref> property and the <xref href=\"System.Net.Sockets.LingerOption.LingerTime\" data-throw-if-not-resolved=\"false\"></xref> property stored in the <xref href=\"System.Net.Sockets.TcpClient.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>LingerState.Enabled</p>\n<p>LingerState.LingerTime</p>\n<p>Behavior</p>\n<p>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref href=\"System.Net.Sockets.TcpClient.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property is not set.</p>\n<p>When the <xref href=\"System.Net.Sockets.LingerOption.LingerTime\" data-throw-if-not-resolved=\"false\"></xref> property stored in the <xref href=\"System.Net.Sockets.TcpClient.LingerState\" data-throw-if-not-resolved=\"false\"></xref> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override. </p>\n"
  example:
  - "\n<p>The following code example sets and gets the sockets linger time.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#12"
  syntax:
    content: public LingerOption LingerState { get; set; }
    content.vb: Public Property LingerState As LingerOption
    parameters: []
    return:
      type: System.Net.Sockets.LingerOption
      description: "\n<p>A <xref href=\"System.Net.Sockets.LingerOption\" data-throw-if-not-resolved=\"false\"></xref>. By default, lingering is disabled.</p>\n"
  seealso:
  - type: System.Net.Sockets.LingerOption
    commentId: T:System.Net.Sockets.LingerOption
  - type: System.Net.Sockets.TcpClient.Close
    commentId: M:System.Net.Sockets.TcpClient.Close
  - type: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.NoDelay
  commentId: P:System.Net.Sockets.TcpClient.NoDelay
  id: NoDelay
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: NoDelay
  fullName: System.Net.Sockets.TcpClient.NoDelay
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NoDelay
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 426
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets a value that disables a delay when send or receive buffers are not full.</p>\n"
  remarks: "\n<p>When <xref href=\"System.Net.Sockets.TcpClient.NoDelay\" data-throw-if-not-resolved=\"false\"></xref> is <strong>false</strong>, a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> does not send a packet over the network until it has collected a significant amount of outgoing data. Because of the amount of overhead in a TCP segment, sending small amounts of data is inefficient. However, situations do exist where you need to send very small amounts of data or expect immediate responses from each packet you send. Your decision should weigh the relative importance of network efficiency versus application requirements.</p>\n"
  example:
  - "\n<p>The following code example disables the delay. It then checks the value of <xref href=\"System.Net.Sockets.TcpClient.NoDelay\" data-throw-if-not-resolved=\"false\"></xref> to verify that the property was successfully set.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#13"
  syntax:
    content: public bool NoDelay { get; set; }
    content.vb: Public Property NoDelay As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the delay is disabled, otherwise <strong>false</strong>. The default value is <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.ReceiveBufferSize
  commentId: P:System.Net.Sockets.TcpClient.ReceiveBufferSize
  id: ReceiveBufferSize
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ReceiveBufferSize
  fullName: System.Net.Sockets.TcpClient.ReceiveBufferSize
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveBufferSize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 427
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets the size of the receive buffer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.ReceiveBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property gets or sets the number of bytes that you are expecting to store in the receive buffer for each read operation. This property actually manipulates the network buffer space allocated for receiving incoming data.</p>\n<p>Your network buffer should be at least as large as your application buffer to ensure that the desired data will be available when you call the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. Use the <xref href=\"System.Net.Sockets.TcpClient.ReceiveBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property to set this size. If your application will be receiving bulk data, you should pass the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method a very large application buffer.</p>\n<p>If the network buffer is smaller than the amount of data you request in the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, you will not be able to retrieve the desired amount of data in one read operation. This incurs the overhead of additional calls to the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - "\n<p>The following code example sets and gets the receive buffer size.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#8"
  syntax:
    content: public int ReceiveBufferSize { get; set; }
    content.vb: Public Property ReceiveBufferSize As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The size of the receive buffer, in bytes. The default value is 8192 bytes.</p>\n"
  exceptions:
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when setting the buffer size.</p>\n<p>-or-</p>\n<p>In .NET Compact Framework applications, you cannot set this property. For a workaround, see the Platform Note in Remarks.</p>\n"
  seealso:
  - type: System.Net.Sockets.TcpClient.SendBufferSize
    commentId: P:System.Net.Sockets.TcpClient.SendBufferSize
  - type: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.ReceiveTimeout
  commentId: P:System.Net.Sockets.TcpClient.ReceiveTimeout
  id: ReceiveTimeout
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ReceiveTimeout
  fullName: System.Net.Sockets.TcpClient.ReceiveTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReceiveTimeout
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 428
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets the amount of time a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> will wait to receive data once a read operation is initiated.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.ReceiveTimeout\" data-throw-if-not-resolved=\"false\"></xref> property determines the amount of time that the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method will block until it is able to receive data. This time is measured in milliseconds. If the time-out expires before <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> successfully completes, <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> throws a <xref href=\"System.IO.IOException\" data-throw-if-not-resolved=\"false\"></xref>. There is no time-out by default.</p>\n"
  example:
  - "\n<p>The following code example sets and gets the receive time out.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#10"
  syntax:
    content: public int ReceiveTimeout { get; set; }
    content.vb: Public Property ReceiveTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The time-out value of the connection in milliseconds. The default value is 0.</p>\n"
  seealso:
  - type: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - type: System.Net.Sockets.TcpClient.SendTimeout
    commentId: P:System.Net.Sockets.TcpClient.SendTimeout
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.SendBufferSize
  commentId: P:System.Net.Sockets.TcpClient.SendBufferSize
  id: SendBufferSize
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: SendBufferSize
  fullName: System.Net.Sockets.TcpClient.SendBufferSize
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendBufferSize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 429
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets the size of the send buffer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.SendBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property gets or sets the number of bytes that you are expecting to send in each call to the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. This property actually manipulates the network buffer space allocated for send operation.</p>\n<p>Your network buffer should be at least as large as your application buffer to ensure that the desired data will be stored and sent in one operation. Use the <xref href=\"System.Net.Sockets.TcpClient.SendBufferSize\" data-throw-if-not-resolved=\"false\"></xref> property to set this size. If your application will be sending bulk data, you should pass the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method a very large application buffer.</p>\n<p>If the network buffer is smaller than the amount of data you provide the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, several network send operations will be performed for every call you make to the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. You can achieve greater data throughput by ensuring that your network buffer is at least as large as your application buffer.</p>\n"
  example:
  - "\n<p>The following code example sets and gets the send buffer size.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#9"
  syntax:
    content: public int SendBufferSize { get; set; }
    content.vb: Public Property SendBufferSize As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The size of the send buffer, in bytes. The default value is 8192 bytes.</p>\n"
  seealso:
  - type: System.Net.Sockets.TcpClient.ReceiveBufferSize
    commentId: P:System.Net.Sockets.TcpClient.ReceiveBufferSize
  - type: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.SendTimeout
  commentId: P:System.Net.Sockets.TcpClient.SendTimeout
  id: SendTimeout
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: SendTimeout
  fullName: System.Net.Sockets.TcpClient.SendTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SendTimeout
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 430
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Gets or sets the amount of time a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> will wait for a send operation to complete successfully.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref> property determines the amount of time that the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method will block until it is able to return successfully. This time is measured in milliseconds.</p>\n<p>After you call the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> returns the number of bytes actually sent to the host. The <xref href=\"System.Net.Sockets.TcpClient.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref> property determines the amount of time a <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> will wait before receiving the number of bytes returned. If the time-out expires before the <xref href=\"System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\" data-throw-if-not-resolved=\"false\"></xref> method successfully completes, <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> will throw a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>. There is no time-out by default.</p>\n"
  example:
  - "\n<p>The following code example sets and gets the <xref href=\"System.Net.Sockets.TcpClient.SendTimeout\" data-throw-if-not-resolved=\"false\"></xref> value.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#11"
  syntax:
    content: public int SendTimeout { get; set; }
    content.vb: Public Property SendTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The send time-out value, in milliseconds. The default is 0.</p>\n"
  seealso:
  - type: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - type: System.Net.Sockets.TcpClient.ReceiveTimeout
    commentId: P:System.Net.Sockets.TcpClient.ReceiveTimeout
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)
  commentId: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress,System.Int32)
  id: ConnectAsync(System.Net.IPAddress,System.Int32)
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ConnectAsync(IPAddress, Int32)
  fullName: System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 431
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Connects the client to a remote TCP host using the specified IP address and port number as an asynchronous operation.</p>\n"
  remarks: "\n<p>This operation will not block. The returned Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>  object will complete after the TCP connection has been established. This method does not block the calling thread while the connection request is underway.</p>\n<p>Call this method to establish a synchronous remote host connection to the specified <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> and port number as an asynchronous operation. After connecting with the remote host, use the <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> method to obtain the underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>. Use this <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> to send and receive data.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Task ConnectAsync(IPAddress address, int port)
    content.vb: Public Function ConnectAsync(address As IPAddress, port As Integer) As Task
    parameters:
    - id: address
      type: System.Net.IPAddress
      description: "\n<p>The <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> of the host to which you intend to connect. </p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number to which you intend to connect. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>address</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>port</em> is not between <xref href=\"System.Net.IPEndPoint.MinPort\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.IPEndPoint.MaxPort\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when accessing the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>\n<xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.TcpClient.GetStream
    commentId: M:System.Net.Sockets.TcpClient.GetStream
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)
  commentId: M:System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[],System.Int32)
  id: ConnectAsync(System.Net.IPAddress[],System.Int32)
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ConnectAsync(IPAddress[], Int32)
  fullName: System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 432
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Connects the client to a remote TCP host using the specified IP addresses and port number as an asynchronous operation.</p>\n"
  remarks: "\n<p>This operation will not block. The returned Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>  object will complete after the TCP connection has been established. This method does not block the calling thread while the connection request is underway.</p>\n<p>This method is typically used immediately after a call to the <xref href=\"System.Net.Dns.BeginGetHostAddresses(System.String,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, which can return multiple IP addresses for a single host. Call this method to establish a synchronous remote host connection to the host specified by the array of <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> elements and the port number as an asynchronous operation. After connecting with the remote host, use the <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> method to obtain the underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>. Use this <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> to send and receive data.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <see href=\"http://msdn.microsoft.com/library\">http://msdn.microsoft.com/library</see> for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Task ConnectAsync(IPAddress[] addresses, int port)
    content.vb: Public Function ConnectAsync(addresses As IPAddress(), port As Integer) As Task
    parameters:
    - id: addresses
      type: System.Net.IPAddress[]
      description: "\n<p>The <xref href=\"System.Net.IPAddress\" data-throw-if-not-resolved=\"false\"></xref> array of the host to which you intend to connect.</p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number to which you intend to connect.</p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>ipAddresses</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The port number is not valid.</p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when attempting to access the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  - type: System.Security.SecurityException
    commentId: T:System.Security.SecurityException
    description: "\n<p>A caller higher in the call stack does not have permission for the requested operation. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This method is valid for sockets that use the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\" data-throw-if-not-resolved=\"false\"></xref> flag or the <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\" data-throw-if-not-resolved=\"false\"></xref> flag.</p>\n"
  seealso:
  - type: System.Net.Sockets.TcpListener
    commentId: T:System.Net.Sockets.TcpListener
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Net.Sockets.TcpClient.ConnectAsync(System.Net.IPAddress(), System.Int32)
  name.vb: ConnectAsync(IPAddress(), Int32)
- uid: System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)
  commentId: M:System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)
  id: ConnectAsync(System.String,System.Int32)
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: ConnectAsync(String, Int32)
  fullName: System.Net.Sockets.TcpClient.ConnectAsync(System.String, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ConnectAsync
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 433
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Connects the client to the specified TCP port on the specified host as an asynchronous operation.</p>\n"
  remarks: "\n<p>This operation will not block. The returned Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref>  object will complete after the TCP connection has been established. This method does not block the calling thread while the connection request is underway.</p>\n<p>Call this method to establish a synchronous remote host connection to the specified host name and port number as an asynchronous operation. After connecting with the remote host, use the <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> method to obtain the underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>. Use this <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> to send and receive data.</p>\n<p>If IPv6 is enabled and the <xref href=\"System.Net.Sockets.TcpClient.ConnectAsync(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: public Task ConnectAsync(string host, int port)
    content.vb: Public Function ConnectAsync(host As String, port As Integer) As Task
    parameters:
    - id: host
      type: System.String
      description: "\n<p>The DNS name of the remote host to which you intend to connect. </p>\n"
    - id: port
      type: System.Int32
      description: "\n<p>The port number of the remote host to which you intend to connect. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>hostname</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>port</em> parameter is not between <xref href=\"System.Net.IPEndPoint.MinPort\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.IPEndPoint.MaxPort\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.Net.Sockets.SocketException
    commentId: T:System.Net.Sockets.SocketException
    description: "\n<p>An error occurred when accessing the socket. See the Remarks section for more information. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>\n<xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
    commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
  - type: System.Net.Sockets.TcpClient.GetStream
    commentId: M:System.Net.Sockets.TcpClient.GetStream
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.Dispose
  commentId: M:System.Net.Sockets.TcpClient.Dispose
  id: Dispose
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Net.Sockets.TcpClient.Dispose()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 434
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Releases the managed and unmanaged resources used by the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Sockets.TcpClient.Dispose(System.Boolean)
  commentId: M:System.Net.Sockets.TcpClient.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Net.Sockets.TcpClient.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 435
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> and optionally releases the managed resources.</p>\n"
  remarks: "\n<p>This method is called by the public <strong>Dispose()</strong> method and the <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method. <strong>Dispose()</strong> invokes this method with the <em>disposing</em> parameter set to <strong>true</strong>. <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> invokes this method with <em>disposing</em> set to <strong>false</strong>.</p>\n<p>When the <em>disposing</em> parameter is <strong>true</strong>, this method releases all resources held by any managed objects that this <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> references. It does this by invoking the <strong>Dispose()</strong> method of each referenced object.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  syntax:
    content: protected virtual void Dispose(bool disposing)
    content.vb: Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
      description: "\n<p>Set to <strong>true</strong> to release both managed and unmanaged resources; <strong>false</strong> to release only unmanaged resources. </p>\n"
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Net.Sockets.TcpClient.Finalize
  commentId: M:System.Net.Sockets.TcpClient.Finalize
  id: Finalize
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: Finalize()
  fullName: System.Net.Sockets.TcpClient.Finalize()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Finalize
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 436
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Frees resources used by the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>This method overrides <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref>. Application code should not call this method; an object's <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref href=\"System.GC.SuppressFinalize(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> class finalizer closes the TCP connection and releases all managed resources associated with the <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref>. These resources include the underlying <xref href=\"System.Net.Sockets.Socket\" data-throw-if-not-resolved=\"false\"></xref> used for connecting with the remote host, and the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> used to send and receive data. The finalizer does not release any unmanaged resources.</p>\n<p>For more information, see Finalize Methods and Destructors, Cleaning Up Unmanaged Resources, and Overriding the Finalize Method.</p>\n"
  syntax:
    content: protected void Finalize()
    content.vb: Protected Sub Finalize
  seealso:
  - type: System.Net.Sockets.TcpClient.Close
    commentId: M:System.Net.Sockets.TcpClient.Close
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Net.Sockets.TcpClient.GetStream
  commentId: M:System.Net.Sockets.TcpClient.GetStream
  id: GetStream
  parent: System.Net.Sockets.TcpClient
  langs:
  - csharp
  - vb
  name: GetStream()
  fullName: System.Net.Sockets.TcpClient.GetStream()
  type: Method
  source:
    remote:
      path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetStream
    path: src/System.Net.Sockets/ref/System.Net.Sockets.cs
    startLine: 437
  assemblies:
  - System.Net.Sockets
  namespace: System.Net.Sockets
  summary: "\n<p>Returns the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> used to send and receive data.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> returns a <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> that you can use to send and receive data. The <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> class inherits from the <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> class, which provides a rich collection of methods and properties used to facilitate network communications.</p>\n<p>You must call the <xref href=\"System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method first, or the <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> method will throw an <xref href=\"System.InvalidOperationException\" data-throw-if-not-resolved=\"false\"></xref>. After you have obtained the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>, call the <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to send data to the remote host. Call the <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to receive data arriving from the remote host. Both of these methods block until the specified operation is performed. You can avoid blocking on a read operation by checking the <xref href=\"System.Net.Sockets.NetworkStream.DataAvailable\" data-throw-if-not-resolved=\"false\"></xref> property. A <strong>true</strong> value means that data has arrived from the remote host and is available for reading. In this case, <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is guaranteed to complete immediately. If the remote host has shutdown its connection, <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> will immediately return with zero bytes.</p>\n<p>You must close the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref> when you are through sending and receiving data. Closing <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> does not release the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If you receive a <xref href=\"System.Net.Sockets.SocketException\" data-throw-if-not-resolved=\"false\"></xref>, use <xref href=\"System.Net.Sockets.SocketException.ErrorCode\" data-throw-if-not-resolved=\"false\"></xref> to obtain the specific error code. After you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n<p>This member outputs trace information when you enable network tracing in your application. For more information, see Network Tracing in the .NET Framework.</p>\n"
  example:
  - "\n<p>The following code example uses <xref href=\"System.Net.Sockets.TcpClient.GetStream\" data-throw-if-not-resolved=\"false\"></xref> to obtain the underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>. After obtaining the <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>, it sends and receives using its <xref href=\"System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>ClassicTcpClient.PublicMethodsAndPropertiesExample#14"
  syntax:
    content: public NetworkStream GetStream()
    content.vb: Public Function GetStream As NetworkStream
    return:
      type: System.Net.Sockets.NetworkStream
      description: "\n<p>The underlying <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> is not connected to a remote host. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Net.Sockets.TcpClient\" data-throw-if-not-resolved=\"false\"></xref> has been closed. </p>\n"
  seealso:
  - type: System.Net.Sockets.NetworkStream
    commentId: T:System.Net.Sockets.NetworkStream
  - type: System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)
  - type: System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
    commentId: M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)
  - type: System.Net.Sockets.NetworkStream.DataAvailable
    commentId: P:System.Net.Sockets.NetworkStream.DataAvailable
  - type: System.IO.Stream
    commentId: T:System.IO.Stream
  - type: System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
    commentId: M:System.Net.Sockets.TcpClient.Connect(System.String,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Net.Sockets
  isExternal: false
  name: System.Net.Sockets
  fullName: System.Net.Sockets
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Net.Sockets.AddressFamily
  parent: System.Net.Sockets
  isExternal: false
  name: AddressFamily
  fullName: System.Net.Sockets.AddressFamily
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Net.Sockets.Socket
  parent: System.Net.Sockets
  isExternal: false
  name: Socket
  fullName: System.Net.Sockets.Socket
- uid: System.Net.Sockets.LingerOption
  parent: System.Net.Sockets
  isExternal: false
  name: LingerOption
  fullName: System.Net.Sockets.LingerOption
- uid: System.Net.IPAddress
  parent: System.Net
  isExternal: false
  name: IPAddress
  fullName: System.Net.IPAddress
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Net
  isExternal: false
  name: System.Net
  fullName: System.Net
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Net.IPAddress[]
  isExternal: false
  name: IPAddress[]
  fullName: System.Net.IPAddress[]
  fullname.vb: System.Net.IPAddress()
  name.vb: IPAddress()
  spec.csharp:
  - uid: System.Net.IPAddress
    name: IPAddress
    fullName: System.Net.IPAddress
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Net.IPAddress
    name: IPAddress
    fullName: System.Net.IPAddress
  - name: ()
    fullName: ()
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Net.Sockets.NetworkStream
  parent: System.Net.Sockets
  isExternal: false
  name: NetworkStream
  fullName: System.Net.Sockets.NetworkStream
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.Net.Sockets.SocketException
  isExternal: false
  name: SocketException
  fullName: System.Net.Sockets.SocketException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.Security.SecurityException
  isExternal: false
  name: SecurityException
  fullName: System.Security.SecurityException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
