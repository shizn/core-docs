items:
- uid: System.Array
  commentId: T:System.Array
  id: Array
  parent: System
  children:
  - System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)
  - System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  - System.Array.BinarySearch(System.Array,System.Object)
  - System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)
  - System.Array.BinarySearch``1(``0[],``0)
  - System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})
  - System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)
  - System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})
  - System.Array.Clear(System.Array,System.Int32,System.Int32)
  - System.Array.Clone
  - System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  - System.Array.Copy(System.Array,System.Array,System.Int32)
  - System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  - System.Array.CopyTo(System.Array,System.Int32)
  - System.Array.CreateInstance(System.Type,System.Int32)
  - System.Array.CreateInstance(System.Type,System.Int32[])
  - System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])
  - System.Array.Empty``1
  - System.Array.Exists``1(``0[],System.Predicate{``0})
  - System.Array.Find``1(``0[],System.Predicate{``0})
  - System.Array.FindAll``1(``0[],System.Predicate{``0})
  - System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  - System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})
  - System.Array.FindIndex``1(``0[],System.Predicate{``0})
  - System.Array.FindLast``1(``0[],System.Predicate{``0})
  - System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  - System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})
  - System.Array.FindLastIndex``1(``0[],System.Predicate{``0})
  - System.Array.GetEnumerator
  - System.Array.GetLength(System.Int32)
  - System.Array.GetLowerBound(System.Int32)
  - System.Array.GetUpperBound(System.Int32)
  - System.Array.GetValue(System.Int32)
  - System.Array.GetValue(System.Int32[])
  - System.Array.IndexOf(System.Array,System.Object)
  - System.Array.IndexOf(System.Array,System.Object,System.Int32)
  - System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)
  - System.Array.IndexOf``1(``0[],``0)
  - System.Array.IndexOf``1(``0[],``0,System.Int32)
  - System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)
  - System.Array.Initialize
  - System.Array.LastIndexOf(System.Array,System.Object)
  - System.Array.LastIndexOf(System.Array,System.Object,System.Int32)
  - System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)
  - System.Array.LastIndexOf``1(``0[],``0)
  - System.Array.LastIndexOf``1(``0[],``0,System.Int32)
  - System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)
  - System.Array.Length
  - System.Array.Rank
  - System.Array.Resize``1(``0[]@,System.Int32)
  - System.Array.Reverse(System.Array)
  - System.Array.Reverse(System.Array,System.Int32,System.Int32)
  - System.Array.SetValue(System.Object,System.Int32)
  - System.Array.SetValue(System.Object,System.Int32[])
  - System.Array.Sort(System.Array)
  - System.Array.Sort(System.Array,System.Array)
  - System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)
  - System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)
  - System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  - System.Array.Sort(System.Array,System.Collections.IComparer)
  - System.Array.Sort(System.Array,System.Int32,System.Int32)
  - System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  - System.Array.Sort``1(``0[])
  - System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})
  - System.Array.Sort``1(``0[],System.Comparison{``0})
  - System.Array.Sort``1(``0[],System.Int32,System.Int32)
  - System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  - System.Array.Sort``2(``0[],``1[])
  - System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})
  - System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)
  - System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  - System.Array.System#Collections#ICollection#Count
  - System.Array.System#Collections#ICollection#IsSynchronized
  - System.Array.System#Collections#ICollection#SyncRoot
  - System.Array.System#Collections#IList#Add(System.Object)
  - System.Array.System#Collections#IList#Clear
  - System.Array.System#Collections#IList#Contains(System.Object)
  - System.Array.System#Collections#IList#IndexOf(System.Object)
  - System.Array.System#Collections#IList#Insert(System.Int32,System.Object)
  - System.Array.System#Collections#IList#IsFixedSize
  - System.Array.System#Collections#IList#IsReadOnly
  - System.Array.System#Collections#IList#Item(System.Int32)
  - System.Array.System#Collections#IList#Remove(System.Object)
  - System.Array.System#Collections#IList#RemoveAt(System.Int32)
  - System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)
  - System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)
  - System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)
  - System.Array.TrueForAll``1(``0[],System.Predicate{``0})
  langs:
  - csharp
  - vb
  name: Array
  fullName: System.Array
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Array
    path: src/mscorlib/src/System/Array.cs
    startLine: 26
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</p>\n<p>To browse the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf\">Reference Source</see>.</p>\n"
  remarks: "\n<p>To view the .NET Framework source code for this type, see the <see href=\"http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf\">Reference Source</see>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <see href=\"http://referencesource.microsoft.com/\">instructions</see>.</p>\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class is not part of the <xref href=\"System.Collections\" data-throw-if-not-resolved=\"false\"></xref> namespaces. However, it is still considered a collection because it is based on the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface. </p>\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class is the base class for language implementations that support arrays. However, only the system and compilers can derive explicitly from the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class. Users should employ the array constructs provided by the language.</p>\n<p>An element is a value in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The length of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is the total number of elements it can contain. The lower bound of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is the index of its first element. An <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> can have any lower bound, but it has a lower bound of zero by default. A different lower bound can be defined when creating an instance of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class using <xref href=\"System.Array.CreateInstance(System.Type,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.A multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> can have different bounds for each dimension. An array can have a maximum of 32 dimensions. </p>\n<p>Unlike the classes in the <xref href=\"System.Collections\" data-throw-if-not-resolved=\"false\"></xref> namespaces, <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a fixed capacity. To increase the capacity, you must create a new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> object with the required capacity, copy the elements from the old <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> object to the new one, and delete the old <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p></p>\n<p>By default, the maximum size of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is 2 gigabytes (GB). In a 64-bit environment, you can avoid the size restriction by setting the <strong>enabled</strong> attribute of the gcAllowVeryLargeObjects configuration element to <strong>true</strong> in the run-time environment. However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</p>\n<p>Starting with the .NET Framework 2.0, the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class implements the <xref href=\"System.Collections.Generic.IList`1\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Collections.Generic.ICollection`1\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interfaces. The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class. In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations). The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>\n<xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> objects provide information about array type declarations. <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects with the same array type share the same <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n<p>\n<xref href=\"System.Type.IsArray\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Type.GetElementType\" data-throw-if-not-resolved=\"false\"></xref> might not return the expected results with <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> because if an array is cast to the type <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>, the result is an object, not an array. That is, <code>typeof(System.Array).IsArray</code> returns <strong>false</strong>, and <code>typeof(System.Array).GetElementType</code> returns <strong>null</strong>.</p>\n<p>The <xref href=\"System.Array.Copy(System.Array,System.Array,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</p>\n<p>Some methods, such as <xref href=\"System.Array.CreateInstance(System.Type,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Copy(System.Array,System.Array,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.CopyTo(System.Array,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, <see cref=\"Overload:System.Array.GetValue\"></see>, and <see cref=\"Overload:System.Array.SetValue\"></see>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays. <xref href=\"System.Array.LongLength\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetLongLength(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> return 64-bit integers indicating the length of the array.</p>\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is not guaranteed to be sorted.  You must sort the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> prior to performing operations (such as <see cref=\"Overload:System.Array.BinarySearch\"></see>) that require the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to be sorted.</p>\n<p>Using an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> object of pointers in native code is not supported and will throw a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> for several methods.</p>\n"
  example:
  - "\n<p>The following code example shows how <xref href=\"System.Array.Copy(System.Array,System.Array,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> copies elements between an array of type integer and an array of type <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array Example#1<p>The following code example creates and initializes an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> and displays its properties and its elements.</p>Classic Array Example#2"
  syntax:
    content: >-
      [Serializable]

      [ComVisible(true)]

      public abstract class Array : ICloneable, IList, ICollection, IEnumerable, IStructuralComparable, IStructuralEquatable
    content.vb: >-
      <Serializable>

      <ComVisible(True)>

      Public MustInherit Class Array
          Implements ICloneable, IList, ICollection, IEnumerable, IStructuralComparable, IStructuralEquatable
  seealso:
  - type: System.Object
    commentId: T:System.Object
  - type: System.Type
    commentId: T:System.Type
  inheritance:
  - System.Object
  implements:
  - System.Collections.IList
  - System.Collections.ICollection
  - System.Collections.IEnumerable
  - System.Collections.IStructuralComparable
  - System.Collections.IStructuralEquatable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Array.Length
  commentId: P:System.Array.Length
  id: Length
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Length
  fullName: System.Array.Length
  type: Property
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the total number of elements in all the dimensions of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Retrieving the value of this property is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following example uses the\n<xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> property to get the total number of elements in an array. It also uses the\n<xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to determine the number of elements in each dimension of a multidimensional array.\n</p>System.Array.Length#1"
  syntax:
    content: >-
      public int Length

      {
          [SecuritySafeCritical]
          [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
          [MethodImpl(MethodImplOptions.InternalCall)]
          get;
      }
    content.vb: Public ReadOnly Property Length As Integer
    parameters: []
    return:
      type: System.Int32
  exceptions:
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: "\n<p>The array is multidimensional and contains more than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> elements.</p>\n"
  seealso:
  - type: System.Array.GetLength(System.Int32)
    commentId: M:System.Array.GetLength(System.Int32)
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.LongLength
    commentId: P:System.Array.LongLength
  - type: System.Collections.ICollection.Count
    commentId: P:System.Collections.ICollection.Count
  - type: System.Array.Rank
    commentId: P:System.Array.Rank
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Array.Rank
  commentId: P:System.Array.Rank
  id: Rank
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Rank
  fullName: System.Array.Rank
  type: Property
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the rank (number of dimensions) of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on. </p>\n"
  remarks: "\n<p>For example, the Visual Basic code </p>\n<pre><code>Dim TDArray(0,0,0) As Integer</code></pre>\n<p>and the C# code </p>\n<pre><code>int[,,] TDArray = new int[1,1,1];</code></pre>\n<p>create an array of three dimensions with a <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref> property whose value is 3.</p>\n<p>A jagged array (an array of arrays) is a one-dimensional array; the value of its <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref> property is 1.</p>\n<p>Retrieving the value of this property is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref> property of each.</p>System.Array.Rank#1"
  syntax:
    content: >-
      public int Rank

      {
          [SecuritySafeCritical]
          [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
          [MethodImpl(MethodImplOptions.InternalCall)]
          get;
      }
    content.vb: Public ReadOnly Property Rank As Integer
    parameters: []
    return:
      type: System.Int32
  seealso:
  - type: System.Array.Length
    commentId: P:System.Array.Length
  - type: System.Array.GetLength(System.Int32)
    commentId: M:System.Array.GetLength(System.Int32)
  - type: System.Array.LongLength
    commentId: P:System.Array.LongLength
  - type: System.Array.GetLongLength(System.Int32)
    commentId: M:System.Array.GetLongLength(System.Int32)
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Array.System#Collections#ICollection#Count
  commentId: P:System.Array.System#Collections#ICollection#Count
  id: System#Collections#ICollection#Count
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: ICollection.Count
  fullName: System.Array.System.Collections.ICollection.Count
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.ICollection.Count
    path: src/mscorlib/src/System/Array.cs
    startLine: 663
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the number of elements contained in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: int ICollection.Count { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.ICollection.Count As Integer Implements ICollection.Count
    parameters: []
    return:
      type: System.Int32
  implements:
  - System.Collections.ICollection.Count
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.Collections.ICollection.Count
- uid: System.Array.System#Collections#ICollection#IsSynchronized
  commentId: P:System.Array.System#Collections#ICollection#IsSynchronized
  id: System#Collections#ICollection#IsSynchronized
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: ICollection.IsSynchronized
  fullName: System.Array.System.Collections.ICollection.IsSynchronized
  type: Property
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: System.Collections.ICollection.IsSynchronized
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 73
  assemblies:
  - System.Runtime
  namespace: System
  syntax:
    content: bool ICollection.IsSynchronized { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.ICollection.IsSynchronized As Boolean Implements ICollection.IsSynchronized
    parameters: []
    return:
      type: System.Boolean
  implements:
  - System.Collections.ICollection.IsSynchronized
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.Collections.ICollection.IsSynchronized
- uid: System.Array.System#Collections#ICollection#SyncRoot
  commentId: P:System.Array.System#Collections#ICollection#SyncRoot
  id: System#Collections#ICollection#SyncRoot
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: ICollection.SyncRoot
  fullName: System.Array.System.Collections.ICollection.SyncRoot
  type: Property
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: System.Collections.ICollection.SyncRoot
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 74
  assemblies:
  - System.Runtime
  namespace: System
  syntax:
    content: object ICollection.SyncRoot { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.ICollection.SyncRoot As Object Implements ICollection.SyncRoot
    parameters: []
    return:
      type: System.Object
  implements:
  - System.Collections.ICollection.SyncRoot
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.Collections.ICollection.SyncRoot
- uid: System.Array.System#Collections#IList#IsFixedSize
  commentId: P:System.Array.System#Collections#IList#IsFixedSize
  id: System#Collections#IList#IsFixedSize
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.IsFixedSize
  fullName: System.Array.System.Collections.IList.IsFixedSize
  type: Property
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: System.Collections.IList.IsFixedSize
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 75
  assemblies:
  - System.Runtime
  namespace: System
  syntax:
    content: bool IList.IsFixedSize { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.IList.IsFixedSize As Boolean Implements IList.IsFixedSize
    parameters: []
    return:
      type: System.Boolean
  implements:
  - System.Collections.IList.IsFixedSize
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.Collections.IList.IsFixedSize
- uid: System.Array.System#Collections#IList#IsReadOnly
  commentId: P:System.Array.System#Collections#IList#IsReadOnly
  id: System#Collections#IList#IsReadOnly
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.IsReadOnly
  fullName: System.Array.System.Collections.IList.IsReadOnly
  type: Property
  source:
    remote:
      path: src/System.Runtime/ref/System.Runtime.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: System.Collections.IList.IsReadOnly
    path: src/System.Runtime/ref/System.Runtime.cs
    startLine: 76
  assemblies:
  - System.Runtime
  namespace: System
  syntax:
    content: bool IList.IsReadOnly { get; }
    content.vb: ReadOnly WriteOnly Property System.Collections.IList.IsReadOnly As Boolean Implements IList.IsReadOnly
    parameters: []
    return:
      type: System.Boolean
  implements:
  - System.Collections.IList.IsReadOnly
  modifiers.csharp:
  - get
  modifiers.vb:
  - ReadOnly
  name.vb: System.Collections.IList.IsReadOnly
- uid: System.Array.System#Collections#IList#Item(System.Int32)
  commentId: P:System.Array.System#Collections#IList#Item(System.Int32)
  id: System#Collections#IList#Item(System.Int32)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Item[Int32]
  fullName: System.Array.System.Collections.IList.Item[System.Int32]
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.this[]
    path: src/mscorlib/src/System/Array.cs
    startLine: 688
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets or sets the element at the specified index.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an<xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: object IList.this[int index] { get; set; }
    content.vb: ReadOnly WriteOnly Property System.Collections.IList.Item(index As Integer) As Object Implements IList.this
    parameters:
    - id: index
      type: System.Int32
    return:
      type: System.Object
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>index</em> is equal to or greater than <xref href=\"System.Collections.ICollection.Count\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not have exactly one dimension.</p>\n"
  implements:
  - System.Collections.IList.Item(System.Int32)
  modifiers.csharp:
  - get
  - set
  fullName.vb: System.Array.System.Collections.IList.Item(System.Int32)
  name.vb: System.Collections.IList.Item(Int32)
- uid: System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)
  commentId: M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)
  id: BinarySearch(System.Array,System.Int32,System.Int32,System.Object)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch(Array, Int32, Int32, Object)
  fullName: System.Array.BinarySearch(System.Array, System.Int32, System.Int32, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 846
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches a range of elements in a one-dimensional sorted array for a value, using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface implemented by each element of the array and by the specified value.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>Either <em>value</em> or every element of <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, which is used for comparisons. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>If <em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, the elements of <em>array</em> are not tested for <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> before the search begins. An exception is thrown if the search encounters an element that does not implement <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>   For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch(Array array, int index, int length, object value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(array As Array, index As Integer, length As Integer, value As Object) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: value
      type: System.Object
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, and the search encounters an element that does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  commentId: M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  id: BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch(Array, Int32, Int32, Object, IComparer)
  fullName: System.Array.BinarySearch(System.Array, System.Int32, System.Int32, System.Object, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 891
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>The comparer customizes how the elements are compared. For example, you can use a <xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref> as the comparer to perform case-insensitive string searches.</p>\n<p>If <em>comparer</em> is not <strong>null</strong>, the elements of <em>array</em> are compared to the specified value using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by <em>comparer</em>; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, the comparison is done using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation provided by the element itself or by the specified value. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong> and <em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, the elements of <em>array</em> are not tested for <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> before the search begins. An exception is thrown if the search encounters an element that does not implement <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception when using <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(array As Array, index As Integer, length As Integer, value As Object, comparer As IComparer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: value
      type: System.Object
    - id: comparer
      type: System.Collections.IComparer
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, <em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, and the search encounters an element that does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.BinarySearch(System.Array,System.Object)
  commentId: M:System.Array.BinarySearch(System.Array,System.Object)
  id: BinarySearch(System.Array,System.Object)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch(Array, Object)
  fullName: System.Array.BinarySearch(System.Array, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 822
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches an entire one-dimensional sorted array for a specific element, using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface implemented by each element of the array and by the specified object.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>Either <em>value</em> or every element of <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, which is used for comparisons. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>If<em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, the elements of <em>array</em> are not tested for <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> before the search begins. An exception is thrown if the search encounters an element that does not implement <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>   For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to use <see cref=\"Overload:System.Array.BinarySearch\"></see> to locate a specific object in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The array is created with its elements in ascending sort order. The <see cref=\"Overload:System.Array.BinarySearch\"></see> method requires the array to be sorted in ascending order.</p>Classic Array.BinarySearch Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch(Array array, object value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(array As Array, value As Object) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, and the search encounters an element that does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)
  commentId: M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)
  id: BinarySearch(System.Array,System.Object,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch(Array, Object, IComparer)
  fullName: System.Array.BinarySearch(System.Array, System.Object, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 866
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches an entire one-dimensional sorted array for a value using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is one greater than the upper bound of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>The comparer customizes how the elements are compared. For example, you can use a <xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref> as the comparer to perform case-insensitive string searches.</p>\n<p>If <em>comparer</em> is not <strong>null</strong>, the elements of <em>array</em> are compared to the specified value using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by <em>comparer</em>; otherwise, the result might be incorrect.</p>\n<p>If<em>comparer</em> is <strong>null</strong>, the comparison is done using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation provided by the element itself or by the specified value. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong> and <em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, the elements of <em>array</em> are not tested for <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> before the search begins. An exception is thrown if the search encounters an element that does not implement <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch(Array array, object value, IComparer comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(array As Array, value As Object, comparer As IComparer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    - id: comparer
      type: System.Collections.IComparer
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, <em>value</em> does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface, and the search encounters an element that does not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.BinarySearch``1(``0[],``0)
  commentId: M:System.Array.BinarySearch``1(``0[],``0)
  id: BinarySearch``1(``0[],``0)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch<T>(T[], T)
  fullName: System.Array.BinarySearch<T>(T[], T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 966
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches an entire one-dimensional sorted array for a specific element, using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implemented by each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> and by the specified object.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If <em>array</em> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is equal to the size of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>\n<em>T</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface, which is used for comparisons. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``1(``0[])\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload. An array of strings is created, in no particular order. </p>\n<p>The array is displayed, sorted, and displayed again. Arrays must be sorted in order to use the <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>\n<p>The <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is then used to search for two strings, one that is not in the array and one that is. The array and the return value of the <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method are passed to the <code>ShowWhere</code> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array. The index is negative if the string is not in the array, so the <code>ShowWhere</code> method takes the bitwise complement (the ~ operator in C# and Visual C++, <strong>Xor</strong>-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</p>Array_SortSearch#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch<T>(T[] array, T value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(Of T)(array As T(), value As T) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>T</em> does not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.BinarySearch(Of T)(T(), T)
  name.vb: BinarySearch(Of T)(T(), T)
- uid: System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})
  id: BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch<T>(T[], T, IComparer<T>)
  fullName: System.Array.BinarySearch<T>(T[], T, System.Collections.Generic.IComparer<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 975
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches an entire one-dimensional sorted array for a value using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result to produce an index. If this index is equal to the size of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>The comparer customizes how the elements are compared. For example, you can use a <xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref> as the comparer to perform case-insensitive string searches.</p>\n<p>If <em>comparer</em> is not <strong>null</strong>, the elements of <em>array</em> are compared to the specified value using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by <em>comparer</em>; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, the comparison is done using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation provided by <em>T</em>. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong> and <em>value</em> does not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface, the elements of <em>array</em> are not tested for <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> before the search begins. An exception is thrown if the search encounters an element that does not implement <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example demonstrates the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload. </p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The array is displayed, sorted, and displayed again. Arrays must be sorted in order to use the<xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>\n<p>The <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is then used to search for two strings, one that is not in the array and one that is. The array and the return value of the <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> method are passed to the <code>ShowWhere</code> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array. The index is negative if the string is not n the array, so the <code>ShowWhere</code>method takes the bitwise complement (the ~ operator in C# and Visual C++, <strong>Xor</strong> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</p>Array_SortSearchComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch<T>(T[] array, T value, IComparer<T> comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(Of T)(array As T(), value As T, comparer As IComparer(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    - id: comparer
      type: System.Collections.Generic.IComparer{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>T</em> does not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.BinarySearch(Of T)(T(), T, System.Collections.Generic.IComparer(Of T))
  name.vb: BinarySearch(Of T)(T(), T, IComparer(Of T))
- uid: System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)
  commentId: M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)
  id: BinarySearch``1(``0[],System.Int32,System.Int32,``0)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch<T>(T[], Int32, Int32, T)
  fullName: System.Array.BinarySearch<T>(T[], System.Int32, System.Int32, T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 984
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches a range of elements in a one-dimensional sorted array for a value, using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implemented by each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> and by the specified value.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the array does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is equal to the size of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>\n<em>T</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface, which is used for comparisons. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch<T>(T[] array, int index, int length, T value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(Of T)(array As T(), index As Integer, length As Integer, value As T) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: value
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>T</em> does not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.BinarySearch(Of T)(T(), System.Int32, System.Int32, T)
  name.vb: BinarySearch(Of T)(T(), Int32, Int32, T)
- uid: System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})
  id: BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: BinarySearch<T>(T[], Int32, Int32, T, IComparer<T>)
  fullName: System.Array.BinarySearch<T>(T[], System.Int32, System.Int32, T, System.Collections.Generic.IComparer<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: BinarySearch
    path: src/mscorlib/src/System/Array.cs
    startLine: 990
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches a range of elements in a one-dimensional sorted array for a value, using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>This method does not support searching arrays that contain negative indexes. <em>array</em> must be sorted before calling this method.</p>\n<p>If the array does not contain the specified value, the method returns a negative integer. You can apply the bitwise complement operator (~ in C#, <strong>Not</strong> in Visual Basic) to the negative result  to produce an index. If this index is equal to the size of the array, there are no elements larger than <em>value</em> in the array. Otherwise, it is the index of the first element that is larger than <em>value</em>. </p>\n<p>The comparer customizes how the elements are compared. For example, you can use a <xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref> as the comparer to perform case-insensitive string searches.</p>\n<p>If <em>comparer</em> is not <strong>null</strong>, the elements of <em>array</em> are compared to the specified value using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by <em>comparer</em>; otherwise, the result might be incorrect.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, the comparison is done using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation provided for type <em>T</em>. The elements of <em>array</em> must already be sorted in increasing value according to the sort order defined by the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation; otherwise, the result might be incorrect.</p>\n<p>Duplicate elements are allowed. If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> contains more than one element equal to <em>value</em>, the method returns the index of only one of the occurrences, and not necessarily the first one.</p>\n<p>\n<strong>null</strong> can always be compared with any other reference type; therefore, comparisons with <strong>null</strong> do not generate an exception when using <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>For every element tested, <em>value</em> is passed to the appropriate <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation, even if <em>value</em> is <strong>null</strong>. That is, the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> implementation determines how a given element compares to <strong>null</strong>.</p>\n<p>This method is an O(log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int BinarySearch<T>(T[] array, int index, int length, T value, IComparer<T> comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function BinarySearch(Of T)(array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: value
      type: '{T}'
    - id: comparer
      type: System.Collections.Generic.IComparer{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>value</em> is of a type that is not compatible with the elements of <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and <em>T</em> does not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.BinarySearch(Of T)(T(), System.Int32, System.Int32, T, System.Collections.Generic.IComparer(Of T))
  name.vb: BinarySearch(Of T)(T(), Int32, Int32, T, IComparer(Of T))
- uid: System.Array.Clear(System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.Clear(System.Array,System.Int32,System.Int32)
  id: Clear(System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Clear(Array, Int32, Int32)
  fullName: System.Array.Clear(System.Array, System.Int32, System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sets a range of elements in an array to the default value of each element type.</p>\n"
  remarks: "\n<p>This method resets each element in an array to the element type's default value. It sets elements of reference types (including <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> elements) to <strong>null</strong>, and sets elements of value types to the default values shown in the following table.</p>\n<p>Type</p>\n<p>Value</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<strong>false</strong>\n</p>\n</td></tr><tr><td>\n<p>All integral and floating point numeric types </p>\n</td><td>\n<p>0 (zero)</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.DateTime\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>\n<xref href=\"System.DateTime.MinValue\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td></tr><tr><td>\n<p>Other value types </p>\n</td><td>\n<p>Default value of the type's fields </p>\n</td></tr></tbody></table>\n<p>The range of cleared elements wrap from row to row in a multi-dimensional array.</p>\n<p>This method only clears the values of the elements; it does not delete the elements themselves. An array has a fixed size; therefore, elements cannot be added or removed.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Array.Clear(System.Array,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</p>System.Array.Clear#1"
  - "\n<p>The following example defines a <code>TimeZoneTime</code> structure that includes a <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> field and a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> field. It then calls the <xref href=\"System.Array.Clear(System.Array,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to clear one element in a two-element array of <code>TimeZoneTime</code> values. The method sets the value of the cleared element to the default value of a <xref href=\"System.TimeZoneInfo\" data-throw-if-not-resolved=\"false\"></xref> object, which is <strong>null</strong>, and the default value of a <xref href=\"System.DateTimeOffset\" data-throw-if-not-resolved=\"false\"></xref> object, which is <xref href=\"System.DateTimeOffset.MinValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>System.Array.Clear#2"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static void Clear(Array array, int index, int length)
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Sub Clear(array As Array, index As Integer, length As Integer)
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n<p>-or-</p>\n<p>The sum of <em>index</em> and <em>length</em> is greater than the size of <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Clone
  commentId: M:System.Array.Clone
  id: Clone
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Clone()
  fullName: System.Array.Clone()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Clone
    path: src/mscorlib/src/System/Array.cs
    startLine: 730
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates a shallow copy of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>A shallow copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> copies only the elements of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>, whether they are reference types or value types, but it does not copy the objects that the references refer to. The references in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> point to the same objects that the references in the original <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> point to.</p>\n<p>In contrast, a deep copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> copies the elements and everything directly or indirectly referenced by the elements.</p>\n<p>The clone is of the same <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> as the original <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example clones a <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref> array and demonstrates the behavior of a shallow copy.</p>System.Array.Clone#1"
  syntax:
    content: public object Clone()
    content.vb: Public Function Clone As Object
    return:
      type: System.Object
  seealso:
  - type: System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
    commentId: M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  id: ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: ConstrainedCopy(Array, Int32, Array, Int32, Int32)
  fullName: System.Array.ConstrainedCopy(System.Array, System.Int32, System.Array, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ConstrainedCopy
    path: src/mscorlib/src/System/Array.cs
    startLine: 305
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Copies a range of elements from an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the specified source index and pastes them to another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the specified destination index.  Guarantees that all changes are undone if the copy does not succeed completely.</p>\n"
  remarks: "\n<p>The <em>sourceArray</em> and <em>destinationArray</em> parameters must have the same number of dimensions.  The <em>sourceArray</em> type must be the same as or derived from the <em>destinationArray</em> type; otherwise, an <xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.  Unlike <see cref=\"Overload:System.Array.Copy\"></see>, <xref href=\"System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> verifies the compatibility of the array types before performing any operation.</p>\n<p>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column). To start copying from the second element of the third row (or column), <em>sourceIndex</em> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</p>\n<p>If <em>sourceArray</em> and <em>destinationArray</em> overlap, this method behaves as if the original values of <em>sourceArray</em> were preserved in a temporary location before <em>destinationArray</em> is overwritten.</p>\n<p>[C++]</p>\n<p>This method is equivalent to the standard C/C++ function <strong>memmove</strong>, not <strong>memcpy</strong>.</p>\n<p>The arrays can be reference-type arrays or value-type arrays.  If <em>sourceArray</em> and <em>destinationArray</em> are both reference-type arrays or are both arrays of type <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, a shallow copy is performed. A shallow copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is a new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> containing references to the same elements as the original <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> copies the elements and everything directly or indirectly referenced by the elements.</p>\n<p>If this method throws an exception while copying, the <em>destinationArray</em> remains unchanged; therefore, <xref href=\"System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> can be used within a constrained execution region (<xref href=\"System.Runtime.ConstrainedExecution.Cer\" data-throw-if-not-resolved=\"false\"></xref>).</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Sub ConstrainedCopy(sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)
    parameters:
    - id: sourceArray
      type: System.Array
    - id: sourceIndex
      type: System.Int32
    - id: destinationArray
      type: System.Array
    - id: destinationIndex
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>sourceArray</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>destinationArray</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>sourceArray</em> and <em>destinationArray</em> have different ranks.</p>\n"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "\n<p>The <em>sourceArray</em> type is neither the same as nor derived from the <em>destinationArray</em> type.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>At least one element in <em>sourceArray</em> cannot be cast to the type of <em>destinationArray</em>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>sourceIndex</em> is less than the lower bound of the first dimension of <em>sourceArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>destinationIndex</em> is less than the lower bound of the first dimension of <em>destinationArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>length</em> is greater than the number of elements from <em>sourceIndex</em> to the end of <em>sourceArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is greater than the number of elements from <em>destinationIndex</em> to the end of <em>destinationArray</em>.</p>\n"
  seealso:
  - type: System.Array.Clone
    commentId: M:System.Array.Clone
  - type: System.Runtime.ConstrainedExecution.ReliabilityContractAttribute
    commentId: T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute
  - type: System.Runtime.ConstrainedExecution.Cer
    commentId: T:System.Runtime.ConstrainedExecution.Cer
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Copy(System.Array,System.Array,System.Int32)
  commentId: M:System.Array.Copy(System.Array,System.Array,System.Int32)
  id: Copy(System.Array,System.Array,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Copy(Array, Array, Int32)
  fullName: System.Array.Copy(System.Array, System.Array, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Copy
    path: src/mscorlib/src/System/Array.cs
    startLine: 262
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Copies a range of elements from an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the first element and pastes them into another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the first element. The length is specified as a 32-bit integer.</p>\n"
  remarks: "\n<p>The <em>sourceArray</em> and <em>destinationArray</em> parameters must have the same number of dimensions. In addition, <em>destinationArray</em> must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data. </p>\n<p>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</p>\n<p>If <em>sourceArray</em> and <em>destinationArray</em> overlap, this method behaves as if the original values of <em>sourceArray</em> were preserved in a temporary location before <em>destinationArray</em> is overwritten.</p>\n<p>[C++]</p>\n<p>This method is equivalent to the standard C/C++ function <strong>memmove</strong>, not <strong>memcpy</strong>.</p>\n<p>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</p>\n<ul><li>\n<p>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</p>\n</li><li>\n<p>When copying from a reference-type or value-type array to an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> array, an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is created to hold each value or reference and then copied. When copying from an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> array to a reference-type or value-type array and the assignment is not possible, an <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n</li><li>\n<p>If <em>sourceArray</em> and <em>destinationArray</em> are both reference-type arrays or are both arrays of type <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, a shallow copy is performed. A shallow copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is a new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> containing references to the same elements as the original <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> copies the elements and everything directly or indirectly referenced by the elements.</p>\n</li></ul>\n<p>An <xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </p>\n<ul><li>\n<p>A type is compatible with itself.</p>\n</li><li>\n<p>A value type is compatible with <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</p>\n</li><li>\n<p>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <xref href=\"System.Convert\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>A nonintrinsic (user-defined) value type is compatible only with itself.</p>\n</li><li>\n<p>Enumerations have an implicit conversion to <xref href=\"System.Enum\" data-throw-if-not-resolved=\"false\"></xref> and to their underlying type.</p>\n</li></ul>\n<p>If every element in <em>sourceArray</em> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <em>destinationArray</em>, an <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If this method throws an exception while copying, the state of <em>destinationArray</em> is undefined.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Copy(Array sourceArray, Array destinationArray, int length)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Copy(sourceArray As Array, destinationArray As Array, length As Integer)
    parameters:
    - id: sourceArray
      type: System.Array
    - id: destinationArray
      type: System.Array
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>sourceArray</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>destinationArray</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>sourceArray</em> and <em>destinationArray</em> have different ranks.</p>\n"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "\n<p>\n<em>sourceArray</em> and <em>destinationArray</em> are of incompatible types.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>At least one element in <em>sourceArray</em> cannot be cast to the type of <em>destinationArray</em>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>length</em> is greater than the number of elements in <em>sourceArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is greater than the number of elements in <em>destinationArray</em>.</p>\n"
  seealso:
  - type: System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
    commentId: M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  - type: System.Array.Clone
    commentId: M:System.Array.Clone
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  id: Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Copy(Array, Int32, Array, Int32, Int32)
  fullName: System.Array.Copy(System.Array, System.Int32, System.Array, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Copy
    path: src/mscorlib/src/System/Array.cs
    startLine: 284
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Copies a range of elements from an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the specified source index and pastes them to another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> starting at the specified destination index. The length and the indexes are specified as 32-bit integers.</p>\n"
  remarks: "\n<p>The <em>sourceArray</em> and <em>destinationArray</em> parameters must have the same number of dimensions. In addition, <em>destinationArray</em> must already have been dimensioned and must have a sufficient number of elements starting from the <em>destinationIndex</em> position to accommodate the copied data. </p>\n<p>When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end. For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column). To start copying from the second element of the third row (or column), <em>sourceIndex</em> must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</p>\n<p>If <em>sourceArray</em> and <em>destinationArray</em> overlap, this method behaves as if the original values of <em>sourceArray</em> were preserved in a temporary location before <em>destinationArray</em> is overwritten.</p>\n<p>[C++]</p>\n<p>This method is equivalent to the standard C/C++ function <strong>memmove</strong>, not <strong>memcpy</strong>.</p>\n<p>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</p>\n<ul><li>\n<p>When copying from a reference-type array to a value-type array, each element is unboxed and then copied. When copying from a value-type array to a reference-type array, each element is boxed and then copied.</p>\n</li><li>\n<p>When copying from a reference-type or value-type array to an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> array, an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> is created to hold each value or reference and then copied. When copying from an <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> array to a reference-type or value-type array and the assignment is not possible, an <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n</li><li>\n<p>If <em>sourceArray</em> and <em>destinationArray</em> are both reference-type arrays or are both arrays of type <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>, a shallow copy is performed. A shallow copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is a new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> containing references to the same elements as the original <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The elements themselves or anything referenced by the elements are not copied. In contrast, a deep copy of an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> copies the elements and everything directly or indirectly referenced by the elements.</p>\n</li></ul>\n<p>An <xref href=\"System.ArrayTypeMismatchException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the arrays are of incompatible types. Type compatibility is defined as follows: </p>\n<ul><li>\n<p>A type is compatible with itself.</p>\n</li><li>\n<p>A value type is compatible with <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> and with an interface type implemented by that value type. A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</p>\n</li><li>\n<p>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion. A widening conversion never loses information, whereas a narrowing conversion can lose information. For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion. For more information about conversions, see <xref href=\"System.Convert\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n</li><li>\n<p>A nonintrinsic (user-defined) value type is compatible only with itself.</p>\n</li><li>\n<p>Enumerations have an implicit conversion to <xref href=\"System.Enum\" data-throw-if-not-resolved=\"false\"></xref> and to their underlying type.</p>\n</li></ul>\n<p>If every element in <em>sourceArray</em> requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in <em>destinationArray</em>, an <xref href=\"System.InvalidCastException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>If this method throws an exception while copying, the state of <em>destinationArray</em> is undefined.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to copy from one <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> of type <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> to another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> of type integer.</p>Classic Array.Copy1 Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Copy(sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)
    parameters:
    - id: sourceArray
      type: System.Array
    - id: sourceIndex
      type: System.Int32
    - id: destinationArray
      type: System.Array
    - id: destinationIndex
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>sourceArray</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>destinationArray</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>sourceArray</em> and <em>destinationArray</em> have different ranks.</p>\n"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "\n<p>\n<em>sourceArray</em> and <em>destinationArray</em> are of incompatible types.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>At least one element in <em>sourceArray</em> cannot be cast to the type of <em>destinationArray</em>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>sourceIndex</em> is less than the lower bound of the first dimension of <em>sourceArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>destinationIndex</em> is less than the lower bound of the first dimension of <em>destinationArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>length</em> is greater than the number of elements from <em>sourceIndex</em> to the end of <em>sourceArray</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is greater than the number of elements from <em>destinationIndex</em> to the end of <em>destinationArray</em>.</p>\n"
  seealso:
  - type: System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
    commentId: M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)
  - type: System.Array.Clone
    commentId: M:System.Array.Clone
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.CopyTo(System.Array,System.Int32)
  commentId: M:System.Array.CopyTo(System.Array,System.Int32)
  id: CopyTo(System.Array,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: CopyTo(Array, Int32)
  fullName: System.Array.CopyTo(System.Array, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CopyTo
    path: src/mscorlib/src/System/Array.cs
    startLine: 1030
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index. The index is specified as a 32-bit integer.</p>\n"
  remarks: "\n<p>This method copies all the elements of the current array instance to the <em>array</em> destination array, starting at index <em>index</em>. The <em>array</em> destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements. Otherwise, the method throws an exception. </p>\n<p>This method supports the <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> interface. If implementing <xref href=\"System.Collections.ICollection\" data-throw-if-not-resolved=\"false\"></xref> is not explicitly required, use <xref href=\"System.Array.Copy(System.Array,System.Array,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to avoid an extra indirection.</p>\n<p>If this method throws an exception while copying, the state of <em>array</em> is undefined.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>.It performs a shallow copy only.</p>\n"
  example:
  - "\n<p>The following code example shows how to copy an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.CopyTo Example#1<p>The following code example shows how to copy an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to another <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> with a nonzero lower bound. Note that the entire source <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is copied, including empty elements that overwrite existing elements in the target <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.CopyTo Example#2"
  syntax:
    content: public void CopyTo(Array array, int index)
    content.vb: Public Sub CopyTo(array As Array, index As Integer)
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n<p>-or-</p>\n<p>The number of elements in the source array is greater than the available number of elements from <em>index</em> to the end of the destination <em>array</em>.</p>\n"
  - type: System.ArrayTypeMismatchException
    commentId: T:System.ArrayTypeMismatchException
    description: "\n<p>The type of the source <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> cannot be cast automatically to the type of the destination <em>array</em>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>The source array is multidimensional.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>At least one element in the source <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> cannot be cast to the type of destination <em>array</em>.</p>\n"
  seealso:
  - type: System.Collections.ICollection
    commentId: T:System.Collections.ICollection
  - type: System.Array.Copy(System.Array,System.Array,System.Int32)
    commentId: M:System.Array.Copy(System.Array,System.Array,System.Int32)
  implements:
  - System.Collections.ICollection.CopyTo(System.Array,System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.CreateInstance(System.Type,System.Int32)
  commentId: M:System.Array.CreateInstance(System.Type,System.Int32)
  id: CreateInstance(System.Type,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: CreateInstance(Type, Int32)
  fullName: System.Array.CreateInstance(System.Type, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CreateInstance
    path: src/mscorlib/src/System/Array.cs
    startLine: 66
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates a one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> of the specified <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> and length, with zero-based indexing.</p>\n"
  remarks: "\n<p>Unlike most classes, <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> provides the <see cref=\"Overload:System.Array.CreateInstance\"></see> method, instead of public constructors, to allow for late bound access.</p>\n<p>Reference-type elements are initialized to <strong>null</strong>. Value-type elements are initialized to zero.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to create and initialize a one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.CreateInstance Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static Array CreateInstance(Type elementType, int length)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Function CreateInstance(elementType As Type, length As Integer) As Array
    parameters:
    - id: elementType
      type: System.Type
    - id: length
      type: System.Int32
    return:
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>elementType</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>elementType</em> is not a valid <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>elementType</em> is not supported. For example, <xref href=\"System.Void\" data-throw-if-not-resolved=\"false\"></xref> is not supported.</p>\n<p>-or-</p>\n<p>\n<em>elementType</em> is an open generic type.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>length</em> is less than zero.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.CreateInstance(System.Type,System.Int32[])
  commentId: M:System.Array.CreateInstance(System.Type,System.Int32[])
  id: CreateInstance(System.Type,System.Int32[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: CreateInstance(Type, Int32[])
  fullName: System.Array.CreateInstance(System.Type, System.Int32[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CreateInstance
    path: src/mscorlib/src/System/Array.cs
    startLine: 132
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates a multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> of the specified <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> and dimension lengths, with zero-based indexing. The dimension lengths are specified in an array of 32-bit integers.</p>\n"
  remarks: "\n<p>Unlike most classes, <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> provides the <see cref=\"Overload:System.Array.CreateInstance\"></see> method, instead of public constructors, to allow for late bound access.</p>\n<p>The number of elements in the <em>lengths</em> array must equal the number of dimensions in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. Each element of the <em>lengths</em> array must specify the length of the corresponding dimension in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Reference-type elements are initialized to <strong>null</strong>. Value-type elements are initialized to zero.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the product of all values in <em>lengths</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to create and initialize a multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.CreateInstance3 Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static Array CreateInstance(Type elementType, params int[] lengths)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Function CreateInstance(elementType As Type, ParamArray lengths As Integer()) As Array
    parameters:
    - id: elementType
      type: System.Type
    - id: lengths
      type: System.Int32[]
    return:
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>elementType</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>lengths</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>elementType</em> is not a valid <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The <em>lengths</em> array contains less than one element.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>elementType</em> is not supported. For example, <xref href=\"System.Void\" data-throw-if-not-resolved=\"false\"></xref> is not supported. </p>\n<p>-or-</p>\n<p>\n<em>elementType</em> is an open generic type.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>Any value in <em>lengths</em> is less than zero.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.CreateInstance(System.Type, System.Int32())
  name.vb: CreateInstance(Type, Int32())
- uid: System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])
  commentId: M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])
  id: CreateInstance(System.Type,System.Int32[],System.Int32[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: CreateInstance(Type, Int32[], Int32[])
  fullName: System.Array.CreateInstance(System.Type, System.Int32[], System.Int32[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CreateInstance
    path: src/mscorlib/src/System/Array.cs
    startLine: 186
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates a multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> of the specified <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref> and dimension lengths, with the specified lower bounds.</p>\n"
  remarks: "\n<p>Unlike most classes, <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> provides the <see cref=\"Overload:System.Array.CreateInstance\"></see> method, instead of public constructors, to allow for late bound access.</p>\n<p>The <em>lengths</em> and <em>lowerBounds</em> arrays must have the same number of elements. The number of elements in the <em>lengths</em> array must equal the number of dimensions in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each element of the <em>lengths</em> array must specify the length of the corresponding dimension in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each element of the <em>lowerBounds</em> array must specify the lower bound of the corresponding dimension in the new <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</p>\n<p>Reference-type elements are initialized to <strong>null</strong>. Value-type elements are initialized to zero.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the product of all values in <em>lengths</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to create and initialize a multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> with specified lower bounds.</p>Classic Array.CreateInstance4 Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static Array CreateInstance(Type elementType, int[] lengths, int[] lowerBounds)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Function CreateInstance(elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array
    parameters:
    - id: elementType
      type: System.Type
    - id: lengths
      type: System.Int32[]
    - id: lowerBounds
      type: System.Int32[]
    return:
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>elementType</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>lengths</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>lowerBounds</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>elementType</em> is not a valid <xref href=\"System.Type\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The <em>lengths</em> array contains less than one element.</p>\n<p>-or-</p>\n<p>The <em>lengths</em> and <em>lowerBounds</em> arrays do not contain the same number of elements.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>elementType</em> is not supported. For example, <xref href=\"System.Void\" data-throw-if-not-resolved=\"false\"></xref> is not supported. </p>\n<p>-or-</p>\n<p>\n<em>elementType</em> is an open generic type.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>Any value in <em>lengths</em> is less than zero.</p>\n<p>-or-</p>\n<p>Any value in <em>lowerBounds</em> is very large, such that the sum of a dimension's lower bound and length is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.CreateInstance(System.Type, System.Int32(), System.Int32())
  name.vb: CreateInstance(Type, Int32(), Int32())
- uid: System.Array.Empty``1
  commentId: M:System.Array.Empty``1
  id: Empty``1
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Empty<T>()
  fullName: System.Array.Empty<T>()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Empty
    path: src/mscorlib/src/System/Array.cs
    startLine: 1051
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns an empty array.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static T[] Empty<T>()
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function Empty(Of T) As T()
    typeParameters:
    - id: T
    return:
      type: '{T}[]'
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Empty(Of T)()
  name.vb: Empty(Of T)()
- uid: System.Array.Exists``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  id: Exists``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Exists<T>(T[], Predicate<T>)
  fullName: System.Array.Exists<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Exists
    path: src/mscorlib/src/System/Array.cs
    startLine: 1062
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>, and processing is stopped when a match is found.</p>\n<p>In C# and Visual Basic, it is not necessary to create the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> delegate explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example specifies the match conditions for the <xref href=\"System.Array.Exists``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref>method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</p>System.Array.Exists#3<p>The following example uses the <xref href=\"System.Array.Exists``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method to indicate whether any names in a string array begin with a specified character. The example instantiates a <code>StringSearcher</code> object by passing the string to search for to its class constructor. The <code>StringSearcher.StartsWith</code> method has same signature as the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> delegate. When the<xref href=\"System.Array.Exists``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method is called, each member of the array is passed to the delegate until it returns <strong>true</strong> or iterates all the elements in the array. </p>System.Array.Exists#1<p>You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate. The following example replaces the <code>StringSearcher</code>class and its <strong>StartsWith</strong> method with a lambda expression.  </p>System.Array.Exists#2"
  syntax:
    content: public static bool Exists<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function Exists(Of T)(array As T(), match As Predicate(Of T)) As Boolean
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Boolean
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Array.TrueForAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Exists(Of T)(T(), System.Predicate(Of T))
  name.vb: Exists(Of T)(T(), Predicate(Of T))
- uid: System.Array.Find``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  id: Find``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Find<T>(T[], Predicate<T>)
  fullName: System.Array.Find<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Find
    path: src/mscorlib/src/System/Array.cs
    startLine: 1066
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method or a lambda expression that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate or lambda expression.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>, starting with the first element and ending with the last element.  Processing is stopped when a match is found.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example uses a <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> delegate with the <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method to search an array of <xref href=\"System.Drawing.Point\" data-throw-if-not-resolved=\"false\"></xref> structures. The method the delegate represents, <code>ProductGT10</code>, returns <strong>true</strong> if the product of the X and Y fields is greater than 100,000. The <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method calls the delegate for each element of the array, returning the first point that meets the test condition. </p>\n<p>Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method. The compilers determine the necessary types from the method arguments you supply.</p>System.Array.Find#1"
  - "\n<p>Rather than explicitly defining a method with the necessary signature, instantiating a <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> delegate, and passing the delegate to the <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method, it is customary to use a lambda expression. The following example is identical to the previous one, except that it uses a lambda expression as the <em>match</em> argument. </p>System.Array.Find#2"
  syntax:
    content: public static T Find<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function Find(Of T)(array As T(), match As Predicate(Of T)) As T
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: '{T}'
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Find(Of T)(T(), System.Predicate(Of T))
  name.vb: Find(Of T)(T(), Predicate(Of T))
- uid: System.Array.FindAll``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  id: FindAll``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindAll<T>(T[], Predicate<T>)
  fullName: System.Array.FindAll<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindAll
    path: src/mscorlib/src/System/Array.cs
    startLine: 1084
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Retrieves all the elements that match the conditions defined by the specified predicate.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>, and the elements that match the conditions are saved in the returned array.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example creates an array of 50 random numbers with values that can range from 0 to 1,000. It then calls the <xref href=\"System.Array.FindAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method with a lambda expression that returns the values that range from 300 to 600. Note that the lambda expression is passed a parameter named <code>x</code>;  this represents the individual array member that is passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>. Also note that the local <code>lBound</code> and <code>uBound</code> variables are accessible within the lambda expression. </p>System.Array.FindAll#1"
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.FindLast``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.FindAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method traverses the array from the beginning, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element \"Amargasaurus\". </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindLast``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method is used to search the array backward from the end. It finds the element \"Dilophosaurus\" at position 5. The <xref href=\"System.Array.FindAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method is used to return an array containing all the elements that end in \"saurus\". The elements are displayed.</p>\n<p>The code example also demonstrates the <xref href=\"System.Array.Exists``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.TrueForAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods.</p>Array_FindEtAl#1"
  syntax:
    content: public static T[] FindAll<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function FindAll(Of T)(array As T(), match As Predicate(Of T)) As T()
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: '{T}[]'
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindAll(Of T)(T(), System.Predicate(Of T))
  name.vb: FindAll(Of T)(T(), Predicate(Of T))
- uid: System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  commentId: M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  id: FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindIndex<T>(T[], Int32, Int32, Predicate<T>)
  fullName: System.Array.FindIndex<T>(T[], System.Int32, System.Int32, System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1123
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that starts at the specified index and contains the specified number of elements.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched forward starting at <em>startIndex</em> and ending at <em>startIndex</em> plus <em>count</em> minus 1, if <em>count</em> is greater than 0.</p>\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array from the beginning, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 1. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 2 and continuing to the end of the array. It finds the element at position 5. Finally, the <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 2. It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindIndex#1"
  syntax:
    content: public static int FindIndex<T>(T[] array, int startIndex, int count, Predicate<T> match)
    content.vb: Public Shared Function FindIndex(Of T)(array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindIndex(Of T)(T(), System.Int32, System.Int32, System.Predicate(Of T))
  name.vb: FindIndex(Of T)(T(), Int32, Int32, Predicate(Of T))
- uid: System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})
  commentId: M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})
  id: FindIndex``1(``0[],System.Int32,System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindIndex<T>(T[], Int32, Predicate<T>)
  fullName: System.Array.FindIndex<T>(T[], System.Int32, System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1113
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that extends from the specified index to the last element.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched forward starting at <em>startIndex</em> and ending at the last element.</p>\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from <em>startIndex</em> to the end of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array from the beginning, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 1. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 2 and continuing to the end of the array. It finds the element at position 5. Finally, the <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 2. It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindIndex#1"
  syntax:
    content: public static int FindIndex<T>(T[] array, int startIndex, Predicate<T> match)
    content.vb: Public Shared Function FindIndex(Of T)(array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: startIndex
      type: System.Int32
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindIndex(Of T)(T(), System.Int32, System.Predicate(Of T))
  name.vb: FindIndex(Of T)(T(), Int32, Predicate(Of T))
- uid: System.Array.FindIndex``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.FindIndex``1(``0[],System.Predicate{``0})
  id: FindIndex``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindIndex<T>(T[], Predicate<T>)
  fullName: System.Array.FindIndex<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1103
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched forward starting at the first element and ending at the last element.</p>\n<p>The<xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array from the beginning, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 1. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 2 and continuing to the end of the array. It finds the element at position 5. Finally, the <xref href=\"System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 2. It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindIndex#1"
  syntax:
    content: public static int FindIndex<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function FindIndex(Of T)(array As T(), match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindIndex(Of T)(T(), System.Predicate(Of T))
  name.vb: FindIndex(Of T)(T(), Predicate(Of T))
- uid: System.Array.FindLast``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  id: FindLast``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindLast<T>(T[], Predicate<T>)
  fullName: System.Array.FindLast<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindLast
    path: src/mscorlib/src/System/Array.cs
    startLine: 1149
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>, moving backward in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>, starting with the last element and ending with the first element.  Processing is stopped when a match is found.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.FindLast``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.FindAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.Find``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method traverses the array from the beginning, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element \"Amargasaurus\". </p>\n<p>In C# and Visual Basic, it is not necessary to create the<code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindLast``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method is used to search the array backward from the end. It finds the element \"Dilophosaurus\" at position 5. The <xref href=\"System.Array.FindAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method is used to return an array containing all the elements that end in \"saurus\". The elements are displayed.</p>\n<p>The code example also demonstrates the <xref href=\"System.Array.Exists``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.TrueForAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods.</p>Array_FindEtAl#1"
  syntax:
    content: public static T FindLast<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function FindLast(Of T)(array As T(), match As Predicate(Of T)) As T
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: '{T}'
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindLast(Of T)(T(), System.Predicate(Of T))
  name.vb: FindLast(Of T)(T(), Predicate(Of T))
- uid: System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  commentId: M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  id: FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindLastIndex<T>(T[], Int32, Int32, Predicate<T>)
  fullName: System.Array.FindLastIndex<T>(T[], System.Int32, System.Int32, System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindLastIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1185
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that contains the specified number of elements and ends at the specified index.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at <em>startIndex</em> minus <em>count</em> plus 1, if <em>count</em> is greater than 0.</p>\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindLastIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array backward from the end, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 5. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array. It finds the element at position 1. Finally, the <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2). It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindLastIndex#1"
  syntax:
    content: public static int FindLastIndex<T>(T[] array, int startIndex, int count, Predicate<T> match)
    content.vb: Public Shared Function FindLastIndex(Of T)(array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindLastIndex(Of T)(T(), System.Int32, System.Int32, System.Predicate(Of T))
  name.vb: FindLastIndex(Of T)(T(), Int32, Int32, Predicate(Of T))
- uid: System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})
  commentId: M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})
  id: FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindLastIndex<T>(T[], Int32, Predicate<T>)
  fullName: System.Array.FindLastIndex<T>(T[], System.Int32, System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindLastIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1176
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that extends from the first element to the specified index.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at the first element.</p>\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from the beginning of <em>array</em> to <em>startIndex</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindLastIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array backward from the end, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 5. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array. It finds the element at position 1. Finally, the <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2). It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindLastIndex#1"
  syntax:
    content: public static int FindLastIndex<T>(T[] array, int startIndex, Predicate<T> match)
    content.vb: Public Shared Function FindLastIndex(Of T)(array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: startIndex
      type: System.Int32
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindLastIndex(Of T)(T(), System.Int32, System.Predicate(Of T))
  name.vb: FindLastIndex(Of T)(T(), Int32, Predicate(Of T))
- uid: System.Array.FindLastIndex``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})
  id: FindLastIndex``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: FindLastIndex<T>(T[], Predicate<T>)
  fullName: System.Array.FindLastIndex<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FindLastIndex
    path: src/mscorlib/src/System/Array.cs
    startLine: 1167
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at the last element and ending at the first element.</p>\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns <strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three overloads of the <see cref=\"Overload:System.Array.FindLastIndex\"></see> generic method. An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with \"saurus\". The code example also defines a search predicate method named <code>EndsWithSaurus</code>, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in \"saurus\". </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload traverses the array backward from the end, passing each element in turn to the <code>EndsWithSaurus</code> method. The search stops when the <code>EndsWithSaurus</code> method returns <strong>true</strong> for the element at position 5. </p>\n<p>In C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>\n<p>The <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array. It finds the element at position 1. Finally, the <xref href=\"System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2). It returns –1 because there are no dinosaur names in that range that end with \"saurus\".</p>Array_FindLastIndex#1"
  syntax:
    content: public static int FindLastIndex<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function FindLastIndex(Of T)(array As T(), match As Predicate(Of T)) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Array.Find``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Find``1(``0[],System.Predicate{``0})
  - type: System.Array.FindLast``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindLast``1(``0[],System.Predicate{``0})
  - type: System.Array.FindAll``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.FindAll``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.FindLastIndex(Of T)(T(), System.Predicate(Of T))
  name.vb: FindLastIndex(Of T)(T(), Predicate(Of T))
- uid: System.Array.GetEnumerator
  commentId: M:System.Array.GetEnumerator
  id: GetEnumerator
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetEnumerator()
  fullName: System.Array.GetEnumerator()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetEnumerator
    path: src/mscorlib/src/System/Array.cs
    startLine: 1241
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns an <xref href=\"System.Collections.IEnumerator\" data-throw-if-not-resolved=\"false\"></xref> for the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>[Visual Basic, C#]</p>\n<p>The <strong>foreach</strong> statement of the C# language (<strong>for each</strong> in C++, <strong>For Each</strong> in Visual Basic) hides the complexity of the enumerators. Therefore, using <strong>foreach</strong> is recommended, instead of directly manipulating the enumerator.</p>\n<p>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</p>\n<p>Initially, the enumerator is positioned before the first element in the collection. <xref href=\"System.Collections.IEnumerator.Reset\" data-throw-if-not-resolved=\"false\"></xref> also brings the enumerator back to this position.  At this position, <xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref> is undefined. Therefore, you must call <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> to advance the enumerator to the first element of the collection before reading the value of <xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>\n<xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref> returns the same object until either <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Collections.IEnumerator.Reset\" data-throw-if-not-resolved=\"false\"></xref> is called. <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> sets <xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref> to the next element.</p>\n<p>If <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong>. When the enumerator is at this position, subsequent calls to <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> also return <strong>false</strong>. If the last call to <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref> returned <strong>false</strong>, <xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref> is undefined. To set <xref href=\"System.Collections.IEnumerator.Current\" data-throw-if-not-resolved=\"false\"></xref> to the first element of the collection again, you can call <xref href=\"System.Collections.IEnumerator.Reset\" data-throw-if-not-resolved=\"false\"></xref> followed by <xref href=\"System.Collections.IEnumerator.MoveNext\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>An enumerator remains valid as long as the collection remains unchanged. If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</p>\n<p>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.  To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.  To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following code example shows how to use <xref href=\"System.Array.GetEnumerator\" data-throw-if-not-resolved=\"false\"></xref> to list the elements of an array.</p>System.Array_GetEnumerator#1"
  syntax:
    content: public IEnumerator GetEnumerator()
    content.vb: Public Function GetEnumerator As IEnumerator
    return:
      type: System.Collections.IEnumerator
  implements:
  - System.Collections.IEnumerable.GetEnumerator
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.GetLength(System.Int32)
  commentId: M:System.Array.GetLength(System.Int32)
  id: GetLength(System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetLength(Int32)
  fullName: System.Array.GetLength(System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>An example of <xref href=\"System.Array.GetLength(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is <code>GetLength(0)</code>, which returns the number of elements in the first dimension of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following example shows how to use <xref href=\"System.Array.GetLength(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to display the dimensions of two arrays with different ranks.</p>System.Array.GetLength#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public int GetLength(int dimension)
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Function GetLength(dimension As Integer) As Integer
    parameters:
    - id: dimension
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>dimension</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>dimension</em> is equal to or greater than <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.Length
    commentId: P:System.Array.Length
  - type: System.Array.GetLongLength(System.Int32)
    commentId: M:System.Array.GetLongLength(System.Int32)
  - type: System.Collections.ICollection.Count
    commentId: P:System.Collections.ICollection.Count
  - type: System.Array.Rank
    commentId: P:System.Array.Rank
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.GetLowerBound(System.Int32)
  commentId: M:System.Array.GetLowerBound(System.Int32)
  id: GetLowerBound(System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetLowerBound(Int32)
  fullName: System.Array.GetLowerBound(System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the index of the first element of the specified dimension in the array.</p>\n"
  remarks: "\n<p>\n<code>GetLowerBound(0)</code> returns the starting index of the first dimension of the array, and <code>GetLowerBound(Rank - 1)</code> returns the starting index of the last dimension of the array.</p>\n<p>The <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</p>\n<p>Note that, although most arrays in the .NET Framework are zero-based (that is, the <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based. Such arrays can be created with the <xref href=\"System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])\" data-throw-if-not-resolved=\"false\"></xref> method, and can also be returned from unmanaged code. </p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</p>System.Array.GetUpperBound#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public int GetLowerBound(int dimension)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Function GetLowerBound(dimension As Integer) As Integer
    parameters:
    - id: dimension
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>dimension</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>dimension</em> is equal to or greater than <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  - type: System.Array.Rank
    commentId: P:System.Array.Rank
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.GetUpperBound(System.Int32)
  commentId: M:System.Array.GetUpperBound(System.Int32)
  id: GetUpperBound(System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetUpperBound(Int32)
  fullName: System.Array.GetUpperBound(System.Int32)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the index of the last element of the specified dimension in the array.</p>\n"
  remarks: "\n<p>\n<code>GetUpperBound(0)</code> returns the last index in the first dimension of the array, and <code>GetUpperBound(Rank - 1)</code> returns the last index of the last dimension of the array.</p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</p>System.Array.GetUpperBound#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public int GetUpperBound(int dimension)
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Function GetUpperBound(dimension As Integer) As Integer
    parameters:
    - id: dimension
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>dimension</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>dimension</em> is equal to or greater than <xref href=\"System.Array.Rank\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.Rank
    commentId: P:System.Array.Rank
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.GetValue(System.Int32)
  commentId: M:System.Array.GetValue(System.Int32)
  id: GetValue(System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetValue(Int32)
  fullName: System.Array.GetValue(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetValue
    path: src/mscorlib/src/System/Array.cs
    startLine: 359
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the value at the specified position in the one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The index is specified as a 32-bit integer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods can determine whether the value of <em>index</em> is out of bounds.</p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</p>System.Array_GetSetValue#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public object GetValue(int index)
    content.vb: >-
      <SecuritySafeCritical>

      Public Function GetValue(index As Integer) As Object
    parameters:
    - id: index
      type: System.Int32
    return:
      type: System.Object
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not have exactly one dimension.</p>\n"
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>index</em> is outside the range of valid indexes for the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.GetValue(System.Int32[])
  commentId: M:System.Array.GetValue(System.Int32[])
  id: GetValue(System.Int32[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: GetValue(Int32[])
  fullName: System.Array.GetValue(System.Int32[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetValue
    path: src/mscorlib/src/System/Array.cs
    startLine: 344
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the value at the specified position in the multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The indexes are specified as an array of 32-bit integers.</p>\n"
  remarks: "\n<p>The number of elements in <em>indices</em> must equal the number of dimensions in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. All elements in the <em>indices</em> array must collectively specify the position of the desired element in the multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods can determine whether any of the indexes is out of bounds.</p>\n<p>This method is an O(1) operation.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</p>System.Array_GetSetValue#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public object GetValue(params int[] indices)
    content.vb: >-
      <SecuritySafeCritical>

      Public Function GetValue(ParamArray indices As Integer()) As Object
    parameters:
    - id: indices
      type: System.Int32[]
    return:
      type: System.Object
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>indices</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The number of dimensions in the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is not equal to the number of elements in <em>indices</em>.</p>\n"
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>Any element in <em>indices</em> is outside the range of valid indexes for the corresponding dimension of the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Array.GetValue(System.Int32())
  name.vb: GetValue(Int32())
- uid: System.Array.IndexOf(System.Array,System.Object)
  commentId: M:System.Array.IndexOf(System.Array,System.Object)
  id: IndexOf(System.Array,System.Object)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf(Array, Object)
  fullName: System.Array.IndexOf(System.Array, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1254
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</p>\n"
  remarks: "\n<p>This method searches all the elements of a one-dimensional arrayfor <em>value</em>. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling each element's <strong>Equals</strong> method until it finds a match. This means that if the element overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called. </p>\n<p>Because most arrays have a lower bound of zero, this method generally returns –1 if<em>value</em> isn’t found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref>(0x80000000) and <em>value</em> isn’t found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> (0x7FFFFFFF).</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The example calls the following three overloads of the <xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>method to find the index of a string in a string array:</p>\n<ul><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in the fourth to the last elements of a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array from the element that follows the last successful match to the end of the array. </p>\n</li></ul>Classic Array.IndexOf Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int IndexOf(Array array, object value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function IndexOf(array As Array, value As Object) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.IndexOf(System.Array,System.Object,System.Int32)
  commentId: M:System.Array.IndexOf(System.Array,System.Object,System.Int32)
  id: IndexOf(System.Array,System.Object,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf(Array, Object, Int32)
  fullName: System.Array.IndexOf(System.Array, System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1270
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.</p>\n"
  remarks: "\n<p>This method searches a one-dimensional array from the element at index <em>startIndex</em>to the last element. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling the <strong>Equals</strong> method of every element until it finds a match. This means that if the element overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called. </p>\n<p>Because most arrays have a lower bound of zero, this method generally returns –1 if <em>value</em> isn’t found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref>(0x80000000) and <em>value</em> isn’t found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> (0x7FFFFFFF).</p>\n<p>If <em>startIndex</em> equals <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>,the method returns -1. If <em>startIndex</em> is greater than <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method throws an <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from <em>startIndex</em> to the end of <em>array</em>.</p>\n"
  example:
  - "\n<p>The example calls the following three overloads of the <xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to find the index of a string in a string array: </p>\n<ul><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in the fourth to the last elements of a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array from the element that follows the last successful match to the end of the array. </p>\n</li></ul>Classic Array.IndexOf Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int IndexOf(Array array, object value, int startIndex)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function IndexOf(array As Array, value As Object, startIndex As Integer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    - id: startIndex
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)
  commentId: M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)
  id: IndexOf(System.Array,System.Object,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf(Array, Object, Int32, Int32)
  fullName: System.Array.IndexOf(System.Array, System.Object, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1286
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence. The range extends from a specified index for a specified number of elements.</p>\n"
  remarks: "\n<p>This method searches the elements of a one-dimensional arrayfrom <em>startIndex</em>to <em>startIndex</em> plus <em>count</em> minus 1, if <em>count</em> is greater than 0. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling the <strong>Equals</strong> method of every element until it finds a match. This means that if the element overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called. </p>\n<p>Becausemost arrays have a lower bound of zero, this method generally returns –1 when <em>value</em> isn’t found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref> (0x80000000) and <em>value</em> isn’t found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> (0x7FFFFFFF).</p>\n<p>If <em>startindex</em> equals <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method returns -1. If <em>startIndex</em> is greater than <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method throws an <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n"
  example:
  - "\n<p>The example calls the following three overloads of the <xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to find the index of a string in a string array:</p>\n<ul><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in the fourth to the last elements of a string array. </p>\n</li><li>\n<p>\n<xref href=\"System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, to determine the first occurrence of the string \"the\" in a string array from the element that follows the last successful match to the end of the array. To determine the value of the <em>count</em> argument, it subtracts the upper bound of the array from the starting index and adds one. </p>\n</li></ul>Classic Array.IndexOf Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int IndexOf(Array array, object value, int startIndex, int count)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function IndexOf(array As Array, value As Object, startIndex As Integer, count As Integer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.IndexOf``1(``0[],``0)
  commentId: M:System.Array.IndexOf``1(``0[],``0)
  id: IndexOf``1(``0[],``0)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf<T>(T[], T)
  fullName: System.Array.IndexOf<T>(T[], T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1341
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</p>\n"
  remarks: "\n<p>This method searches all the elements of a one-dimensional array for <em>value</em>. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling the <strong>T.Equals</strong> method on every element. This means that if <em>T</em> overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called.  </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.IndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.IndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the array from the beginning, and finds the first occurrence of the string. The <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string. Finally, the <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</p>Array_IndexOf#1"
  syntax:
    content: public static int IndexOf<T>(T[] array, T value)
    content.vb: Public Shared Function IndexOf(Of T)(array As T(), value As T) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.IndexOf(Of T)(T(), T)
  name.vb: IndexOf(Of T)(T(), T)
- uid: System.Array.IndexOf``1(``0[],``0,System.Int32)
  commentId: M:System.Array.IndexOf``1(``0[],``0,System.Int32)
  id: IndexOf``1(``0[],``0,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf<T>(T[], T, Int32)
  fullName: System.Array.IndexOf<T>(T[], T, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1353
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence. The range extends from a specified index to the end of the array.</p>\n"
  remarks: "\n<p>This method searches a one-dimensional array from the element at <em>startIndex</em> to the end of the array. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling the <strong>T.Equals</strong> method on every element. This means that if <em>T</em> overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called. </p>\n<p>If <em>startIndex</em> equals <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>,the method returns -1.If <em>startIndex</em> is greater than <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method throws an <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from <em>startIndex</em> to the end of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.IndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.IndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the array from the beginning, and finds the first occurrence of the string. The <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string. Finally, the <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</p>Array_IndexOf#1"
  syntax:
    content: public static int IndexOf<T>(T[] array, T value, int startIndex)
    content.vb: Public Shared Function IndexOf(Of T)(array As T(), value As T, startIndex As Integer) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    - id: startIndex
      type: System.Int32
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.IndexOf(Of T)(T(), T, System.Int32)
  name.vb: IndexOf(Of T)(T(), T, Int32)
- uid: System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)
  commentId: M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)
  id: IndexOf``1(``0[],``0,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IndexOf<T>(T[], T, Int32, Int32)
  fullName: System.Array.IndexOf<T>(T[], T, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1363
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence. The range extends from a specified index for a specified number of elements.</p>\n"
  remarks: "\n<p>This method searchesthe elements of a one-dimensional array from <em>startIndex</em> to <em>startIndex</em> plus <em>count</em> minus 1, if <em>count</em> is greater than 0. To determine whether <em>value</em> exists in <em>array</em>, the method performs an equality comparison by calling the <strong>T.Equals</strong> method on every element. This means that if <em>T</em> overrides the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method, that override is called.</p>\n<p>If <em>startIndex</em> equals <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method returns -1.  If <em>startIndex</em> is greater than <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>, the method throws an <xref href=\"System.ArgumentOutOfRangeException\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n"
  example:
  - "\n<p>The following example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.IndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.IndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the array from the beginning, and finds the first occurrence of the string. The <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string. Finally, the <xref href=\"System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</p>Array_IndexOf#1"
  syntax:
    content: public static int IndexOf<T>(T[] array, T value, int startIndex, int count)
    content.vb: Public Shared Function IndexOf(Of T)(array As T(), value As T, startIndex As Integer, count As Integer) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.IndexOf(Of T)(T(), T, System.Int32, System.Int32)
  name.vb: IndexOf(Of T)(T(), T, Int32, Int32)
- uid: System.Array.Initialize
  commentId: M:System.Array.Initialize
  id: Initialize
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Initialize()
  fullName: System.Array.Initialize()
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes every element of the value-type <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> by calling the default constructor of the value type.</p>\n"
  remarks: "\n<p>This method is designed to help compilers support value-type arrays; most users do not need this method. It must not be used on reference-type arrays.</p>\n<p>If the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is not a value-type <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> or if the value type does not have a default constructor, the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is not modified.</p>\n<p>The value-type <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> can have any lower bound and any number of dimensions.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public void Initialize()
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Sub Initialize
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.LastIndexOf(System.Array,System.Object)
  commentId: M:System.Array.LastIndexOf(System.Array,System.Object)
  id: LastIndexOf(System.Array,System.Object)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf(Array, Object)
  fullName: System.Array.LastIndexOf(System.Array, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1391
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at the last element and ending at the first element.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the <strong>Equals</strong> implementation of that type is used.</p>\n<p>Since most arrays will have a lower bound of zero, this method would generally return –1 when <em>value</em> is not found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref> and <em>value</em> is not found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, which is <code>System.Int32.MinValue - 1</code>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n<p>In the .NET Framework version 2.0, this method uses the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to determine whether the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> specified by the <em>value</em> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <em>value</em><xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> itself.</p>\n<p>\n<xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <em>item</em> parameter on the objects in the collection.</p>\n"
  example:
  - "\n<p>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</p>Classic Array.LastIndexOf Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int LastIndexOf(Array array, object value)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function LastIndexOf(array As Array, value As Object) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.LastIndexOf(System.Array,System.Object,System.Int32)
  commentId: M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)
  id: LastIndexOf(System.Array,System.Object,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf(Array, Object, Int32)
  fullName: System.Array.LastIndexOf(System.Array, System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1406
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that extends from the first element to the specified index.</p>\n"
  remarks: "\n<p>The one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at the first element.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the <strong>Equals</strong> implementation of that type is used.</p>\n<p>Since most arrays will have a lower bound of zero, this method would generally return –1 when <em>value</em> is not found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref> and <em>value</em> is not found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, which is <code>System.Int32.MinValue - 1</code>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from the beginning of <em>array</em> to <em>startIndex</em>.</p>\n<p>In the .NET Framework version 2.0, this method uses the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to determine whether the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> specified by the <em>value</em> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <em>value</em><xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> itself.</p>\n"
  example:
  - "\n<p>The following code example shows how to determine the index of the last occurrence of a specified element in an array.</p>Classic Array.LastIndexOf Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int LastIndexOf(Array array, object value, int startIndex)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function LastIndexOf(array As Array, value As Object, startIndex As Integer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    - id: startIndex
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)
  commentId: M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)
  id: LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf(Array, Object, Int32, Int32)
  fullName: System.Array.LastIndexOf(System.Array, System.Object, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1422
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that contains the specified number of elements and ends at the specified index.</p>\n"
  remarks: "\n<p>The one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at <em>startIndex</em> minus <em>count</em> plus 1, if <em>count</em> is greater than 0.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the<strong>Equals</strong> implementation of that type is used.</p>\n<p>Since most arrays will have a lower bound of zero, this method would generally return –1 when <em>value</em> is not found. In the rare case that the lower bound of the array is equal to <xref href=\"System.Int32.MinValue\" data-throw-if-not-resolved=\"false\"></xref> and <em>value</em> is not found, this method returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>, which is <code>System.Int32.MinValue - 1</code>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n<p>In the .NET Framework version 2.0, this method uses the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> to determine whether the <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> specified by the <em>value</em> parameter exists. In the earlier versions of the .NET Framework, this determination was made by using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IComparable.CompareTo(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods of the <em>value</em><xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref> itself.</p>\n"
  example:
  - "\n<p>The following code example shows how to determine the index of the last occurrence of a specified element in an array. Note that the <see cref=\"Overload:System.Array.LastIndexOf\"></see> method is a backward search; therefore, <em>count</em> must be less than or equal to (<em>startIndex</em> minus the lower bound of the array plus 1).</p>Classic Array.LastIndexOf Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static int LastIndexOf(Array array, object value, int startIndex, int count)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Function LastIndexOf(array As Array, value As Object, startIndex As Integer, count As Integer) As Integer
    parameters:
    - id: array
      type: System.Array
    - id: value
      type: System.Object
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.LastIndexOf``1(``0[],``0)
  commentId: M:System.Array.LastIndexOf``1(``0[],``0)
  id: LastIndexOf``1(``0[],``0)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf<T>(T[], T)
  fullName: System.Array.LastIndexOf<T>(T[], T)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1478
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at the last element and ending at the first element.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the <strong>Equals</strong> implementation of that type is used.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.LastIndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the entire array from the end, and finds the second occurrence of the string. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string. Finally, the <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</p>Array_LastIndexOf#1"
  syntax:
    content: public static int LastIndexOf<T>(T[] array, T value)
    content.vb: Public Shared Function LastIndexOf(Of T)(array As T(), value As T) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.LastIndexOf(Of T)(T(), T)
  name.vb: LastIndexOf(Of T)(T(), T)
- uid: System.Array.LastIndexOf``1(``0[],``0,System.Int32)
  commentId: M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)
  id: LastIndexOf``1(``0[],``0,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf<T>(T[], T, Int32)
  fullName: System.Array.LastIndexOf<T>(T[], T, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1488
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that extends from the first element to the specified index.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at the first element.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the <strong>Equals</strong> implementation of that type is used.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the number of elements from the beginning of <em>array</em> to <em>startIndex</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.LastIndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the entire array from the end, and finds the second occurrence of the string. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string. Finally, the <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</p>Array_LastIndexOf#1"
  syntax:
    content: public static int LastIndexOf<T>(T[] array, T value, int startIndex)
    content.vb: Public Shared Function LastIndexOf(Of T)(array As T(), value As T, startIndex As Integer) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    - id: startIndex
      type: System.Int32
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.LastIndexOf(Of T)(T(), T, System.Int32)
  name.vb: LastIndexOf(Of T)(T(), T, Int32)
- uid: System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)
  commentId: M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)
  id: LastIndexOf``1(``0[],``0,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: LastIndexOf<T>(T[], T, Int32, Int32)
  fullName: System.Array.LastIndexOf<T>(T[], T, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: LastIndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 1498
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Searches for the specified object and returns the index of the last occurrence within the range of elements in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> that contains the specified number of elements and ends at the specified index.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is searched backward starting at <em>startIndex</em> and ending at <em>startIndex</em> minus <em>count</em> plus 1, if <em>count</em> is greater than 0.</p>\n<p>The elements are compared to the specified value using the <xref href=\"System.Object.Equals(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. If the element type is a nonintrinsic (user-defined) type, the <strong>Equals</strong> implementation of that type is used.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>count</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates all three generic overloads of the <see cref=\"Overload:System.Array.LastIndexOf\"></see> method. An array of strings is created, with one entry that appears twice, at index location 0 and index location 5. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload searches the entire array from the end, and finds the second occurrence of the string. The <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string. Finally, the <xref href=\"System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</p>Array_LastIndexOf#1"
  syntax:
    content: public static int LastIndexOf<T>(T[] array, T value, int startIndex, int count)
    content.vb: Public Shared Function LastIndexOf(Of T)(array As T(), value As T, startIndex As Integer, count As Integer) As Integer
    parameters:
    - id: array
      type: '{T}[]'
    - id: value
      type: '{T}'
    - id: startIndex
      type: System.Int32
    - id: count
      type: System.Int32
    typeParameters:
    - id: T
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> is outside the range of valid indexes for <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>count</em> is less than zero.</p>\n<p>-or-</p>\n<p>\n<em>startIndex</em> and <em>count</em> do not specify a valid section in <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.LastIndexOf(Of T)(T(), T, System.Int32, System.Int32)
  name.vb: LastIndexOf(Of T)(T(), T, Int32, Int32)
- uid: System.Array.Resize``1(``0[]@,System.Int32)
  commentId: M:System.Array.Resize``1(``0[]@,System.Int32)
  id: Resize``1(``0[]@,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Resize<T>(ref T[], Int32)
  fullName: System.Array.Resize<T>(ref T[], System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Resize
    path: src/mscorlib/src/System/Array.cs
    startLine: 44
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Changes the number of elements of a one-dimensional array to the specified new size.</p>\n"
  remarks: "\n<p>This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.<em>array</em> must be a one-dimensional array. </p>\n<p>If <em>array</em> is <strong>null</strong>, this method creates a new array with the specified size.</p>\n<p>If <em>newSize</em> is greater than the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.  If <em>newSize</em> is less than the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.  If <em>newSize</em> is equal to the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of the old array, this method does nothing.  </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>newSize</em>.</p>\n<p>The <xref href=\"System.Array.Resize``1(``0[]@,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method resizes a one-dimensional array only. The <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> class does not include a method for resizing multi-dimensional arrays. To do this, you must either provide your own code or call a special-purpose method in a third-party library. The following code illustrates one possible implementation for a method that resizes an array of n dimensions.  </p>System.Array.Resize#2"
  example:
  - "\n<p>The following example shows how resizing affects the array.</p>System.Array.Resize#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      public static void Resize<T>(ref T[] array, int newSize)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Public Shared Sub Resize(Of T)(ByRef array As T(), newSize As Integer)
    parameters:
    - id: array
      type: '{T}[]'
    - id: newSize
      type: System.Int32
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>newSize</em> is less than zero.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Resize(Of T)(ByRef T(), System.Int32)
  name.vb: Resize(Of T)(ByRef T(), Int32)
- uid: System.Array.Reverse(System.Array)
  commentId: M:System.Array.Reverse(System.Array)
  id: Reverse(System.Array)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Reverse(Array)
  fullName: System.Array.Reverse(System.Array)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Reverse
    path: src/mscorlib/src/System/Array.cs
    startLine: 1545
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Reverses the sequence of the elements in the entire one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>After a call to this method, the element at <code>myArray[i]</code>, where <em>i</em> is any index in the array, moves to <code>myArray[j]</code>, where <em>j</em> equals <code>(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1</code>.</p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n<p>As the following example shows, the <xref href=\"System.Array.Reverse(System.Array)\" data-throw-if-not-resolved=\"false\"></xref> method can be used to reverse a jagged array. It initializes a jagged array with one element for each month of the current year in the current culture's calendar. Each element contains an array with as many elements as that month has days. The example displays the contents of the array, calls the <xref href=\"System.Array.Reverse(System.Array)\" data-throw-if-not-resolved=\"false\"></xref> method, and then displays the contents of the reversed array. </p>System.Array.Reverse#1"
  example:
  - "\n<p>The following code example shows how to reverse the sort of the values in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.Reverse Example#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Reverse(Array array)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Reverse(array As Array)
    parameters:
    - id: array
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>. </p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Reverse(System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.Reverse(System.Array,System.Int32,System.Int32)
  id: Reverse(System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Reverse(Array, Int32, Int32)
  fullName: System.Array.Reverse(System.Array, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Reverse
    path: src/mscorlib/src/System/Array.cs
    startLine: 1559
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Reverses the sequence of the elements in a range of elements in the one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>After a call to this method, the element at <code>myArray[i]</code>, where <em>i</em> is any index in the array, moves to <code>myArray[j]</code>, where <em>j</em> equals <code>(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1</code>.</p>\n<p>The<xref href=\"System.Array.Reverse(System.Array)\" data-throw-if-not-resolved=\"false\"></xref> method can be used to reverse a jagged array. </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to reverse the sort of the values in a range of elements in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>Classic Array.Reverse1 Example#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Reverse(Array array, int index, int length)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Reverse(array As Array, index As Integer, length As Integer)
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.SetValue(System.Object,System.Int32)
  commentId: M:System.Array.SetValue(System.Object,System.Int32)
  id: SetValue(System.Object,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: SetValue(Object, Int32)
  fullName: System.Array.SetValue(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: SetValue
    path: src/mscorlib/src/System/Array.cs
    startLine: 463
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sets a value to the element at the specified position in the one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The index is specified as a 32-bit integer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods can determine whether the value of <em>index</em> is out of bounds.</p>\n<p>For more information about conversions, see <xref href=\"System.Convert\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(1) operation.</p>\n<p>If <see cref=\"Overload:System.Array.SetValue\"></see> is used to assign <strong>null</strong> to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</p>System.Array_GetSetValue#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public void SetValue(object value, int index)
    content.vb: >-
      <SecuritySafeCritical>

      Public Sub SetValue(value As Object, index As Integer)
    parameters:
    - id: value
      type: System.Object
    - id: index
      type: System.Int32
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> does not have exactly one dimension.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>\n<em>value</em> cannot be cast to the element type of the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>\n<em>index</em> is outside the range of valid indexes for the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Array.SetValue(System.Object,System.Int32[])
  commentId: M:System.Array.SetValue(System.Object,System.Int32[])
  id: SetValue(System.Object,System.Int32[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: SetValue(Object, Int32[])
  fullName: System.Array.SetValue(System.Object, System.Int32[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: SetValue
    path: src/mscorlib/src/System/Array.cs
    startLine: 508
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sets a value to the element at the specified position in the multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. The indexes are specified as an array of 32-bit integers.</p>\n"
  remarks: "\n<p>The number of elements in <em>indices</em> must equal the number of dimensions in the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. All elements in the <em>indices</em> array must collectively specify the position of the desired element in the multidimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Array.GetLowerBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.GetUpperBound(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods can determine whether any of the values in the <em>indices</em> array is out of bounds.</p>\n<p>For more information about conversions, see <xref href=\"System.Convert\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is an O(1) operation.</p>\n<p>If <see cref=\"Overload:System.Array.SetValue\"></see> is used to assign <strong>null</strong> to an element of an array of value types, all fields of the element are initialized to zero. The value of the element is not a null reference, and cannot be found by searching for a null reference.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</p>System.Array_GetSetValue#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public void SetValue(object value, params int[] indices)
    content.vb: >-
      <SecuritySafeCritical>

      Public Sub SetValue(value As Object, ParamArray indices As Integer())
    parameters:
    - id: value
      type: System.Object
    - id: indices
      type: System.Int32[]
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>indices</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The number of dimensions in the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is not equal to the number of elements in <em>indices</em>.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>\n<em>value</em> cannot be cast to the element type of the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.IndexOutOfRangeException
    commentId: T:System.IndexOutOfRangeException
    description: "\n<p>Any element in <em>indices</em> is outside the range of valid indexes for the corresponding dimension of the current <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  seealso:
  - type: System.Array.GetLowerBound(System.Int32)
    commentId: M:System.Array.GetLowerBound(System.Int32)
  - type: System.Array.GetUpperBound(System.Int32)
    commentId: M:System.Array.GetUpperBound(System.Int32)
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Array.SetValue(System.Object, System.Int32())
  name.vb: SetValue(Object, Int32())
- uid: System.Array.Sort(System.Array)
  commentId: M:System.Array.Sort(System.Array)
  id: Sort(System.Array)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array)
  fullName: System.Array.Sort(System.Array)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1609
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in an entire one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation of each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each element of <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows: </p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an<see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to sort the values in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array array)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(array As Array)
    parameters:
    - id: array
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Array)
  commentId: M:System.Array.Sort(System.Array,System.Array)
  id: Sort(System.Array,System.Array)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Array)
  fullName: System.Array.Sort(System.Array, System.Array)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1623
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a pair of one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation of each key.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>keys</em>.</p>\n"
  example:
  - "\n<p>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values. Sorts are done using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort2#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array keys, Array items)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(keys As Array, items As Array)
    parameters:
    - id: keys
      type: System.Array
    - id: items
      type: System.Array
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>The <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n<p>-or-</p>\n<p>The <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  - type: System.Collections.IDictionary
    commentId: T:System.Collections.IDictionary
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)
  commentId: M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)
  id: Sort(System.Array,System.Array,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Array, IComparer)
  fullName: System.Array.Sort(System.Array, System.Array, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1673
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a pair of one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>The .NET Framework includes predefined <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementations listed in the following table. </p>\n<p>Implementation</p>\n<p>Description</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects, but performs a case-insensitive comparison of strings. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the current culture. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.DefaultInvariant\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the invariant culture.</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Generic.Comparer`1.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares two objects of type <em>T</em> by using the type's default sort order. </p>\n</td></tr></tbody></table>\n<p>You can also support custom comparisons by providing an instance of your own <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation to the <em>comparer</em> parameter. The example does this by defining an <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation that reverses the default sort order and performs case-insensitive string comparison. </p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>keys</em>.</p>\n"
  example:
  - "\n<p>The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values. Sorts are done using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort2#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array keys, Array items, IComparer comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(keys As Array, items As Array, comparer As IComparer)
    parameters:
    - id: keys
      type: System.Array
    - id: items
      type: System.Array
    - id: comparer
      type: System.Collections.IComparer
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>The <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n<p>-or-</p>\n<p>The <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>. </p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)
  id: Sort(System.Array,System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Array, Int32, Int32)
  fullName: System.Array.Sort(System.Array, System.Array, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1646
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a range of elements in a pair of one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation of each key.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each key within the specified range of elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values. Sorts are done using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort2#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array keys, Array items, int index, int length)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(keys As Array, items As Array, index As Integer, length As Integer)
    parameters:
    - id: keys
      type: System.Array
    - id: items
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>The <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n<p>-or-</p>\n<p>The <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>keys</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and <em>index</em> and <em>length</em> do not specify a valid range in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  commentId: M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  id: Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Array, Int32, Int32, IComparer)
  fullName: System.Array.Sort(System.Array, System.Array, System.Int32, System.Int32, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1700
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a range of elements in a pair of one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, each key within the specified range of elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>The .NET Framework includes predefined <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementations listed in the following table. </p>\n<p>Implementation</p>\n<p>Description</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects, but performs a case-insensitive comparison of strings. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the current culture. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.DefaultInvariant\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the invariant culture.</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Generic.Comparer`1.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares two objects of type <em>T</em> by using the type's default sort order. </p>\n</td></tr></tbody></table>\n<p>You can also support custom comparisons by providing an instance of your own <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation to the <em>comparer</em> parameter. The example does this by defining a custom <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation that reverses the default sort order and performs case-insensitive string comparison. </p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values. Sorts are done using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort2#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array keys, Array items, int index, int length, IComparer comparer)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)
    parameters:
    - id: keys
      type: System.Array
    - id: items
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: comparer
      type: System.Collections.IComparer
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>The <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n<p>-or-</p>\n<p>The <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>keys</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the lower bound of <em>keys</em> does not match the lower bound of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and <em>index</em> and <em>length</em> do not specify a valid range in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Collections.IComparer)
  commentId: M:System.Array.Sort(System.Array,System.Collections.IComparer)
  id: Sort(System.Array,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, IComparer)
  fullName: System.Array.Sort(System.Array, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1657
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in a one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If <em>comparer</em> is <strong>null</strong>, each element of <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n<p>The .NET Framework includes predefined <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementations listed in the following table. </p>\n<p>Implementation</p>\n<p>Description</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects, but performs a case-insensitive comparison of strings. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the current culture. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.DefaultInvariant\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the invariant culture.</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Generic.Comparer`1.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares two objects of type <em>T</em> by using the type's default sort order. </p>\n</td></tr></tbody></table>\n<p>You can also support custom comparisons by providing an instance of your own <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation to the <em>comparer</em> parameter. The example does this by defining a <code>ReverseComparer</code> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison. </p>\n"
  example:
  - "\n<p>The following example sorts the values in a string arrayby using the default comparer. It also defines a custom <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation named <code>ReverseComparer</code> that reverses an object's default sort order while performing a case-insensitive string comparison. Note that the output might vary depending on the current culture.</p>System.Array.Sort#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array array, IComparer comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(array As Array, comparer As IComparer)
    parameters:
    - id: array
      type: System.Array
    - id: comparer
      type: System.Collections.IComparer
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Int32,System.Int32)
  commentId: M:System.Array.Sort(System.Array,System.Int32,System.Int32)
  id: Sort(System.Array,System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Int32, Int32)
  fullName: System.Array.Sort(System.Array, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1635
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in a range of elements in a one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> implementation of each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each element within the specified range of elements in <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:  </p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to sort the values in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array array, int index, int length)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(array As Array, index As Integer, length As Integer)
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  commentId: M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  id: Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort(Array, Int32, Int32, IComparer)
  fullName: System.Array.Sort(System.Array, System.Int32, System.Int32, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1687
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in a range of elements in a one-dimensional <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If <em>comparer</em> is <strong>null</strong>, each element within the specified range of elements in <em>array</em> must implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>The .NET Framework includes predefined <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementations listed in the following table. </p>\n<p>Implementation</p>\n<p>Description</p>\n<table><tbody><tr><td>\n<p>\n<xref href=\"System.Collections.CaseInsensitiveComparer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects, but performs a case-insensitive comparison of strings. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the current culture. </p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Comparer.DefaultInvariant\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares any two objects by using the sorting conventions of the invariant culture.</p>\n</td></tr><tr><td>\n<p>\n<xref href=\"System.Collections.Generic.Comparer`1.Default\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</td><td>\n<p>Compares two objects of type <em>T</em> by using the type's default sort order. </p>\n</td></tr></tbody></table>\n<p>You can also support custom comparisons by providing an instance of your own <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> implementation to the <em>comparer</em> parameter. The example does this by defining a <code>ReverseComparer</code> class that reverses the default sort order for instances of a type and performs case-insensitive string comparison. </p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example shows how to sort the values in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the default comparer and a custom comparer that reverses the sort order. Note that the result might vary depending on the current <xref href=\"System.Globalization.CultureInfo\" data-throw-if-not-resolved=\"false\"></xref>.</p>System.Array.Sort#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort(Array array, int index, int length, IComparer comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(array As Array, index As Integer, length As Integer, comparer As IComparer)
    parameters:
    - id: array
      type: System.Array
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: comparer
      type: System.Collections.IComparer
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.RankException
    commentId: T:System.RankException
    description: "\n<p>\n<em>array</em> is multidimensional.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>. </p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  seealso:
  - type: System.Collections.IComparer
    commentId: T:System.Collections.IComparer
  - type: System.IComparable
    commentId: T:System.IComparable
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Array.Sort``1(``0[])
  commentId: M:System.Array.Sort``1(``0[])
  id: Sort``1(``0[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<T>(T[])
  fullName: System.Array.Sort<T>(T[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1744
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in an entire <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation of each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each element of <em>array</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``1(``0[])\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the<xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload. An array of strings is created, in no particular order. </p>\n<p>The array is displayed, sorted, and displayed again.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[])\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>\n<p>The <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is then used to search for two strings, one that is not in the array and one that is. The array and the return value of the <xref href=\"System.Array.BinarySearch``1(``0[],``0)\" data-throw-if-not-resolved=\"false\"></xref> method are passed to the <code>ShowWhere</code> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array. The index is negative if the string is not n the array, so the <code>ShowWhere</code> method takes the bitwise complement (the ~ operator in C# and Visual C++, <strong>Xor</strong> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</p>Array_SortSearch#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<T>(T[] array)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of T)(array As T())
    parameters:
    - id: array
      type: '{T}[]'
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of T)(T())
  name.vb: Sort(Of T)(T())
- uid: System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})
  id: Sort``1(``0[],System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<T>(T[], IComparer<T>)
  fullName: System.Array.Sort<T>(T[], System.Collections.Generic.IComparer<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1770
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>If <em>comparer</em> is <strong>null</strong>, each element of <em>array</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload. </p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The array is displayed, sorted, and displayed again. Arrays must be sorted in order to use the <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>\n<p>The <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is then used to search for two strings, one that is not in the array and one that is. The array and the return value of the <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> method are passed to the <code>ShowWhere</code> generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array. The index is negative if the string is not n the array, so the <code>ShowWhere</code> method takes the bitwise complement (the ~ operator in C# and Visual C++, <strong>Xor</strong> -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</p>Array_SortSearchComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<T>(T[] array, IComparer<T> comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of T)(array As T(), comparer As IComparer(Of T))
    parameters:
    - id: array
      type: '{T}[]'
    - id: comparer
      type: System.Collections.Generic.IComparer{{T}}
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of T)(T(), System.Collections.Generic.IComparer(Of T))
  name.vb: Sort(Of T)(T(), IComparer(Of T))
- uid: System.Array.Sort``1(``0[],System.Comparison{``0})
  commentId: M:System.Array.Sort``1(``0[],System.Comparison{``0})
  id: Sort``1(``0[],System.Comparison{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<T>(T[], Comparison<T>)
  fullName: System.Array.Sort<T>(T[], System.Comparison<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1836
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Comparison`1\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Collections.Generic.List`1.Sort(System.Comparison{`0})\" data-throw-if-not-resolved=\"false\"></xref> method overload. </p>\n<p>The code example defines an alternative comparison method for strings, named <code>CompareDinosByLength</code>. This method works as follows: First, the comparandsare tested for<strong>null</strong>, and a null reference is treated as less than a non-null. Second, the string lengths are compared, and the longer string is deemed to be greater. Third, if the lengths are equal, ordinary string comparison is used.</p>\n<p>A array of strings is created and populated with four strings, in no particular order. The list also includes an empty string and a null reference. The list is displayed, sorted using a <xref href=\"System.Comparison`1\" data-throw-if-not-resolved=\"false\"></xref> generic delegate representing the <code>CompareDinosByLength</code> method, and displayed again.</p>Array_SortComparison#1"
  syntax:
    content: public static void Sort<T>(T[] array, Comparison<T> comparison)
    content.vb: Public Shared Sub Sort(Of T)(array As T(), comparison As Comparison(Of T))
    parameters:
    - id: array
      type: '{T}[]'
    - id: comparison
      type: System.Comparison{{T}}
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>comparison</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The implementation of <em>comparison</em> caused an error during the sort. For example, <em>comparison</em> might not return 0 when comparing an item with itself.</p>\n"
  seealso:
  - type: System.Comparison`1
    commentId: T:System.Comparison`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of T)(T(), System.Comparison(Of T))
  name.vb: Sort(Of T)(T(), Comparison(Of T))
- uid: System.Array.Sort``1(``0[],System.Int32,System.Int32)
  commentId: M:System.Array.Sort``1(``0[],System.Int32,System.Int32)
  id: Sort``1(``0[],System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<T>(T[], Int32, Int32)
  fullName: System.Array.Sort<T>(T[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1760
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in a range of elements in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation of each element of the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Each element within the specified range of elements in <em>array</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``1(``0[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload for sorting a range in an array. </p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise). The <xref href=\"System.Array.Sort``1(``0[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is used to sort the last three elements of the array, which is then displayed. The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is used with <code>ReverseCompare</code> to sort the last three elements in reverse order. The thoroughly confused dinosaurs are displayed again.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_SortIntIntIComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<T>(T[] array, int index, int length)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of T)(array As T(), index As Integer, length As Integer)
    parameters:
    - id: array
      type: '{T}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of T)(T(), System.Int32, System.Int32)
  name.vb: Sort(Of T)(T(), Int32, Int32)
- uid: System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  id: Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<T>(T[], Int32, Int32, IComparer<T>)
  fullName: System.Array.Sort<T>(T[], System.Int32, System.Int32, System.Collections.Generic.IComparer<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1786
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts the elements in a range of elements in an <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>If <em>comparer</em> is <strong>null</strong>, each element within the specified range of elements in <em>array</em> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other element in <em>array</em>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``1(``0[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload and the <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload for sorting a range in an array. </p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise). The <xref href=\"System.Array.Sort``1(``0[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is used to sort the last three elements of the array, which is then displayed. The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overload is used with <code>ReverseCompare</code> to sort the last three elements in reverse order. The thoroughly confused dinosaurs are displayed again.</p>\n<p>The calls to the <xref href=\"System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_SortIntIntIComparer#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<T>(T[] array, int index, int length, IComparer<T> comparer)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of T)(array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))
    parameters:
    - id: array
      type: '{T}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: comparer
      type: System.Collections.Generic.IComparer{{T}}
    typeParameters:
    - id: T
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>array</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in <em>array</em>. </p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in <em>array</em> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of T)(T(), System.Int32, System.Int32, System.Collections.Generic.IComparer(Of T))
  name.vb: Sort(Of T)(T(), Int32, Int32, IComparer(Of T))
- uid: System.Array.Sort``2(``0[],``1[])
  commentId: M:System.Array.Sort``2(``0[],``1[])
  id: Sort``2(``0[],``1[])
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<TKey, TValue>(TKey[], TValue[])
  fullName: System.Array.Sort<TKey, TValue>(TKey[], TValue[])
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1752
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a pair of <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation of each key.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an<xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overloads, for sorting pairs of arrays that represent keys and values.</p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values). The arrays are then sorted and displayed several times:</p>\n<ul><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort both arrays in order of the dinosaur names in the first array. </p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload and an instance of <code>ReverseCompare</code> are used to reverse the sort order of the paired arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays in reverse order.</p>\n</li></ul>\n<p>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_Sort2IntIntIComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of TKey, TValue)(keys As TKey(), items As TValue())
    parameters:
    - id: keys
      type: '{TKey}[]'
    - id: items
      type: '{TValue}[]'
    typeParameters:
    - id: TKey
    - id: TValue
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the lower bound of <em>keys</em> does not match the lower bound of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  - type: System.Collections.Generic.IDictionary`2
    commentId: T:System.Collections.Generic.IDictionary`2
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of TKey, TValue)(TKey(), TValue())
  name.vb: Sort(Of TKey, TValue)(TKey(), TValue())
- uid: System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})
  id: Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<TKey, TValue>(TKey[], TValue[], IComparer<TKey>)
  fullName: System.Array.Sort<TKey, TValue>(TKey[], TValue[], System.Collections.Generic.IComparer<TKey>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1778
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a pair of <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref>,<xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overloads, for sorting pairs of arrays that represent keys and values.</p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values). The arrays are then sorted and displayed several times:</p>\n<ul><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort both arrays in order of the dinosaur names in the first array. </p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload and an instance of <code>ReverseCompare</code> are used to reverse the sort order of the paired arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays in reverse order.</p>\n</li></ul>\n<p>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_Sort2IntIntIComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, IComparer<TKey> comparer)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of TKey, TValue)(keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))
    parameters:
    - id: keys
      type: '{TKey}[]'
    - id: items
      type: '{TValue}[]'
    - id: comparer
      type: System.Collections.Generic.IComparer{{TKey}}
    typeParameters:
    - id: TKey
    - id: TValue
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the lower bound of <em>keys</em> does not match the lower bound of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of TKey, TValue)(TKey(), TValue(), System.Collections.Generic.IComparer(Of TKey))
  name.vb: Sort(Of TKey, TValue)(TKey(), TValue(), IComparer(Of TKey))
- uid: System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)
  commentId: M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)
  id: Sort``2(``0[],``1[],System.Int32,System.Int32)
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<TKey, TValue>(TKey[], TValue[], Int32, Int32)
  fullName: System.Array.Sort<TKey, TValue>(TKey[], TValue[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1765
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a range of elements in a pair of <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface implementation of each key.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>Each key within the specified range of elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the<xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overloads, for sorting pairs of arrays that represent keys and values.</p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code> (<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values). The arrays are then sorted and displayed several times:</p>\n<ul><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort both arrays in order of the dinosaur names in the first array. </p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload and an instance of <code>ReverseCompare</code> are used to reverse the sort order of the paired arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays in reverse order.</p>\n</li></ul>\n<p>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_Sort2IntIntIComparer#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of TKey, TValue)(keys As TKey(), items As TValue(), index As Integer, length As Integer)
    parameters:
    - id: keys
      type: '{TKey}[]'
    - id: items
      type: '{TValue}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    typeParameters:
    - id: TKey
    - id: TValue
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>keys</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the lower bound of <em>keys</em> does not match the lower bound of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and <em>index</em> and <em>length</em> do not specify a valid range in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>One or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of TKey, TValue)(TKey(), TValue(), System.Int32, System.Int32)
  name.vb: Sort(Of TKey, TValue)(TKey(), TValue(), Int32, Int32)
- uid: System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  commentId: M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  id: Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: Sort<TKey, TValue>(TKey[], TValue[], Int32, Int32, IComparer<TKey>)
  fullName: System.Array.Sort<TKey, TValue>(TKey[], TValue[], System.Int32, System.Int32, System.Collections.Generic.IComparer<TKey>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Sort
    path: src/mscorlib/src/System/Array.cs
    startLine: 1808
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Sorts a range of elements in a pair of <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> using the specified <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  remarks: "\n<p>Each key in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> has a corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. When a key is repositioned during the sorting, the corresponding item in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is similarly repositioned. Therefore, the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> is sorted according to the arrangement of the corresponding keys in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If <em>comparer</em> is <strong>null</strong>, each key within the specified range of elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> must implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface to be capable of comparisons with every other key.</p>\n<p>You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted. You cannot sort if there are more keys than items; doing this throws an <xref href=\"System.ArgumentException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the sort is not successfully completed, the results are undefined.</p>\n<p>This method uses the introspective sort (introsort) algorithm as follows:</p>\n<ul><li>\n<p>If the partition size is fewer than 16 elements, it uses an <see href=\"http://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</see> algorithm. </p>\n</li><li>\n<p>If the number of partitions exceeds 2 * LogN, where  N is the range of the input array, it uses a <see href=\"http://en.wikipedia.org/wiki/Heapsort\">Heapsort</see> algorithm.</p>\n</li><li>\n<p>Otherwise, it uses a <see href=\"http://en.wikipedia.org/wiki/Quicksort\">Quicksort</see> algorithm. </p>\n</li></ul>\n<p>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved. In contrast, a stable sort preserves the order of elements that are equal.</p>\n<p>For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(<em>n</em> log <em>n</em>) operation, where <em>n</em> is <em>length</em>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> generic method overloads, for sorting pairs of arrays that represent keys and values.</p>\n<p>The code example defines an alternative comparer for strings, named <code>ReverseCompare</code>, which implements the <code>IComparer<string></code>(<code>IComparer(Of String)</code> in Visual Basic, <code>IComparer<String^></code> in Visual C++) generic interface. The comparer calls the <xref href=\"System.String.CompareTo(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</p>\n<p>The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values). The arrays are then sorted and displayed several times:</p>\n<ul><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[])\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort both arrays in order of the dinosaur names in the first array. </p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload and an instance of <code>ReverseCompare</code> are used to reverse the sort order of the paired arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays.</p>\n</li><li>\n<p>The <xref href=\"System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})\" data-throw-if-not-resolved=\"false\"></xref> overload is used to sort the last three elements of both arrays in reverse order.</p>\n</li></ul>\n<p>The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments. If you use the Ildasm.exe (IL Disassembler) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</p>Array_Sort2IntIntIComparer#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      public static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, IComparer<TKey> comparer)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      Public Shared Sub Sort(Of TKey, TValue)(keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))
    parameters:
    - id: keys
      type: '{TKey}[]'
    - id: items
      type: '{TValue}[]'
    - id: index
      type: System.Int32
    - id: length
      type: System.Int32
    - id: comparer
      type: System.Collections.Generic.IComparer{{TKey}}
    typeParameters:
    - id: TKey
    - id: TValue
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>keys</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is less than the lower bound of <em>keys</em>.</p>\n<p>-or-</p>\n<p>\n<em>length</em> is less than zero.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>items</em> is not <strong>null</strong>, and the lower bound of <em>keys</em> does not match the lower bound of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and the length of <em>keys</em> is greater than the length of <em>items</em>.</p>\n<p>-or-</p>\n<p>\n<em>index</em> and <em>length</em> do not specify a valid range in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>\n<em>items</em> is not <strong>null</strong>, and <em>index</em> and <em>length</em> do not specify a valid range in the <em>items</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>-or-</p>\n<p>The implementation of <em>comparer</em> caused an error during the sort. For example, <em>comparer</em> might not return 0 when comparing an item with itself.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>\n<em>comparer</em> is <strong>null</strong>, and one or more elements in the <em>keys</em><xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> do not implement the <xref href=\"System.IComparable`1\" data-throw-if-not-resolved=\"false\"></xref> generic interface.</p>\n"
  seealso:
  - type: System.Collections.Generic.IComparer`1
    commentId: T:System.Collections.Generic.IComparer`1
  - type: System.IComparable`1
    commentId: T:System.IComparable`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.Sort(Of TKey, TValue)(TKey(), TValue(), System.Int32, System.Int32, System.Collections.Generic.IComparer(Of TKey))
  name.vb: Sort(Of TKey, TValue)(TKey(), TValue(), Int32, Int32, IComparer(Of TKey))
- uid: System.Array.System#Collections#IList#Add(System.Object)
  commentId: M:System.Array.System#Collections#IList#Add(System.Object)
  id: System#Collections#IList#Add(System.Object)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Add(Object)
  fullName: System.Array.System.Collections.IList.Add(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.Add
    path: src/mscorlib/src/System/Array.cs
    startLine: 693
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Calling this method always throws a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> exception. </p>\n"
  remarks: "\n<p>Ordinarily, an <xref href=\"System.Collections.IList.Add(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> implementation adds a member to a collection. However, because arrays have a fixed size (the <xref href=\"System.Array.IsFixedSize\" data-throw-if-not-resolved=\"false\"></xref> property always returns <strong>true</strong>), this method always throws a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> exception. </p>\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: int IList.Add(object value)
    content.vb: Function System.Collections.IList.Add(value As Object) As Integer Implements IList.Add
    parameters:
    - id: value
      type: System.Object
    return:
      type: System.Int32
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> has a fixed size.</p>\n"
  implements:
  - System.Collections.IList.Add(System.Object)
  name.vb: System.Collections.IList.Add(Object)
- uid: System.Array.System#Collections#IList#Clear
  commentId: M:System.Array.System#Collections#IList#Clear
  id: System#Collections#IList#Clear
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Clear()
  fullName: System.Array.System.Collections.IList.Clear()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.Clear
    path: src/mscorlib/src/System/Array.cs
    startLine: 703
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Removes all items from the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: void IList.Clear()
    content.vb: Sub System.Collections.IList.Clear Implements IList.Clear
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> is read-only.</p>\n"
  implements:
  - System.Collections.IList.Clear
  name.vb: System.Collections.IList.Clear()
- uid: System.Array.System#Collections#IList#Contains(System.Object)
  commentId: M:System.Array.System#Collections#IList#Contains(System.Object)
  id: System#Collections#IList#Contains(System.Object)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Contains(Object)
  fullName: System.Array.System.Collections.IList.Contains(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.Contains
    path: src/mscorlib/src/System/Array.cs
    startLine: 698
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether an element is in the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: bool IList.Contains(object value)
    content.vb: Function System.Collections.IList.Contains(value As Object) As Boolean Implements IList.Contains
    parameters:
    - id: value
      type: System.Object
    return:
      type: System.Boolean
  implements:
  - System.Collections.IList.Contains(System.Object)
  name.vb: System.Collections.IList.Contains(Object)
- uid: System.Array.System#Collections#IList#IndexOf(System.Object)
  commentId: M:System.Array.System#Collections#IList#IndexOf(System.Object)
  id: System#Collections#IList#IndexOf(System.Object)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.IndexOf(Object)
  fullName: System.Array.System.Collections.IList.IndexOf(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.IndexOf
    path: src/mscorlib/src/System/Array.cs
    startLine: 708
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines the index of a specific item in the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: int IList.IndexOf(object value)
    content.vb: Function System.Collections.IList.IndexOf(value As Object) As Integer Implements IList.IndexOf
    parameters:
    - id: value
      type: System.Object
    return:
      type: System.Int32
  implements:
  - System.Collections.IList.IndexOf(System.Object)
  name.vb: System.Collections.IList.IndexOf(Object)
- uid: System.Array.System#Collections#IList#Insert(System.Int32,System.Object)
  commentId: M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)
  id: System#Collections#IList#Insert(System.Int32,System.Object)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Insert(Int32, Object)
  fullName: System.Array.System.Collections.IList.Insert(System.Int32, System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.Insert
    path: src/mscorlib/src/System/Array.cs
    startLine: 713
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Inserts an item to the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> at the specified index.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: void IList.Insert(int index, object value)
    content.vb: Sub System.Collections.IList.Insert(index As Integer, value As Object) Implements IList.Insert
    parameters:
    - id: index
      type: System.Int32
    - id: value
      type: System.Object
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> is not a valid index in the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> is read-only.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> has a fixed size. </p>\n"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>\n<em>value</em> is null reference in the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  implements:
  - System.Collections.IList.Insert(System.Int32,System.Object)
  name.vb: System.Collections.IList.Insert(Int32, Object)
- uid: System.Array.System#Collections#IList#Remove(System.Object)
  commentId: M:System.Array.System#Collections#IList#Remove(System.Object)
  id: System#Collections#IList#Remove(System.Object)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.Remove(Object)
  fullName: System.Array.System.Collections.IList.Remove(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.Remove
    path: src/mscorlib/src/System/Array.cs
    startLine: 718
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Removes the first occurrence of a specific object from the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n<p></p>\n"
  syntax:
    content: void IList.Remove(object value)
    content.vb: Sub System.Collections.IList.Remove(value As Object) Implements IList.Remove
    parameters:
    - id: value
      type: System.Object
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> is read-only.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> has a fixed size. </p>\n"
  implements:
  - System.Collections.IList.Remove(System.Object)
  name.vb: System.Collections.IList.Remove(Object)
- uid: System.Array.System#Collections#IList#RemoveAt(System.Int32)
  commentId: M:System.Array.System#Collections#IList#RemoveAt(System.Int32)
  id: System#Collections#IList#RemoveAt(System.Int32)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IList.RemoveAt(Int32)
  fullName: System.Array.System.Collections.IList.RemoveAt(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IList.RemoveAt
    path: src/mscorlib/src/System/Array.cs
    startLine: 723
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Removes the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> item at the specified index.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: void IList.RemoveAt(int index)
    content.vb: Sub System.Collections.IList.RemoveAt(index As Integer) Implements IList.RemoveAt
    parameters:
    - id: index
      type: System.Int32
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>index is not a valid index in the <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> is read-only.</p>\n<p>-or- </p>\n<p>The <xref href=\"System.Collections.IList\" data-throw-if-not-resolved=\"false\"></xref> has a fixed size.</p>\n"
  implements:
  - System.Collections.IList.RemoveAt(System.Int32)
  name.vb: System.Collections.IList.RemoveAt(Int32)
- uid: System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)
  commentId: M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)
  id: System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IStructuralComparable.CompareTo(Object, IComparer)
  fullName: System.Array.System.Collections.IStructuralComparable.CompareTo(System.Object, System.Collections.IComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IStructuralComparable.CompareTo
    path: src/mscorlib/src/System/Array.cs
    startLine: 735
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an <xref href=\"System.Collections.IStructuralComparable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  syntax:
    content: int IStructuralComparable.CompareTo(object other, IComparer comparer)
    content.vb: Function System.Collections.IStructuralComparable.CompareTo(other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo
    parameters:
    - id: other
      type: System.Object
    - id: comparer
      type: System.Collections.IComparer
    return:
      type: System.Int32
  implements:
  - System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)
  name.vb: System.Collections.IStructuralComparable.CompareTo(Object, IComparer)
- uid: System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)
  commentId: M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)
  id: System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IStructuralEquatable.Equals(Object, IEqualityComparer)
  fullName: System.Array.System.Collections.IStructuralEquatable.Equals(System.Object, System.Collections.IEqualityComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IStructuralEquatable.Equals
    path: src/mscorlib/src/System/Array.cs
    startLine: 760
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether an object is equal to the current instance.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an<xref href=\"System.Collections.IStructuralEquatable\" data-throw-if-not-resolved=\"false\"></xref>interface.</p>\n"
  syntax:
    content: bool IStructuralEquatable.Equals(object other, IEqualityComparer comparer)
    content.vb: Function System.Collections.IStructuralEquatable.Equals(other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals
    parameters:
    - id: other
      type: System.Object
    - id: comparer
      type: System.Collections.IEqualityComparer
    return:
      type: System.Boolean
  implements:
  - System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)
  name.vb: System.Collections.IStructuralEquatable.Equals(Object, IEqualityComparer)
- uid: System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)
  commentId: M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)
  id: System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)
  isEii: true
  parent: System.Array
  langs:
  - csharp
  - vb
  name: IStructuralEquatable.GetHashCode(IEqualityComparer)
  fullName: System.Array.System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: System.Collections.IStructuralEquatable.GetHashCode
    path: src/mscorlib/src/System/Array.cs
    startLine: 795
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns a hash code for the current instance.</p>\n"
  remarks: "\n<p>This member is an explicit interface member implementation. It can be used only when the <xref href=\"System.Array\" data-throw-if-not-resolved=\"false\"></xref> instance is cast to an<xref href=\"System.Collections.IStructuralEquatable\" data-throw-if-not-resolved=\"false\"></xref>interface.</p>\n"
  example:
  - 
  syntax:
    content: int IStructuralEquatable.GetHashCode(IEqualityComparer comparer)
    content.vb: Function System.Collections.IStructuralEquatable.GetHashCode(comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode
    parameters:
    - id: comparer
      type: System.Collections.IEqualityComparer
    return:
      type: System.Int32
  implements:
  - System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
  name.vb: System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer)
- uid: System.Array.TrueForAll``1(``0[],System.Predicate{``0})
  commentId: M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})
  id: TrueForAll``1(``0[],System.Predicate{``0})
  parent: System.Array
  langs:
  - csharp
  - vb
  name: TrueForAll<T>(T[], Predicate<T>)
  fullName: System.Array.TrueForAll<T>(T[], System.Predicate<T>)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Array.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TrueForAll
    path: src/mscorlib/src/System/Array.cs
    startLine: 1850
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether every element in the array matches the conditions defined by the specified predicate.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> is a delegate to a method that returns<strong>true</strong> if the object passed to it matches the conditions defined in the delegate.  The elements of <em>array</em> are individually passed to the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref>, and processing is stopped when the delegate returns <strong>false</strong> for any element. </p>\n<p>This method is an O(<em>n</em>) operation, where <em>n</em> is the <xref href=\"System.Array.Length\" data-throw-if-not-resolved=\"false\"></xref> of <em>array</em>.</p>\n"
  example:
  - "\n<p>The following example determines whether the last character of each element in a string array is a number. It creates two string arrays. The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters. The example also defines an <code>EndWithANumber</code> method whose signature matches the <xref href=\"System.Predicate`1\" data-throw-if-not-resolved=\"false\"></xref> delegate. The example passes each array to the <xref href=\"System.Array.TrueForAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method along with a delegate that represents the <code>EndsWithANumber</code> method. </p>System.Array.TrueForAll#2<p>The following example is similar to the first, except that it passes the string array to the <xref href=\"System.Array.TrueForAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number. </p>System.Array.TrueForAll#1<p>In both cases, the <xref href=\"System.Array.TrueForAll``1(``0[],System.Predicate{``0})\" data-throw-if-not-resolved=\"false\"></xref> method returns <strong>false</strong> as soon as it encounters the first array element that does not end in a number. Otherwise, it returns <strong>true</strong> after iterating all the elements in the array.</p><p>As both examples show, in C# and Visual Basic, it is not necessary to create the <code>Predicate<string></code> delegate (<code>Predicate(Of String)</code> in Visual Basic) explicitly. These languages infer the correct delegate from context and create it automatically. </p>"
  syntax:
    content: public static bool TrueForAll<T>(T[] array, Predicate<T> match)
    content.vb: Public Shared Function TrueForAll(Of T)(array As T(), match As Predicate(Of T)) As Boolean
    parameters:
    - id: array
      type: '{T}[]'
    - id: match
      type: System.Predicate{{T}}
    typeParameters:
    - id: T
    return:
      type: System.Boolean
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>array</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>match</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Array.Exists``1(``0[],System.Predicate{``0})
    commentId: M:System.Array.Exists``1(``0[],System.Predicate{``0})
  - type: System.Predicate`1
    commentId: T:System.Predicate`1
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Array.TrueForAll(Of T)(T(), System.Predicate(Of T))
  name.vb: TrueForAll(Of T)(T(), Predicate(Of T))
references:
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Collections.IList
  parent: System.Collections
  isExternal: false
  name: IList
  fullName: System.Collections.IList
- uid: System.Collections.ICollection
  parent: System.Collections
  isExternal: false
  name: ICollection
  fullName: System.Collections.ICollection
- uid: System.Collections.IEnumerable
  parent: System.Collections
  isExternal: false
  name: IEnumerable
  fullName: System.Collections.IEnumerable
- uid: System.Collections.IStructuralComparable
  parent: System.Collections
  isExternal: false
  name: IStructuralComparable
  fullName: System.Collections.IStructuralComparable
- uid: System.Collections.IStructuralEquatable
  parent: System.Collections
  isExternal: false
  name: IStructuralEquatable
  fullName: System.Collections.IStructuralEquatable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections
  isExternal: false
  name: System.Collections
  fullName: System.Collections
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Collections.ICollection.Count
  parent: System.Collections.ICollection
  isExternal: false
  name: Count
  fullName: System.Collections.ICollection.Count
- uid: System.Collections.ICollection.IsSynchronized
  parent: System.Collections.ICollection
  isExternal: false
  name: IsSynchronized
  fullName: System.Collections.ICollection.IsSynchronized
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Collections.ICollection.SyncRoot
  parent: System.Collections.ICollection
  isExternal: false
  name: SyncRoot
  fullName: System.Collections.ICollection.SyncRoot
- uid: System.Collections.IList.IsFixedSize
  parent: System.Collections.IList
  isExternal: false
  name: IsFixedSize
  fullName: System.Collections.IList.IsFixedSize
- uid: System.Collections.IList.IsReadOnly
  parent: System.Collections.IList
  isExternal: false
  name: IsReadOnly
  fullName: System.Collections.IList.IsReadOnly
- uid: System.Collections.IList.Item(System.Int32)
  parent: System.Collections.IList
  isExternal: true
  name: Item[Int32]
  fullName: System.Collections.IList.Item[System.Int32]
  fullname.vb: System.Collections.IList.Item(System.Int32)
  name.vb: Item(Int32)
  spec.csharp:
  - uid: System.Collections.IList.Item(System.Int32)
    name: Item
    fullName: System.Collections.IList.Item
  - name: '['
    fullName: '['
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: ']'
    fullName: ']'
  spec.vb:
  - uid: System.Collections.IList.Item(System.Int32)
    name: Item
    fullName: System.Collections.IList.Item
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Array
  parent: System
  isExternal: false
  name: Array
  fullName: System.Array
- uid: System.Collections.IComparer
  parent: System.Collections
  isExternal: false
  name: IComparer
  fullName: System.Collections.IComparer
- uid: '{T}[]'
  isExternal: false
  name: T[]
  fullName: T[]
  fullname.vb: T()
  name.vb: T()
  spec.csharp:
  - name: T
    fullName: T
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - name: T
    fullName: T
  - name: ()
    fullName: ()
- uid: '{T}'
  isExternal: false
  name: T
  fullName: T
- uid: System.Collections.Generic.IComparer{{T}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IComparer`1
  name: IComparer<T>
  fullName: System.Collections.Generic.IComparer<T>
  fullname.vb: System.Collections.Generic.IComparer(Of T)
  name.vb: IComparer(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic.IComparer`1
  parent: System.Collections.Generic
  isExternal: false
  name: IComparer<T>
  fullName: System.Collections.Generic.IComparer<T>
  fullname.vb: System.Collections.Generic.IComparer(Of T)
  name.vb: IComparer(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
  parent: System.Collections.ICollection
  isExternal: true
  name: CopyTo(Array, Int32)
  fullName: System.Collections.ICollection.CopyTo(System.Array, System.Int32)
  spec.csharp:
  - uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
    name: CopyTo
    fullName: System.Collections.ICollection.CopyTo
  - name: (
    fullName: (
  - uid: System.Array
    name: Array
    fullName: System.Array
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.ICollection.CopyTo(System.Array,System.Int32)
    name: CopyTo
    fullName: System.Collections.ICollection.CopyTo
  - name: (
    fullName: (
  - uid: System.Array
    name: Array
    fullName: System.Array
  - name: ', '
    fullName: ', '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  fullName: System.Type
- uid: System.Int32[]
  isExternal: true
  name: Int32[]
  fullName: System.Int32[]
  fullname.vb: System.Int32()
  name.vb: Int32()
  spec.csharp:
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Predicate{{T}}
  parent: System
  definition: System.Predicate`1
  name: Predicate<T>
  fullName: System.Predicate<T>
  fullname.vb: System.Predicate(Of T)
  name.vb: Predicate(Of T)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    fullName: System.Predicate
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    fullName: System.Predicate
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Predicate`1
  parent: System
  isExternal: false
  name: Predicate<T>
  fullName: System.Predicate<T>
  fullname.vb: System.Predicate(Of T)
  name.vb: Predicate(Of T)
  spec.csharp:
  - uid: System.Predicate`1
    name: Predicate
    fullName: System.Predicate
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Predicate`1
    name: Predicate
    fullName: System.Predicate
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.IEnumerable.GetEnumerator
  parent: System.Collections.IEnumerable
  isExternal: false
  name: GetEnumerator()
  fullName: System.Collections.IEnumerable.GetEnumerator()
  spec.csharp:
  - uid: System.Collections.IEnumerable.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.IEnumerable.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IEnumerable.GetEnumerator
    name: GetEnumerator
    fullName: System.Collections.IEnumerable.GetEnumerator
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.IEnumerator
  parent: System.Collections
  isExternal: false
  name: IEnumerator
  fullName: System.Collections.IEnumerator
- uid: System.Comparison{{T}}
  parent: System
  definition: System.Comparison`1
  name: Comparison<T>
  fullName: System.Comparison<T>
  fullname.vb: System.Comparison(Of T)
  name.vb: Comparison(Of T)
  spec.csharp:
  - uid: System.Comparison`1
    name: Comparison
    fullName: System.Comparison
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Comparison`1
    name: Comparison
    fullName: System.Comparison
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Comparison`1
  parent: System
  isExternal: false
  name: Comparison<T>
  fullName: System.Comparison<T>
  fullname.vb: System.Comparison(Of T)
  name.vb: Comparison(Of T)
  spec.csharp:
  - uid: System.Comparison`1
    name: Comparison
    fullName: System.Comparison
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Comparison`1
    name: Comparison
    fullName: System.Comparison
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: '{TKey}[]'
  isExternal: false
  name: TKey[]
  fullName: TKey[]
  fullname.vb: TKey()
  name.vb: TKey()
  spec.csharp:
  - name: TKey
    fullName: TKey
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - name: TKey
    fullName: TKey
  - name: ()
    fullName: ()
- uid: '{TValue}[]'
  isExternal: false
  name: TValue[]
  fullName: TValue[]
  fullname.vb: TValue()
  name.vb: TValue()
  spec.csharp:
  - name: TValue
    fullName: TValue
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - name: TValue
    fullName: TValue
  - name: ()
    fullName: ()
- uid: System.Collections.Generic.IComparer{{TKey}}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IComparer`1
  name: IComparer<TKey>
  fullName: System.Collections.Generic.IComparer<TKey>
  fullname.vb: System.Collections.Generic.IComparer(Of TKey)
  name.vb: IComparer(Of TKey)
  spec.csharp:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: <
    fullName: <
  - name: TKey
    fullName: TKey
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IComparer`1
    name: IComparer
    fullName: System.Collections.Generic.IComparer
  - name: '(Of '
    fullName: '(Of '
  - name: TKey
    fullName: TKey
  - name: )
    fullName: )
- uid: System.Collections.IList.Add(System.Object)
  parent: System.Collections.IList
  isExternal: true
  name: Add(Object)
  fullName: System.Collections.IList.Add(System.Object)
  spec.csharp:
  - uid: System.Collections.IList.Add(System.Object)
    name: Add
    fullName: System.Collections.IList.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.Add(System.Object)
    name: Add
    fullName: System.Collections.IList.Add
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IList.Clear
  parent: System.Collections.IList
  isExternal: false
  name: Clear()
  fullName: System.Collections.IList.Clear()
  spec.csharp:
  - uid: System.Collections.IList.Clear
    name: Clear
    fullName: System.Collections.IList.Clear
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.Clear
    name: Clear
    fullName: System.Collections.IList.Clear
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Collections.IList.Contains(System.Object)
  parent: System.Collections.IList
  isExternal: true
  name: Contains(Object)
  fullName: System.Collections.IList.Contains(System.Object)
  spec.csharp:
  - uid: System.Collections.IList.Contains(System.Object)
    name: Contains
    fullName: System.Collections.IList.Contains
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.Contains(System.Object)
    name: Contains
    fullName: System.Collections.IList.Contains
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IList.IndexOf(System.Object)
  parent: System.Collections.IList
  isExternal: true
  name: IndexOf(Object)
  fullName: System.Collections.IList.IndexOf(System.Object)
  spec.csharp:
  - uid: System.Collections.IList.IndexOf(System.Object)
    name: IndexOf
    fullName: System.Collections.IList.IndexOf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.IndexOf(System.Object)
    name: IndexOf
    fullName: System.Collections.IList.IndexOf
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IList.Insert(System.Int32,System.Object)
  parent: System.Collections.IList
  isExternal: true
  name: Insert(Int32, Object)
  fullName: System.Collections.IList.Insert(System.Int32, System.Object)
  spec.csharp:
  - uid: System.Collections.IList.Insert(System.Int32,System.Object)
    name: Insert
    fullName: System.Collections.IList.Insert
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.Insert(System.Int32,System.Object)
    name: Insert
    fullName: System.Collections.IList.Insert
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IList.Remove(System.Object)
  parent: System.Collections.IList
  isExternal: true
  name: Remove(Object)
  fullName: System.Collections.IList.Remove(System.Object)
  spec.csharp:
  - uid: System.Collections.IList.Remove(System.Object)
    name: Remove
    fullName: System.Collections.IList.Remove
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.Remove(System.Object)
    name: Remove
    fullName: System.Collections.IList.Remove
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IList.RemoveAt(System.Int32)
  parent: System.Collections.IList
  isExternal: true
  name: RemoveAt(Int32)
  fullName: System.Collections.IList.RemoveAt(System.Int32)
  spec.csharp:
  - uid: System.Collections.IList.RemoveAt(System.Int32)
    name: RemoveAt
    fullName: System.Collections.IList.RemoveAt
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IList.RemoveAt(System.Int32)
    name: RemoveAt
    fullName: System.Collections.IList.RemoveAt
  - name: (
    fullName: (
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)
  parent: System.Collections.IStructuralComparable
  isExternal: true
  name: CompareTo(Object, IComparer)
  fullName: System.Collections.IStructuralComparable.CompareTo(System.Object, System.Collections.IComparer)
  spec.csharp:
  - uid: System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)
    name: CompareTo
    fullName: System.Collections.IStructuralComparable.CompareTo
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Collections.IComparer
    name: IComparer
    fullName: System.Collections.IComparer
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)
    name: CompareTo
    fullName: System.Collections.IStructuralComparable.CompareTo
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Collections.IComparer
    name: IComparer
    fullName: System.Collections.IComparer
  - name: )
    fullName: )
- uid: System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)
  parent: System.Collections.IStructuralEquatable
  isExternal: true
  name: Equals(Object, IEqualityComparer)
  fullName: System.Collections.IStructuralEquatable.Equals(System.Object, System.Collections.IEqualityComparer)
  spec.csharp:
  - uid: System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)
    name: Equals
    fullName: System.Collections.IStructuralEquatable.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Collections.IEqualityComparer
    name: IEqualityComparer
    fullName: System.Collections.IEqualityComparer
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)
    name: Equals
    fullName: System.Collections.IStructuralEquatable.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Collections.IEqualityComparer
    name: IEqualityComparer
    fullName: System.Collections.IEqualityComparer
  - name: )
    fullName: )
- uid: System.Collections.IEqualityComparer
  parent: System.Collections
  isExternal: false
  name: IEqualityComparer
  fullName: System.Collections.IEqualityComparer
- uid: System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
  parent: System.Collections.IStructuralEquatable
  isExternal: false
  name: GetHashCode(IEqualityComparer)
  fullName: System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
  spec.csharp:
  - uid: System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
    name: GetHashCode
    fullName: System.Collections.IStructuralEquatable.GetHashCode
  - name: (
    fullName: (
  - uid: System.Collections.IEqualityComparer
    name: IEqualityComparer
    fullName: System.Collections.IEqualityComparer
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)
    name: GetHashCode
    fullName: System.Collections.IStructuralEquatable.GetHashCode
  - name: (
    fullName: (
  - uid: System.Collections.IEqualityComparer
    name: IEqualityComparer
    fullName: System.Collections.IEqualityComparer
  - name: )
    fullName: )
- uid: System.OverflowException
  isExternal: false
  name: OverflowException
  fullName: System.OverflowException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.RankException
  isExternal: false
  name: RankException
  fullName: System.RankException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.IndexOutOfRangeException
  isExternal: false
  name: IndexOutOfRangeException
  fullName: System.IndexOutOfRangeException
- uid: System.ArrayTypeMismatchException
  isExternal: false
  name: ArrayTypeMismatchException
  fullName: System.ArrayTypeMismatchException
- uid: System.InvalidCastException
  isExternal: false
  name: InvalidCastException
  fullName: System.InvalidCastException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.NullReferenceException
  isExternal: false
  name: NullReferenceException
  fullName: System.NullReferenceException
