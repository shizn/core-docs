items:
- uid: System.Runtime.InteropServices.SafeHandle
  commentId: T:System.Runtime.InteropServices.SafeHandle
  id: SafeHandle
  parent: System.Runtime.InteropServices
  children:
  - System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)
  - System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)
  - System.Runtime.InteropServices.SafeHandle.DangerousGetHandle
  - System.Runtime.InteropServices.SafeHandle.DangerousRelease
  - System.Runtime.InteropServices.SafeHandle.Dispose
  - System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)
  - System.Runtime.InteropServices.SafeHandle.Finalize
  - System.Runtime.InteropServices.SafeHandle.handle
  - System.Runtime.InteropServices.SafeHandle.IsClosed
  - System.Runtime.InteropServices.SafeHandle.IsInvalid
  - System.Runtime.InteropServices.SafeHandle.ReleaseHandle
  - System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)
  - System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid
  langs:
  - csharp
  - vb
  name: SafeHandle
  fullName: System.Runtime.InteropServices.SafeHandle
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: SafeHandle
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 136
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Represents a wrapper class for operating system handles. This class must be inherited.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects. </p>\n<p>This topic includes the following sections: </p>\n<p>Why SafeHandle?What SafeHandle doesClasses derived from SafeHandle</p>\n"
  example:
  - >-
    <p>The following code example creates a custom safe handle for an operating system file handle, deriving from <xref href="Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid" data-throw-if-not-resolved="false"></xref>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <xref href="System.IntPtr" data-throw-if-not-resolved="false"></xref> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</p>

    <p>You will need a text file in the same folder as the compiled application. Assuming that you name the application "HexViewer", the command line usage is:</p>

    <p>

    <code>HexViewer <filename> -Fault</code>

    </p>

    <p>Optionally specify <code>-Fault</code> to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.</p>SafeHandle#1
  syntax:
    content: >-
      [SecurityCritical]

      public abstract class SafeHandle : CriticalFinalizerObject, IDisposable
    content.vb: >-
      <SecurityCritical>

      Public MustInherit Class SafeHandle
          Inherits CriticalFinalizerObject
          Implements IDisposable
  seealso:
  - type: Microsoft.Win32.SafeHandles
    commentId: N:Microsoft.Win32.SafeHandles
  - type: System.Runtime.InteropServices.CriticalHandle
    commentId: T:System.Runtime.InteropServices.CriticalHandle
  - type: System.Runtime.ConstrainedExecution.CriticalFinalizerObject
    commentId: T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject
  see:
  - type: System.Security.Permissions.SecurityAction.InheritanceDemand
    commentId: F:System.Security.Permissions.SecurityAction.InheritanceDemand
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Runtime.InteropServices.SafeHandle.handle
  commentId: F:System.Runtime.InteropServices.SafeHandle.handle
  id: handle
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: handle
  fullName: System.Runtime.InteropServices.SafeHandle.handle
  type: Field
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: handle
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 150
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Specifies the handle to be wrapped.</p>\n"
  remarks: "\n<p>Do not expose the handle publicly (that is, outside of the derived class).</p>\n"
  syntax:
    content: protected IntPtr handle
    content.vb: Protected handle As IntPtr
    return:
      type: System.IntPtr
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)
  commentId: M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)
  id: '#ctor(System.IntPtr,System.Boolean)'
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: SafeHandle(IntPtr, Boolean)
  fullName: System.Runtime.InteropServices.SafeHandle.SafeHandle(System.IntPtr, System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 160
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class with the specified invalid handle value.</p>\n"
  remarks: "\n<p>If the <em>ownsHandle</em> parameter is <strong>false</strong>, <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      Protected Sub New(invalidHandleValue As IntPtr, ownsHandle As Boolean)
    parameters:
    - id: invalidHandleValue
      type: System.IntPtr
    - id: ownsHandle
      type: System.Boolean
  exceptions:
  - type: System.TypeLoadException
    commentId: T:System.TypeLoadException
    description: "\n<p>The derived class resides in an assembly without unmanaged code access permission. </p>\n"
  see:
  - type: System.Security.Permissions.SecurityAction.InheritanceDemand
    commentId: F:System.Security.Permissions.SecurityAction.InheritanceDemand
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Runtime.InteropServices.SafeHandle.IsClosed
  commentId: P:System.Runtime.InteropServices.SafeHandle.IsClosed
  id: IsClosed
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: IsClosed
  fullName: System.Runtime.InteropServices.SafeHandle.IsClosed
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsClosed
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 228
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Gets a value indicating whether the handle is closed.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.IsClosed\" data-throw-if-not-resolved=\"false\"></xref> method returns a value indicating whether the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object's handle is no longer associated with a native resource. This differs from the definition of the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\" data-throw-if-not-resolved=\"false\"></xref> property, which computes whether a given handle is always considered invalid. The <xref href=\"System.Runtime.InteropServices.SafeHandle.IsClosed\" data-throw-if-not-resolved=\"false\"></xref> method returns a <strong>true</strong> value in the following cases:</p>\n<ul><li>\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\" data-throw-if-not-resolved=\"false\"></xref> method was called.</p>\n</li><li>\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method or <xref href=\"System.Runtime.InteropServices.SafeHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method was called and there are no references to the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object on other threads.</p>\n</li></ul>\n"
  syntax:
    content: >-
      public bool IsClosed

      {
          [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
          get;
      }
    content.vb: Public ReadOnly Property IsClosed As Boolean
    parameters: []
    return:
      type: System.Boolean
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Runtime.InteropServices.SafeHandle.IsInvalid
  commentId: P:System.Runtime.InteropServices.SafeHandle.IsInvalid
  id: IsInvalid
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: IsInvalid
  fullName: System.Runtime.InteropServices.SafeHandle.IsInvalid
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsInvalid
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 233
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>When overridden in a derived class, gets a value indicating whether the handle value is invalid.</p>\n"
  remarks: "\n<p>Derived classes must implement the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\" data-throw-if-not-resolved=\"false\"></xref> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.</p>\n<p>Unlike the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsClosed\" data-throw-if-not-resolved=\"false\"></xref> property, which reports whether the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object has finished using the underlying handle, the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\" data-throw-if-not-resolved=\"false\"></xref> property calculates whether the given handle value is always considered invalid. Therefore, the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\" data-throw-if-not-resolved=\"false\"></xref> property always returns the same value for any one handle value.</p>\n"
  example:
  - "\n<p>The following example checks if a file was opened successfully. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>SafeHandle#2"
  syntax:
    content: >-
      public abstract bool IsInvalid

      {
          [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
          get;
      }
    content.vb: Public MustOverride ReadOnly Property IsInvalid As Boolean
    parameters: []
    return:
      type: System.Boolean
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - abstract
  - get
  modifiers.vb:
  - Public
  - MustOverride
  - ReadOnly
- uid: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)
  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)
  id: DangerousAddRef(System.Boolean@)
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: DangerousAddRef(ref Boolean)
  fullName: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(ref System.Boolean)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Manually increments the reference counter on <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> instances.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> method). You can use this method to manually increment the reference count on a <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> instance. <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> returns a Boolean value using a <strong>ref</strong> parameter (<em>success</em>) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set <em>success</em> to <strong>false</strong> before calling <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref>. If <em>success</em> is <strong>true</strong>, avoid resource leaks by matching the call to <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> with a corresponding call to <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public void DangerousAddRef(ref bool success)
    content.vb: >-
      <SecurityCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.MayFail)>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Sub DangerousAddRef(ByRef success As Boolean)
    parameters:
    - id: success
      type: System.Boolean
  seealso:
  - type: System.Runtime.InteropServices.SafeHandle.DangerousRelease
    commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousRelease
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(ByRef System.Boolean)
  name.vb: DangerousAddRef(ByRef Boolean)
- uid: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle
  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle
  id: DangerousGetHandle
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: DangerousGetHandle()
  fullName: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: DangerousGetHandle
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 222
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\" data-throw-if-not-resolved=\"false\"></xref> field.</p>\n"
  remarks: "\n<p>You can use this method to retrieve the actual handle value from an instance of the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return <strong>IntPtr</strong> handle types. <strong>IntPtr</strong> handle types are platform-specific types used to represent a pointer or a handle.</p>\n<p>Using the <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\" data-throw-if-not-resolved=\"false\"></xref> method can pose security risks because, if the handle has been marked as invalid with <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\" data-throw-if-not-resolved=\"false\"></xref> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref> methods for more information about using the <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\" data-throw-if-not-resolved=\"false\"></xref> methodsafely.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public IntPtr DangerousGetHandle()
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Function DangerousGetHandle As IntPtr
    return:
      type: System.IntPtr
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Runtime.InteropServices.SafeHandle.DangerousRelease
  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousRelease
  id: DangerousRelease
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: DangerousRelease()
  fullName: System.Runtime.InteropServices.SafeHandle.DangerousRelease()
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Manually decrements the reference counter on a <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref> method is the counterpart to <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref>. You should always match a call to the <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref> method with a successful call to <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> calls can cause resource leaks, unmatched <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref> calls can cause invalid handle states to become visible to other threads. Do not expose <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.SafeHandle.DangerousRelease\" data-throw-if-not-resolved=\"false\"></xref> calls to untrusted code.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public void DangerousRelease()
    content.vb: >-
      <SecurityCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Sub DangerousRelease
  seealso:
  - type: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)
    commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Runtime.InteropServices.SafeHandle.Dispose
  commentId: M:System.Runtime.InteropServices.SafeHandle.Dispose
  id: Dispose
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Runtime.InteropServices.SafeHandle.Dispose()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 244
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Releases all resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Calling the <xref href=\"System.Runtime.InteropServices.SafeHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.SafeHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> critical finalizer runs.</p>\n<p>Call the <xref href=\"System.Runtime.InteropServices.SafeHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.SafeHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method when you are finished using the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object. The <xref href=\"System.Runtime.InteropServices.SafeHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> method leaves the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object in an unusable state.</p>\n<p>Always call the <xref href=\"System.Runtime.InteropServices.SafeHandle.Close\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.SafeHandle.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method before you release your last reference to the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> object's <xref href=\"System.Runtime.InteropServices.SafeHandle.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public void Dispose()
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Sub Dispose
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  implements:
  - System.IDisposable.Dispose
  attributes:
  - type: System.Security.SecuritySafeCriticalAttribute
    ctor: System.Security.SecuritySafeCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)
  commentId: M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 250
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class specifying whether to perform a normal dispose operation.</p>\n"
  remarks: "\n<p>You should never explicitly call the <xref href=\"System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method with the <em>disposing</em> parameter set to <strong>false</strong>.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      protected virtual void Dispose(bool disposing)
    content.vb: >-
      <SecurityCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Runtime.InteropServices.SafeHandle.ReleaseHandle
  commentId: M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle
  id: ReleaseHandle
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: ReleaseHandle()
  fullName: System.Runtime.InteropServices.SafeHandle.ReleaseHandle()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReleaseHandle
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 281
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>When overridden in a derived class, executes the code required to free the handle.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\" data-throw-if-not-resolved=\"false\"></xref> property. Implement this method in your <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> is to guarantee prevention of resource leaks, the code in your implementation of <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> must never fail. The garbage collector calls <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> method. In particular, apply the <xref href=\"System.Runtime.ConstrainedExecution.ReliabilityContractAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute to any methods you call from <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref>. In most cases this code should be:</p>\n<p>\n<code>ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)</code>\n</p>\n<p>Additionally, for simple cleanup (for example, calling the Win32 API <strong>CloseHandle</strong> on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.</p>\n<p>If <xref href=\"System.Runtime.InteropServices.SafeHandle.ReleaseHandle\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>false</strong> for any reason, it generates a releaseHandleFailed MDA Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.</p>\n"
  example:
  - "\n<p>The following code example releases the handle and is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class.</p>SafeHandle#3"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      protected abstract bool ReleaseHandle()
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Protected MustOverride Function ReleaseHandle As Boolean
    return:
      type: System.Boolean
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
- uid: System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)
  id: SetHandle(System.IntPtr)
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: SetHandle(IntPtr)
  fullName: System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: SetHandle
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 203
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Sets the handle to the specified pre-existing handle.</p>\n"
  remarks: "\n<p>Use the <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      protected void SetHandle(IntPtr handle)
    content.vb: >-
      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Protected Sub SetHandle(handle As IntPtr)
    parameters:
    - id: handle
      type: System.IntPtr
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid
  commentId: M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid
  id: SetHandleAsInvalid
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: SetHandleAsInvalid()
  fullName: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid()
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Marks a handle as no longer used.</p>\n"
  remarks: "\n<p>Call the <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\" data-throw-if-not-resolved=\"false\"></xref> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\" data-throw-if-not-resolved=\"false\"></xref> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.</p>\n<p>As with the <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method, use <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\" data-throw-if-not-resolved=\"false\"></xref> only if you need to support a pre-existing handle.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public void SetHandleAsInvalid()
    content.vb: >-
      <SecurityCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Sub SetHandleAsInvalid
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Runtime.InteropServices.SafeHandle.Finalize
  commentId: M:System.Runtime.InteropServices.SafeHandle.Finalize
  id: Finalize
  parent: System.Runtime.InteropServices.SafeHandle
  langs:
  - csharp
  - vb
  name: Finalize()
  fullName: System.Runtime.InteropServices.SafeHandle.Finalize()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Finalize
    path: src/mscorlib/src/System/Runtime/InteropServices/SafeHandle.cs
    startLine: 193
  assemblies:
  - System.Runtime.Handles
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees all resources associated with the handle.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.SafeHandle.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method is the destructor for the <xref href=\"System.Runtime.InteropServices.SafeHandle\" data-throw-if-not-resolved=\"false\"></xref> class. Application code should not call this method directly.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      protected void Finalize()
    content.vb: >-
      <SecuritySafeCritical>

      Protected Sub Finalize
  seealso:
  - type: System.Runtime.InteropServices.SafeHandle.Dispose
    commentId: M:System.Runtime.InteropServices.SafeHandle.Dispose
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
references:
- uid: System.Runtime.InteropServices
  isExternal: false
  name: System.Runtime.InteropServices
  fullName: System.Runtime.InteropServices
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.TypeLoadException
  parent: System
  isExternal: false
  name: TypeLoadException
  fullName: System.TypeLoadException
