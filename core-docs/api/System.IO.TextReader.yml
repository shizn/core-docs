items:
- uid: System.IO.TextReader
  commentId: T:System.IO.TextReader
  id: TextReader
  parent: System.IO
  children:
  - System.IO.TextReader.#ctor
  - System.IO.TextReader.Dispose
  - System.IO.TextReader.Dispose(System.Boolean)
  - System.IO.TextReader.Null
  - System.IO.TextReader.Peek
  - System.IO.TextReader.Read
  - System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)
  - System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)
  - System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)
  - System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  - System.IO.TextReader.ReadLine
  - System.IO.TextReader.ReadLineAsync
  - System.IO.TextReader.ReadToEnd
  - System.IO.TextReader.ReadToEndAsync
  langs:
  - csharp
  - vb
  name: TextReader
  fullName: System.IO.TextReader
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TextReader
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 35
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Represents a reader that can read a sequential series of characters.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is the abstract base class of <xref href=\"System.IO.StreamReader\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IO.StringReader\" data-throw-if-not-resolved=\"false\"></xref>, which read characters from streams and strings, respectively. Use these derived classes to open a text file for reading a specified range of characters, or to create a reader based on an existing stream. </p>\n<p>This type implements the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface. When you have finished using any type that derives from this type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref href=\"System.IO.TextReader.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method in a <strong>try</strong>/<strong>catch</strong> block. To dispose of it indirectly, use a language construct such as <strong>using</strong> (in C#) or <strong>Using</strong> (in Visual Basic). For more information, see Dispose and the “Using an Object that Implements IDisposable” section in the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface topic.</p>\n"
  example:
  - "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. The <xref href=\"System.IO.StreamReader\" data-throw-if-not-resolved=\"false\"></xref> class derives from <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> and provides implementations of the members for reading from a stream. The following example shows how to read all the characters in a file by using the <xref href=\"System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. It checks whether each character is a letter, digit, or white space before adding the character to an instance of the <xref href=\"System.Text.StringBuilder\" data-throw-if-not-resolved=\"false\"></xref> class.</p>System.IO.StreamReader#42"
  syntax:
    content: >-
      [Serializable]

      [ComVisible(true)]

      public abstract class TextReader : IDisposable
    content.vb: >-
      <Serializable>

      <ComVisible(True)>

      Public MustInherit Class TextReader
          Implements IDisposable
  seealso:
  - type: System.IO.StringReader
    commentId: T:System.IO.StringReader
  - type: System.IO.StreamReader
    commentId: T:System.IO.StreamReader
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.IO.TextReader.Null
  commentId: F:System.IO.TextReader.Null
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  fullName: System.IO.TextReader.Null
  type: Field
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 43
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Provides a <strong>TextReader</strong> with no data to read from.</p>\n"
  remarks: "\n<p>Reading from the <xref href=\"System.IO.TextReader.Null\" data-throw-if-not-resolved=\"false\"></xref> text reader is similar to reading from the end of a stream: </p>\n<ul><li>\n<p>The <xref href=\"System.IO.TextReader.Read\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.IO.TextReader.Peek\" data-throw-if-not-resolved=\"false\"></xref> methods return -1.</p>\n</li><li>\n<p>The <xref href=\"System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method returns zero.</p>\n</li><li>\n<p>The <xref href=\"System.IO.TextReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> method returns <strong>null</strong>.</p>\n</li><li>\n<p>The <xref href=\"System.IO.TextReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> method returns an empty string.</p>\n</li></ul>\n"
  syntax:
    content: public static readonly TextReader Null
    content.vb: Public Shared ReadOnly Null As TextReader
    return:
      type: System.IO.TextReader
  seealso:
  - type: System.IO.StringReader
    commentId: T:System.IO.StringReader
  - type: System.IO.StreamReader
    commentId: T:System.IO.StreamReader
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.IO.TextReader.#ctor
  commentId: M:System.IO.TextReader.#ctor
  id: '#ctor'
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: TextReader()
  fullName: System.IO.TextReader.TextReader()
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 45
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Use this constructor for derived classes.</p>\n"
  syntax:
    content: protected TextReader()
    content.vb: Protected Sub New
  seealso:
  - type: System.IO.StringReader
    commentId: T:System.IO.StringReader
  - type: System.IO.StreamReader
    commentId: T:System.IO.StreamReader
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.IO.TextReader.Dispose
  commentId: M:System.IO.TextReader.Dispose
  id: Dispose
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.IO.TextReader.Dispose()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 59
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Releases all resources used by the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>Call <xref href=\"System.IO.TextReader.Dispose\" data-throw-if-not-resolved=\"false\"></xref> when you are finished using the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.IO.TextReader.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method leaves the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> in an unusable state. After calling <xref href=\"System.IO.TextReader.Dispose\" data-throw-if-not-resolved=\"false\"></xref>, you must release all references to the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> so the garbage collector can reclaim the memory that the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> was occupying.</p>\n<p>For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>\n<p>Always call <xref href=\"System.IO.TextReader.Dispose\" data-throw-if-not-resolved=\"false\"></xref> before you release your last reference to the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> object's <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IO.TextReader.Dispose(System.Boolean)
  commentId: M:System.IO.TextReader.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.IO.TextReader.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 65
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> and optionally releases the managed resources.</p>\n"
  remarks: "\n<p>This method is called by the public <strong>Dispose</strong> method and the <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> method. By default, this method specifies the <em>disposing</em> parameter as <strong>true</strong>. <xref href=\"System.Object.Finalize\" data-throw-if-not-resolved=\"false\"></xref> specifies the <em>disposing</em> parameter as <strong>false</strong>.</p>\n<p>When the <em>disposing</em> parameter is <strong>true</strong>, this method releases all resources held by any managed objects that this <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> references. This method invokes the <strong>Dispose</strong> method of each referenced object.</p>\n"
  syntax:
    content: protected virtual void Dispose(bool disposing)
    content.vb: Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.IO.TextReader.Peek
  commentId: M:System.IO.TextReader.Peek
  id: Peek
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: Peek()
  fullName: System.IO.TextReader.Peek()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Peek
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 76
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads the next character without changing the state of the reader or the character source. Returns the next available character without actually reading it from the reader.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IO.TextReader.Peek\" data-throw-if-not-resolved=\"false\"></xref> method returns an integer value in order to determine whether the end of the file, or another error has occurred. This allows a user to first check if the returned value is -1 before casting it to a <xref href=\"System.Char\" data-throw-if-not-resolved=\"false\"></xref> type.</p>\n<p>The current position of the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is not changed by this operation. The returned value is -1 if no more characters are available. The default implementation returns -1.</p>\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.Peek\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.Peek\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public virtual int Peek()
    content.vb: Public Overridable Function Peek As Integer
    return:
      type: System.Int32
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  seealso:
  - type: System.IO.StreamReader.Peek
    commentId: M:System.IO.StreamReader.Peek
  - type: System.IO.StringReader.Peek
    commentId: M:System.IO.StringReader.Peek
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.IO.TextReader.Read
  commentId: M:System.IO.TextReader.Read
  id: Read
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: Read()
  fullName: System.IO.TextReader.Read()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Read
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 89
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads the next character from the text reader and advances the character position by one character.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.Read\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.Read\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public virtual int Read()
    content.vb: Public Overridable Function Read As Integer
    return:
      type: System.Int32
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  seealso:
  - type: System.IO.StreamReader.Read
    commentId: M:System.IO.StreamReader.Read
  - type: System.IO.StringReader.Read
    commentId: M:System.IO.StringReader.Read
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)
  commentId: M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)
  id: Read(System.Char[],System.Int32,System.Int32)
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: Read(Char[], Int32, Int32)
  fullName: System.IO.TextReader.Read(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Read
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 100
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a specified maximum number of characters from the current reader and writes the data to a buffer, beginning at the specified index.</p>\n"
  remarks: "\n<p>This method returns after either <em>count</em> characters are read or the end of the file is reached. <xref href=\"System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is a blocking version of this method.</p>\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public virtual int Read([In, Out] char[] buffer, int index, int count)
    content.vb: Public Overridable Function Read(buffer As Char(), index As Integer, count As Integer) As Integer
    parameters:
    - id: buffer
      type: System.Char[]
      attributes:
      - type: System.Runtime.InteropServices.InAttribute
        ctor: System.Runtime.InteropServices.InAttribute.#ctor
        arguments: []
      - type: System.Runtime.InteropServices.OutAttribute
        ctor: System.Runtime.InteropServices.OutAttribute.#ctor
        arguments: []
    - id: index
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The buffer length minus <em>index</em> is less than <em>count</em>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is negative. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  seealso:
  - type: System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)
  - type: System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StringReader.Read(System.Char[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.IO.TextReader.Read(System.Char(), System.Int32, System.Int32)
  name.vb: Read(Char(), Int32, Int32)
- uid: System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)
  commentId: M:System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)
  id: ReadAsync(System.Char[],System.Int32,System.Int32)
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadAsync(Char[], Int32, Int32)
  fullName: System.IO.TextReader.ReadAsync(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadAsync
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 203
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a specified maximum number of characters from the current text reader asynchronously and writes the data to a buffer, beginning at the specified index. </p>\n"
  remarks: "\n<p>The task completes after either the number of characters specified by the <em>count</em> parameter are read or the end of the file is reached. </p>\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.ReadAsync(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: >-
      [HostProtection(ExternalThreading = true)]

      [ComVisible(false)]

      public virtual Task<int> ReadAsync(char[] buffer, int index, int count)
    content.vb: >-
      <HostProtection(ExternalThreading:=True)>

      <ComVisible(False)>

      Public Overridable Function ReadAsync(buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)
    parameters:
    - id: buffer
      type: System.Char[]
    - id: index
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Threading.Tasks.Task{System.Int32}
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is negative.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The sum of <em>index</em> and <em>count</em> is larger than the buffer length.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The text reader has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The reader is currently in use by a previous read operation. </p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)
  - type: System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StringReader.ReadAsync(System.Char[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.IO.TextReader.ReadAsync(System.Char(), System.Int32, System.Int32)
  name.vb: ReadAsync(Char(), Int32, Int32)
- uid: System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)
  commentId: M:System.IO.TextReader.ReadBlock(System.Char[],System.Int32,System.Int32)
  id: ReadBlock(System.Char[],System.Int32,System.Int32)
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadBlock(Char[], Int32, Int32)
  fullName: System.IO.TextReader.ReadBlock(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadBlock
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 142
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a specified maximum number of characters from the current text reader and writes the data to a buffer, beginning at the specified index.</p>\n"
  remarks: "\n<p>The position of the underlying text reader is advanced by the number of characters that were read into <em>buffer</em>.</p>\n<p>The method blocks until either <em>count</em> characters are read, or all characters have been read. This is a blocking version of <xref href=\"System.IO.TextReader.Read\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public virtual int ReadBlock([In, Out] char[] buffer, int index, int count)
    content.vb: Public Overridable Function ReadBlock(buffer As Char(), index As Integer, count As Integer) As Integer
    parameters:
    - id: buffer
      type: System.Char[]
      attributes:
      - type: System.Runtime.InteropServices.InAttribute
        ctor: System.Runtime.InteropServices.InAttribute.#ctor
        arguments: []
      - type: System.Runtime.InteropServices.OutAttribute
        ctor: System.Runtime.InteropServices.OutAttribute.#ctor
        arguments: []
    - id: index
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Int32
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>. </p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The buffer length minus <em>index</em> is less than <em>count</em>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is negative. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.IO.TextReader.ReadBlock(System.Char(), System.Int32, System.Int32)
  name.vb: ReadBlock(Char(), Int32, Int32)
- uid: System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  commentId: M:System.IO.TextReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  id: ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadBlockAsync(Char[], Int32, Int32)
  fullName: System.IO.TextReader.ReadBlockAsync(System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadBlockAsync
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 234
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a specified maximum number of characters from the current text reader asynchronously and writes the data to a buffer, beginning at the specified index.</p>\n"
  remarks: "\n<p>The task does not complete until either the number of characters specified by the <em>count</em> parameter are read, or the end of the text has been reached. </p>\n"
  syntax:
    content: >-
      [HostProtection(ExternalThreading = true)]

      [ComVisible(false)]

      public virtual Task<int> ReadBlockAsync(char[] buffer, int index, int count)
    content.vb: >-
      <HostProtection(ExternalThreading:=True)>

      <ComVisible(False)>

      Public Overridable Function ReadBlockAsync(buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)
    parameters:
    - id: buffer
      type: System.Char[]
    - id: index
      type: System.Int32
    - id: count
      type: System.Int32
    return:
      type: System.Threading.Tasks.Task{System.Int32}
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>index</em> or <em>count</em> is negative.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The sum of <em>index</em> and <em>count</em> is larger than the buffer length.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The text reader has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The reader is currently in use by a previous read operation. </p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  - type: System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
    commentId: M:System.IO.StringReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
  fullName.vb: System.IO.TextReader.ReadBlockAsync(System.Char(), System.Int32, System.Int32)
  name.vb: ReadBlockAsync(Char(), Int32, Int32)
- uid: System.IO.TextReader.ReadLine
  commentId: M:System.IO.TextReader.ReadLine
  id: ReadLine
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadLine()
  fullName: System.IO.TextReader.ReadLine()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadLine
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 160
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a line of characters from the text reader and returns the data as a string.</p>\n"
  remarks: "\n<p>A line is defined as a sequence of characters followed by a carriage return (0x000d), a line feed (0x000a), a carriage return followed by a line feed, <xref href=\"System.Environment.NewLine\" data-throw-if-not-resolved=\"false\"></xref>, or the end-of-stream marker. The string that is returned does not contain the terminating carriage return or line feed. The return value is <strong>null</strong> if the end of the input stream has been reached.</p>\n<p>If the method throws an <xref href=\"System.OutOfMemoryException\" data-throw-if-not-resolved=\"false\"></xref> exception, the reader's position in the underlying <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> is advanced by the number of characters the method was able to read, but the characters that were already read into the internal <xref href=\"System.IO.TextReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> buffer are discarded. Because the position of the reader in the stream cannot be changed, the characters that were already read are unrecoverable and can be accessed only by reinitializing the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> object. If the initial position within the stream is unknown or the stream does not support seeking, the underlying <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> also needs to be reinitialized.</p>\n<p>To avoid such a situation and produce robust code you should use the <xref href=\"System.IO.TextReader.Read\" data-throw-if-not-resolved=\"false\"></xref> method and store the read characters in a preallocated buffer.</p>\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.ReadLine\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public virtual string ReadLine()
    content.vb: Public Overridable Function ReadLine As String
    return:
      type: System.String
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to allocate a buffer for the returned string. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The number of characters in the next line is larger than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadLine
    commentId: M:System.IO.StreamReader.ReadLine
  - type: System.IO.StringReader.ReadLine
    commentId: M:System.IO.StringReader.ReadLine
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.IO.TextReader.ReadLineAsync
  commentId: M:System.IO.TextReader.ReadLineAsync
  id: ReadLineAsync
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadLineAsync()
  fullName: System.IO.TextReader.ReadLineAsync()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadLineAsync
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 178
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads a line of characters asynchronously and returns the data as a string. </p>\n"
  remarks: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.ReadLineAsync\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.ReadLineAsync\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>If the current <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> represents the standard input stream returned by the <xref href=\"System.Console.In\" data-throw-if-not-resolved=\"false\"></xref> property, the <xref href=\"System.IO.TextReader.ReadLineAsync\" data-throw-if-not-resolved=\"false\"></xref> method executes synchronously rather than asynchronously. </p>\n"
  syntax:
    content: >-
      [HostProtection(ExternalThreading = true)]

      [ComVisible(false)]

      public virtual Task<string> ReadLineAsync()
    content.vb: >-
      <HostProtection(ExternalThreading:=True)>

      <ComVisible(False)>

      Public Overridable Function ReadLineAsync As Task(Of String)
    return:
      type: System.Threading.Tasks.Task{System.String}
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The number of characters in the next line is larger than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The text reader has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The reader is currently in use by a previous read operation. </p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadLineAsync
    commentId: M:System.IO.StreamReader.ReadLineAsync
  - type: System.IO.StringReader.ReadLineAsync
    commentId: M:System.IO.StringReader.ReadLineAsync
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.IO.TextReader.ReadToEnd
  commentId: M:System.IO.TextReader.ReadToEnd
  id: ReadToEnd
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadToEnd()
  fullName: System.IO.TextReader.ReadToEnd()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadToEnd
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 125
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads all characters from the current position to the end of the text reader and returns them as one string.</p>\n"
  remarks: "\n<p>If the method throws an <xref href=\"System.OutOfMemoryException\" data-throw-if-not-resolved=\"false\"></xref> exception, the reader's position in the underlying <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> is advanced by the number of characters the method was able to read, but the characters that were already read into the internal <xref href=\"System.IO.TextReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> buffer are discarded. Because the position of the reader in the stream cannot be changed, the characters that were already read are unrecoverable and can be accessed only by reinitializing the <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref>. If the initial position within the stream is unknown or the stream does not support seeking, the underlying <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> also needs to be reinitialized.</p>\n<p>To avoid such a situation and produce robust code you should use the <xref href=\"System.IO.TextReader.Read\" data-throw-if-not-resolved=\"false\"></xref> method and store the read characters in a preallocated buffer.</p>\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.ReadToEnd\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public virtual string ReadToEnd()
    content.vb: Public Overridable Function ReadToEnd As String
    return:
      type: System.String
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>An I/O error occurs. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> is closed. </p>\n"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to allocate a buffer for the returned string. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The number of characters in the next line is larger than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref></p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadToEnd
    commentId: M:System.IO.StreamReader.ReadToEnd
  - type: System.IO.StringReader.ReadToEnd
    commentId: M:System.IO.StringReader.ReadToEnd
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.IO.TextReader.ReadToEndAsync
  commentId: M:System.IO.TextReader.ReadToEndAsync
  id: ReadToEndAsync
  parent: System.IO.TextReader
  langs:
  - csharp
  - vb
  name: ReadToEndAsync()
  fullName: System.IO.TextReader.ReadToEndAsync()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IO/TextReader.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ReadToEndAsync
    path: src/mscorlib/src/System/IO/TextReader.cs
    startLine: 189
  assemblies:
  - System.IO
  namespace: System.IO
  summary: "\n<p>Reads all characters from the current position to the end of the text reader asynchronously and returns them as one string.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IO.TextReader\" data-throw-if-not-resolved=\"false\"></xref> class is an abstract class. Therefore, you do not instantiate it in your code. For an example of using the <xref href=\"System.IO.TextReader.ReadToEndAsync\" data-throw-if-not-resolved=\"false\"></xref> method, see the <xref href=\"System.IO.StreamReader.ReadToEndAsync\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: >-
      [HostProtection(ExternalThreading = true)]

      [ComVisible(false)]

      public virtual Task<string> ReadToEndAsync()
    content.vb: >-
      <HostProtection(ExternalThreading:=True)>

      <ComVisible(False)>

      Public Overridable Function ReadToEndAsync As Task(Of String)
    return:
      type: System.Threading.Tasks.Task{System.String}
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The number of characters is larger than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The text reader has been disposed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The reader is currently in use by a previous read operation. </p>\n"
  seealso:
  - type: System.IO.StreamReader.ReadToEndAsync
    commentId: M:System.IO.StreamReader.ReadToEndAsync
  - type: System.IO.StringReader.ReadToEndAsync
    commentId: M:System.IO.StringReader.ReadToEndAsync
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
references:
- uid: System.IO
  isExternal: false
  name: System.IO
  fullName: System.IO
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.IO.TextReader
  parent: System.IO
  isExternal: false
  name: TextReader
  fullName: System.IO.TextReader
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Char[]
  isExternal: true
  name: Char[]
  fullName: System.Char[]
  fullname.vb: System.Char()
  name.vb: Char()
  spec.csharp:
  - uid: System.Char
    name: Char
    fullName: System.Char
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Char
    name: Char
    fullName: System.Char
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Threading.Tasks.Task{System.Int32}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Int32>
  fullName: System.Threading.Tasks.Task<System.Int32>
  fullname.vb: System.Threading.Tasks.Task(Of System.Int32)
  name.vb: Task(Of Int32)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
    isExternal: true
  - name: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  parent: System.Threading.Tasks
  isExternal: false
  name: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    fullName: <
  - name: TResult
    fullName: TResult
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    fullName: '(Of '
  - name: TResult
    fullName: TResult
  - name: )
    fullName: )
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Threading.Tasks.Task{System.String}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<String>
  fullName: System.Threading.Tasks.Task<System.String>
  fullname.vb: System.Threading.Tasks.Task(Of System.String)
  name.vb: Task(Of String)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    fullName: <
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.String
    name: String
    fullName: System.String
    isExternal: true
  - name: )
    fullName: )
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.IO.IOException
  parent: System.IO
  isExternal: false
  name: IOException
  fullName: System.IO.IOException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.OutOfMemoryException
  isExternal: false
  name: OutOfMemoryException
  fullName: System.OutOfMemoryException
