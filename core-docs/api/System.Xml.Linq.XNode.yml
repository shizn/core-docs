items:
- uid: System.Xml.Linq.XNode
  commentId: T:System.Xml.Linq.XNode
  id: XNode
  parent: System.Xml.Linq
  children:
  - System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  - System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  - System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  - System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  - System.Xml.Linq.XNode.Ancestors
  - System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.CreateReader
  - System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  - System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.DocumentOrderComparer
  - System.Xml.Linq.XNode.ElementsAfterSelf
  - System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.ElementsBeforeSelf
  - System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  - System.Xml.Linq.XNode.EqualityComparer
  - System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  - System.Xml.Linq.XNode.NextNode
  - System.Xml.Linq.XNode.NodesAfterSelf
  - System.Xml.Linq.XNode.NodesBeforeSelf
  - System.Xml.Linq.XNode.PreviousNode
  - System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  - System.Xml.Linq.XNode.Remove
  - System.Xml.Linq.XNode.ReplaceWith(System.Object)
  - System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  - System.Xml.Linq.XNode.ToString
  - System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  - System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  langs:
  - csharp
  - vb
  name: XNode
  fullName: System.Xml.Linq.XNode
  type: Class
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: XNode
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 341
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.  </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> is an abstract common base class for the following types:</p>\n<ul><li>\n<p>\n<xref href=\"System.Xml.Linq.XComment\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XDocumentType\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XProcessingInstruction\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>\n<xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> is an abstract common base class for the following types:</p>\n<ul><li>\n<p>\n<xref href=\"System.Xml.Linq.XDocument\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li><li>\n<p>\n<xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>\n</p>\n</li></ul>\n<p>Objects of classes that derive from <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> can contain child nodes.</p>\n<p>An <xref href=\"System.Xml.Linq.XAttribute\" data-throw-if-not-resolved=\"false\"></xref> is not an <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref>. Attributes are maintained as a list of name/value pairs on an element.</p>\n<p>If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level. Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes. </p>\n"
  example:
  - 
  syntax:
    content: 'public abstract class XNode : XObject'
    content.vb: >-
      Public MustInherit Class XNode
          Inherits XObject
  inheritance:
  - System.Object
  - System.Xml.Linq.XObject
  inheritedMembers:
  - System.Xml.Linq.XObject.BaseUri
  - System.Xml.Linq.XObject.Document
  - System.Xml.Linq.XObject.NodeType
  - System.Xml.Linq.XObject.Parent
  - System.Xml.Linq.XObject.Changed
  - System.Xml.Linq.XObject.Changing
  - System.Xml.Linq.XObject.AddAnnotation(System.Object)
  - System.Xml.Linq.XObject.Annotation(System.Type)
  - System.Xml.Linq.XObject.Annotation``1
  - System.Xml.Linq.XObject.Annotations(System.Type)
  - System.Xml.Linq.XObject.Annotations``1
  - System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  - System.Xml.Linq.XObject.RemoveAnnotations``1
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Xml.Linq.XNode.DocumentOrderComparer
  commentId: P:System.Xml.Linq.XNode.DocumentOrderComparer
  id: DocumentOrderComparer
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: DocumentOrderComparer
  fullName: System.Xml.Linq.XNode.DocumentOrderComparer
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DocumentOrderComparer
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 344
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets a comparer that can compare the relative position of two nodes.</p>\n"
  remarks: "\n<p>This property is primarily used internally for implementing the <xref href=\"System.Xml.Linq.Extensions.InDocumentOrder``1(System.Collections.Generic.IEnumerable{``0})\" data-throw-if-not-resolved=\"false\"></xref> extension method. The recommended approach is to use that extension method instead of using this property directly.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree with some elements. It then creates a <xref href=\"System.Collections.Generic.List`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> that contains some elements from the XML tree at random. It sorts the list, using this property to retrieve a <xref href=\"System.Xml.Linq.XNodeDocumentOrderComparer\" data-throw-if-not-resolved=\"false\"></xref>, which implements the <xref href=\"System.Collections.IComparer\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Collections.Generic.IComparer`1\" data-throw-if-not-resolved=\"false\"></xref> interfaces.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\n\nList<XNode> nodeList = new List<XNode>();\nnodeList.Add(xmlTree.Element(\"Child5\"));\nnodeList.Add(xmlTree.Element(\"Child3\"));\nnodeList.Add(xmlTree.Element(\"Child1\"));\n\n// Sort nodes in document order.\nnodeList.Sort(XNode.DocumentOrderComparer);\n\nforeach (XElement el in nodeList)\nConsole.WriteLine(el);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim nodeList As List(Of XNode) = New List(Of XNode)()\nnodeList.Add(xmlTree.Element(\"Child5\"))\nnodeList.Add(xmlTree.Element(\"Child3\"))\nnodeList.Add(xmlTree.Element(\"Child1\"))\n\n' Sort nodes in document order.\nnodeList.Sort(XNode.DocumentOrderComparer)\n\nFor Each el In nodeList\nConsole.WriteLine(el)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Child1>1</Child1>\n<Child3>3</Child3>\n<Child5>5</Child5></code></pre>\n"
  syntax:
    content: public static XNodeDocumentOrderComparer DocumentOrderComparer { get; }
    content.vb: Public Shared ReadOnly Property DocumentOrderComparer As XNodeDocumentOrderComparer
    parameters: []
    return:
      type: System.Xml.Linq.XNodeDocumentOrderComparer
      description: "\n<p>An <xref href=\"System.Xml.Linq.XNodeDocumentOrderComparer\" data-throw-if-not-resolved=\"false\"></xref> that can compare the relative position of two nodes.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Xml.Linq.XNode.EqualityComparer
  commentId: P:System.Xml.Linq.XNode.EqualityComparer
  id: EqualityComparer
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: EqualityComparer
  fullName: System.Xml.Linq.XNode.EqualityComparer
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EqualityComparer
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 345
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets a comparer that can compare two nodes for value equality.</p>\n"
  example:
  - "\n<p>The following example uses this property to retrieve an <xref href=\"System.Xml.Linq.XNodeEqualityComparer\" data-throw-if-not-resolved=\"false\"></xref>, which implements the <xref href=\"System.Collections.IEqualityComparer\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Collections.Generic.IEqualityComparer`1\" data-throw-if-not-resolved=\"false\"></xref> interfaces. It creates a dictionary that uses this property.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\n\nDictionary<XNode, string> nodeDictionary = new Dictionary<XNode, string>(XNode.EqualityComparer);\nnodeDictionary.Add(xmlTree.Element(\"Child5\"), \"Child 5 Information\");\nnodeDictionary.Add(xmlTree.Element(\"Child3\"), \"Child 3 Information\");\nnodeDictionary.Add(xmlTree.Element(\"Child1\"), \"Child 1 Information\");\n\nstring str = nodeDictionary[xmlTree.Element(\"Child3\")];\nConsole.WriteLine(str);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)\nnodeDictionary.Add(xmlTree.Element(\"Child5\"), \"Child 5 Information\")\nnodeDictionary.Add(xmlTree.Element(\"Child3\"), \"Child 3 Information\")\nnodeDictionary.Add(xmlTree.Element(\"Child1\"), \"Child 1 Information\")\n\nDim str As String = nodeDictionary(xmlTree.Element(\"Child3\"))\nConsole.WriteLine(str)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child 3 Information</code></pre>\n"
  syntax:
    content: public static XNodeEqualityComparer EqualityComparer { get; }
    content.vb: Public Shared ReadOnly Property EqualityComparer As XNodeEqualityComparer
    parameters: []
    return:
      type: System.Xml.Linq.XNodeEqualityComparer
      description: "\n<p>A <xref href=\"System.Xml.Linq.XNodeEqualityComparer\" data-throw-if-not-resolved=\"false\"></xref> that can compare two nodes for value equality.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Xml.Linq.XNode.NextNode
  commentId: P:System.Xml.Linq.XNode.NextNode
  id: NextNode
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: NextNode
  fullName: System.Xml.Linq.XNode.NextNode
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NextNode
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 346
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the next sibling node of this node.</p>\n"
  remarks: "\n<p>If this <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> does not have a parent, or if there is no next node, this property returns <strong>null</strong>.</p>\n"
  example:
  - "\n<p>The following example uses this property to loop through nodes.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XText(\"Some Text\"),\nnew XElement(\"Child2\",\n2,\nnew XElement(\"GrandChild\", \"GrandChild Content\")\n),\nnew XComment(\"a comment\"),\nnew XElement(\"Child3\")\n);\nXNode node = xmlTree.Element(\"Child2\");\ndo {\nStringBuilder sb = new StringBuilder();\nsb.Append(String.Format(\"NodeType: {0}\", node.NodeType.ToString().PadRight(10)));\nswitch (node.NodeType)\n{\ncase XmlNodeType.Text:\n    sb.Append((node as XText).Value);\n    break;\ncase XmlNodeType.Element:\n    sb.Append((node as XElement).Name);\n    break;\ncase XmlNodeType.Comment:\n    sb.Append((node as XComment).Value);\n    break;\n}\nConsole.WriteLine(sb.ToString());\n}\nwhile ((node = node.NextNode) != null);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>Some Text\n    <Child2>2\n        <GrandChild>GrandChild Content</GrandChild>\n    </Child2>\n    <!--a comment-->\n    <Child3>3</Child3>\n</Root>\n\nDim node As XNode = xmlTree.Element(\"Child2\")\nDo\nDim sb As StringBuilder = New StringBuilder()\nsb.Append(String.Format(\"NodeType: {0}\", node.NodeType.ToString().PadRight(10)))\nSelect Case node.NodeType\nCase XmlNodeType.Text\n    sb.Append(DirectCast(node, XText).Value)\nCase XmlNodeType.Element\n    sb.Append(DirectCast(node, XElement).Name)\nCase XmlNodeType.Comment\n    sb.Append(DirectCast(node, XComment).Value)\nEnd Select\nConsole.WriteLine(sb.ToString())\n\nnode = node.NextNode\nLoop While (Not (node Is Nothing))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>NodeType: Element   Child2\nNodeType: Comment   a comment\nNodeType: Element   Child3</code></pre>\n"
  syntax:
    content: public XNode NextNode { get; }
    content.vb: Public ReadOnly Property NextNode As XNode
    parameters: []
    return:
      type: System.Xml.Linq.XNode
      description: "\n<p>The <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> that contains the next sibling node.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XNode.PreviousNode
  commentId: P:System.Xml.Linq.XNode.PreviousNode
  id: PreviousNode
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: PreviousNode
  fullName: System.Xml.Linq.XNode.PreviousNode
  type: Property
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PreviousNode
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 347
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Gets the previous sibling node of this node.</p>\n"
  remarks: "\n<p>If this <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> does not have a parent, or if there is no previous node, this property returns <strong>null</strong>.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <xref href=\"System.Xml.Linq.XNode.PreviousNode\" data-throw-if-not-resolved=\"false\"></xref> property must traverse the list of direct child nodes under the parent container. Therefore, using this property might affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses this property to loop through nodes.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XText(\"Some Text\"),\nnew XElement(\"Child2\",\n2,\nnew XElement(\"GrandChild\", \"GrandChild Content\")\n),\nnew XComment(\"a comment\"),\nnew XElement(\"Child3\")\n);\nXNode node = xmlTree.Element(\"Child2\");\ndo {\nStringBuilder sb = new StringBuilder();\nsb.Append(String.Format(\"NodeType: {0}\", node.NodeType.ToString().PadRight(10)));\nswitch (node.NodeType)\n{\ncase XmlNodeType.Text:\n    sb.Append((node as XText).Value);\n    break;\ncase XmlNodeType.Element:\n    sb.Append((node as XElement).Name);\n    break;\ncase XmlNodeType.Comment:\n    sb.Append((node as XComment).Value);\n    break;\n}\nConsole.WriteLine(sb.ToString());\n}\nwhile ((node = node.PreviousNode) != null);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root>\n<Child1>1</Child1>Some Text<Child2>2\n    <GrandChild>GrandChild Content</GrandChild>\n</Child2>\n<!--a comment-->\n<Child3>3</Child3>\n</Root>\n\nDim node As XNode = xmlTree.Element(\"Child2\")\nDo\nDim sb As StringBuilder = New StringBuilder()\nsb.Append(String.Format(\"NodeType: {0}\", node.NodeType.ToString().PadRight(10)))\nSelect Case node.NodeType\nCase XmlNodeType.Text\n    sb.Append(DirectCast(node, XText).Value)\nCase XmlNodeType.Element\n    sb.Append(DirectCast(node, XElement).Name)\nCase XmlNodeType.Comment\n    sb.Append(DirectCast(node, XComment).Value)\nEnd Select\nConsole.WriteLine(sb.ToString())\n\nnode = node.PreviousNode\nLoop While (Not (node Is Nothing))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>NodeType: Element   Child2\nNodeType: Text      Some Text\nNodeType: Element   Child1</code></pre>\n"
  syntax:
    content: public XNode PreviousNode { get; }
    content.vb: Public ReadOnly Property PreviousNode As XNode
    parameters: []
    return:
      type: System.Xml.Linq.XNode
      description: "\n<p>The <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> that contains the previous sibling node.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  commentId: M:System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  id: AddAfterSelf(System.Object)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: AddAfterSelf(Object)
  fullName: System.Xml.Linq.XNode.AddAfterSelf(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddAfterSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 348
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Adds the specified content immediately after this node.</p>\n"
  remarks: "\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>\n<xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example uses this method to add an element into the tree.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\nXElement child1 = xmlTree.Element(\"Child1\");\nchild1.AddAfterSelf(\nnew XElement(\"NewChild\", 10)\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\n\nDim child1 As XElement = xmlTree.<Child1>(0)\nchild1.AddAfterSelf(New XElement(\"NewChild\", 10))\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>1</Child1>\n<NewChild>10</NewChild>\n<Child2>2</Child2>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void AddAfterSelf(object content)
    content.vb: Public Sub AddAfterSelf(content As Object)
    parameters:
    - id: content
      type: System.Object
      description: "\n<p>A content object that contains simple content or a collection of content objects to be added after this node.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The parent is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  commentId: M:System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  id: AddAfterSelf(System.Object[])
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: AddAfterSelf(Object[])
  fullName: System.Xml.Linq.XNode.AddAfterSelf(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddAfterSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 349
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Adds the specified content immediately after this node.</p>\n"
  remarks: "\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example uses a LINQ query to create an <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, which it then passes to this method. This adds the results of a query to the tree in the desired location.</p>\n<pre><code class=\"c#\">XElement srcTree = new XElement(\"Root\",\nnew XElement(\"Element1\", 1),\nnew XElement(\"Element2\", 2),\nnew XElement(\"Element3\", 3),\nnew XElement(\"Element4\", 4),\nnew XElement(\"Element5\", 5)\n);\nXElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\nXElement child1 = xmlTree.Element(\"Child1\");\nchild1.AddAfterSelf(\nfrom el in srcTree.Elements()\nwhere (int)el > 3\nselect el\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim srcTree As XElement = _ \n<Root>\n    <Element1>1</Element1>\n    <Element2>2</Element2>\n    <Element3>3</Element3>\n    <Element4>4</Element4>\n    <Element5>5</Element5>\n</Root>\n\nDim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim child1 As XElement = xmlTree.<Child1>(0)\nchild1.AddAfterSelf( _\nFrom el In srcTree.Elements() _\nWhere CInt(el) > 3 _\nSelect el)\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>1</Child1>\n<Element4>4</Element4>\n<Element5>5</Element5>\n<Child2>2</Child2>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void AddAfterSelf(params object[] content)
    content.vb: Public Sub AddAfterSelf(ParamArray content As Object())
    parameters:
    - id: content
      type: System.Object[]
      description: "\n<p>A parameter list of content objects.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The parent is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XNode.AddAfterSelf(System.Object())
  name.vb: AddAfterSelf(Object())
- uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  commentId: M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  id: AddBeforeSelf(System.Object)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: AddBeforeSelf(Object)
  fullName: System.Xml.Linq.XNode.AddBeforeSelf(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddBeforeSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 350
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Adds the specified content immediately before this node.</p>\n"
  remarks: "\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <see cref=\"Overload:System.Xml.Linq.XNode.AddBeforeSelf\"></see> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might  affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses this method to add an element into the tree.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\nXElement child1 = xmlTree.Element(\"Child1\");\nchild1.AddBeforeSelf(\nnew XElement(\"NewChild\", 10)\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim child1 As XElement = xmlTree.<Child1>(0)\nchild1.AddBeforeSelf(New XElement(\"NewChild\", 10))\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<NewChild>10</NewChild>\n<Child1>1</Child1>\n<Child2>2</Child2>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void AddBeforeSelf(object content)
    content.vb: Public Sub AddBeforeSelf(content As Object)
    parameters:
    - id: content
      type: System.Object
      description: "\n<p>A content object that contains simple content or a collection of content objects to be added before this node.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The parent is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  commentId: M:System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  id: AddBeforeSelf(System.Object[])
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: AddBeforeSelf(Object[])
  fullName: System.Xml.Linq.XNode.AddBeforeSelf(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddBeforeSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 351
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Adds the specified content immediately before this node.</p>\n"
  remarks: "\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <see cref=\"Overload:System.Xml.Linq.XNode.AddBeforeSelf\"></see> method must traverse the list of direct child nodes under the parent container. Therefore, using this function might affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses a LINQ query to create an <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref>, which it then passes to this method. This adds the results of a query to the tree in the desired location.</p>\n<pre><code class=\"c#\">XElement srcTree = new XElement(\"Root\",\nnew XElement(\"Element1\", 1),\nnew XElement(\"Element2\", 2),\nnew XElement(\"Element3\", 3),\nnew XElement(\"Element4\", 4),\nnew XElement(\"Element5\", 5)\n);\nXElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\nXElement child1 = xmlTree.Element(\"Child1\");\nchild1.AddBeforeSelf(\nfrom el in srcTree.Elements()\nwhere (int)el > 3\nselect el\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim srcTree As XElement = _ \n<Root>\n    <Element1>1</Element1>\n    <Element2>2</Element2>\n    <Element3>3</Element3>\n    <Element4>4</Element4>\n    <Element5>5</Element5>\n</Root>\n\nDim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim child1 As XElement = xmlTree.<Child1>(0)\nchild1.AddBeforeSelf( _\nFrom el In srcTree.Elements() _\nWhere CInt(el) > 3 _\nSelect el)\n\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Element4>4</Element4>\n<Element5>5</Element5>\n<Child1>1</Child1>\n<Child2>2</Child2>\n<Child3>3</Child3>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void AddBeforeSelf(params object[] content)
    content.vb: Public Sub AddBeforeSelf(ParamArray content As Object())
    parameters:
    - id: content
      type: System.Object[]
      description: "\n<p>A parameter list of content objects.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The parent is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XNode.AddBeforeSelf(System.Object())
  name.vb: AddBeforeSelf(Object())
- uid: System.Xml.Linq.XNode.Ancestors
  commentId: M:System.Xml.Linq.XNode.Ancestors
  id: Ancestors
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: Ancestors()
  fullName: System.Xml.Linq.XNode.Ancestors()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ancestors
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 352
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of the ancestor elements of this node.</p>\n"
  remarks: "\n<p>This method does not return itself in the results.</p>\n<p>The nodes in the returned collection are in reverse document order.</p>\n<p>This method uses deferred execution.</p>\n"
  example:
  - "\n<p>The following example uses this method to enumerate the ancestors of a node.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child\", \nnew XElement(\"GrandChild\", \"content\")\n)\n);\nIEnumerable<XElement> grandChild = xmlTree.Descendants(\"GrandChild\");\nforeach (XElement el in grandChild.Ancestors())\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child>\n        <GrandChild>content</GrandChild>\n    </Child>\n</Root>\n\nDim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>\nFor Each el In grandChild.Ancestors()\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child\nRoot</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> Ancestors()
    content.vb: Public Function Ancestors As IEnumerable(Of XElement)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the ancestor elements of this node.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  id: Ancestors(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: Ancestors(XName)
  fullName: System.Xml.Linq.XNode.Ancestors(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Ancestors
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 353
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of the ancestor elements of this node. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>This method will not return itself in the results.</p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child\", \nnew XElement(\"GrandChild\", \"content\")\n)\n);\nIEnumerable<XElement> grandChild = xmlTree.Descendants(\"GrandChild\");\nforeach (XElement el in grandChild.Ancestors(\"Child\"))\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child>\n        <GrandChild>content</GrandChild>\n    </Child>\n</Root>\n\nDim grandChild As IEnumerable(Of XElement) = xmlTree...<GrandChild>\nFor Each el In grandChild.Ancestors(\"Child\")\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> Ancestors(XName name)
    content.vb: Public Function Ancestors(name As XName) As IEnumerable(Of XElement)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the ancestor elements of this node. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n<p>The nodes in the returned collection are in reverse document order.</p>\n<p>This method uses deferred execution.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  commentId: M:System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  id: CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: CompareDocumentOrder(XNode, XNode)
  fullName: System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode, System.Xml.Linq.XNode)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CompareDocumentOrder
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 354
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Compares two nodes to determine their relative XML document order.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <xref href=\"System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)\" data-throw-if-not-resolved=\"false\"></xref> method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\",\nnew XElement(\"GrandChild1\", 1),\nnew XElement(\"GrandChild2\", 2),\nnew XElement(\"GrandChild3\", 3)\n),\nnew XElement(\"Child2\",\nnew XElement(\"GrandChild4\", 4),\nnew XElement(\"GrandChild5\", 5),\nnew XElement(\"GrandChild6\", 6)\n)\n);\nXElement el1 = xmlTree.Descendants(\"GrandChild2\").First();\nXElement el2 = xmlTree.Descendants(\"GrandChild6\").First();\nif (XElement.CompareDocumentOrder(el1, el2) == 0)\nConsole.WriteLine(\"Compared elements are the same element\");\nelse if (XElement.CompareDocumentOrder(el1, el2) > 0)\nConsole.WriteLine(\"el1 is after el2\");\nelse\nConsole.WriteLine(\"el1 is before el2\");</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>\n        <GrandChild1>1</GrandChild1>\n        <GrandChild2>2</GrandChild2>\n        <GrandChild3>3</GrandChild3>\n    </Child1>\n    <Child2>\n        <GrandChild4>4</GrandChild4>\n        <GrandChild5>5</GrandChild5>\n        <GrandChild6>6</GrandChild6>\n    </Child2>\n</Root>\n\nDim el1 As XElement = xmlTree...<GrandChild2>(0)\nDim el2 As XElement = xmlTree...<GrandChild6>(0)\n\nIf (XElement.CompareDocumentOrder(el1, el2) = 0) Then\nConsole.WriteLine(\"Compared elements are the same element\")\nElseIf (XElement.CompareDocumentOrder(el1, el2) > 0) Then\nConsole.WriteLine(\"el1 is after el2\")\nElse\nConsole.WriteLine(\"el1 is before el2\")\nEnd If</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>el1 is before el2</code></pre>\n"
  syntax:
    content: public static int CompareDocumentOrder(XNode n1, XNode n2)
    content.vb: Public Shared Function CompareDocumentOrder(n1 As XNode, n2 As XNode) As Integer
    parameters:
    - id: n1
      type: System.Xml.Linq.XNode
      description: "\n<p>First <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare.</p>\n"
    - id: n2
      type: System.Xml.Linq.XNode
      description: "\n<p>Second <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>An <strong>int</strong> containing 0 if the nodes are equal; -1 if <em>n1</em> is before <em>n2</em>; 1 if <em>n1</em> is after <em>n2</em>.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The two nodes do not share a common ancestor.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XNode.CreateReader
  commentId: M:System.Xml.Linq.XNode.CreateReader
  id: CreateReader
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: CreateReader()
  fullName: System.Xml.Linq.XNode.CreateReader()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateReader
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 355
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Creates an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> for this node.</p>\n"
  remarks: "\n<p>You typically use this method when you have to supply another component with an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>. For example, you can create an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> from a LINQ to XML tree, and then pass that reader to <xref href=\"System.Xml.XmlDocument.Load(System.Xml.XmlReader)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>All of the readers returned by <see cref=\"Overload:System.Xml.XmlReader.Create\"></see> are normalizing readers. They always perform line break normalization and full normalization of attributes. In contrast, the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> returned by <xref href=\"System.Xml.Linq.XNode.CreateReader\" data-throw-if-not-resolved=\"false\"></xref> is not a normalizing reader. It does not transform any white space. It also returns attributes in the order that they were added, not in attribute name order.</p>\n<p>LINQ to XML does not keep information about whether attributes are default attributes. <xref href=\"System.Xml.XmlReader.IsDefault\" data-throw-if-not-resolved=\"false\"></xref> will always return false regardless of whether the attribute was populated from a default value or not.</p>\n<p>The the <strong>PUBLIC</strong> and <strong>SYSTEM</strong> pseudo attributes on <xref href=\"System.Xml.Linq.XDocumentType\" data-throw-if-not-resolved=\"false\"></xref> are not available through the <xref href=\"System.Xml.XmlReader.MoveToAttribute(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method. They are only available through the <xref href=\"System.Xml.XmlReader.GetAttribute(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method that takes the qualified name of the attribute as a parameter. If you have to retrieve the <strong>PUBLIC</strong> or <strong>SYSTEM</strong> attributes, you should use the <xref href=\"System.Xml.XmlReader.GetAttribute(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>Base64 and BinHex data are not supported. If you attempt to retrieve these types of data (for example, by calling <xref href=\"System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>), the reader will throw <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <strong>xml</strong> declaration is not surfaced by the reader. While reading, you will not encounter a node of type <xref href=\"System.Xml.XmlNodeType.XmlDeclaration\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example creates an XML tree, creates an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> by using the <xref href=\"System.Xml.Linq.XNode.CreateReader\" data-throw-if-not-resolved=\"false\"></xref> method, and creates an <xref href=\"System.Xml.XmlDocument\" data-throw-if-not-resolved=\"false\"></xref> by using the reader.</p>\n<pre><code class=\"c#\">XDocument xmlTree = new XDocument(\nnew XElement(\"Root\",\nnew XAttribute(\"Att1\", \"Attribute Content\"),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2)\n)\n);\nXmlReader reader = xmlTree.CreateReader();\nreader.MoveToContent();\nXmlDocument doc = new XmlDocument();\nXmlNode cd = doc.ReadNode(reader);\ndoc.AppendChild(cd);\nConsole.WriteLine(doc.OuterXml);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XDocument =  _ \n<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"yes\"?>\n<Root Att1=\"Attribute Content\">\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n</Root>\nDim reader As XmlReader = xmlTree.CreateReader()\nreader.MoveToContent()\nDim doc As XmlDocument = New XmlDocument()\nDim cd As XmlNode = doc.ReadNode(reader)\ndoc.AppendChild(cd)\nConsole.WriteLine(doc.OuterXml)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root Att1=\"Attribute Content\"><Child1>1</Child1><Child2>2</Child2></Root></code></pre>\n<p>Another use for this method is to do an XSLT transformation. You can create an XML tree, create an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> from the XML tree, create a new document, and create an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> that will write into the new document. Then, you can invoke the XSLT transformation, passing the <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> to the transformation. After the transformation successfully completes, the new XML tree is populated with the results of the transform.</p>\n<pre><code class=\"c#\">string xslMarkup = @\"<?xml version='1.0'?>\n<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n<xsl:template match='/Parent'>\n<Root>\n    <C1>\n    <xsl:value-of select='Child1'/>\n    </C1>\n    <C2>\n    <xsl:value-of select='Child2'/>\n    </C2>\n</Root>\n</xsl:template>\n</xsl:stylesheet>\";\n\nXDocument xmlTree = new XDocument(\nnew XElement(\"Parent\",\nnew XElement(\"Child1\", \"Child1 data\"),\nnew XElement(\"Child2\", \"Child2 data\")\n)\n);\n\nXDocument newTree = new XDocument();\nusing (XmlWriter writer = newTree.CreateWriter()) {\n// Load the style sheet.\nXslCompiledTransform xslt = new XslCompiledTransform();\nxslt.Load(XmlReader.Create(new StringReader(xslMarkup)));\n\n// Execute the transform and output the results to a writer.\nxslt.Transform(xmlTree.CreateReader(), writer);\n}\n\nConsole.WriteLine(newTree);</code></pre>\n<pre><code class=\"vb\">Dim xslMarkup As XDocument = _ \n<?xml version='1.0'?>\n<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n<xsl:template match='/Parent'>\n    <Root>\n        <C1>\n            <xsl:value-of select='Child1'/>\n        </C1>\n        <C2>\n            <xsl:value-of select='Child2'/>\n        </C2>\n    </Root>\n</xsl:template>\n</xsl:stylesheet>\n\nDim xmlTree As XElement = _ \n<Parent>\n    <Child1>Child1 data</Child1>\n    <Child2>Child2 data</Child2>\n</Parent>\n\nDim newTree As XDocument = New XDocument()\n\nUsing writer As XmlWriter = newTree.CreateWriter()\n' Load the style sheet.\nDim xslt As XslCompiledTransform = _\nNew XslCompiledTransform()\nxslt.Load(xslMarkup.CreateReader())\n\n' Execute the transform and output the results to a writer.\nxslt.Transform(xmlTree.CreateReader(), writer)\nEnd Using\n\nConsole.WriteLine(newTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<C1>Child1 data</C1>\n<C2>Child2 data</C2>\n</Root></code></pre>\n"
  syntax:
    content: public XmlReader CreateReader()
    content.vb: Public Function CreateReader As XmlReader
    return:
      type: System.Xml.XmlReader
      description: "\n<p>An <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> that can be used to read this node and its descendants.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  commentId: M:System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  id: CreateReader(System.Xml.Linq.ReaderOptions)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: CreateReader(ReaderOptions)
  fullName: System.Xml.Linq.XNode.CreateReader(System.Xml.Linq.ReaderOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateReader
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 356
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Creates an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> with the options specified by the <em>readerOptions</em> parameter.</p>\n"
  example:
  - "\n<p></p>\n"
  syntax:
    content: public XmlReader CreateReader(ReaderOptions readerOptions)
    content.vb: Public Function CreateReader(readerOptions As ReaderOptions) As XmlReader
    parameters:
    - id: readerOptions
      type: System.Xml.Linq.ReaderOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.ReaderOptions\" data-throw-if-not-resolved=\"false\"></xref> object that specifies whether to omit duplicate namespaces.</p>\n"
    return:
      type: System.Xml.XmlReader
      description: "\n<p>An <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  commentId: M:System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  id: DeepEquals(System.Xml.Linq.XNode,System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: DeepEquals(XNode, XNode)
  fullName: System.Xml.Linq.XNode.DeepEquals(System.Xml.Linq.XNode, System.Xml.Linq.XNode)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DeepEquals
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 357
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Compares the values of two nodes, including the values of all descendant nodes.</p>\n"
  remarks: "\n<p>The following criteria determine whether two nodes are equal:</p>\n<ul><li>\n<p>A <strong>null</strong> node is equal to another <strong>null</strong> node but unequal to a non-<strong>null</strong> node. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects of different types are never equal. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XText\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if they contain the same text. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XDocument\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if their root nodes are equal.</p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XComment\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if they contain the same comment text. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XProcessingInstruction\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if they have the same target and data. </p>\n</li><li>\n<p>Two <xref href=\"System.Xml.Linq.XDocumentType\" data-throw-if-not-resolved=\"false\"></xref> nodes are equal if the have the same name, public ID, system ID, and internal subset.</p>\n</li></ul>\n"
  example:
  - "\n<p>The following example uses this method to compare two XML trees.</p>\n<pre><code class=\"c#\">XElement xmlTree1 = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", \"some content\")\n);\nXElement xmlTree2 = new XElement(\"Root\",\nnew XAttribute(\"Att1\", 1),\nnew XAttribute(\"Att2\", 2),\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", \"some content\")\n);\nConsole.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));</code></pre>\n<pre><code class=\"vb\">Dim xmlTree1 As XElement = _ \n<Root Att1=\"1\" Att2=\"2\">\n    <Child1>1</Child1>\n    <Child2>some content</Child2>\n</Root>\n\nDim xmlTree2 As XElement = _ \n<Root Att1=\"1\" Att2=\"2\">\n    <Child1>1</Child1>\n    <Child2>some content</Child2>\n</Root>\n\nConsole.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>True</code></pre>\n"
  syntax:
    content: public static bool DeepEquals(XNode n1, XNode n2)
    content.vb: Public Shared Function DeepEquals(n1 As XNode, n2 As XNode) As Boolean
    parameters:
    - id: n1
      type: System.Xml.Linq.XNode
      description: "\n<p>The first <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare.</p>\n"
    - id: n2
      type: System.Xml.Linq.XNode
      description: "\n<p>The second <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the nodes are equal; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XNode.ElementsAfterSelf
  commentId: M:System.Xml.Linq.XNode.ElementsAfterSelf
  id: ElementsAfterSelf
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ElementsAfterSelf()
  fullName: System.Xml.Linq.XNode.ElementsAfterSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ElementsAfterSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 358
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of the sibling elements after this node, in document order.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an element with some complex content. It then uses this method to retrieve the nodes in document order.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child = xmlTree.Element(\"Child3\");\nIEnumerable<XElement> elements = child.ElementsAfterSelf();\nforeach (XElement el in elements)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _\n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child As XElement = xmlTree.<Child3>(0)\nDim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()\nFor Each el In elements\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child4\nChild5</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> ElementsAfterSelf()
    content.vb: Public Function ElementsAfterSelf As IEnumerable(Of XElement)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the sibling elements after this node, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  id: ElementsAfterSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ElementsAfterSelf(XName)
  fullName: System.Xml.Linq.XNode.ElementsAfterSelf(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ElementsAfterSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 359
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of the sibling elements after this node, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an element with some complex content. It then uses this method to retrieve the sibling elements, in document order.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child = xmlTree.Element(\"Child3\");\nIEnumerable<XElement> elements = child.ElementsAfterSelf(\"Child4\");\nforeach (XElement el in elements)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child As XElement = xmlTree.<Child3>(0)\nDim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf(\"Child4\")\n\nFor Each el In elements\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child4</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> ElementsAfterSelf(XName name)
    content.vb: Public Function ElementsAfterSelf(name As XName) As IEnumerable(Of XElement)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the sibling elements after this node, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ElementsBeforeSelf
  commentId: M:System.Xml.Linq.XNode.ElementsBeforeSelf
  id: ElementsBeforeSelf
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ElementsBeforeSelf()
  fullName: System.Xml.Linq.XNode.ElementsBeforeSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ElementsBeforeSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 360
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of the sibling elements before this node, in document order.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example uses this axis method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child = xmlTree.Element(\"Child3\");\nIEnumerable<XElement> elements = child.ElementsBeforeSelf();\nforeach (XElement el in elements)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child As XElement = xmlTree.<Child3>(0)\nDim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()\n\nFor Each el In elements\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child1\nChild2</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> ElementsBeforeSelf()
    content.vb: Public Function ElementsBeforeSelf As IEnumerable(Of XElement)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the sibling elements before this node, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  commentId: M:System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  id: ElementsBeforeSelf(System.Xml.Linq.XName)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ElementsBeforeSelf(XName)
  fullName: System.Xml.Linq.XNode.ElementsBeforeSelf(System.Xml.Linq.XName)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ElementsBeforeSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 361
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a filtered collection of the sibling elements before this node, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child = xmlTree.Element(\"Child3\");\nIEnumerable<XElement> elements = child.ElementsBeforeSelf(\"Child2\");\nforeach (XElement el in elements)\nConsole.WriteLine(el.Name);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child As XElement = xmlTree.<Child3>(0)\nDim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf(\"Child2\")\n\nFor Each el In elements\nConsole.WriteLine(el.Name)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child2</code></pre>\n"
  syntax:
    content: public IEnumerable<XElement> ElementsBeforeSelf(XName name)
    content.vb: Public Function ElementsBeforeSelf(name As XName) As IEnumerable(Of XElement)
    parameters:
    - id: name
      type: System.Xml.Linq.XName
      description: "\n<p>The <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> to match.</p>\n"
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XElement\" data-throw-if-not-resolved=\"false\"></xref> of the sibling elements before this node, in document order. Only elements that have a matching <xref href=\"System.Xml.Linq.XName\" data-throw-if-not-resolved=\"false\"></xref> are included in the collection.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  commentId: M:System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  id: IsAfter(System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: IsAfter(XNode)
  fullName: System.Xml.Linq.XNode.IsAfter(System.Xml.Linq.XNode)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAfter
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 362
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Determines if the current node appears after a specified node in terms of document order.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <xref href=\"System.Xml.Linq.XNode.CompareDocumentOrder(System.Xml.Linq.XNode,System.Xml.Linq.XNode)\" data-throw-if-not-resolved=\"false\"></xref> method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child3 = xmlTree.Element(\"Child3\");\nXElement child5 = xmlTree.Element(\"Child5\");\nif (child5.IsAfter(child3))\nConsole.WriteLine(\"Child5 is after Child3\");\nelse\nConsole.WriteLine(\"Child5 is not after Child3\");</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child3 As XElement = xmlTree.<Child3>(0)\nDim child5 As XElement = xmlTree.<Child5>(0)\nIf (child5.IsAfter(child3)) Then\nConsole.WriteLine(\"Child5 is after Child3\")\nElse\nConsole.WriteLine(\"Child5 is not after Child3\")\nEnd If</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child5 is after Child3</code></pre>\n"
  syntax:
    content: public bool IsAfter(XNode node)
    content.vb: Public Function IsAfter(node As XNode) As Boolean
    parameters:
    - id: node
      type: System.Xml.Linq.XNode
      description: "\n<p>The <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare for document order.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this node appears after the specified node; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  commentId: M:System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  id: IsBefore(System.Xml.Linq.XNode)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: IsBefore(XNode)
  fullName: System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsBefore
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 363
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Determines if the current node appears before a specified node in terms of document order.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <xref href=\"System.Xml.Linq.XNode.IsBefore(System.Xml.Linq.XNode)\" data-throw-if-not-resolved=\"false\"></xref> method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n"
  example:
  - "\n<p>The following example uses this method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child3 = xmlTree.Element(\"Child3\");\nXElement child5 = xmlTree.Element(\"Child5\");\nif (child5.IsBefore(child3))\nConsole.WriteLine(\"Child5 is before Child3\");\nelse\nConsole.WriteLine(\"Child5 is not before Child3\");</code></pre>\n<p>[vb]</p>\n<pre><code>Dim xmlTree As XElement = _ \n<Root>Text content.\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>More text content.\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child3 As XElement = xmlTree.<Child3>(0)\nDim child5 As XElement = xmlTree.<Child5>(0)\nIf (child5.IsBefore(child3)) Then\nConsole.WriteLine(\"Child5 is before Child3\")\nElse\nConsole.WriteLine(\"Child5 is not before Child3\")\nEnd If</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Child5 is not before Child3</code></pre>\n"
  syntax:
    content: public bool IsBefore(XNode node)
    content.vb: Public Function IsBefore(node As XNode) As Boolean
    parameters:
    - id: node
      type: System.Xml.Linq.XNode
      description: "\n<p>The <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> to compare for document order.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this node appears before the specified node; otherwise <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.NodesAfterSelf
  commentId: M:System.Xml.Linq.XNode.NodesAfterSelf
  id: NodesAfterSelf
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: NodesAfterSelf()
  fullName: System.Xml.Linq.XNode.NodesAfterSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NodesAfterSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 364
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of the sibling nodes after this node, in document order.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an XML tree, and then queries the tree using this axis method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"child3\", \"child3 content\")\n);\nXElement child = xmlTree.Element(\"Child2\");\nIEnumerable<XNode> nodes =\nfrom node in child.NodesAfterSelf()\nselect node;\nforeach (XNode node in nodes)\n{\nConsole.WriteLine(\"Node type: {0}  {1}\",\nnode.NodeType,\nnode.NodeType == XmlNodeType.Text ? (node as XText).Value : \"\");\n}</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = New XElement(\"Root\", _New XText(\"Text content.\"), _\nNew XElement(\"Child1\", \"child1 content\"), _\nNew XElement(\"Child2\", \"child2 content\"), _\nNew XText(\"More text content.\"), _\nNew XElement(\"child3\", \"child3 content\") _\n)\n\nDim child As XElement = xmlTree.Element(\"Child2\")\nDim nodes As IEnumerable(Of XNode) = _\nFrom node In child.NodesAfterSelf() _\nSelect node\nFor Each node As XNode In nodes\nDim s As String = \"\"\nIf node.NodeType = XmlNodeType.Text Then\ns = DirectCast(node, XText).Value\nEnd If\nConsole.WriteLine(\"Node type: {0}  {1}\", node.NodeType, s)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Node type: Text  More text content.\nNode type: Element</code></pre>\n"
  syntax:
    content: public IEnumerable<XNode> NodesAfterSelf()
    content.vb: Public Function NodesAfterSelf As IEnumerable(Of XNode)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XNode}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> of the sibling nodes after this node, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.NodesBeforeSelf
  commentId: M:System.Xml.Linq.XNode.NodesBeforeSelf
  id: NodesBeforeSelf
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: NodesBeforeSelf()
  fullName: System.Xml.Linq.XNode.NodesBeforeSelf()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NodesBeforeSelf
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 365
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns a collection of the sibling nodes before this node, in document order.</p>\n"
  remarks: "\n<p>This method only includes siblings in the returned collection. It does not include descendants.</p>\n<p>This method uses deferred execution. </p>\n"
  example:
  - "\n<p>The following example creates an XML tree, and then queries the tree using this axis method.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XText(\"Text content.\"),\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XText(\"More text content.\"),\nnew XElement(\"child3\", \"child3 content\")\n);\nXElement child = xmlTree.Element(\"Child2\");\nIEnumerable<XNode> nodes =\nfrom node in child.NodesBeforeSelf()\nselect node;\nforeach (XNode node in nodes)\nConsole.WriteLine(\"Node type: {0}  {1}\",\nnode.NodeType,\nnode.NodeType == XmlNodeType.Text ? (node as XText).Value : \"\");</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = New XElement(\"Root\", _\nNew XText(\"Text content.\"), _\nNew XElement(\"Child1\", \"child1 content\"), _\nNew XElement(\"Child2\", \"child2 content\"), _\nNew XText(\"More text content.\"), _\nNew XElement(\"child3\", \"child3 content\") _\n)\n\nDim child As XElement = xmlTree.Element(\"Child2\")\nDim nodes As IEnumerable(Of XNode) = _\nFrom node In child.NodesBeforeSelf() _\nSelect node\nFor Each node As XNode In nodes\nDim s As String = \"\"\nIf node.NodeType = XmlNodeType.Text Then\ns = DirectCast(node, XText).Value\nEnd If\nConsole.WriteLine(\"Node type: {0}  {1}\", node.NodeType, s)\nNext</code></pre>\n<p>This example produces the following output:</p>\n<pre><code>Node type: Text  Text content.\nNode type: Element</code></pre>\n"
  syntax:
    content: public IEnumerable<XNode> NodesBeforeSelf()
    content.vb: Public Function NodesBeforeSelf As IEnumerable(Of XNode)
    return:
      type: System.Collections.Generic.IEnumerable{System.Xml.Linq.XNode}
      description: "\n<p>An <xref href=\"System.Collections.Generic.IEnumerable`1\" data-throw-if-not-resolved=\"false\"></xref> of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> of the sibling nodes before this node, in document order.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  commentId: M:System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  id: ReadFrom(System.Xml.XmlReader)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ReadFrom(XmlReader)
  fullName: System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadFrom
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 366
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Creates an <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> from an <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader. This method enables you to process arbitrarily large XML files with a very small memory footprint.</p>\n<p>The reader that you pass to this method might throw exceptions. <xref href=\"System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)\" data-throw-if-not-resolved=\"false\"></xref> does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called <xref href=\"System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)\" data-throw-if-not-resolved=\"false\"></xref>. In particular, your code should be prepared to handle <xref href=\"System.Xml.XmlException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>For an example of how to stream a more complex document, see How to: Stream XML Fragments with Access to Header Information.</p>\n<p>Certain standard query operators, such as <see cref=\"Overload:System.Linq.Enumerable.OrderBy\"></see>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence. If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.</p>\n<p>For an example of using LINQ to XML to transform extremely large XML documents while maintaining a small memory footprint, see How to: Perform Streaming Transform of Large XML Documents.</p>\n"
  example:
  - "\n<p>This example uses the following XML file, named Source.xml:</p>\n<pre><code class=\"xml\"><?xml version=\"1.0\" encoding=\"utf-8\" ?> \n<Root>\n<Child Key=\"01\">\n<GrandChild>aaa</GrandChild>\n</Child>\n<Child Key=\"02\">\n<GrandChild>bbb</GrandChild>\n</Child>\n<Child Key=\"03\">\n<GrandChild>ccc</GrandChild>\n</Child>\n</Root></code></pre>\n<p>This example creates a custom axis method that uses <xref href=\"System.Xml.Linq.XNode.ReadFrom(System.Xml.XmlReader)\" data-throw-if-not-resolved=\"false\"></xref>. You can query the custom axis by using a LINQ query.</p>\n<p>The following example uses the yield return construct of C#. Because there is no equivalent feature in Visual Basic 2008, this example is provided only in C#.</p>\n<pre><code class=\"c#\">class Program\n{\nstatic IEnumerable<XElement> StreamRootChildDoc(string uri)\n{\nusing (XmlReader reader = XmlReader.Create(uri))\n{\n    reader.MoveToContent();\n    // Parse the file and display each of the nodes.\n    while (reader.Read())\n    {\n        switch (reader.NodeType)\n        {\n            case XmlNodeType.Element:\n                if (reader.Name == \"Child\")\n                {\n                    XElement el = XElement.ReadFrom(reader) as XElement;\n                    if (el != null)\n                        yield return el;\n                }\n                break;\n        }\n    }\n}\n}\n\nstatic void Main(string[] args)\n{\nIEnumerable<string> grandChildData =\n    from el in StreamRootChildDoc(\"Source.xml\")\n    where (int)el.Attribute(\"Key\") > 1\n    select (string)el.Element(\"GrandChild\");\n\nforeach (string str in grandChildData)\n    Console.WriteLine(str);\n}\n}</code></pre>\n<p>This example produces the following output.</p>\n<pre><code>bbb\nccc</code></pre>\n"
  syntax:
    content: public static XNode ReadFrom(XmlReader reader)
    content.vb: Public Shared Function ReadFrom(reader As XmlReader) As XNode
    parameters:
    - id: reader
      type: System.Xml.XmlReader
      description: "\n<p>An <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> positioned at the node to read into this <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.Xml.Linq.XNode
      description: "\n<p>An <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> that contains the node and its descendant nodes that were read from the reader. The runtime type of the node is determined by the node type (<xref href=\"System.Xml.Linq.XObject.NodeType\" data-throw-if-not-resolved=\"false\"></xref>) of the first node encountered in the reader.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> is not positioned on a recognized node type.</p>\n"
  - type: System.Xml.XmlException
    commentId: T:System.Xml.XmlException
    description: "\n<p>The underlying <xref href=\"System.Xml.XmlReader\" data-throw-if-not-resolved=\"false\"></xref> throws an exception.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Xml.Linq.XNode.Remove
  commentId: M:System.Xml.Linq.XNode.Remove
  id: Remove
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: Remove()
  fullName: System.Xml.Linq.XNode.Remove()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Remove
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 367
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Removes this node from its parent.</p>\n"
  remarks: "\n<p>In LINQ to XML programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set. In practical terms, this means that you should not iterate over a set of nodes and remove them. Instead, you should materialize them into a <xref href=\"System.Collections.Generic.List`1\" data-throw-if-not-resolved=\"false\"></xref> by using the <xref href=\"System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})\" data-throw-if-not-resolved=\"false\"></xref> extension method. Then, you can iterate over the list to remove the nodes. For more information, see Mixed Declarative Code/Imperative Code Bugs (LINQ to XML).</p>\n<p>Alternatively, if you want to remove a set of nodes, it is recommended that you use the <see cref=\"Overload:System.Xml.Linq.Extensions.Remove\"></see> method. This method copies the nodes to a list, and then iterates over the list to remove the nodes.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <xref href=\"System.Xml.Linq.XNode.Remove\" data-throw-if-not-resolved=\"false\"></xref> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.</p>\n"
  example:
  - "\n<p>The following example removes a node from its parent.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child3 = xmlTree.Element(\"Child3\");\nchild3.Remove();\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child3 As XElement = xmlTree.<Child3>(0)\nchild3.Remove()\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>child1 content</Child1>\n<Child2>child2 content</Child2>\n<Child4>child4 content</Child4>\n<Child5>child5 content</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void Remove()
    content.vb: Public Sub Remove
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The parent is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ReplaceWith(System.Object)
  commentId: M:System.Xml.Linq.XNode.ReplaceWith(System.Object)
  id: ReplaceWith(System.Object)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ReplaceWith(Object)
  fullName: System.Xml.Linq.XNode.ReplaceWith(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceWith
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 368
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces this node with the specified content.</p>\n"
  remarks: "\n<p>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <see cref=\"Overload:System.Xml.Linq.XNode.ReplaceWith\"></see> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.</p>\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example uses this method to replace the contents of a node with different content.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", \"child1 content\"),\nnew XElement(\"Child2\", \"child2 content\"),\nnew XElement(\"Child3\", \"child3 content\"),\nnew XElement(\"Child4\", \"child4 content\"),\nnew XElement(\"Child5\", \"child5 content\")\n);\nXElement child3 = xmlTree.Element(\"Child3\");\nchild3.ReplaceWith(\nnew XElement(\"NewChild\", \"new content\")\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>child1 content</Child1>\n    <Child2>child2 content</Child2>\n    <Child3>child3 content</Child3>\n    <Child4>child4 content</Child4>\n    <Child5>child5 content</Child5>\n</Root>\n\nDim child3 As XElement = xmlTree.<Child3>(0)\nchild3.ReplaceWith(<NewChild>new content</NewChild>)\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>child1 content</Child1>\n<Child2>child2 content</Child2>\n<NewChild>new content</NewChild>\n<Child4>child4 content</Child4>\n<Child5>child5 content</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void ReplaceWith(object content)
    content.vb: Public Sub ReplaceWith(content As Object)
    parameters:
    - id: content
      type: System.Object
      description: "\n<p>Content that replaces this node.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  commentId: M:System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  id: ReplaceWith(System.Object[])
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ReplaceWith(Object[])
  fullName: System.Xml.Linq.XNode.ReplaceWith(System.Object[])
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReplaceWith
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 369
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Replaces this node with the specified content.</p>\n"
  remarks: "\n<p>This method first removes this node from its parent, and then adds the specified content to this node's parent, in the place of this node.</p>\n<p>The <xref href=\"System.Xml.Linq.XContainer\" data-throw-if-not-resolved=\"false\"></xref> stores its child nodes as a singly-linked list of <xref href=\"System.Xml.Linq.XNode\" data-throw-if-not-resolved=\"false\"></xref> objects. This means that the <see cref=\"Overload:System.Xml.Linq.XNode.ReplaceWith\"></see> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.</p>\n<p>For details about the valid content that can be passed to this method, see Valid Content of XElement and XDocument Objects.</p>\n<p>This method will raise the <xref href=\"System.Xml.Linq.XObject.Changed\" data-throw-if-not-resolved=\"false\"></xref> and the <xref href=\"System.Xml.Linq.XObject.Changing\" data-throw-if-not-resolved=\"false\"></xref> events.</p>\n"
  example:
  - "\n<p>The following example shows using the results of a LINQ to XML query as the input to this method.</p>\n<pre><code class=\"c#\">XElement srcTree = new XElement(\"Root\",\nnew XElement(\"Element1\", 1),\nnew XElement(\"Element2\", 2),\nnew XElement(\"Element3\", 3),\nnew XElement(\"Element4\", 4),\nnew XElement(\"Element5\", 5)\n);\nXElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1),\nnew XElement(\"Child2\", 2),\nnew XElement(\"Child3\", 3),\nnew XElement(\"Child4\", 4),\nnew XElement(\"Child5\", 5)\n);\nXElement child3 = xmlTree.Element(\"Child3\");\nchild3.ReplaceWith(\nfrom el in srcTree.Elements()\nwhere (int)el > 3\nselect el\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim srcTree As XElement = _ \n<Root>\n    <Element1>1</Element1>\n    <Element2>2</Element2>\n    <Element3>3</Element3>\n    <Element4>4</Element4>\n    <Element5>5</Element5>\n</Root>\n\nDim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n    <Child2>2</Child2>\n    <Child3>3</Child3>\n    <Child4>4</Child4>\n    <Child5>5</Child5>\n</Root>\n\nDim child3 As XElement = xmlTree.<Child3>(0)\nchild3.ReplaceWith( _\nFrom el In srcTree.Elements() _\nWhere (CInt(el) > 3) _\nSelect el)\n\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>1</Child1>\n<Child2>2</Child2>\n<Element4>4</Element4>\n<Element5>5</Element5>\n<Child4>4</Child4>\n<Child5>5</Child5>\n</Root></code></pre>\n"
  syntax:
    content: public void ReplaceWith(params object[] content)
    content.vb: Public Sub ReplaceWith(ParamArray content As Object())
    parameters:
    - id: content
      type: System.Object[]
      description: "\n<p>A parameter list of the new content.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Xml.Linq.XNode.ReplaceWith(System.Object())
  name.vb: ReplaceWith(Object())
- uid: System.Xml.Linq.XNode.ToString
  commentId: M:System.Xml.Linq.XNode.ToString
  id: ToString
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ToString()
  fullName: System.Xml.Linq.XNode.ToString()
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ToString
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 370
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns the indented XML for this node.</p>\n"
  example:
  - "\n<p>The following example uses this method to retrieve indented XML.</p>\n<pre><code class=\"c#\">XElement xmlTree = new XElement(\"Root\",\nnew XElement(\"Child1\", 1)\n);\nConsole.WriteLine(xmlTree);</code></pre>\n<pre><code class=\"vb\">Dim xmlTree As XElement = _ \n<Root>\n    <Child1>1</Child1>\n</Root>\n\nConsole.WriteLine(xmlTree)</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child1>1</Child1>\n</Root></code></pre>\n"
  syntax:
    content: public override string ToString()
    content.vb: Public Overrides Function ToString As String
    return:
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the indented XML.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  commentId: M:System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  id: ToString(System.Xml.Linq.SaveOptions)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: ToString(SaveOptions)
  fullName: System.Xml.Linq.XNode.ToString(System.Xml.Linq.SaveOptions)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ToString
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 371
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Returns the XML for this node, optionally disabling formatting.</p>\n"
  example:
  - "\n<p>The following example uses this method to retrieve unformatted and formatted XML.</p>\n<pre><code class=\"c#\">XElement root = XElement.Parse(\"<Root><Child/></Root>\");\nConsole.WriteLine(root.ToString(SaveOptions.DisableFormatting));\nConsole.WriteLine(\"---\");\nConsole.WriteLine(root.ToString(SaveOptions.None));</code></pre>\n<pre><code class=\"vb\">Dim root As XElement = <Root>\n                   <Child/>\n               </Root>\nConsole.WriteLine(root.ToString(SaveOptions.DisableFormatting))\nConsole.WriteLine(\"---\")\nConsole.WriteLine(root.ToString(SaveOptions.None))</code></pre>\n<p>This example produces the following output:</p>\n<pre><code><Root><Child /></Root>\n---\n<Root>\n<Child />\n</Root></code></pre>\n"
  syntax:
    content: public string ToString(SaveOptions options)
    content.vb: Public Function ToString(options As SaveOptions) As String
    parameters:
    - id: options
      type: System.Xml.Linq.SaveOptions
      description: "\n<p>A <xref href=\"System.Xml.Linq.SaveOptions\" data-throw-if-not-resolved=\"false\"></xref> that specifies formatting behavior.</p>\n"
    return:
      type: System.String
      description: "\n<p>A <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> containing the XML.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  commentId: M:System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  id: WriteTo(System.Xml.XmlWriter)
  parent: System.Xml.Linq.XNode
  langs:
  - csharp
  - vb
  name: WriteTo(XmlWriter)
  fullName: System.Xml.Linq.XNode.WriteTo(System.Xml.XmlWriter)
  type: Method
  source:
    remote:
      path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteTo
    path: src/System.Xml.XDocument/ref/System.Xml.XDocument.cs
    startLine: 372
  assemblies:
  - System.Xml.XDocument
  namespace: System.Xml.Linq
  summary: "\n<p>Writes this node to an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>You can use this method to write code that does a streaming transform of a very large document. For more information, see How to: Perform Streaming Transform of Large XML Documents.</p>\n"
  example:
  - "\n<p>The following example creates an <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> that writes to a <xref href=\"System.Text.StringBuilder\" data-throw-if-not-resolved=\"false\"></xref>. It then uses this method to write two XML trees to the writer.</p>\n<pre><code class=\"c#\">StringBuilder sb = new StringBuilder();\nXmlWriterSettings xws = new XmlWriterSettings();\nxws.OmitXmlDeclaration = true;\nxws.Indent = true;\n\nusing (XmlWriter xw = XmlWriter.Create(sb, xws)) {\nxw.WriteStartElement(\"Root\");\nXElement child1 = new XElement(\"Child\",\nnew XElement(\"GrandChild\", \"some content\")\n);\nchild1.WriteTo(xw);\nXElement child2 = new XElement(\"AnotherChild\",\nnew XElement(\"GrandChild\", \"different content\")\n);\nchild2.WriteTo(xw);\nxw.WriteEndElement();\n}\nConsole.WriteLine(sb.ToString());</code></pre>\n<pre><code class=\"vb\">Dim sb As StringBuilder = New StringBuilder()\nDim xws As XmlWriterSettings = New XmlWriterSettings()\nxws.OmitXmlDeclaration = True\nxws.Indent = True\n\nUsing xw = XmlWriter.Create(sb, xws)\nxw.WriteStartElement(\"Root\")\nDim child1 As XElement = <Child>\n                         <GrandChild>some content</GrandChild>\n                     </Child>\nchild1.WriteTo(xw)\nDim child2 As XElement = <AnotherChild>\n                         <GrandChild>different content</GrandChild>\n                     </AnotherChild>\nchild2.WriteTo(xw)\nxw.WriteEndElement()\nEnd Using\n\nConsole.WriteLine(sb.ToString())</code></pre>\n<p>This example produces the following output:</p>\n<pre><code class=\"xml\"><Root>\n<Child>\n<GrandChild>some content</GrandChild>\n</Child>\n<AnotherChild>\n<GrandChild>different content</GrandChild>\n</AnotherChild>\n</Root></code></pre>\n"
  syntax:
    content: public abstract void WriteTo(XmlWriter writer)
    content.vb: Public MustOverride Sub WriteTo(writer As XmlWriter)
    parameters:
    - id: writer
      type: System.Xml.XmlWriter
      description: "\n<p>An <xref href=\"System.Xml.XmlWriter\" data-throw-if-not-resolved=\"false\"></xref> into which this method will write.</p>\n"
  modifiers.csharp:
  - public
  - abstract
  modifiers.vb:
  - Public
  - MustOverride
references:
- uid: System.Xml.Linq
  isExternal: false
  name: System.Xml.Linq
  fullName: System.Xml.Linq
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Xml.Linq.XObject
  parent: System.Xml.Linq
  isExternal: false
  name: XObject
  fullName: System.Xml.Linq.XObject
- uid: System.Xml.Linq.XObject.BaseUri
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: BaseUri
  fullName: System.Xml.Linq.XObject.BaseUri
- uid: System.Xml.Linq.XObject.Document
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Document
  fullName: System.Xml.Linq.XObject.Document
- uid: System.Xml.Linq.XObject.NodeType
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: NodeType
  fullName: System.Xml.Linq.XObject.NodeType
- uid: System.Xml.Linq.XObject.Parent
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Parent
  fullName: System.Xml.Linq.XObject.Parent
- uid: System.Xml.Linq.XObject.Changed
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Changed
  fullName: System.Xml.Linq.XObject.Changed
- uid: System.Xml.Linq.XObject.Changing
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Changing
  fullName: System.Xml.Linq.XObject.Changing
- uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: AddAnnotation(Object)
  fullName: System.Xml.Linq.XObject.AddAnnotation(System.Object)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
    name: AddAnnotation
    fullName: System.Xml.Linq.XObject.AddAnnotation
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.AddAnnotation(System.Object)
    name: AddAnnotation
    fullName: System.Xml.Linq.XObject.AddAnnotation
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotation(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: Annotation(Type)
  fullName: System.Xml.Linq.XObject.Annotation(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotation(System.Type)
    name: Annotation
    fullName: System.Xml.Linq.XObject.Annotation
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotation(System.Type)
    name: Annotation
    fullName: System.Xml.Linq.XObject.Annotation
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotation``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Annotation<T>()
  fullName: System.Xml.Linq.XObject.Annotation<T>()
  fullname.vb: System.Xml.Linq.XObject.Annotation(Of T)()
  name.vb: Annotation(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotation``1
    name: Annotation<T>
    fullName: System.Xml.Linq.XObject.Annotation<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotation``1
    name: Annotation(Of T)
    fullName: System.Xml.Linq.XObject.Annotation(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotations(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: Annotations(Type)
  fullName: System.Xml.Linq.XObject.Annotations(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotations(System.Type)
    name: Annotations
    fullName: System.Xml.Linq.XObject.Annotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotations(System.Type)
    name: Annotations
    fullName: System.Xml.Linq.XObject.Annotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.Annotations``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: Annotations<T>()
  fullName: System.Xml.Linq.XObject.Annotations<T>()
  fullname.vb: System.Xml.Linq.XObject.Annotations(Of T)()
  name.vb: Annotations(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.Annotations``1
    name: Annotations<T>
    fullName: System.Xml.Linq.XObject.Annotations<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.Annotations``1
    name: Annotations(Of T)
    fullName: System.Xml.Linq.XObject.Annotations(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  parent: System.Xml.Linq.XObject
  isExternal: true
  name: RemoveAnnotations(Type)
  fullName: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
  spec.csharp:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
    name: RemoveAnnotations
    fullName: System.Xml.Linq.XObject.RemoveAnnotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations(System.Type)
    name: RemoveAnnotations
    fullName: System.Xml.Linq.XObject.RemoveAnnotations
  - name: (
    fullName: (
  - uid: System.Type
    name: Type
    fullName: System.Type
    isExternal: true
  - name: )
    fullName: )
- uid: System.Xml.Linq.XObject.RemoveAnnotations``1
  parent: System.Xml.Linq.XObject
  isExternal: false
  name: RemoveAnnotations<T>()
  fullName: System.Xml.Linq.XObject.RemoveAnnotations<T>()
  fullname.vb: System.Xml.Linq.XObject.RemoveAnnotations(Of T)()
  name.vb: RemoveAnnotations(Of T)()
  spec.csharp:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations``1
    name: RemoveAnnotations<T>
    fullName: System.Xml.Linq.XObject.RemoveAnnotations<T>
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Xml.Linq.XObject.RemoveAnnotations``1
    name: RemoveAnnotations(Of T)
    fullName: System.Xml.Linq.XObject.RemoveAnnotations(Of T)
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Xml.Linq.XNodeDocumentOrderComparer
  parent: System.Xml.Linq
  isExternal: false
  name: XNodeDocumentOrderComparer
  fullName: System.Xml.Linq.XNodeDocumentOrderComparer
- uid: System.Xml.Linq.XNodeEqualityComparer
  parent: System.Xml.Linq
  isExternal: false
  name: XNodeEqualityComparer
  fullName: System.Xml.Linq.XNodeEqualityComparer
- uid: System.Xml.Linq.XNode
  parent: System.Xml.Linq
  isExternal: false
  name: XNode
  fullName: System.Xml.Linq.XNode
- uid: System.Object[]
  isExternal: true
  name: Object[]
  fullName: System.Object[]
  fullname.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<XElement>
  fullName: System.Collections.Generic.IEnumerable<System.Xml.Linq.XElement>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Xml.Linq.XElement)
  name.vb: IEnumerable(Of XElement)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Xml.Linq.XElement
    name: XElement
    fullName: System.Xml.Linq.XElement
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Xml.Linq.XElement
    name: XElement
    fullName: System.Xml.Linq.XElement
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Xml.Linq.XName
  parent: System.Xml.Linq
  isExternal: false
  name: XName
  fullName: System.Xml.Linq.XName
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Xml.XmlReader
  parent: System.Xml
  isExternal: false
  name: XmlReader
  fullName: System.Xml.XmlReader
- uid: System.Xml
  isExternal: false
  name: System.Xml
  fullName: System.Xml
- uid: System.Xml.Linq.ReaderOptions
  parent: System.Xml.Linq
  isExternal: false
  name: ReaderOptions
  fullName: System.Xml.Linq.ReaderOptions
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Collections.Generic.IEnumerable{System.Xml.Linq.XNode}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<XNode>
  fullName: System.Collections.Generic.IEnumerable<System.Xml.Linq.XNode>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Xml.Linq.XNode)
  name.vb: IEnumerable(Of XNode)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Xml.Linq.XNode
    name: XNode
    fullName: System.Xml.Linq.XNode
  - name: )
    fullName: )
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Xml.Linq.SaveOptions
  parent: System.Xml.Linq
  isExternal: false
  name: SaveOptions
  fullName: System.Xml.Linq.SaveOptions
- uid: System.Xml.XmlWriter
  parent: System.Xml
  isExternal: false
  name: XmlWriter
  fullName: System.Xml.XmlWriter
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.Xml.XmlException
  isExternal: false
  name: XmlException
  fullName: System.Xml.XmlException
