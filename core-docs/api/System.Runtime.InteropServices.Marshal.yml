items:
- uid: System.Runtime.InteropServices.Marshal
  commentId: T:System.Runtime.InteropServices.Marshal
  id: Marshal
  parent: System.Runtime.InteropServices
  children:
  - System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  - System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)
  - System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup
  - System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)
  - System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)
  - System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)
  - System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)
  - System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
  - System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
  - System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  - System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)
  - System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)
  - System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)
  - System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetExceptionCode
  - System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)
  - System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)
  - System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)
  - System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)
  - System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error
  - System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  - System.Runtime.InteropServices.Marshal.GetLastWin32Error
  - System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)
  - System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)
  - System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)
  - System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.IsComObject(System.Object)
  - System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)
  - System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)
  - System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)
  - System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)
  - System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)
  - System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  - System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
  - System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  - System.Runtime.InteropServices.Marshal.SizeOf(System.Type)
  - System.Runtime.InteropServices.Marshal.SizeOf``1
  - System.Runtime.InteropServices.Marshal.SizeOf``1(``0)
  - System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
  - System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  - System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)
  - System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  - System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)
  - System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)
  - System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)
  - System.Runtime.InteropServices.Marshal.SystemDefaultCharSize
  - System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize
  - System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)
  - System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)
  - System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)
  - System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)
  - System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  - System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)
  - System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)
  - System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)
  - System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)
  - System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)
  - System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)
  - System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)
  - System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)
  - System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)
  langs:
  - csharp
  - vb
  name: Marshal
  fullName: System.Runtime.InteropServices.Marshal
  type: Class
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Marshal
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 342
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Provides a collection of methods for allocating unmanaged memory, copying unmanaged memory blocks, and converting managed to unmanaged types, as well as other miscellaneous methods used when interacting with unmanaged code.</p>\n"
  remarks: "\n<p>The <strong>static</strong> methods defined on the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class are essential to working with unmanaged code. Most methods defined in this class are typically used by developers who want to provide a bridge between the managed and unmanaged programming models. For example, the <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method copies ANSI characters from a specified string (in the managed heap) to a buffer in the unmanaged heap. It also allocates the target heap of the right size.</p>\n<p>The common language runtime provides specific marshaling capabilities. For details on marshaling behavior, see Interop Marshaling.</p>\n<p>The <strong>Read</strong> and <strong>Write</strong> methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class support both aligned and unaligned access.</p>\n"
  example:
  - "\n<p>The following example shows how to use various methods defined by the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#1"
  syntax:
    content: 'public class Marshal : object'
    content.vb: >-
      Public Class Marshal
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Runtime.InteropServices.Marshal.SystemDefaultCharSize
  commentId: F:System.Runtime.InteropServices.Marshal.SystemDefaultCharSize
  id: SystemDefaultCharSize
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SystemDefaultCharSize
  fullName: System.Runtime.InteropServices.Marshal.SystemDefaultCharSize
  type: Field
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SystemDefaultCharSize
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 344
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for ANSI systems. This field is read-only.</p>\n"
  example:
  - "\n<p>The following example demonstrates the <xref href=\"System.Runtime.InteropServices.Marshal.SystemDefaultCharSize\" data-throw-if-not-resolved=\"false\"></xref> field. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#2"
  syntax:
    content: public static readonly int SystemDefaultCharSize
    content.vb: Public Shared ReadOnly SystemDefaultCharSize As Integer
    return:
      type: System.Int32
  seealso:
  - type: System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringAuto(System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAuto(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto(System.String)
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize
  commentId: F:System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize
  id: SystemMaxDBCSCharSize
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SystemMaxDBCSCharSize
  fullName: System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize
  type: Field
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SystemMaxDBCSCharSize
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 345
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system. This field is read-only.</p>\n"
  example:
  - "\n<p>The following example demonstrates the <xref href=\"System.Runtime.InteropServices.Marshal.SystemDefaultCharSize\" data-throw-if-not-resolved=\"false\"></xref> field. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#2"
  syntax:
    content: public static readonly int SystemMaxDBCSCharSize
    content.vb: Public Shared ReadOnly SystemMaxDBCSCharSize As Integer
    return:
      type: System.Int32
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  id: AddRef(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: AddRef(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AddRef
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 346
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Increments the reference count on the specified interface.</p>\n"
  remarks: "\n<p>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly. In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually. After calling <xref href=\"System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, you must decrement the reference count by using a method such as <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. Do not rely on the return value of <xref href=\"System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, as it can sometimes be unstable.</p>\n<p>You can call <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to obtain an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> value that represents an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface pointer. You can also use these methods and the <xref href=\"System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method on managed objects to obtain the COM interfaces represented by the managed object's COM callable wrapper. If you are not familiar with the details of this wrapper type, see COM Callable Wrapper.</p>\n"
  syntax:
    content: public static int AddRef(IntPtr pUnk)
    content.vb: Public Shared Function AddRef(pUnk As IntPtr) As Integer
    parameters:
    - id: pUnk
      type: System.IntPtr
      description: "\n<p>The interface reference count to increment.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The new value of the reference count on the <em>pUnk</em> parameter.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
    commentId: M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  - type: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  - type: System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  - type: System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  id: AllocCoTaskMem(System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: AllocCoTaskMem(Int32)
  fullName: System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AllocCoTaskMem
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 348
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a block of memory of specified size from the COM task memory allocator.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is one of two memory allocation API methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class. (<xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is the other.) The initial memory content returned is undefined, and the allocated memory can be larger than the requested number of bytes. This method exposes the COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148626\">CoTaskMemAlloc</see> function, which is referred to as the COM task memory allocator.</p>\n"
  syntax:
    content: public static IntPtr AllocCoTaskMem(int cb)
    content.vb: Public Shared Function AllocCoTaskMem(cb As Integer) As IntPtr
    parameters:
    - id: cb
      type: System.Int32
      description: "\n<p>The size of the block of memory to be allocated.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>An integer representing the address of the block of memory allocated. This memory must be released with <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to satisfy the request.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)
  id: AllocHGlobal(System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: AllocHGlobal(Int32)
  fullName: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AllocHGlobal
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 350
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates memory from the unmanaged memory of the process by using the specified number of bytes.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is one of two memory allocation methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class. (<xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is the other.) This method exposes the Win32 <see href=\"http://go.microsoft.com/fwlink/?LinkId=148628\">LocalAlloc</see> function from Kernel32.dll.</p>\n<p>When <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> calls <strong>LocalAlloc</strong>, it passes a <strong>LMEM_FIXED</strong> flag, which causes the allocated memory to be locked in place. Also, the allocated memory is not zero-filled.</p>\n"
  example:
  - "\n<p>The following example demonstrates calling the <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>method. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#4"
  syntax:
    content: public static IntPtr AllocHGlobal(int cb)
    content.vb: Public Shared Function AllocHGlobal(cb As Integer) As IntPtr
    parameters:
    - id: cb
      type: System.Int32
      description: "\n<p>The required number of bytes in memory.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>A pointer to the newly allocated memory. This memory must be released using the <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to satisfy the request.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  id: AllocHGlobal(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: AllocHGlobal(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AllocHGlobal
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 352
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates memory from the unmanaged memory of the process by using the pointer to the specified number of bytes.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is one of two memory allocation methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class. (<xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is the other.) This method exposes the Win32 <see href=\"http://go.microsoft.com/fwlink/?LinkID=148628\">LocalAlloc</see> function from Kernel32.dll.</p>\n<p>When <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> calls <strong>LocalAlloc</strong>, it passes a <strong>LMEM_FIXED</strong> flag, which causes the allocated memory to be locked in place. Also, the allocated memory is not zero-filled.</p>\n<p>For example code, see <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static IntPtr AllocHGlobal(IntPtr cb)
    content.vb: Public Shared Function AllocHGlobal(cb As IntPtr) As IntPtr
    parameters:
    - id: cb
      type: System.IntPtr
      description: "\n<p>The required number of bytes in memory.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>A pointer to the newly allocated memory. This memory must be released using the <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to satisfy the request.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup
  commentId: M:System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup
  id: AreComObjectsAvailableForCleanup
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: AreComObjectsAvailableForCleanup()
  fullName: System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup()
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AreComObjectsAvailableForCleanup
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 354
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Indicates whether runtime callable wrappers (RCWs) from any context are available for cleanup.</p>\n"
  remarks: "\n<p>If there are a lot of references between managed and native code with deep dependency graphs it can take a long time for all the objects to clean up. Each time a GC runs it will free up some number of RCWs, which will in turn release the underlying COM objects. Those COM objects will then release their managed references and make more objects available for cleanup the next time a GC runs, which starts the process over again.</p>\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.AreComObjectsAvailableForCleanup\" data-throw-if-not-resolved=\"false\"></xref> method provides a way for the application to determine how many cycles of GC.Collect and GC.WaitForPendingFinalizers need to happen in order to clean everything up.</p>\n"
  syntax:
    content: public static bool AreComObjectsAvailableForCleanup()
    content.vb: Public Shared Function AreComObjectsAvailableForCleanup As Boolean
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if there are any RCWs available for cleanup; otherwise, <strong>false</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Byte[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Byte[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 356
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory by using the <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Byte[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload, and then copies the unmanaged array back to managed memory by using the <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>overload.</p>Runtime.InteropServices.Marshal.Copy-byte#1"
  syntax:
    content: public static void Copy(byte[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Byte(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Byte[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Byte(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Byte(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Char[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Char[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Char[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 358
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed character array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-char#1"
  syntax:
    content: public static void Copy(char[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Char(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Char[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Char(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Char(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Double[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Double[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Double[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 360
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-double#1"
  syntax:
    content: public static void Copy(double[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Double(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Double[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Double(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Double(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Int16[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Int16[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Int16[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 362
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed 16-bit signed integer array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int16#1"
  syntax:
    content: public static void Copy(short[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Short(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Int16[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Int16(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Int16(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Int32[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Int32[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 364
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int#1"
  syntax:
    content: public static void Copy(int[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Integer(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Int32[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>startIndex</em> or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Int32(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Int32(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Int64[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Int64[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Int64[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 366
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed 64-bit signed integer array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int64#1"
  syntax:
    content: public static void Copy(long[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Long(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Int64[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Int64(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Int64(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Byte[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Byte[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 368
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed 8-bit unsigned integer array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-byte#1"
  syntax:
    content: public static void Copy(IntPtr source, byte[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Byte(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Byte[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Byte(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Byte(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Char[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Char[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Char[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 370
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed character array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-char#1"
  syntax:
    content: public static void Copy(IntPtr source, char[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Char(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Char[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Char(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Char(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Double[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Double[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Double[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 372
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed double-precision floating-point number array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-double#1"
  syntax:
    content: public static void Copy(IntPtr source, double[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Double(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Double[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Double(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Double(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Int16[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Int16[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int16[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 374
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed 16-bit signed integer array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int16#1"
  syntax:
    content: public static void Copy(IntPtr source, short[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Short(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Int16[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int16(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Int16(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Int32[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Int32[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int32[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 376
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed 32-bit signed integer array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int#1"
  syntax:
    content: public static void Copy(IntPtr source, int[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Integer(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Int32[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int32(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Int32(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Int64[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Int64[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int64[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 378
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed 64-bit signed integer array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the<em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  example:
  - "\n<p>The following example copies an array to unmanaged memory and then copies the unmanaged array back to managed memory.</p>Runtime.InteropServices.Marshal.Copy-int64#1"
  syntax:
    content: public static void Copy(IntPtr source, long[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Long(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from.</p>\n"
    - id: destination
      type: System.Int64[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Int64(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Int64(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, IntPtr[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.IntPtr[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 380
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Therefore, the unmanaged data that corresponds to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling the <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.IntPtr[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - 
  syntax:
    content: public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As IntPtr(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from. </p>\n"
    - id: destination
      type: System.IntPtr[]
      description: "\n<p>The array to copy to.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.IntPtr(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, IntPtr(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)
  id: Copy(System.IntPtr,System.Single[],System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr, Single[], Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Single[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 382
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from an unmanaged memory pointer to a managed single-precision floating-point number array.</p>\n"
  remarks: "\n<p>Unmanaged, C-style arrays do not contain bounds information, which prevents the <em>startIndex</em> and <em>length</em> parameters from being validated. Thus, the unmanaged data corresponding to the <em>source</em> parameter populates the managed array regardless of its usefulness. You must initialize the managed array with the appropriate size before calling this method.</p>\n"
  syntax:
    content: public static void Copy(IntPtr source, float[] destination, int startIndex, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr, destination As Single(), startIndex As Integer, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy from. </p>\n"
    - id: destination
      type: System.Single[]
      description: "\n<p>The array to copy to. </p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the destination array where copying should start. </p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr, System.Single(), System.Int32, System.Int32)
  name.vb: Copy(IntPtr, Single(), Int32, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.IntPtr[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(IntPtr[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 384
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> array to an unmanaged C-style array.</p>\n"
  example:
  - 
  syntax:
    content: public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As IntPtr(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.IntPtr[]
      description: "\n<p>The one-dimensional array to copy from.</p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start.</p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to.</p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>destination</em>, <em>startIndex</em>, or <em>length</em> is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.IntPtr(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(IntPtr(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)
  id: Copy(System.Single[],System.Int32,System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Copy(Single[], Int32, IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.Copy(System.Single[], System.Int32, System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Copy
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 386
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies data from a one-dimensional, managed single-precision floating-point number array to an unmanaged memory pointer.</p>\n"
  remarks: "\n<p>You can use this method to copy a subset of a one-dimensional managed array to an unmanaged C-style array.</p>\n"
  syntax:
    content: public static void Copy(float[] source, int startIndex, IntPtr destination, int length)
    content.vb: Public Shared Sub Copy(source As Single(), startIndex As Integer, destination As IntPtr, length As Integer)
    parameters:
    - id: source
      type: System.Single[]
      description: "\n<p>The one-dimensional array to copy from. </p>\n"
    - id: startIndex
      type: System.Int32
      description: "\n<p>The zero-based index in the source array where copying should start. </p>\n"
    - id: destination
      type: System.IntPtr
      description: "\n<p>The memory pointer to copy to. </p>\n"
    - id: length
      type: System.Int32
      description: "\n<p>The number of array elements to copy. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>startIndex</em> and <em>length</em> are not valid. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>source</em>, <em>startIndex</em>, <em>destination</em>, or <em>length</em> is <strong>null</strong>. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.Copy(System.Single(), System.Int32, System.IntPtr, System.Int32)
  name.vb: Copy(Single(), Int32, IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)
  id: CreateAggregatedObject(System.IntPtr,System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: CreateAggregatedObject(IntPtr, Object)
  fullName: System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateAggregatedObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 388
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Aggregates a managed object with the specified COM object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.CreateAggregatedObject(System.IntPtr,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method aggregates the inner managed pointer of a managed object with the specified outer pointer, and then returns an inner <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer of the managed object.</p>\n"
  syntax:
    content: public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o)
    content.vb: Public Shared Function CreateAggregatedObject(pOuter As IntPtr, o As Object) As IntPtr
    parameters:
    - id: pOuter
      type: System.IntPtr
      description: "\n<p>The outer <strong>IUnknown</strong> pointer.</p>\n"
    - id: o
      type: System.Object
      description: "\n<p>An object to aggregate.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The inner <strong>IUnknown</strong> pointer of the managed object.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>o</em> is a Windows Runtime object.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)
  commentId: M:System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)
  id: CreateAggregatedObject``1(System.IntPtr,``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: CreateAggregatedObject<T>(IntPtr, T)
  fullName: System.Runtime.InteropServices.Marshal.CreateAggregatedObject<T>(System.IntPtr, T)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateAggregatedObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 392
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Aggregates a managed object of the specified type with the specified COM object. </p>\n"
  remarks: "\n<p>The<xref href=\"System.Runtime.InteropServices.Marshal.CreateAggregatedObject``1(System.IntPtr,``0)\" data-throw-if-not-resolved=\"false\"></xref> method aggregates the inner managed pointer of a managed object of a specified type with the specified outer pointer, and returns an inner <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer of the managed object.</p>\n"
  syntax:
    content: public static IntPtr CreateAggregatedObject<T>(IntPtr pOuter, T o)
    content.vb: Public Shared Function CreateAggregatedObject(Of T)(pOuter As IntPtr, o As T) As IntPtr
    parameters:
    - id: pOuter
      type: System.IntPtr
      description: "\n<p>The outer <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer. </p>\n"
    - id: o
      type: '{T}'
      description: "\n<p>The managed object to aggregate. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the managed object to aggregate. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The inner <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer of the managed object. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>o</em> is a Windows Runtime object. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.CreateAggregatedObject(Of T)(System.IntPtr, T)
  name.vb: CreateAggregatedObject(Of T)(IntPtr, T)
- uid: System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)
  id: CreateWrapperOfType(System.Object,System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: CreateWrapperOfType(Object, Type)
  fullName: System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateWrapperOfType
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 394
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Wraps the specified COM object in an object of the specified type.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.CreateWrapperOfType(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> converts one COM class type, typically the generic <strong>__ComObject</strong> type, to another COM class type. The input COM object, represented by parameter <em>o</em>, is a Runtime Callable Wrapper (RCW).</p>\n<p>Both the <em>t</em> and <em>o</em> parameters must be classes whose signatures are attributed with <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref>. The Tlbimp.exe (Type Library Importer) tool applies this attribute for you when it imports a type library. If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</p>\n<p>Tlbimp.exe imports a COM coclass as a managed class and an interface. The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with \"Class\". For example, a coclass called <code>MyCoclass</code> becomes a coclass interface called <code>MyCoclass</code> and a managed class called <code>MyCoclassClass</code>. Since <em>t</em> must be a class, not an interface, be sure to specify the managed class (<code>MyCoclassClass</code>) and not the coclass interface.</p>\n<p>You lose the identity of the input COM object because a new RCW instance wraps the <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer exposed by the original RCW.</p>\n"
  syntax:
    content: public static object CreateWrapperOfType(object o, Type t)
    content.vb: Public Shared Function CreateWrapperOfType(o As Object, t As Type) As Object
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The object to be wrapped. </p>\n"
    - id: t
      type: System.Type
      description: "\n<p>The type of wrapper to create. </p>\n"
    return:
      type: System.Object
      description: "\n<p>The newly wrapped object that is an instance of the desired type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>t</em> must derive from <strong>__ComObject</strong>.</p>\n<p>-or-</p>\n<p>\n<em>t</em> is a Windows Runtime type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>t</em> parameter is <strong>null</strong>.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>\n<em>o</em> cannot be converted to the destination type because it does not support all required interfaces. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.ComImportAttribute
    commentId: T:System.Runtime.InteropServices.ComImportAttribute
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)
  commentId: M:System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)
  id: CreateWrapperOfType``2(``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: CreateWrapperOfType<T, TWrapper>(T)
  fullName: System.Runtime.InteropServices.Marshal.CreateWrapperOfType<T, TWrapper>(T)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CreateWrapperOfType
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 398
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Wraps the specified COM object in an object of the specified type.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.CreateWrapperOfType``2(``0)\" data-throw-if-not-resolved=\"false\"></xref> converts a COM object of type <em>T</em> to the <em>TWrapper</em> COM class type. The input COM object, represented by parameter <em>o</em>, is a Runtime Callable Wrapper (RCW).</p>\n<p>Both the <em>T</em>generic type parameter and the <em>o</em> parameter must be classes whose signatures are attributed with the <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute. The Tlbimp.exe (Type Library Importer) tool applies this attribute for you when it imports a type library. If you create the RCW manually in source code, you should apply this attribute to the managed signature that represents the original coclass to signify its COM origins.</p>\n<p>Tlbimp.exe imports a COM coclass as a managed class and an interface. The coclass interface has the same name as the original coclass, and the managed class has the original coclass name appended with \"Class\". For example, a coclass called <code>MyCoclass</code> becomes a coclass interface called <code>MyCoclass</code> and a managed class called <code>MyCoclassClass</code>. Because<em>T</em> must be a class, not an interface, be sure to specify the managed class (<code>MyCoclassClass</code>) and not the <strong>coclass</strong> interface.</p>\n<p>You lose the identity of the input COM object, because a new RCW instance wraps the <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> pointer exposed by the original RCW.</p>\n"
  syntax:
    content: public static TWrapper CreateWrapperOfType<T, TWrapper>(T o)
    content.vb: Public Shared Function CreateWrapperOfType(Of T, TWrapper)(o As T) As TWrapper
    parameters:
    - id: o
      type: '{T}'
      description: "\n<p>The object to be wrapped. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of object to wrap. </p>\n"
    - id: TWrapper
      description: "\n<p>The type of object to return. </p>\n"
    return:
      type: '{TWrapper}'
      description: "\n<p>The newly wrapped object. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>T</em> must derive from <strong>__ComObject</strong>. </p>\n<p>-or-</p>\n<p>\n<em>T</em> is a Windows Runtime type.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>\n<em>o</em> cannot be converted to the <em>TWrapper</em> because it does not support all required interfaces. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.CreateWrapperOfType(Of T, TWrapper)(T)
  name.vb: CreateWrapperOfType(Of T, TWrapper)(T)
- uid: System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
  id: DestroyStructure(System.IntPtr,System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: DestroyStructure(IntPtr, Type)
  fullName: System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DestroyStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 400
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees all substructures that the specified unmanaged memory block points to.</p>\n"
  remarks: "\n<p>You can use this method to free reference-type fields, such as strings, of an unmanaged structure. Unlike its fields, a structure can be a value type or a reference type. Value-type structures that contain value-type fields (all blittable) have no references whose memory must be freed. The <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> calls the COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148633\">SysFreeString</see> function, which, in turn, frees an allocated string.</p>\n<p>In addition to <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class provides two other memory-deallocation methods: <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static void DestroyStructure(IntPtr ptr, Type structuretype)
    content.vb: Public Shared Sub DestroyStructure(ptr As IntPtr, structuretype As Type)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory. </p>\n"
    - id: structuretype
      type: System.Type
      description: "\n<p>Type of a formatted class. This provides the layout information necessary to delete the buffer in the <em>ptr</em> parameter.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>structureType</em> has an automatic layout. Use sequential or explicit instead.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)
  id: DestroyStructure``1(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: DestroyStructure<T>(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.DestroyStructure<T>(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: DestroyStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 404
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Frees all substructures of a specified type that the specified unmanaged memory block points to. </p>\n"
  remarks: "\n<p>You can use this method to free reference type fields, such as strings, of an unmanaged structure. Unlike its fields, a structure can be a value type or a reference type. Value type structures that contain value type fields (all blittable) have no references whose memory must be freed. The <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method uses this method to prevent memory leaks when reusing memory occupied by a structure.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> calls the COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148633\">SysFreeString</see> function, which, in turn, frees an allocated string.</p>\n"
  syntax:
    content: public static void DestroyStructure<T>(IntPtr ptr)
    content.vb: Public Shared Sub DestroyStructure(Of T)(ptr As IntPtr)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the formatted structure. This provides the layout information necessary to delete the buffer in the <em>ptr</em> parameter. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>T</em> has an automatic layout. Use sequential or explicit instead. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.DestroyStructure(Of T)(System.IntPtr)
  name.vb: DestroyStructure(Of T)(IntPtr)
- uid: System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
  id: FinalReleaseComObject(System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: FinalReleaseComObject(Object)
  fullName: System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FinalReleaseComObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 406
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Releases all references to a Runtime Callable Wrapper (RCW) by setting its reference count to 0.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method releases the managed reference to a COM object. Calling this method is equivalent to calling the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method in a loop until it returns 0 (zero).</p>\n<p>When the reference count on the COM object becomes 0, the COM object is usually freed, although this depends on the COM object's implementation and is beyond the control of the runtime. However, the RCW can still exist, waiting to be garbage-collected.</p>\n<p>The COM object cannot be used after it has been separated from its underlying RCW. If you try to call a method on the RCW after its reference count becomes 0, a <xref href=\"System.Runtime.InteropServices.InvalidComObjectException\" data-throw-if-not-resolved=\"false\"></xref> will be thrown.</p>\n"
  syntax:
    content: public static int FinalReleaseComObject(object o)
    content.vb: Public Shared Function FinalReleaseComObject(o As Object) As Integer
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The RCW to be released.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The new value of the reference count of the RCW associated with the <em>o</em><em></em>parameter, which is 0 (zero) if the release is successful.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>o</em> is not a valid COM object.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>o</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
  id: FreeBSTR(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: FreeBSTR(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FreeBSTR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 408
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees a <strong>BSTR</strong> using the COM <see href=\"http://go.microsoft.com/fwlink/?LinkID=148633\">SysFreeString</see> function.</p>\n"
  remarks: "\n<p>Like <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, you can use this method to deallocate memory. <xref href=\"System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> calls the COM <see href=\"http://go.microsoft.com/fwlink/?LinkID=148633\">SysFreeString</see> function, which frees memory allocated by any of the following unmanaged methods: <strong>SysAllocString</strong>, <strong>SysAllocStringByteLen</strong>, <strong>SysAllocStringLen</strong>, <strong>SysReAllocString</strong>, <strong>SysReAllocStringLen</strong>. You can call unmanaged methods such as these with platform invoke. For details, see Consuming Unmanaged DLL Functions.</p>\n"
  syntax:
    content: public static void FreeBSTR(IntPtr ptr)
    content.vb: Public Shared Sub FreeBSTR(ptr As IntPtr)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the BSTR to be freed. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  id: FreeCoTaskMem(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: FreeCoTaskMem(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FreeCoTaskMem
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 410
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees a block of memory allocated by the unmanaged COM task memory allocator.</p>\n"
  remarks: "\n<p>You can use <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> to free any memory allocated by <xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, or any equivalent unmanaged method. If the <em>ptr</em> parameter is <strong>null</strong>, the method does nothing.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> exposes the COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148638\">CoTaskMemFree</see> function, which frees all bytes so that you can no longer use the memory that the <em>ptr</em> parameter points to.</p>\n<p>In addition to <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class provides two other memory-deallocation methods: <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static void FreeCoTaskMem(IntPtr ptr)
    content.vb: Public Shared Sub FreeCoTaskMem(ptr As IntPtr)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the memory to be freed. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)
  - type: System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  id: FreeHGlobal(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: FreeHGlobal(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FreeHGlobal
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 412
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees memory previously allocated from the unmanaged memory of the process.</p>\n"
  remarks: "\n<p>You can use <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> to free any memory from the global heap allocated by <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, or any equivalent unmanaged API method. If the <em>hglobal</em> parameter is <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref> the method does nothing.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> exposes the <see href=\"http://go.microsoft.com/fwlink/?LinkId=148640\">LocalFree</see> function from Kernel32.DLL, which frees all bytes so that you can no longer use the memory pointed to by <em>hglobal</em>.</p>\n<p>In addition to <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>, the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class provides two other memory-deallocation API methods: <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following example demonstrates calling the <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#4<p>The following example demonstrates how to convert the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> class to unmanaged memory and then dispose of the unmanaged memory when done. </p>Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1"
  syntax:
    content: public static void FreeHGlobal(IntPtr hglobal)
    content.vb: Public Shared Sub FreeHGlobal(hglobal As IntPtr)
    parameters:
    - id: hglobal
      type: System.IntPtr
      description: "\n<p>The handle returned by the original matching call to <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  id: GetComInterfaceForObject(System.Object,System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetComInterfaceForObject(Object, Type)
  fullName: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetComInterfaceForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 414
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns a pointer to an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface that represents the specified interface on the specified object. Custom query interface access is enabled by default.</p>\n"
  remarks: "\n<p>This method returns an interface pointer that represents the requested interface on the specified object. It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> to decrement the reference count once you have finished with the pointer. You must adhere to the rules defined by COM when using raw COM interface pointers.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> is useful when calling a method that exposes a COM object parameter as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type, or with custom marshaling. Although less common, you can use this method on a managed object to obtain a pointer to the object's COM callable wrapper. For example, you can use <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> on a managed object that is exported to COM to obtain an interface pointer for <xref href=\"System.Runtime.InteropServices.UCOMIConnectionPointContainer\" data-throw-if-not-resolved=\"false\"></xref>. You cannot obtain a pointer to a class interface since a class interface lacks the corresponding type to pass to the second parameter (<em>t</em>). Instead, use <xref href=\"System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to invoke the members on the default interface of the COM callable wrapper, which is usually an auto-dispatch class interface.</p>\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method overload allows query interface customization by default. To specify whether to apply query interface customization, use the <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)\" data-throw-if-not-resolved=\"false\"></xref> method overload. </p>\n<p>For additional information, see the COM Callable Wrapper, Runtime Callable Wrapper, and Introducing the Class Interface topics.</p>\n"
  syntax:
    content: public static IntPtr GetComInterfaceForObject(object o, Type T)
    content.vb: Public Shared Function GetComInterfaceForObject(o As Object, T As Type) As IntPtr
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The object that provides the interface. </p>\n"
    - id: T
      type: System.Type
      description: "\n<p>The type of interface that is requested. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The interface pointer that represents the specified interface for the object.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>T</em> parameter is not an interface.</p>\n<p>-or-</p>\n<p>The type is not visible to COM. </p>\n<p>-or-</p>\n<p>The <em>T</em> parameter is a generic type.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>The <em>o</em> parameter does not support the requested interface. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>o</em> parameter is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>The <em>T</em> parameter is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObjectInContext(System.Object,System.Type)
  - type: System.Runtime.InteropServices.ComImportAttribute
    commentId: T:System.Runtime.InteropServices.ComImportAttribute
  - type: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - type: System.Runtime.InteropServices.UCOMIConnectionPointContainer
    commentId: T:System.Runtime.InteropServices.UCOMIConnectionPointContainer
  - type: System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)
  commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)
  id: GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetComInterfaceForObject(Object, Type, CustomQueryInterfaceMode)
  fullName: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object, System.Type, System.Runtime.InteropServices.CustomQueryInterfaceMode)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetComInterfaceForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 418
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns a pointer to an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface that represents the specified interface on the specified object. Custom query interface access is controlled by the specified customization mode.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)\" data-throw-if-not-resolved=\"false\"></xref>lets you specify whether to apply query interface customization. Use the <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> overload to apply query interface customization by default.</p>\n"
  syntax:
    content: public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode)
    content.vb: Public Shared Function GetComInterfaceForObject(o As Object, T As Type, mode As CustomQueryInterfaceMode) As IntPtr
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The object that provides the interface.</p>\n"
    - id: T
      type: System.Type
      description: "\n<p>The type of interface that is requested.</p>\n"
    - id: mode
      type: System.Runtime.InteropServices.CustomQueryInterfaceMode
      description: "\n<p>One of the enumeration values that indicates whether to apply an <strong>IUnknown::QueryInterface</strong> customization that is supplied by an <xref href=\"System.Runtime.InteropServices.ICustomQueryInterface\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The interface pointer that represents the interface for the object.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>T</em> parameter is not an interface.</p>\n<p>-or- </p>\n<p>The type is not visible to COM.</p>\n<p>-or-</p>\n<p>The <em>T</em> parameter is a generic type.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>The object <em>o</em> does not support the requested interface.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>o</em> parameter is <strong>null</strong>.</p>\n<p>-or- </p>\n<p>The <em>T</em> parameter is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)
  commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)
  id: GetComInterfaceForObject``2(``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetComInterfaceForObject<T, TInterface>(T)
  fullName: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject<T, TInterface>(T)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetComInterfaceForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 422
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Returns a pointer to an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface that represents the specified interface on an object of the specified type. Custom query interface access is enabled by default.</p>\n"
  remarks: "\n<p>This method returns an interface pointer that represents the <em>TInterface</em> interface on the specified object. It is particularly useful if you have an unmanaged method that expects to be passed an interface pointer. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use the <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>method to decrement the reference count when you have finished with the pointer. You must adhere to the rules defined by COM when using raw COM interface pointers.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)\" data-throw-if-not-resolved=\"false\"></xref> is useful when calling a method that exposes a COM object parameter as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type, or with custom marshaling. You can also use this method on a managed object to obtain a pointer to the object's COM callable wrapper, although this is less common. For example, you can use<xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)\" data-throw-if-not-resolved=\"false\"></xref> on a managed object that is exported to COM to obtain an interface pointer for <xref href=\"System.Runtime.InteropServices.UCOMIConnectionPointContainer\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The<xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject``2(``0)\" data-throw-if-not-resolved=\"false\"></xref> method overload allows query interface customization by default. To specify whether to apply query interface customization, use the <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type,System.Runtime.InteropServices.CustomQueryInterfaceMode)\" data-throw-if-not-resolved=\"false\"></xref> method overload. </p>\n<p>For additional information, see the COM Callable Wrapper, Runtime Callable Wrapper, and Introducing the Class Interface topics.</p>\n"
  syntax:
    content: public static IntPtr GetComInterfaceForObject<T, TInterface>(T o)
    content.vb: Public Shared Function GetComInterfaceForObject(Of T, TInterface)(o As T) As IntPtr
    parameters:
    - id: o
      type: '{T}'
      description: "\n<p>The object that provides the interface. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of <em>o</em>. </p>\n"
    - id: TInterface
      description: "\n<p>The type of interface to return. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The interface pointer that represents the <em>TInterface</em> interface.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>TInterface</em> parameter is not an interface.</p>\n<p>-or- </p>\n<p>The type is not visible to COM. </p>\n<p>-or-</p>\n<p>The <em>T</em> parameter is an open generic type.</p>\n"
  - type: System.InvalidCastException
    commentId: T:System.InvalidCastException
    description: "\n<p>The <em>o</em> parameter does not support the <em>TInterface</em> interface. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>o</em> parameter is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(Of T, TInterface)(T)
  name.vb: GetComInterfaceForObject(Of T, TInterface)(T)
- uid: System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)
  id: GetDelegateForFunctionPointer(System.IntPtr,System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetDelegateForFunctionPointer(IntPtr, Type)
  fullName: System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetDelegateForFunctionPointer
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 424
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts an unmanaged function pointer to a delegate.</p>\n"
  remarks: "\n<p>In versions 1.0 and 1.1 of the .NET Framework, it was possible to pass a delegate representing a managed method to unmanaged code as a function pointer, allowing the unmanaged code to call the managed method through the function pointer. It was also possible for the unmanaged code to pass that function pointer back to the managed code, and the pointer was resolved properly to the underlying managed method.</p>\n<p>In the .NET Framework 2.0 and later versions, you can use the <xref href=\"System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> methods to marshal delegates in both directions. With <xref href=\"System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>, <em>ptr</em> is imported as a <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>. A <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> can be obtained for a managed delegate by calling <xref href=\"System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)\" data-throw-if-not-resolved=\"false\"></xref> and passed as a parameter; it can then be called from inside the unmanaged method. Note that the parameter marshaler can also marshal function pointers to delegates in the .NET Framework 2.0 and later versions.</p>\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method has the following restrictions:</p>\n<ul><li>\n<p>Generics are not supported in interop scenarios.</p>\n</li><li>\n<p>You cannot pass an invalid function pointer to this method.</p>\n</li><li>\n<p>You can use this method only for pure unmanaged function pointers.</p>\n</li><li>\n<p>You cannot use this method with function pointers obtained through C++ or from the <xref href=\"System.RuntimeMethodHandle.GetFunctionPointer\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n</li><li>\n<p>You cannot use this method to create a delegate from a function pointer to another managed delegate.</p>\n</li></ul>\n"
  syntax:
    content: public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t)
    content.vb: 'Public Shared Function GetDelegateForFunctionPointer(ptr As IntPtr, t As Type) As '
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The unmanaged function pointer to be converted.</p>\n"
    - id: t
      type: System.Type
      description: "\n<p>The type of the delegate to be returned.</p>\n"
    return:
      type: System.Delegate
      description: "\n<p>A delegate instance that can be cast to the appropriate delegate type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>t</em> parameter is not a delegate or is generic.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>ptr</em> parameter is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>The <em>t</em> parameter is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)
  id: GetDelegateForFunctionPointer``1(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetDelegateForFunctionPointer<TDelegate>(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer<TDelegate>(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetDelegateForFunctionPointer
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 428
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Converts an unmanaged function pointer to a delegate of a specified type. </p>\n"
  remarks: "\n<p>You can use the<xref href=\"System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> and<xref href=\"System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)\" data-throw-if-not-resolved=\"false\"></xref>methods to marshal delegates in both directions. </p>\n<p>The<xref href=\"System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method has the following restrictions:</p>\n<ul><li>\n<p>You cannot pass an invalid function pointer to this method.</p>\n</li><li>\n<p>You can use this method only for pure unmanaged function pointers.</p>\n</li><li>\n<p>You cannot use this method with function pointers obtained through C++ or from the <xref href=\"System.RuntimeMethodHandle.GetFunctionPointer\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n</li><li>\n<p>You cannot use this method to create a delegate from a function pointer to another managed delegate.</p>\n</li></ul>\n"
  syntax:
    content: public static TDelegate GetDelegateForFunctionPointer<TDelegate>(IntPtr ptr)
    content.vb: Public Shared Function GetDelegateForFunctionPointer(Of TDelegate)(ptr As IntPtr) As TDelegate
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The unmanaged function pointer to convert. </p>\n"
    typeParameters:
    - id: TDelegate
      description: "\n<p>The type of the delegate to return. </p>\n"
    return:
      type: '{TDelegate}'
      description: "\n<p>A instance of the specified delegate type.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>TDelegate</em> generic parameter is not a delegate, or it is an open generic type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>ptr</em> parameter is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetDelegateForFunctionPointer(Of TDelegate)(System.IntPtr)
  name.vb: GetDelegateForFunctionPointer(Of TDelegate)(IntPtr)
- uid: System.Runtime.InteropServices.Marshal.GetExceptionCode
  commentId: M:System.Runtime.InteropServices.Marshal.GetExceptionCode
  id: GetExceptionCode
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetExceptionCode()
  fullName: System.Runtime.InteropServices.Marshal.GetExceptionCode()
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetExceptionCode
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 430
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Retrieves a code that identifies the type of the exception that occurred.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetExceptionCode\" data-throw-if-not-resolved=\"false\"></xref> is exposed for compiler support of structured exception handling (SEH) only. If this method is called before an exception is thrown, it returns 0x0.</p>\n"
  syntax:
    content: public static int GetExceptionCode()
    content.vb: Public Shared Function GetExceptionCode As Integer
    return:
      type: System.Int32
      description: "\n<p>The type of the exception.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)
  id: GetExceptionForHR(System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetExceptionForHR(Int32)
  fullName: System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetExceptionForHR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 434
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts the specified HRESULT error code to a corresponding <xref href=\"System.Exception\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>Use the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.GetExceptionForHR\"></see> method to get an <xref href=\"System.Exception\" data-throw-if-not-resolved=\"false\"></xref> based on an HRESULT without having to call the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR\"></see> method and catch the exception.</p>\n<p>The current IErrorInfo interface is used to construct the exception.</p>\n<p>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see How to: Map HRESULTs and Exceptions.</p>\n"
  syntax:
    content: public static Exception GetExceptionForHR(int errorCode)
    content.vb: Public Shared Function GetExceptionForHR(errorCode As Integer) As Exception
    parameters:
    - id: errorCode
      type: System.Int32
      description: "\n<p>The HRESULT to be converted.</p>\n"
    return:
      type: System.Exception
      description: "\n<p>An object that represents the converted HRESULT.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32,System.IntPtr)
  id: GetExceptionForHR(System.Int32,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetExceptionForHR(Int32, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetExceptionForHR(System.Int32, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetExceptionForHR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 436
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts the specified HRESULT error code to a corresponding <xref href=\"System.Exception\" data-throw-if-not-resolved=\"false\"></xref> object, with additional error information passed in an IErrorInfo interface for the exception object.</p>\n"
  remarks: "\n<p>Use the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.GetExceptionForHR\"></see> method to get an <xref href=\"System.Exception\" data-throw-if-not-resolved=\"false\"></xref> based on an HRESULT without having to call the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR\"></see> method and catch the exception (thus avoiding the corresponding performance overhead). The <em>errorInfo</em> parameter supplies additional information about the error, such as its textual description and the globally unique identifier (GUID) for the interface that defined the error.</p>\n<p>Use this method overload if you have custom error information that you have to supply in the conversion.</p>\n<p>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see How to: Map HRESULTs and Exceptions.</p>\n"
  syntax:
    content: public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo)
    content.vb: Public Shared Function GetExceptionForHR(errorCode As Integer, errorInfo As IntPtr) As Exception
    parameters:
    - id: errorCode
      type: System.Int32
      description: "\n<p>The HRESULT to be converted.</p>\n"
    - id: errorInfo
      type: System.IntPtr
      description: "\n<p>A pointer to the <strong>IErrorInfo</strong> interface that provides more information about the error. You can specify <code>IntPtr(0)</code> to use the current <strong>IErrorInfo</strong> interface, or <code>IntPtr(-1)</code> to ignore the current <strong>IErrorInfo</strong> interface and construct the exception just from the error code.</p>\n"
    return:
      type: System.Exception
      description: "\n<p>An object that represents the converted HRESULT and information obtained from <em>errorInfo</em>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)
  commentId: M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)
  id: GetFunctionPointerForDelegate(System.Delegate)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetFunctionPointerForDelegate(Delegate)
  fullName: System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(System.Delegate)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetFunctionPointerForDelegate
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 438
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts a delegate into a function pointer that is callable from unmanaged code.</p>\n"
  remarks: "\n<p>The delegate <em>d</em> is converted to a function pointer that can be passed to unmanaged code using the __stdcall calling convention.</p>\n<p>You must manually keep the delegate from being collected by the garbage collector from managed code. The garbage collector does not track references to unmanaged code.</p>\n"
  syntax:
    content: public static IntPtr GetFunctionPointerForDelegate(Delegate d)
    content.vb: Public Shared Function GetFunctionPointerForDelegate(d As  Delegate) As IntPtr
    parameters:
    - id: d
      type: System.Delegate
      description: "\n<p>The delegate to be passed to unmanaged code.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>d</em> parameter is a generic type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>d</em> parameter is <strong>null</strong>.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)
  commentId: M:System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate``1(``0)
  id: GetFunctionPointerForDelegate``1(``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetFunctionPointerForDelegate<TDelegate>(TDelegate)
  fullName: System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate<TDelegate>(TDelegate)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetFunctionPointerForDelegate
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 442
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Converts a delegate of a specified type to a function pointer that is callable from unmanaged code. </p>\n"
  remarks: "\n<p>The delegate <em>d</em> is converted to a function pointer that can be passed to unmanaged code by using the __stdcall calling convention.</p>\n<p>You must manually keep the delegate from being collected by the garbage collector from managed code. The garbage collector does not track references to unmanaged code.</p>\n"
  syntax:
    content: public static IntPtr GetFunctionPointerForDelegate<TDelegate>(TDelegate d)
    content.vb: Public Shared Function GetFunctionPointerForDelegate(Of TDelegate)(d As TDelegate) As IntPtr
    parameters:
    - id: d
      type: '{TDelegate}'
      description: "\n<p>The delegate to be passed to unmanaged code. </p>\n"
    typeParameters:
    - id: TDelegate
      description: "\n<p>The type of delegate to convert. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>A value that can be passed to unmanaged code, which, in turn, can use it to call the underlying managed delegate. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>d</em> parameter is <strong>null</strong>. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetFunctionPointerForDelegate(Of TDelegate)(TDelegate)
  name.vb: GetFunctionPointerForDelegate(Of TDelegate)(TDelegate)
- uid: System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)
  commentId: M:System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)
  id: GetHRForException(System.Exception)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetHRForException(Exception)
  fullName: System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHRForException
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 444
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts the specified exception to an HRESULT.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)\" data-throw-if-not-resolved=\"false\"></xref> also sets up an <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface for the exception that can be obtained by calling the COM GetErrorInfoNEEDGUID function. You can use this function to return an HRESULT value on a managed class implementation of a COM interface where you apply the <xref href=\"System.Runtime.InteropServices.PreserveSigAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute. Have the attributed method catch all exceptions and use the <xref href=\"System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)\" data-throw-if-not-resolved=\"false\"></xref> method to return the appropriate HRESULT value. Allowing an exception to propagate outside the method produces incorrect behavior. (In fact, the common language runtime fails to pass an exception to a COM client that calls such a method through a v-table.)</p>\n<p>Note that the <xref href=\"System.Runtime.InteropServices.Marshal.GetHRForException(System.Exception)\" data-throw-if-not-resolved=\"false\"></xref> method sets the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface of the current thread. This can cause unexpected results for methods like the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR\"></see> methods that default to using the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> of the current thread if it is set.</p>\n"
  syntax:
    content: public static int GetHRForException(Exception e)
    content.vb: Public Shared Function GetHRForException(e As Exception) As Integer
    parameters:
    - id: e
      type: System.Exception
      description: "\n<p>The exception to convert to an HRESULT.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The HRESULT mapped to the supplied exception.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.PreserveSigAttribute
    commentId: T:System.Runtime.InteropServices.PreserveSigAttribute
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error
  commentId: M:System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error
  id: GetHRForLastWin32Error
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetHRForLastWin32Error()
  fullName: System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error()
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetHRForLastWin32Error
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 446
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the HRESULT corresponding to the last error incurred by Win32 code executed using <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>The target function must have had the <strong>setLastError</strong> metadata flag set. For example, the <strong>SetLastError</strong> field of the <xref href=\"System.Runtime.InteropServices.DllImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> must be <strong>true</strong>. The process for setting this flag depends on the source language used: C# and C++ are <strong>false</strong> by default, but the <strong>Declare</strong> statement in Visual Basic is <strong>true</strong>.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve an HRESULT corresponding to a Win32 error code using the <xref href=\"System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Runtime.InteropServices.Marshal.GetHRForLastWin32Error#1"
  syntax:
    content: public static int GetHRForLastWin32Error()
    content.vb: Public Shared Function GetHRForLastWin32Error As Integer
    return:
      type: System.Int32
      description: "\n<p>The HRESULT corresponding to the last Win32 error code.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.DllImportAttribute
    commentId: T:System.Runtime.InteropServices.DllImportAttribute
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  id: GetIUnknownForObject(System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetIUnknownForObject(Object)
  fullName: System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetIUnknownForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 448
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface from a managed object.</p>\n"
  remarks: "\n<p>In managed code, you seldom work directly with the <strong>IUnknown</strong> interface. However, <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> is useful when calling a method that exposes a COM object parameter as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type, or with custom marshaling. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> to decrement the reference count once you have finished with the pointer. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>You can also use this method on a managed object to obtain an interface pointer to the COM Callable Wrapper for the object.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve an <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface for a managed object using the <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1"
  syntax:
    content: public static IntPtr GetIUnknownForObject(object o)
    content.vb: Public Shared Function GetIUnknownForObject(o As Object) As IntPtr
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The object whose <strong>IUnknown</strong> interface is requested.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The <strong>IUnknown</strong> pointer for the <em>o</em> parameter.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetLastWin32Error
  commentId: M:System.Runtime.InteropServices.Marshal.GetLastWin32Error
  id: GetLastWin32Error
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetLastWin32Error()
  fullName: System.Runtime.InteropServices.Marshal.GetLastWin32Error()
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetLastWin32Error
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 450
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the error code returned by the last unmanaged function that was called using platform invoke that has the <xref href=\"System.Runtime.InteropServices.DllImportAttribute.SetLastError\" data-throw-if-not-resolved=\"false\"></xref> flag set.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetLastWin32Error\" data-throw-if-not-resolved=\"false\"></xref> exposes the Win32 <see href=\"http://go.microsoft.com/fwlink/?LinkId=148657\">GetLastError</see> function from Kernel32.DLL. This method exists because it is not safe to make a direct platform invoke call to <strong>GetLastError</strong> to obtain this information. If you want to access this error code, you must call <xref href=\"System.Runtime.InteropServices.Marshal.GetLastWin32Error\" data-throw-if-not-resolved=\"false\"></xref> instead of writing your own platform invoke definition for <strong>GetLastError</strong> and calling it. The common language runtime can make internal calls to APIs that overwrite the <strong>GetLastError</strong> maintained by the operating system.</p>\n<p>You can use this method to obtain error codes only if you apply the <xref href=\"System.Runtime.InteropServices.DllImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> to the method signature and set the <xref href=\"System.Runtime.InteropServices.DllImportAttribute.SetLastError\" data-throw-if-not-resolved=\"false\"></xref> field to<strong>true</strong>. The process for this varies depending upon the source language used: C# and C++ are <strong>false</strong> by default, but the <strong>Declare</strong> statement in Visual Basic is <strong>true</strong>.</p>\n"
  example:
  - "\n<p>The following example demonstrates calling the <xref href=\"System.Runtime.InteropServices.Marshal.GetLastWin32Error\" data-throw-if-not-resolved=\"false\"></xref>method. The example first demonstrates calling the method with no error present and then demonstrates calling the method with an error present.</p>Runtime.InteropServices.Marshal.GetLastWin32Error#1"
  syntax:
    content: public static int GetLastWin32Error()
    content.vb: Public Shared Function GetLastWin32Error As Integer
    return:
      type: System.Int32
      description: "\n<p>The last error code set by a call to the Win32 <see href=\"http://go.microsoft.com/fwlink/?LinkId=148656\">SetLastError</see> function.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.DllImportAttribute
    commentId: T:System.Runtime.InteropServices.DllImportAttribute
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)
  id: GetNativeVariantForObject(System.Object,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetNativeVariantForObject(Object, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetNativeVariantForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 452
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts an object to a COM VARIANT.</p>\n"
  remarks: "\n<p>The <em>pDstNativeVariant</em> parameter must point to sufficient memory to store the resulting VARIANT. Also, the implementation of this method calls the <see href=\"https://msdn.microsoft.com/library/ms221402(v=vs.85).aspx\">VariantInit</see> function on the raw memory that the <em>pDstNativeVariant</em> parameter points to.</p>\n"
  syntax:
    content: public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant)
    content.vb: Public Shared Sub GetNativeVariantForObject(obj As Object, pDstNativeVariant As IntPtr)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object for which to get a COM VARIANT.</p>\n"
    - id: pDstNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to receive the VARIANT that corresponds to the <em>obj</em> parameter.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>obj</em> parameter is a generic type.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)
  id: GetNativeVariantForObject``1(``0,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetNativeVariantForObject<T>(T, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject<T>(T, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetNativeVariantForObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 456
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Converts an object of a specified type to a COM VARIANT. </p>\n"
  remarks: "\n<p>The <em>pDstNativeVariant</em> parameter must point to sufficient memory to store the resulting VARIANT. Also, the implementation of this method calls <see href=\"https://msdn.microsoft.com/library/ms221402(v=vs.85).aspx\">VariantInit</see> function on the raw memory that the <em>pDstNativeVariant</em> parameter points to.</p>\n"
  syntax:
    content: public static void GetNativeVariantForObject<T>(T obj, IntPtr pDstNativeVariant)
    content.vb: Public Shared Sub GetNativeVariantForObject(Of T)(obj As T, pDstNativeVariant As IntPtr)
    parameters:
    - id: obj
      type: '{T}'
      description: "\n<p>The object for which to get a COM VARIANT. </p>\n"
    - id: pDstNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to receive the VARIANT that corresponds to the <em>obj</em> parameter. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the object to convert. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(Of T)(T, System.IntPtr)
  name.vb: GetNativeVariantForObject(Of T)(T, IntPtr)
- uid: System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  id: GetObjectForIUnknown(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetObjectForIUnknown(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetObjectForIUnknown
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 460
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns an instance of a type that represents a COM object by a pointer to its <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface.</p>\n"
  remarks: "\n<p>This method wraps <strong>IUnknown</strong> in a managed object. This has the effect of incrementing the reference count of the COM component. The reference count will be decremented when the runtime performs garbage collection on the managed object that represents the COM object.</p>\n<p>The <em>pUnk</em> parameter represents an <strong>IUnknown</strong> interface pointer; however, because all COM interfaces derive directly or indirectly from <strong>IUnknown</strong>, you can pass any COM interface to this method. The object returned by <xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is a Runtime Callable Wrapper, which the common language runtime manages as it does any other managed object. The type of this wrapper is often a generic <strong>System.__ComObject</strong> type, which is a hidden type used when the wrapper type is ambiguous. You can still make late-bound calls to such a generic type as long as the COM object implements the IDispatch interface. Likewise, you can cast the returned object to an appropriate COM interface.</p>\n<p>For an object to be wrapped with a specific managed class type (and not a generic wrapper type), you must adhere to the following requirements: </p>\n<ul><li>\n<p>Implement the <see href=\"http://go.microsoft.com/fwlink/?LinkID=148012\">IProvideClassInfo</see> interface for the COM object.</p>\n</li><li>\n<p>Register the containing assembly with the Regasm.exe (Assembly Registration Tool).</p>\n</li></ul>\n<p>Alternatively, you can avoid these requirements and still get an object that is wrapped with a specific managed class type by using the <xref href=\"System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public static object GetObjectForIUnknown(IntPtr pUnk)
    content.vb: Public Shared Function GetObjectForIUnknown(pUnk As IntPtr) As Object
    parameters:
    - id: pUnk
      type: System.IntPtr
      description: "\n<p>A pointer to the <strong>IUnknown</strong> interface. </p>\n"
    return:
      type: System.Object
      description: "\n<p>An object that represents the specified unmanaged COM object.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown(System.IntPtr,System.Type)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)
  id: GetObjectForNativeVariant(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetObjectForNativeVariant(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetObjectForNativeVariant
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 462
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts a COM VARIANT to an object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> returns a managed object that corresponds to a raw pointer to an unmanaged VARIANT type. The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When the VARIANT type is VT_ERROR, <xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> returns an object of type <strong>Int32</strong> instead of <strong>UInt32</strong>.</p>\n"
  syntax:
    content: public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant)
    content.vb: Public Shared Function GetObjectForNativeVariant(pSrcNativeVariant As IntPtr) As Object
    parameters:
    - id: pSrcNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to a COM VARIANT.</p>\n"
    return:
      type: System.Object
      description: "\n<p>An object that corresponds to the <em>pSrcNativeVariant</em> parameter.</p>\n"
  exceptions:
  - type: System.Runtime.InteropServices.InvalidOleVariantTypeException
    commentId: T:System.Runtime.InteropServices.InvalidOleVariantTypeException
    description: "\n<p>\n<em>pSrcNativeVariant</em> is not a valid VARIANT type.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>pSrcNativeVariant</em> has an unsupported type.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.GetNativeVariantForObject(System.Object,System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)
  id: GetObjectForNativeVariant``1(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetObjectForNativeVariant<T>(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant<T>(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetObjectForNativeVariant
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 466
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Converts a COM VARIANT to an object of a specified type. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> returns a managed object of type <em>T</em> that corresponds to a raw pointer to an unmanaged VARIANT type. The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code. </p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> provides the opposite functionality of<xref href=\"System.Runtime.InteropServices.Marshal.GetNativeVariantForObject``1(``0,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static T GetObjectForNativeVariant<T>(IntPtr pSrcNativeVariant)
    content.vb: Public Shared Function GetObjectForNativeVariant(Of T)(pSrcNativeVariant As IntPtr) As T
    parameters:
    - id: pSrcNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to a COM VARIANT. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type to which to convert the COM VARIANT. </p>\n"
    return:
      type: '{T}'
      description: "\n<p>An object of the specified type that corresponds to the <em>pSrcNativeVariant</em> parameter. </p>\n"
  exceptions:
  - type: System.Runtime.InteropServices.InvalidOleVariantTypeException
    commentId: T:System.Runtime.InteropServices.InvalidOleVariantTypeException
    description: "\n<p>\n<em>pSrcNativeVariant</em> is not a valid VARIANT type. </p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>\n<em>pSrcNativeVariant</em> has an unsupported type. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant(Of T)(System.IntPtr)
  name.vb: GetObjectForNativeVariant(Of T)(IntPtr)
- uid: System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)
  id: GetObjectsForNativeVariants(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetObjectsForNativeVariants(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetObjectsForNativeVariants
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 470
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Converts an array of COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148670\">VARIANTs</see> to an array of objects. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns an array of managed objects that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types. The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code. The method returns an empty array when the <em>cVars</em> parameter is 0.</p>\n<p>The object array (the return value) gets garbage collected as usual. The unmanaged input array or individual VARIANTs in the input array are not freed. Therefore it is your responsibility to free them as appropriate.</p>\n"
  syntax:
    content: public static object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars)
    content.vb: Public Shared Function GetObjectsForNativeVariants(aSrcNativeVariant As IntPtr, cVars As Integer) As Object()
    parameters:
    - id: aSrcNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to the first element of an array of COM VARIANTs.</p>\n"
    - id: cVars
      type: System.Int32
      description: "\n<p>The count of COM VARIANTs in <em>aSrcNativeVariant</em>.</p>\n"
    return:
      type: System.Object[]
      description: "\n<p>An object array that corresponds to <em>aSrcNativeVariant</em>.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>cVars</em> is a negative number.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)
  id: GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetObjectsForNativeVariants<T>(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants<T>(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetObjectsForNativeVariants
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 474
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Converts an array of COM VARIANTs to an array of a specified type. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants``1(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> returns an array of <em>T</em> that corresponds to a raw pointer to a C-style array of unmanaged VARIANT types. The interopmarshaler performs the identical transformation when exposing a VARIANT type to managed code. The method returns an empty array when the <em>cVars</em> parameter is 0.</p>\n<p>The returned array is garbage-collected as usual. The unmanaged input array or individual VARIANTs in the input array are not freed. Therefore, it is your responsibility to free them as appropriate. </p>\n"
  syntax:
    content: public static T[] GetObjectsForNativeVariants<T>(IntPtr aSrcNativeVariant, int cVars)
    content.vb: Public Shared Function GetObjectsForNativeVariants(Of T)(aSrcNativeVariant As IntPtr, cVars As Integer) As T()
    parameters:
    - id: aSrcNativeVariant
      type: System.IntPtr
      description: "\n<p>A pointer to the first element of an array of COM VARIANTs. </p>\n"
    - id: cVars
      type: System.Int32
      description: "\n<p>The count of COM VARIANTs in <em>aSrcNativeVariant</em>. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the array to return. </p>\n"
    return:
      type: '{T}[]'
      description: "\n<p>An array of <em>T</em> objects that corresponds to <em>aSrcNativeVariant</em>. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>cVars</em> is a negative number. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants(Of T)(System.IntPtr, System.Int32)
  name.vb: GetObjectsForNativeVariants(Of T)(IntPtr, Int32)
- uid: System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)
  id: GetStartComSlot(System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetStartComSlot(Type)
  fullName: System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetStartComSlot
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 478
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Gets the first slot in the virtual function table (v-table or VTBL) that contains user-defined methods.</p>\n"
  remarks: "\n<p>This method returns the zero-based v-table number for an interface or a class. When used on a class, the slot number that is returned refers to the class interface for the class. If the class interface is auto-dispatch, this method always returns -1 to indicate that the dispatch-only interface does not expose a v-table to managed clients. You can use <xref href=\"System.Runtime.InteropServices.Marshal.GetStartComSlot(System.Type)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)\" data-throw-if-not-resolved=\"false\"></xref> in conjunction with <xref href=\"System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)\" data-throw-if-not-resolved=\"false\"></xref> to pass slots within a specified range. For additional information, see Introducing the Class Interface.</p>\n"
  syntax:
    content: public static int GetStartComSlot(Type t)
    content.vb: Public Shared Function GetStartComSlot(t As Type) As Integer
    parameters:
    - id: t
      type: System.Type
      description: "\n<p>A type that represents an interface.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The first VTBL slot that contains user-defined methods. The first slot is 3 if the interface is based on <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see>, and 7 if the interface is based on IDispatch.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>t</em> is not visible from COM.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetEndComSlot(System.Type)
  - type: System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)
    commentId: M:System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot(System.Type,System.Int32,System.Runtime.InteropServices.ComMemberType@)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)
  commentId: M:System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)
  id: GetTypeFromCLSID(System.Guid)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetTypeFromCLSID(Guid)
  fullName: System.Runtime.InteropServices.Marshal.GetTypeFromCLSID(System.Guid)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetTypeFromCLSID
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 480
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the type associated with the specified class identifier (CLSID). </p>\n"
  syntax:
    content: public static Type GetTypeFromCLSID(Guid clsid)
    content.vb: Public Shared Function GetTypeFromCLSID(clsid As Guid) As Type
    parameters:
    - id: clsid
      type: System.Guid
      description: "\n<p>The CLSID of the type to return. </p>\n"
    return:
      type: System.Type
      description: "\n<p>\n<strong>System.__ComObject</strong> regardless of whether the CLSID is valid. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)
  commentId: M:System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)
  id: GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetTypeInfoName(ITypeInfo)
  fullName: System.Runtime.InteropServices.Marshal.GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetTypeInfoName
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 481
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Retrieves the name of the type represented by an ITypeInfo object.</p>\n"
  remarks: "\n<p>You can also retrieve the name of the type represented by an <strong>ITypeInfo</strong> by calling the <xref href=\"System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)\" data-throw-if-not-resolved=\"false\"></xref> method and passing -1 for its first parameter.</p>\n"
  syntax:
    content: public static string GetTypeInfoName(ITypeInfo typeInfo)
    content.vb: Public Shared Function GetTypeInfoName(typeInfo As ITypeInfo) As String
    parameters:
    - id: typeInfo
      type: System.Runtime.InteropServices.ComTypes.ITypeInfo
      description: "\n<p>An object that represents an <strong>ITypeInfo</strong> pointer.</p>\n"
    return:
      type: System.String
      description: "\n<p>The name of the type that the <em>typeInfo</em> parameter points to.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>typeInfo</em> parameter is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)
    commentId: M:System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation(System.Int32,System.String@,System.String@,System.Int32@,System.String@)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)
  id: GetUniqueObjectForIUnknown(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: GetUniqueObjectForIUnknown(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetUniqueObjectForIUnknown
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 483
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Creates a unique Runtime Callable Wrapper (RCW) object for a given <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.GetUniqueObjectForIUnknown(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method ensures that you receive a unique RCW, because it does not match an <strong>IUnknown</strong> pointer to an existing object. Use this method when you have to create a unique RCW that is not impacted by other code that calls the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - 
  syntax:
    content: public static object GetUniqueObjectForIUnknown(IntPtr unknown)
    content.vb: Public Shared Function GetUniqueObjectForIUnknown(unknown As IntPtr) As Object
    parameters:
    - id: unknown
      type: System.IntPtr
      description: "\n<p>A managed pointer to an <strong>IUnknown</strong> interface.</p>\n"
    return:
      type: System.Object
      description: "\n<p>A unique RCW for the specified <strong>IUnknown</strong> interface.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.IsComObject(System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.IsComObject(System.Object)
  id: IsComObject(System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: IsComObject(Object)
  fullName: System.Runtime.InteropServices.Marshal.IsComObject(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsComObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 485
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Indicates whether a specified object represents a COM object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.IsComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>true</strong> if the class type of the instance is attributed with <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> or if it derives directly or indirectly from a class attributed with <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref>. The Tlbimp.exe (Type Library Importer) tool applies this attribute for you when it imports a type library.</p>\n<p>Two other methods also determine whether a specified object represents a COM object, but the requirements for returning <strong>true</strong> differ from this method's requirements. <xref href=\"System.Type.IsImport\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>true</strong> if the class (or interface) is attributed with <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> directly; it does not return <strong>true</strong> for derived types. <xref href=\"System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)\" data-throw-if-not-resolved=\"false\"></xref> returns <strong>true</strong> if the type is attributed with <xref href=\"System.Runtime.InteropServices.ComImportAttribute\" data-throw-if-not-resolved=\"false\"></xref> or derives from a type with the same GUID.</p>\n"
  syntax:
    content: public static bool IsComObject(object o)
    content.vb: Public Shared Function IsComObject(o As Object) As Boolean
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The object to check.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the <em>o</em> parameter is a COM type; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>o</em> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.ComImportAttribute
    commentId: T:System.Runtime.InteropServices.ComImportAttribute
  - type: System.Type.IsImport
    commentId: P:System.Type.IsImport
  - type: System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)
    commentId: M:System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType(System.Type)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)
  id: OffsetOf(System.Type,System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: OffsetOf(Type, String)
  fullName: System.Runtime.InteropServices.Marshal.OffsetOf(System.Type, System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OffsetOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 486
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the field offset of the unmanaged form of the managed class.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)\" data-throw-if-not-resolved=\"false\"></xref> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout. Marshaling the structure can transform the layout and alter the offset. The <em>t</em> parameter can be a value type or a formatted reference type (with either a sequential or explicit layout). You can obtain the size of the entire layout by using the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. For additional information, see Default Marshaling for Value Types.</p>\n<p>Beginning with the .NET Framework version 2.0, <xref href=\"System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)\" data-throw-if-not-resolved=\"false\"></xref> may expose private fields.</p>\n"
  syntax:
    content: public static IntPtr OffsetOf(Type t, string fieldName)
    content.vb: Public Shared Function OffsetOf(t As Type, fieldName As String) As IntPtr
    parameters:
    - id: t
      type: System.Type
      description: "\n<p>A value type or formatted reference type that specifies the managed class. You must apply the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\" data-throw-if-not-resolved=\"false\"></xref> to the class.</p>\n"
    - id: fieldName
      type: System.String
      description: "\n<p>The field within the <em>t</em> parameter.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The offset, in bytes, for the <em>fieldName</em> parameter within the specified class that is declared by platform invoke.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The class cannot be exported as a structure or the field is nonpublic. Beginning with the .NET Framework version 2.0, the field may be private.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>t</em> parameter is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)
  id: OffsetOf``1(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: OffsetOf<T>(String)
  fullName: System.Runtime.InteropServices.Marshal.OffsetOf<T>(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OffsetOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 489
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Returns the field offset of the unmanaged form of a specified managed class.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)\" data-throw-if-not-resolved=\"false\"></xref> provides the offset in terms of the unmanaged structure layout, which does not necessarily correspond to the offset of the managed structure layout. Marshaling the structure can transform the layout and alter the offset. The <em>T</em> generic type parameter can be a value type or a formatted reference type (with either a sequential or explicit layout). You can obtain the size of the entire layout by using the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf``1(``0)\" data-throw-if-not-resolved=\"false\"></xref> method. For additional information, see Default Marshaling for Value Types.</p>\n<p>Beginning with the .NET Framework version 2.0, <xref href=\"System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)\" data-throw-if-not-resolved=\"false\"></xref> may expose private fields.</p>\n"
  syntax:
    content: public static IntPtr OffsetOf<T>(string fieldName)
    content.vb: Public Shared Function OffsetOf(Of T)(fieldName As String) As IntPtr
    parameters:
    - id: fieldName
      type: System.String
      description: "\n<p>The name of the field in the <em>T</em> type. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>A managed value type or formatted reference type. You must apply the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute to the class. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The offset, in bytes, for the <em>fieldName</em> parameter within the specified class that is declared by platform invoke. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.SizeOf``1(``0)
    commentId: M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.OffsetOf(Of T)(System.String)
  name.vb: OffsetOf(Of T)(String)
- uid: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  id: PtrToStringAnsi(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStringAnsi(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStringAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 490
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies all characters up to the first null character from an unmanaged ANSI string to a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>, and widens each ANSI character to Unicode.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to create a managed string from an unmanaged <strong>char</strong> array.</p>Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr#1"
  syntax:
    content: public static string PtrToStringAnsi(IntPtr ptr)
    content.vb: Public Shared Function PtrToStringAnsi(ptr As IntPtr) As String
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the first character of the unmanaged string.</p>\n"
    return:
      type: System.String
      description: "\n<p>A managed string that holds a copy of the unmanaged ANSI string. If <em>ptr</em> is <strong>null</strong>, the method returns a null string.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)
  id: PtrToStringAnsi(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStringAnsi(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStringAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 492
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref>, copies a specified number of characters from an unmanaged ANSI string into it, and widens each ANSI character to Unicode.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to create a managed string from an unmanaged<strong>char</strong> array.</p>Runtime.InteropServices.Marshal.PtrToStringAnsi-IntPtr-int#1"
  syntax:
    content: public static string PtrToStringAnsi(IntPtr ptr, int len)
    content.vb: Public Shared Function PtrToStringAnsi(ptr As IntPtr, len As Integer) As String
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the first character of the unmanaged string.</p>\n"
    - id: len
      type: System.Int32
      description: "\n<p>The byte count of the input string to copy.</p>\n"
    return:
      type: System.String
      description: "\n<p>A managed string that holds a copy of the native ANSI string if the value of the <em>ptr</em> parameter is not <strong>null</strong>; otherwise, this method returns <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>len</em> is less than zero.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
  id: PtrToStringBSTR(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStringBSTR(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStringBSTR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 494
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> and copies a <see href=\"https://msdn.microsoft.com/library/ms221069(v=vs.85).aspx\">binary string (BSTR)</see> stored in unmanaged memory into it.</p>\n"
  remarks: "\n<p>Call this method only on strings that were allocated with the unmanaged <see href=\"https://msdn.microsoft.com/library/ms221458(v=vs.85).aspx\">SysAllocString</see> and <see href=\"https://msdn.microsoft.com/library/ms221639(v=vs.85).aspx\">SysAllocStringLen</see> functions.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public static string PtrToStringBSTR(IntPtr ptr)
    content.vb: Public Shared Function PtrToStringBSTR(ptr As IntPtr) As String
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the first character of the unmanaged string.</p>\n"
    return:
      type: System.String
      description: "\n<p>A managed string that holds a copy of the unmanaged string. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>ptr</em> equals <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)
  id: PtrToStringUni(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStringUni(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStringUni
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 496
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> and copies all characters up to the first null character from an unmanaged Unicode string into it.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  syntax:
    content: public static string PtrToStringUni(IntPtr ptr)
    content.vb: Public Shared Function PtrToStringUni(ptr As IntPtr) As String
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the first character of the unmanaged string.</p>\n"
    return:
      type: System.String
      description: "\n<p>A managed string that holds a copy of the unmanaged string if the value of the <em>ptr</em> parameter is not <strong>null</strong>; otherwise, this method returns <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
  id: PtrToStringUni(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStringUni(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStringUni
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 498
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> and copies a specified number of characters from an unmanaged Unicode string into it.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method creates a copy of the unmanaged string's contents, you must free the original string as appropriate. This method provides the opposite functionality of the <xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  syntax:
    content: public static string PtrToStringUni(IntPtr ptr, int len)
    content.vb: Public Shared Function PtrToStringUni(ptr As IntPtr, len As Integer) As String
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address of the first character of the unmanaged string.</p>\n"
    - id: len
      type: System.Int32
      description: "\n<p>The number of Unicode characters to copy.</p>\n"
    return:
      type: System.String
      description: "\n<p>A managed string that holds a copy of the unmanaged string if the value of the <em>ptr</em> parameter is not <strong>null</strong>; otherwise, this method returns <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  - type: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
    commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)
  id: PtrToStructure(System.IntPtr,System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStructure(IntPtr, Object)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr, System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 500
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Marshals data from an unmanaged block of memory to a managed object.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> value. You cannot use this overload method with value types.</p>\n"
  syntax:
    content: public static void PtrToStructure(IntPtr ptr, object structure)
    content.vb: Public Shared Sub PtrToStructure(ptr As IntPtr, structure As Object)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory.</p>\n"
    - id: structure
      type: System.Object
      description: "\n<p>The object to which the data is to be copied. This must be an instance of a formatted class.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Structure layout is not sequential or explicit.</p>\n<p>-or- </p>\n<p>Structure is a boxed value type.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)
  id: PtrToStructure(System.IntPtr,System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStructure(IntPtr, Type)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr, System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 504
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Marshals data from an unmanaged block of memory to a newly allocated managed object of the specified type.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> is often necessary in COM interop and platform invoke when structure parameters are represented as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> value. You can pass a value type to this overload method. In this case, the returned object is a boxed instance.</p>\n"
  example:
  - "\n<p>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory using the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1<p>The following example demonstrates how to marshal an unmanaged block of memory to a managed structure using the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method.</p><p>This code assumes 32-bit compilation. Before using a 64-bit compiler, replace <xref href=\"System.IntPtr.ToInt32\" data-throw-if-not-resolved=\"false\"></xref> with <xref href=\"System.IntPtr.ToInt64\" data-throw-if-not-resolved=\"false\"></xref>.</p>PtrToStructure#1"
  syntax:
    content: public static object PtrToStructure(IntPtr ptr, Type structureType)
    content.vb: Public Shared Function PtrToStructure(ptr As IntPtr, structureType As Type) As Object
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory.</p>\n"
    - id: structureType
      type: System.Type
      description: "\n<p>The type of object to be created. This object must represent a formatted class or a structure.</p>\n"
    return:
      type: System.Object
      description: "\n<p>A managed object containing the data pointed to by the <em>ptr</em> parameter.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>structureType</em> parameter layout is not sequential or explicit.</p>\n<p>-or-</p>\n<p>The <em>structureType</em> parameter is a generic type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>structureType</em> is <strong>null</strong>.</p>\n"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "\n<p>The class specified by <em>structureType</em> does not have an accessible default constructor. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)
    commentId: M:System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr(System.IntPtr@)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)
  id: PtrToStructure``1(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStructure<T>(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStructure<T>(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 508
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Marshals data from an unmanaged block of memory to a newly allocated managed object of the type specified by a generic type parameter. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> values. You can pass a value type to this method overload.</p>\n"
  syntax:
    content: public static T PtrToStructure<T>(IntPtr ptr)
    content.vb: Public Shared Function PtrToStructure(Of T)(ptr As IntPtr) As T
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the object to which the data is to be copied. This must be a formatted class or a structure. </p>\n"
    return:
      type: '{T}'
      description: "\n<p>A managed object that contains the data that the <em>ptr</em> parameter points to. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The layout of <em>T</em> is not sequential or explicit.</p>\n"
  - type: System.MissingMethodException
    commentId: T:System.MissingMethodException
    description: "\n<p>The class specified by <em>T</em> does not have an accessible default constructor. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.PtrToStructure(Of T)(System.IntPtr)
  name.vb: PtrToStructure(Of T)(IntPtr)
- uid: System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)
  commentId: M:System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)
  id: PtrToStructure``1(System.IntPtr,``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: PtrToStructure<T>(IntPtr, T)
  fullName: System.Runtime.InteropServices.Marshal.PtrToStructure<T>(System.IntPtr, T)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: PtrToStructure
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 510
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Marshals data from an unmanaged block of memory to a managed object of the specified type. </p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure``1(System.IntPtr,``0)\" data-throw-if-not-resolved=\"false\"></xref> is often necessary in COM interop and platform invoke when structure parameters are represented as <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> values. You cannot use this method overload with value types. </p>\n"
  syntax:
    content: public static void PtrToStructure<T>(IntPtr ptr, T structure)
    content.vb: Public Shared Sub PtrToStructure(Of T)(ptr As IntPtr, structure As T)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory. </p>\n"
    - id: structure
      type: '{T}'
      description: "\n<p>The object to which the data is to be copied. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of <em>structure</em>. This must be a formatted class. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>Structure layout is not sequential or explicit. </p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.PtrToStructure(Of T)(System.IntPtr, T)
  name.vb: PtrToStructure(Of T)(IntPtr, T)
- uid: System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  commentId: M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  id: QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: QueryInterface(IntPtr, ref Guid, out IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr, ref System.Guid, out System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: QueryInterface
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 512
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Requests a pointer to a specified interface from a COM object.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)\" data-throw-if-not-resolved=\"false\"></xref> method exposes the <see href=\"http://go.microsoft.com/fwlink/?LinkID=144867\">IUnknown::QueryInterface</see> method of a COM object, which attempts to obtain a specific interface pointer. Using <strong>QueryInterface</strong> on a COM object is the same as performing a cast operation in managed code. Calling an object with this method causes the reference count to increment on the interface pointer before the pointer is returned. Always use <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> to decrement the reference count once you have finished with the pointer. To obtain an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> value that represents a <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface pointer, you can call <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static int QueryInterface(IntPtr pUnk, ref Guid iid, out IntPtr ppv)
    content.vb: Public Shared Function QueryInterface(pUnk As IntPtr, ByRef iid As Guid, ByRef ppv As IntPtr) As Integer
    parameters:
    - id: pUnk
      type: System.IntPtr
      description: "\n<p>The interface to be queried.</p>\n"
    - id: iid
      type: System.Guid
      description: "\n<p>The interface identifier (IID) of the requested interface.</p>\n"
    - id: ppv
      type: System.IntPtr
      description: "\n<p>When this method returns, contains a reference to the returned interface.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>An HRESULT that indicates the success or failure of the call.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  - type: System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  - type: System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
  - type: System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr, ByRef System.Guid, ByRef System.IntPtr)
  name.vb: QueryInterface(IntPtr, ByRef Guid, ByRef IntPtr)
- uid: System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)
  id: ReadByte(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadByte(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 514
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a single byte from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</p>Runtime.InteropServices.Marshal.ReadByte - WriteByte#1<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged character.</p>Runtime.InteropServices.Marshal.ReadByte#1"
  syntax:
    content: public static byte ReadByte(IntPtr ptr)
    content.vb: Public Shared Function ReadByte(ptr As IntPtr) As Byte
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory from which to read.</p>\n"
    return:
      type: System.Byte
      description: "\n<p>The byte read from unmanaged memory.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)
  id: ReadByte(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadByte(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 516
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a single byte at a given offset (or index) from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#3<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged character.</p>Runtime.InteropServices.Marshal.ReadByte-IntPtr-int#1"
  syntax:
    content: public static byte ReadByte(IntPtr ptr, int ofs)
    content.vb: Public Shared Function ReadByte(ptr As IntPtr, ofs As Integer) As Byte
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory from which to read.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Byte
      description: "\n<p>The byte read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  id: ReadByte(System.Object,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadByte(Object, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadByte(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 518
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a single byte at a given offset (or index) from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static byte ReadByte(object ptr, int ofs)
    content.vb: Public Shared Function ReadByte(ptr As Object, ofs As Integer) As Byte
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the source object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Byte
      description: "\n<p>The byte read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)
  id: ReadInt16(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt16(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 522
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 16-bit signed integer from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style <strong>Int16</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>short</strong> variable.</p>Runtime.InteropServices.Marshal.ReadInt16#1"
  syntax:
    content: public static short ReadInt16(IntPtr ptr)
    content.vb: Public Shared Function ReadInt16(ptr As IntPtr) As Short
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory from which to read.</p>\n"
    return:
      type: System.Int16
      description: "\n<p>The 16-bit signed integer read from unmanaged memory.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)
  id: ReadInt16(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt16(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 524
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 16-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>short</strong> variable.</p>Runtime.InteropServices.Marshal.ReadInt16-IntPtr-Int#1"
  syntax:
    content: public static short ReadInt16(IntPtr ptr, int ofs)
    content.vb: Public Shared Function ReadInt16(ptr As IntPtr, ofs As Integer) As Short
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory from which to read.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int16
      description: "\n<p>The 16-bit signed integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)
  id: ReadInt16(System.Object,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt16(Object, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt16(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 526
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 16-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static short ReadInt16(object ptr, int ofs)
    content.vb: Public Shared Function ReadInt16(ptr As Object, ofs As Integer) As Short
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the source object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int16
      description: "\n<p>The 16-bit signed integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)
  id: ReadInt32(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt32(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 530
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 32-bit signed integer from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style <strong>Int32</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#5<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>int</strong> variable.</p>Runtime.InteropServices.Marshal.ReadInt32#1"
  syntax:
    content: public static int ReadInt32(IntPtr ptr)
    content.vb: Public Shared Function ReadInt32(ptr As IntPtr) As Integer
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory from which to read.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The 32-bit signed integer read from unmanaged memory.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)
  id: ReadInt32(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt32(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 532
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 32-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#5<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>int</strong> variable. </p>Runtime.InteropServices.Marshal.ReadInt32-IntPtr-Int#1"
  syntax:
    content: public static int ReadInt32(IntPtr ptr, int ofs)
    content.vb: Public Shared Function ReadInt32(ptr As IntPtr, ofs As Integer) As Integer
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory from which to read.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The 32-bit signed integer read from unmanaged memory.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)
  id: ReadInt32(System.Object,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt32(Object, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt32(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 534
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 32-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static int ReadInt32(object ptr, int ofs)
    content.vb: Public Shared Function ReadInt32(ptr As Object, ofs As Integer) As Integer
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the source object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The 32-bit signed integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)
  id: ReadInt64(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt64(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 538
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 64-bit signed integer from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style <strong>Int64</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#6<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>__int64</strong> variable.</p>Runtime.InteropServices.Marshal.ReadInt64#1"
  syntax:
    content: public static long ReadInt64(IntPtr ptr)
    content.vb: Public Shared Function ReadInt64(ptr As IntPtr) As Long
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory from which to read.</p>\n"
    return:
      type: System.Int64
      description: "\n<p>The 64-bit signed integer read from unmanaged memory.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)
  id: ReadInt64(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt64(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 540
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 64-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#6<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to read the value of an unmanaged <strong>__int64</strong> variable.</p>Runtime.InteropServices.Marshal.ReadInt64-IntPtr-Int#1"
  syntax:
    content: public static long ReadInt64(IntPtr ptr, int ofs)
    content.vb: Public Shared Function ReadInt64(ptr As IntPtr, ofs As Integer) As Long
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory from which to read.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int64
      description: "\n<p>The 64-bit signed integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)
  id: ReadInt64(System.Object,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadInt64(Object, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadInt64(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 542
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a 64-bit signed integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static long ReadInt64(object ptr, int ofs)
    content.vb: Public Shared Function ReadInt64(ptr As Object, ofs As Integer) As Long
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the source object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.Int64
      description: "\n<p>The 64-bit signed integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)
  id: ReadIntPtr(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadIntPtr(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 546
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a processor native-sized integer from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style <strong>IntPtr</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#2"
  syntax:
    content: public static IntPtr ReadIntPtr(IntPtr ptr)
    content.vb: Public Shared Function ReadIntPtr(ptr As IntPtr) As IntPtr
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory from which to read.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The integer read from unmanaged memory. A 32 bit integer is returned on 32 bit machines and a 64 bit integer is returned on 64 bit machines.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)
  id: ReadIntPtr(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadIntPtr(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 548
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a processor native sized integer at a given offset from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style <strong>IntPtr</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#2"
  syntax:
    content: public static IntPtr ReadIntPtr(IntPtr ptr, int ofs)
    content.vb: Public Shared Function ReadIntPtr(ptr As IntPtr, ofs As Integer) As IntPtr
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory from which to read.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReadByte(System.Object,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)
  id: ReadIntPtr(System.Object,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReadIntPtr(Object, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 550
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Reads a processor native sized integer from unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.Object,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style <strong>IntPtr</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before reading its element values.</p>\n<p>Reading from unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static IntPtr ReadIntPtr(object ptr, int ofs)
    content.vb: Public Shared Function ReadIntPtr(ptr As Object, ofs As Integer) As IntPtr
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the source object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before reading.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The integer read from unmanaged memory at the given offset.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
  id: ReAllocCoTaskMem(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReAllocCoTaskMem(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReAllocCoTaskMem
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 554
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Resizes a block of memory previously allocated with <xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is one of two memory reallocation methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class. (<xref href=\"System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is the other.) The beginning of the reallocated memory content is the same as the original content; however, the entire memory block can be in a different location. This method exposes the COM <see href=\"http://go.microsoft.com/fwlink/?LinkId=148778\">CoTaskMemRealloc</see> function, which is referred to as the COM task memory allocator.</p>\n"
  syntax:
    content: public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb)
    content.vb: Public Shared Function ReAllocCoTaskMem(pv As IntPtr, cb As Integer) As IntPtr
    parameters:
    - id: pv
      type: System.IntPtr
      description: "\n<p>A pointer to memory allocated with <xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: cb
      type: System.Int32
      description: "\n<p>The new size of the allocated block.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>An integer representing the address of the reallocated block of memory. This memory must be released with <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to satisfy the request.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)
  id: ReAllocHGlobal(System.IntPtr,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReAllocHGlobal(IntPtr, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReAllocHGlobal
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 556
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Resizes a block of memory previously allocated with <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.ReAllocHGlobal(System.IntPtr,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> is one of two memory reallocation API methods in the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class. (<xref href=\"System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is the other.) </p>\n<p>This method exposes the Win32 <see href=\"http://go.microsoft.com/fwlink/?LinkId=148780\">GlobalReAlloc</see> function from Kernel32.dll. The returned pointer can differ from the original. If it is different, the contents of the original memory block have been copied to the new block, and the original memory block has been freed.</p>\n"
  syntax:
    content: public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb)
    content.vb: Public Shared Function ReAllocHGlobal(pv As IntPtr, cb As IntPtr) As IntPtr
    parameters:
    - id: pv
      type: System.IntPtr
      description: "\n<p>A pointer to memory allocated with <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
    - id: cb
      type: System.IntPtr
      description: "\n<p>The new size of the allocated block. This is not a pointer; it is the byte count you are requesting, cast to type <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>. If you pass a pointer, it is treated as a size.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>A pointer to the reallocated memory. This memory must be released using <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory to satisfy the request.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem(System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  id: Release(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: Release(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.Release(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Release
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 558
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Decrements the reference count on the specified interface.</p>\n"
  remarks: "\n<p>The common language runtime manages the reference count of a COM object for you, making it unnecessary to use this method directly. Use this value only for testing purposes. In rare cases, such as testing a custom marshaler, you might find it necessary to manipulate an object's lifetime manually. Only programs that call <xref href=\"System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> should call <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. Calling <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> after the reference count has reached zero causes undefined behavior.</p>\n<p>You can call <xref href=\"System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> to obtain an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> value that represents a <see href=\"http://go.microsoft.com/fwlink/?LinkId=148003\">IUnknown</see> interface pointer to release. You can also use these methods and the <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method on managed objects to release the COM interfaces represented by the managed object's COM Callable Wrapper.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to retrieve an <strong>IUnknown</strong> interface for a managed object using the <xref href=\"System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. The example then releases the interface pointer by calling the <xref href=\"System.Runtime.InteropServices.Marshal.Release(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>Runtime.InteropServices.Marshal.GetIUnknownForObject-release#1"
  syntax:
    content: public static int Release(IntPtr pUnk)
    content.vb: Public Shared Function Release(pUnk As IntPtr) As Integer
    parameters:
    - id: pUnk
      type: System.IntPtr
      description: "\n<p>The interface to release.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The new value of the reference count on the interface specified by the <em>pUnk</em> parameter.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.AddRef(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
    commentId: M:System.Runtime.InteropServices.Marshal.QueryInterface(System.IntPtr,System.Guid@,System.IntPtr@)
  - type: System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.GetComInterfaceForObject(System.Object,System.Type)
  - type: System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIUnknownForObject(System.Object)
  - type: System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.GetIDispatchForObject(System.Object)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
  id: ReleaseComObject(System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ReleaseComObject(Object)
  fullName: System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReleaseComObject
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 560
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Decrements the reference count of the specified Runtime Callable Wrapper (RCW) associated with the specified COM object.</p>\n"
  remarks: "\n<p>This method is used to explicitly control the lifetime of a COM object used from managed code. You should use this method to free the underlying COM object that holds references to resources in a timely manner or when objects must be freed in a specific order.</p>\n<p>Every time a COM interface pointer enters the common language runtime (CLR), it is wrapped in an RCW.</p>\n<p>The RCW has a reference count that is incremented every time a COM interface pointer is mapped to it. The <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method decrements the reference count of an RCW. When the reference count reaches zero, the runtime releases all its references on the unmanaged COM object, and throws a <xref href=\"System.NullReferenceException\" data-throw-if-not-resolved=\"false\"></xref> if you attempt to use the object further. If the same COM interface is passed more than one time from unmanaged to managed code, the reference count on the wrapper is incremented every time, and calling <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> returns the number of remaining references.</p>\n<p>This method enables you to force an RCW reference count release so that it occurs precisely when you want it to. However, improper use of <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> may cause your application to fail, or may cause an access violation.</p>\n<p>Consider a scenario in which managed code in an application domain is holding onto an RCW that represents a COM component. If you call the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method on the RCW, the managed code will be unable to access the RCW and will raise an <xref href=\"System.Runtime.InteropServices.InvalidComObjectException\" data-throw-if-not-resolved=\"false\"></xref> exception.</p>\n<p>A more serious error may occur if a call to the RCW is executing when the RCW is released. In this case, there is a good chance that the thread making the call will cause an access violation. However, process memory may become corrupted, and the process may continue to run until it fails for reasons that are very difficult to debug.</p>\n<p>This risk is compounded when the COM component that is being used is a singleton, for the following reason: The CLR activates COM components by calling the COM <see href=\"http://go.microsoft.com/fwlink/?LinkID=142894\">CoCreateInstance</see> function, which returns the same interface pointer every time it is called for singleton COM components. Thus, separate and independent pieces of managed code in an application domain can be using the same RCW for a singleton COM component, and if either one calls the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method on the COM component, the other will be broken.</p>\n<p>Therefore, use the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> only if it is absolutely required. If you want to call this method to ensure that a COM component is released at a determined time, consider using the <xref href=\"System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method instead. <xref href=\"System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> will release the underlying COM component regardless of how many times it has re-entered the CLR. The internal reference count of the RCW is incremented by one every time the COM component re-enters the CLR. Therefore, you could call the <xref href=\"System.Runtime.InteropServices.Marshal.ReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method in a loop until the value returned is zero. This achieves the same result as the <xref href=\"System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  syntax:
    content: public static int ReleaseComObject(object o)
    content.vb: Public Shared Function ReleaseComObject(o As Object) As Integer
    parameters:
    - id: o
      type: System.Object
      description: "\n<p>The COM object to release.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The new value of the reference count of the RCW associated with <em>o</em>. This value is typically zero since the RCW keeps just one reference to the wrapped COM object regardless of the number of managed clients calling it.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>o</em> is not a valid COM object.</p>\n"
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>\n<em>o</em> is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
    commentId: M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  commentId: M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  id: SizeOf(System.Object)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SizeOf(Object)
  fullName: System.Runtime.InteropServices.Marshal.SizeOf(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SizeOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 562
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the unmanaged size of an object in bytes.</p>\n"
  remarks: "\n<p>This method accepts an instance of a structure, which can be a reference type or a boxed value type. The layout must be sequential or explicit.</p>\n<p>The size returned is the size of the unmanaged object. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <xref href=\"System.Runtime.InteropServices.CharSet\" data-throw-if-not-resolved=\"false\"></xref> value applied to that class.</p>\n<p>You can use the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to determine how much unmanaged memory to allocate using the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.AllocHGlobal\"></see> and <xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>\n"
  example:
  - "\n<p>The following example creates a managed structure, transfers it to unmanaged memory, and then transfers it back to managed memory. This example uses the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method to determine how much unmanaged memory to allocate.</p>Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1"
  syntax:
    content: public static int SizeOf(object structure)
    content.vb: Public Shared Function SizeOf(structure As Object) As Integer
    parameters:
    - id: structure
      type: System.Object
      description: "\n<p>The object whose size is to be returned.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The size of the specified object in unmanaged code.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>structure</em> parameter is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.CharSet
    commentId: T:System.Runtime.InteropServices.CharSet
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.SizeOf(System.Type)
  commentId: M:System.Runtime.InteropServices.Marshal.SizeOf(System.Type)
  id: SizeOf(System.Type)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SizeOf(Type)
  fullName: System.Runtime.InteropServices.Marshal.SizeOf(System.Type)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SizeOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 565
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Returns the size of an unmanaged type in bytes.</p>\n"
  remarks: "\n<p>You can use this method when you do not have a structure. The layout must be sequential or explicit.</p>\n<p>The size returned is the size of the unmanaged type. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <xref href=\"System.Runtime.InteropServices.CharSet\" data-throw-if-not-resolved=\"false\"></xref> value applied to that class.</p>\n"
  example:
  - "\n<p>The following example demonstrates calling the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf(System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method. This code example is part of a larger example provided for the <xref href=\"System.Runtime.InteropServices.Marshal\" data-throw-if-not-resolved=\"false\"></xref> class.</p>Marshal#3"
  syntax:
    content: public static int SizeOf(Type t)
    content.vb: Public Shared Function SizeOf(t As Type) As Integer
    parameters:
    - id: t
      type: System.Type
      description: "\n<p>The type whose size is to be returned.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The size of the specified type in unmanaged code.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <em>t</em> parameter is a generic type.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>t</em> parameter is <strong>null</strong>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.CharSet
    commentId: T:System.Runtime.InteropServices.CharSet
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.SizeOf``1
  commentId: M:System.Runtime.InteropServices.Marshal.SizeOf``1
  id: SizeOf``1
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SizeOf<T>()
  fullName: System.Runtime.InteropServices.Marshal.SizeOf<T>()
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SizeOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 568
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Returns the size of an unmanaged type in bytes. </p>\n"
  remarks: "\n<p>You can use this method when you do not have a structure. The layout must be sequential or explicit.</p>\n<p>The size returned is the size of the unmanaged type. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <xref href=\"System.Runtime.InteropServices.CharSet\" data-throw-if-not-resolved=\"false\"></xref> value applied to that class. </p>\n"
  syntax:
    content: public static int SizeOf<T>()
    content.vb: Public Shared Function SizeOf(Of T) As Integer
    typeParameters:
    - id: T
      description: "\n<p>The type whose size is to be returned. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The size, in bytes, of the type that is specified by the <em>T</em> generic type parameter. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.SizeOf(Of T)()
  name.vb: SizeOf(Of T)()
- uid: System.Runtime.InteropServices.Marshal.SizeOf``1(``0)
  commentId: M:System.Runtime.InteropServices.Marshal.SizeOf``1(``0)
  id: SizeOf``1(``0)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: SizeOf<T>(T)
  fullName: System.Runtime.InteropServices.Marshal.SizeOf<T>(T)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SizeOf
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 569
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Returns the unmanaged size of an object of a specified type in bytes. </p>\n"
  remarks: "\n<p>This method accepts an instance of a structure, which can be a reference type or a boxed value type. The layout must be sequential or explicit.</p>\n<p>The size returned is the size of the unmanaged object. The unmanaged and managed sizes of an object can differ. For character types, the size is affected by the <xref href=\"System.Runtime.InteropServices.CharSet\" data-throw-if-not-resolved=\"false\"></xref> value applied to that class.</p>\n<p>You can use the <xref href=\"System.Runtime.InteropServices.Marshal.SizeOf``1(``0)\" data-throw-if-not-resolved=\"false\"></xref> method to determine how much unmanaged memory to allocate by using the <see cref=\"Overload:System.Runtime.InteropServices.Marshal.AllocHGlobal\"></see> and <xref href=\"System.Runtime.InteropServices.Marshal.AllocCoTaskMem(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods. </p>\n"
  syntax:
    content: public static int SizeOf<T>(T structure)
    content.vb: Public Shared Function SizeOf(Of T)(structure As T) As Integer
    parameters:
    - id: structure
      type: '{T}'
      description: "\n<p>The object whose size is to be returned. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the <em>structure</em> parameter. </p>\n"
    return:
      type: System.Int32
      description: "\n<p>The size, in bytes, of the specified object in unmanaged code. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>structure</em> parameter is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.SizeOf(Of T)(T)
  name.vb: SizeOf(Of T)(T)
- uid: System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
  id: StringToBSTR(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StringToBSTR(String)
  fullName: System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StringToBSTR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 570
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Allocates a <see href=\"https://msdn.microsoft.com/library/ms221069.aspx\">BSTR</see> and copies the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> into it.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StringToBSTR(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the <strong>BSTR</strong> when finished by calling <xref href=\"System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. This method provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public static IntPtr StringToBSTR(string s)
    content.vb: Public Shared Function StringToBSTR(s As String) As IntPtr
    parameters:
    - id: s
      type: System.String
      description: "\n<p>The managed string to be copied.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>An unmanaged pointer to the <strong>BSTR</strong>, or 0 if <em>s</em> is null.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory available.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The length for <em>s</em> is out of range.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringBSTR(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeBSTR(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  id: StringToCoTaskMemAnsi(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StringToCoTaskMemAnsi(String)
  fullName: System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StringToCoTaskMemAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 572
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> to a block of memory allocated from the unmanaged COM task allocator.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. This method provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. The characters of the string are copied as ANSI characters.</p>\n"
  syntax:
    content: public static IntPtr StringToCoTaskMemAnsi(string s)
    content.vb: Public Shared Function StringToCoTaskMemAnsi(s As String) As IntPtr
    parameters:
    - id: s
      type: System.String
      description: "\n<p>A managed string to be copied.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>An integer representing a pointer to the block of memory allocated for the string, or 0 if <em>s</em> is <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory available.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>s</em> parameter exceeds the maximum length allowed by the operating system.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)
  id: StringToCoTaskMemUni(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StringToCoTaskMemUni(String)
  fullName: System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StringToCoTaskMemUni
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 574
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> to a block of memory allocated from the unmanaged COM task allocator.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref href=\"System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. This method provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>. The characters of the string are copied as Unicode characters.</p>\n"
  syntax:
    content: public static IntPtr StringToCoTaskMemUni(string s)
    content.vb: Public Shared Function StringToCoTaskMemUni(s As String) As IntPtr
    parameters:
    - id: s
      type: System.String
      description: "\n<p>A managed string to be copied.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>An integer representing a pointer to the block of memory allocated for the string, or 0 if s is <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>s</em> parameter exceeds the maximum length allowed by the operating system.</p>\n"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory available.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  id: StringToHGlobalAnsi(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StringToHGlobalAnsi(String)
  fullName: System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StringToHGlobalAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 576
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> into unmanaged memory, converting into ANSI format as it copies.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method copies embedded null characters, and includes a terminating null character. </p>\n"
  example:
  - "\n<p>The following example demonstrates how to convert the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> class to unmanaged memory and then dispose of the unmanaged memory when done.</p>Runtime.InteropServices.Marshal.StringToHGlobalAnsi#1"
  syntax:
    content: public static IntPtr StringToHGlobalAnsi(string s)
    content.vb: Public Shared Function StringToHGlobalAnsi(s As String) As IntPtr
    parameters:
    - id: s
      type: System.String
      description: "\n<p>A managed string to be copied.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The address, in unmanaged memory, to where <em>s</em> was copied, or 0 if <em>s</em> is <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is insufficient memory available.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>s</em> parameter exceeds the maximum length allowed by the operating system.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.FreeCoTaskMem(System.IntPtr)
  - type: System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)
  commentId: M:System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)
  id: StringToHGlobalUni(System.String)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StringToHGlobalUni(String)
  fullName: System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StringToHGlobalUni
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 578
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Copies the contents of a managed <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> into unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalUni(System.String)\" data-throw-if-not-resolved=\"false\"></xref> is useful for custom marshaling or for use when mixing managed and unmanaged code. Because this method allocates the unmanaged memory required for a string, always free the memory by calling <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref>. This method provides the opposite functionality of <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>This method copies embedded null characters, and includes a terminating null character.</p>\n"
  syntax:
    content: public static IntPtr StringToHGlobalUni(string s)
    content.vb: Public Shared Function StringToHGlobalUni(s As String) As IntPtr
    parameters:
    - id: s
      type: System.String
      description: "\n<p>A managed string to be copied.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The address, in unmanaged memory, to where the <em>s</em> was copied, or 0 if <em>s</em> is <strong>null</strong>.</p>\n"
  exceptions:
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>The method could not allocate enough native heap memory.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The <em>s</em> parameter exceeds the maximum length allowed by the operating system.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.PtrToStringUni(System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)
  commentId: M:System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)
  id: StructureToPtr(System.Object,System.IntPtr,System.Boolean)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StructureToPtr(Object, IntPtr, Boolean)
  fullName: System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object, System.IntPtr, System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StructureToPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 580
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Marshals data from a managed object to an unmanaged block of memory.</p>\n"
  remarks: "\n<p>If <em>structure</em> is a value type, it can be boxed or unboxed. If it is boxed, it is unboxed before copying. </p>\n<p>A formatted class is a reference type whose layout is specified by the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute, as either <xref href=\"System.Runtime.InteropServices.LayoutKind.Explicit\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.LayoutKind.Sequential\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> copies the contents of <em>structure</em> to the pre-allocated block of memory that the <em>ptr</em> parameter points to. If <em>structure</em> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>), the managed objects are kept alive with reference counts. All other reference types (for example, strings and arrays) are marshaled to copies. To release these managed or unmanaged objects, you must call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref>method before you free the memory block.</p>\n<p>If you use the <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to copy a different instance to the memory block at a later time, specify <strong>true</strong> for <em>fDeleteOld</em> to remove reference counts for reference types in the previous instance. Otherwise, the managed reference typesand unmanaged copies are effectively leaked. </p>\n<p>The overall pattern for using <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> is as follows:</p>\n<ol><li>\n<p>On the first call to the <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref>method after a memory block has been allocated, <em>fDeleteOld</em>must be<strong>false</strong>, because there are no contents to clear. </p>\n<p>Specify <strong>true</strong> for <em>fDeleteOld</em> only if the block contains valid data. </p>\n</li><li>\n<p>If you copy a different instance to the memory block, and the object contains reference types, <em>fDeleteOld</em> must be <strong>true</strong> to free reference types in the old contents. </p>\n</li><li>\n<p>If the object contains reference types, you must call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method before you free the memory block. </p>\n</li></ol>\n<p>To pin an existing structure instead of copying it, use the <xref href=\"System.Runtime.InteropServices.GCHandle\" data-throw-if-not-resolved=\"false\"></xref> type to create a pinned handle for the structure. For details on how to pin, see Copying and Pinning.</p>\n"
  example:
  - "\n<p>The following example creates a managed structure, transfers it to unmanaged memory using the <xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr(System.Object,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method, and then transfers it back to managed memory using the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>Runtime.InteropServices.Marshal.PtrToStructure-SizeOf#1"
  syntax:
    content: public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld)
    content.vb: Public Shared Sub StructureToPtr(structure As Object, ptr As IntPtr, fDeleteOld As Boolean)
    parameters:
    - id: structure
      type: System.Object
      description: "\n<p>A managed object that holds the data to be marshaled. This object must be a structure or an instance of a formatted class.</p>\n"
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory, which must be allocated before this method is called.</p>\n"
    - id: fDeleteOld
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)\" data-throw-if-not-resolved=\"false\"></xref> method on the <em>ptr</em> parameter before this method copies the data. The block must contain valid data. Note that passing <strong>false</strong> when the memory block already contains data can lead to a memory leak.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>structure</em> is a reference type that is not a formatted class.</p>\n<p>-or-</p>\n<p>\n<em>structure</em> is a generic type. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
    commentId: M:System.Runtime.InteropServices.Marshal.DestroyStructure(System.IntPtr,System.Type)
  - type: System.Runtime.InteropServices.GCHandle
    commentId: T:System.Runtime.InteropServices.GCHandle
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)
  commentId: M:System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)
  id: StructureToPtr``1(``0,System.IntPtr,System.Boolean)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: StructureToPtr<T>(T, IntPtr, Boolean)
  fullName: System.Runtime.InteropServices.Marshal.StructureToPtr<T>(T, System.IntPtr, System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: StructureToPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 584
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Marshals data from a managed object of a specified type to an unmanaged block of memory. </p>\n"
  remarks: "\n<p>A formatted class is a reference type whose layout is specified by the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\" data-throw-if-not-resolved=\"false\"></xref> attribute, as either <xref href=\"System.Runtime.InteropServices.LayoutKind.Explicit\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Runtime.InteropServices.LayoutKind.Sequential\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> copies the contents of <em>structure</em> to the pre-allocated block of memory that the <em>ptr</em> parameter points to. If <em>structure</em> contains reference types that marshal to COM interface pointers (interfaces, classes without layout, and <xref href=\"System.Object\" data-throw-if-not-resolved=\"false\"></xref>), the managed objects are kept alive with reference counts. All other reference types (for example, strings and arrays) are marshaled to copies. To release these managed or unmanaged objects, you must call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method before you free the memory block. </p>\n<p>If you use the<xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method to copy a different instance to the memory block at a later time, specify <strong>true</strong> for <em>fDeleteOld</em> to remove reference counts for reference types in the previous instance. Otherwise, the managed reference types and unmanaged copies are effectively leaked. </p>\n<p>The overall pattern for using<xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> is as follows:</p>\n<ol><li>\n<p>On the first call to the<xref href=\"System.Runtime.InteropServices.Marshal.StructureToPtr``1(``0,System.IntPtr,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method after a memory block has been allocated, <em>fDeleteOld</em> must be <strong>false</strong>, because there are no contents to clear. </p>\n<p>Specify <strong>true</strong> for <em>fDeleteOld</em> only if the block contains valid data. </p>\n</li><li>\n<p>If you copy a different instance to the memory block, and the object contains reference types, <em>fDeleteOld</em> must be <strong>true</strong> to free reference types in the old contents. </p>\n</li><li>\n<p>If the object contains reference types, you must call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method before you free the memory block. </p>\n</li></ol>\n<p>To pin an existing structure instead of copying it, use the <xref href=\"System.Runtime.InteropServices.GCHandle\" data-throw-if-not-resolved=\"false\"></xref> type to create a pinned handle for the structure. For details on how to pin, see Copying and Pinning.</p>\n"
  syntax:
    content: public static void StructureToPtr<T>(T structure, IntPtr ptr, bool fDeleteOld)
    content.vb: Public Shared Sub StructureToPtr(Of T)(structure As T, ptr As IntPtr, fDeleteOld As Boolean)
    parameters:
    - id: structure
      type: '{T}'
      description: "\n<p>A managed object that holds the data to be marshaled. The object must be a structure or an instance of a formatted class. </p>\n"
    - id: ptr
      type: System.IntPtr
      description: "\n<p>A pointer to an unmanaged block of memory, which must be allocated before this method is called. </p>\n"
    - id: fDeleteOld
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to call the <xref href=\"System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method on the <em>ptr</em> parameter before this method copies the data. The block must contain valid data. Note that passing <strong>false</strong> when the memory block already contains data can lead to a memory leak.</p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the managed object. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>structure</em> is a reference type that is not a formatted class. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)
    commentId: M:System.Runtime.InteropServices.Marshal.DestroyStructure``1(System.IntPtr)
  - type: System.Runtime.InteropServices.GCHandle
    commentId: T:System.Runtime.InteropServices.GCHandle
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.StructureToPtr(Of T)(T, System.IntPtr, System.Boolean)
  name.vb: StructureToPtr(Of T)(T, IntPtr, Boolean)
- uid: System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)
  id: ThrowExceptionForHR(System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ThrowExceptionForHR(Int32)
  fullName: System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ThrowExceptionForHR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 586
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Throws an exception with a specific failure HRESULT value.</p>\n"
  remarks: "\n<p>This method creates an exception object for the specified failure HRESULT. If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</p>\n<p>Note that the <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method returns an exception based on the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface of the current thread if one is set. When this happens, the <em>errorCode</em> parameter is ignored.</p>\n<p>Some failure HRESULTs map to defined exceptions, whereas others do not. If the HRESULT maps to a defined exception, <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> creates an instance of the exception and throws it. Otherwise, it creates an instance of <xref href=\"System.Runtime.InteropServices.COMException\" data-throw-if-not-resolved=\"false\"></xref>, initializes the error code field with the HRESULT, and throws that exception. When <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is invoked, it attempts to retrieve extra information regarding the error by using the unmanaged <see href=\"https://msdn.microsoft.com/library/ms221032(v=vs.85).aspx\">GetErrorInfo</see> function.</p>\n<p>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see How to: Map HRESULTs and Exceptions.</p>\n<p>Occasionally, <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> might return an exception from a previous COM call. In this case, you can use the following workaround and pass <code>IntPtr(-1)</code> as the second parameter (<code>errorInfo</code>):</p>\n<pre><code>[SecurityPermissionAttribute(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]\npublic static void ThrowExceptionForHR(interrorCode,IntPtrerrorInfo)</code></pre>\n"
  syntax:
    content: public static void ThrowExceptionForHR(int errorCode)
    content.vb: Public Shared Sub ThrowExceptionForHR(errorCode As Integer)
    parameters:
    - id: errorCode
      type: System.Int32
      description: "\n<p>The HRESULT corresponding to the desired exception.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.COMException
    commentId: T:System.Runtime.InteropServices.COMException
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)
  id: ThrowExceptionForHR(System.Int32,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ThrowExceptionForHR(Int32, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ThrowExceptionForHR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 588
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Throws an exception with a specific failure HRESULT, based on the specified <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface.</p>\n"
  remarks: "\n<p>This method creates an exception object for the specified failure HRESULT. If the HRESULT is 0 or positive (a success code), the method returns without creating or throwing an exception.</p>\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method releases the <em>errorInfo</em> parameter, decreasing the COM reference count of the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface.</p>\n<p>Note that the <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method returns an exception based on the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface of the current thread if one is set. When this happens, the <em>errorCode</em> parameter is ignored.</p>\n<p>Some failure HRESULTs map to defined exceptions, whereas others do not. If the HRESULT maps to a defined exception, <xref href=\"System.Runtime.InteropServices.Marshal.ThrowExceptionForHR(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> creates an instance of the exception and throws it. Otherwise, it creates an instance of <xref href=\"System.Runtime.InteropServices.COMException\" data-throw-if-not-resolved=\"false\"></xref>, initializes the error code field with the HRESULT, and throws that exception. The <em>errorInfo</em> parameter is used to retrieve extra information regarding the error.</p>\n<p>For the mapping from each HRESULT to its comparable exception class in the .NET Framework, see How to: Map HRESULTs and Exceptions.</p>\n"
  syntax:
    content: public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo)
    content.vb: Public Shared Sub ThrowExceptionForHR(errorCode As Integer, errorInfo As IntPtr)
    parameters:
    - id: errorCode
      type: System.Int32
      description: "\n<p>The HRESULT corresponding to the desired exception.</p>\n"
    - id: errorInfo
      type: System.IntPtr
      description: "\n<p>A pointer to the <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface that provides more information about the error. You can specify <code>IntPtr(0)</code> to use the current <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface, or <code>IntPtr(-1)</code> to ignore the current <see href=\"https://msdn.microsoft.com/library/ms221233(v=vs.85).aspx\">IErrorInfo</see> interface and construct the exception just from the error code.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.COMException
    commentId: T:System.Runtime.InteropServices.COMException
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)
  id: UnsafeAddrOfPinnedArrayElement(System.Array,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: UnsafeAddrOfPinnedArrayElement(Array, Int32)
  fullName: System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(System.Array, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UnsafeAddrOfPinnedArrayElement
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 590
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Gets the address of the element at the specified index inside the specified array.</p>\n"
  remarks: "\n<p>The array must be pinned using a <xref href=\"System.Runtime.InteropServices.GCHandle\" data-throw-if-not-resolved=\"false\"></xref> before it is passed to this method. For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</p>\n"
  syntax:
    content: public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index)
    content.vb: Public Shared Function UnsafeAddrOfPinnedArrayElement(arr As Array, index As Integer) As IntPtr
    parameters:
    - id: arr
      type: System.Array
      description: "\n<p>The array that contains the desired element.</p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index in the <em>arr</em> parameter of the desired element.</p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The address of <em>index</em> inside <em>arr</em>.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.GCHandle
    commentId: T:System.Runtime.InteropServices.GCHandle
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)
  id: UnsafeAddrOfPinnedArrayElement``1(``0[],System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: UnsafeAddrOfPinnedArrayElement<T>(T[], Int32)
  fullName: System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement<T>(T[], System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UnsafeAddrOfPinnedArrayElement
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 594
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>[Supported in the .NET Framework 4.5.1 and later versions] </p>\n<p>Gets the address of the element at the specified index in an array of a specified type. </p>\n"
  remarks: "\n<p>The array must be pinned by using a <xref href=\"System.Runtime.InteropServices.GCHandle\" data-throw-if-not-resolved=\"false\"></xref> before it is passed to this method. For maximum performance, this method does not validate the array passed to it; this can result in unexpected behavior.</p>\n"
  syntax:
    content: public static IntPtr UnsafeAddrOfPinnedArrayElement<T>(T[] arr, int index)
    content.vb: Public Shared Function UnsafeAddrOfPinnedArrayElement(Of T)(arr As T(), index As Integer) As IntPtr
    parameters:
    - id: arr
      type: '{T}[]'
      description: "\n<p>The array that contains the desired element. </p>\n"
    - id: index
      type: System.Int32
      description: "\n<p>The index of the desired element in the <em>arr</em> array. </p>\n"
    typeParameters:
    - id: T
      description: "\n<p>The type of the array. </p>\n"
    return:
      type: System.IntPtr
      description: "\n<p>The address of <em>index</em> in <em>arr</em>. </p>\n"
  seealso:
  - type: System.Runtime.InteropServices.GCHandle
    commentId: T:System.Runtime.InteropServices.GCHandle
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement(Of T)(T(), System.Int32)
  name.vb: UnsafeAddrOfPinnedArrayElement(Of T)(T(), Int32)
- uid: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Byte)
  id: WriteByte(System.IntPtr,System.Byte)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteByte(IntPtr, Byte)
  fullName: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr, System.Byte)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 596
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a single byte value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n"
  example:
  - "\n<p>The following example creates a block of unmanaged memory, writes a byte to the unmanaged memory, reads the byte back from unmanaged memory, and then disposes the unmanaged memory.</p>Runtime.InteropServices.Marshal.ReadByte - WriteByte#1"
  syntax:
    content: public static void WriteByte(IntPtr ptr, byte val)
    content.vb: Public Shared Sub WriteByte(ptr As IntPtr, val As Byte)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.Byte
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  id: WriteByte(System.IntPtr,System.Int32,System.Byte)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteByte(IntPtr, Int32, Byte)
  fullName: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr, System.Int32, System.Byte)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 598
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a single byte value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#3"
  syntax:
    content: public static void WriteByte(IntPtr ptr, int ofs, byte val)
    content.vb: Public Shared Sub WriteByte(ptr As IntPtr, ofs As Integer, val As Byte)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory to write to.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Byte
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.Object,System.Int32,System.Byte)
  id: WriteByte(System.Object,System.Int32,System.Byte)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteByte(Object, Int32, Byte)
  fullName: System.Runtime.InteropServices.Marshal.WriteByte(System.Object, System.Int32, System.Byte)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteByte
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 600
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a single byte value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n"
  syntax:
    content: public static void WriteByte(object ptr, int ofs, byte val)
    content.vb: Public Shared Sub WriteByte(ptr As Object, ofs As Integer, val As Byte)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Byte
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Char)
  id: WriteInt16(System.IntPtr,System.Char)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(IntPtr, Char)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr, System.Char)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 604
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a character as a 16-bit integer value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4"
  syntax:
    content: public static void WriteInt16(IntPtr ptr, char val)
    content.vb: Public Shared Sub WriteInt16(ptr As IntPtr, val As Char)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.Char
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int16)
  id: WriteInt16(System.IntPtr,System.Int16)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(IntPtr, Int16)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr, System.Int16)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 606
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 16-bit integer value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref>methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4"
  syntax:
    content: public static void WriteInt16(IntPtr ptr, short val)
    content.vb: Public Shared Sub WriteInt16(ptr As IntPtr, val As Short)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.Int16
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Char)
  id: WriteInt16(System.IntPtr,System.Int32,System.Char)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(IntPtr, Int32, Char)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr, System.Int32, System.Char)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 608
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4"
  syntax:
    content: public static void WriteInt16(IntPtr ptr, int ofs, char val)
    content.vb: Public Shared Sub WriteInt16(ptr As IntPtr, ofs As Integer, val As Char)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in the native heap to write to.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Char
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
    commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)
  id: WriteInt16(System.IntPtr,System.Int32,System.Int16)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(IntPtr, Int32, Int16)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr, System.Int32, System.Int16)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 610
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 16-bit signed integer value into unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt16(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#4"
  syntax:
    content: public static void WriteInt16(IntPtr ptr, int ofs, short val)
    content.vb: Public Shared Sub WriteInt16(ptr As IntPtr, ofs As Integer, val As Short)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory to write to.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Int16
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
    commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Char)
  id: WriteInt16(System.Object,System.Int32,System.Char)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(Object, Int32, Char)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.Object, System.Int32, System.Char)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 612
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static void WriteInt16(object ptr, int ofs, char val)
    content.vb: Public Shared Sub WriteInt16(ptr As Object, ofs As Integer, val As Char)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Char
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt16(System.Object,System.Int32,System.Int16)
  id: WriteInt16(System.Object,System.Int32,System.Int16)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt16(Object, Int32, Int16)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt16(System.Object, System.Int32, System.Int16)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt16
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 616
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 16-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt16(System.IntPtr,System.Int32,System.Int16)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 16-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static void WriteInt16(object ptr, int ofs, short val)
    content.vb: Public Shared Sub WriteInt16(ptr As Object, ofs As Integer, val As Short)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing. </p>\n"
    - id: val
      type: System.Int16
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32)
  id: WriteInt32(System.IntPtr,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt32(IntPtr, Int32)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 620
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 32-bit signed integer value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#5"
  syntax:
    content: public static void WriteInt32(IntPtr ptr, int val)
    content.vb: Public Shared Sub WriteInt32(ptr As IntPtr, val As Integer)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.Int32
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>. </p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)
  id: WriteInt32(System.IntPtr,System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt32(IntPtr, Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 622
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 32-bit signed integer value into unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt32(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#5"
  syntax:
    content: public static void WriteInt32(IntPtr ptr, int ofs, int val)
    content.vb: Public Shared Sub WriteInt32(ptr As IntPtr, ofs As Integer, val As Integer)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory to write to.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Int32
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
    commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt32(System.Object,System.Int32,System.Int32)
  id: WriteInt32(System.Object,System.Int32,System.Int32)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt32(Object, Int32, Int32)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt32(System.Object, System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt32
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 624
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 32-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt32(System.IntPtr,System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 32-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static void WriteInt32(object ptr, int ofs, int val)
    content.vb: Public Shared Sub WriteInt32(ptr As Object, ofs As Integer, val As Integer)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Int32
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)
  id: WriteInt64(System.IntPtr,System.Int32,System.Int64)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt64(IntPtr, Int32, Int64)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr, System.Int32, System.Int64)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 628
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#6"
  syntax:
    content: public static void WriteInt64(IntPtr ptr, int ofs, long val)
    content.vb: Public Shared Sub WriteInt64(ptr As IntPtr, ofs As Integer, val As Long)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory to write.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Int64
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
    commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int64)
  id: WriteInt64(System.IntPtr,System.Int64)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt64(IntPtr, Int64)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr, System.Int64)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 630
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 64-bit signed integer value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadInt64(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#6"
  syntax:
    content: public static void WriteInt64(IntPtr ptr, long val)
    content.vb: Public Shared Sub WriteInt64(ptr As IntPtr, val As Long)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.Int64
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteInt64(System.Object,System.Int32,System.Int64)
  id: WriteInt64(System.Object,System.Int32,System.Int64)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteInt64(Object, Int32, Int64)
  fullName: System.Runtime.InteropServices.Marshal.WriteInt64(System.Object, System.Int32, System.Int64)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteInt64
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 632
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a 64-bit signed integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteInt64(System.IntPtr,System.Int32,System.Int64)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged 64-bit signed array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static void WriteInt64(object ptr, int ofs, long val)
    content.vb: Public Shared Sub WriteInt64(ptr As Object, ofs As Integer, val As Long)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.Int64
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)
  id: WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteIntPtr(IntPtr, Int32, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr, System.Int32, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 636
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a processor native-sized integer value to unmanaged memory at a specified offset.</p>\n"
  remarks: "\n<p>This method writes a 32 bit integer on 32 bit systems, and a 64 bit integer on 64 bit systems.</p>\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style <strong>IntPtr</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#2"
  syntax:
    content: public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val)
    content.vb: Public Shared Sub WriteIntPtr(ptr As IntPtr, ofs As Integer, val As IntPtr)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The base address in unmanaged memory to write to.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.IntPtr
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  - type: System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
    commentId: M:System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.IntPtr)
  id: WriteIntPtr(System.IntPtr,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteIntPtr(IntPtr, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 638
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a processor native sized integer value into unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style <strong>IntPtr</strong> array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to read and write to an unmanaged array using the <xref href=\"System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> methods.</p>System.Runtime.interopServices.Marshal.Read-Write val#2"
  syntax:
    content: public static void WriteIntPtr(IntPtr ptr, IntPtr val)
    content.vb: Public Shared Sub WriteIntPtr(ptr As IntPtr, val As IntPtr)
    parameters:
    - id: ptr
      type: System.IntPtr
      description: "\n<p>The address in unmanaged memory to write to.</p>\n"
    - id: val
      type: System.IntPtr
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>\n<em>ptr</em> is not a recognized format.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is <strong>null</strong>.</p>\n<p>-or-</p>\n<p>\n<em>ptr</em> is invalid.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object,System.Int32,System.IntPtr)
  id: WriteIntPtr(System.Object,System.Int32,System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: WriteIntPtr(Object, Int32, IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.WriteIntPtr(System.Object, System.Int32, System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteIntPtr
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 640
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Writes a processor native sized integer value to unmanaged memory.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Runtime.InteropServices.Marshal.WriteIntPtr(System.IntPtr,System.Int32,System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> enables direct interaction with an unmanaged C-style byte array, eliminating the expense of copying an entire unmanaged array (using <xref href=\"System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>) to a separate managed array before setting its element values.</p>\n<p>Writing to unaligned memory locations is supported.</p>\n"
  syntax:
    content: public static void WriteIntPtr(object ptr, int ofs, IntPtr val)
    content.vb: Public Shared Sub WriteIntPtr(ptr As Object, ofs As Integer, val As IntPtr)
    parameters:
    - id: ptr
      type: System.Object
      description: "\n<p>The base address in unmanaged memory of the target object.</p>\n"
    - id: ofs
      type: System.Int32
      description: "\n<p>An additional byte offset, which is added to the <em>ptr</em> parameter before writing.</p>\n"
    - id: val
      type: System.IntPtr
      description: "\n<p>The value to write.</p>\n"
  exceptions:
  - type: System.AccessViolationException
    commentId: T:System.AccessViolationException
    description: "\n<p>Base address (<em>ptr</em>) plus offset byte (<em>ofs</em>) produces a null or invalid address.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>ptr</em> is an <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> object. This method does not accept <xref href=\"System.Runtime.InteropServices.ArrayWithOffset\" data-throw-if-not-resolved=\"false\"></xref> parameters.</p>\n"
  seealso:
  - type: System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
    commentId: M:System.Runtime.InteropServices.Marshal.Copy(System.Int32[],System.Int32,System.IntPtr,System.Int32)
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)
  id: ZeroFreeBSTR(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ZeroFreeBSTR(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ZeroFreeBSTR
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 644
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees a <see href=\"https://msdn.microsoft.com/library/ms221069.aspx\">BSTR</see> pointer that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToBSTR(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeBSTR(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method first sets the contents of the BSTR to zero, and then frees the BSTR.</p>\n"
  example:
  - 
  syntax:
    content: public static void ZeroFreeBSTR(IntPtr s)
    content.vb: Public Shared Sub ZeroFreeBSTR(s As IntPtr)
    parameters:
    - id: s
      type: System.IntPtr
      description: "\n<p>The address of the <strong>BSTR</strong> to free.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)
  id: ZeroFreeCoTaskMemAnsi(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ZeroFreeCoTaskMemAnsi(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ZeroFreeCoTaskMemAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 646
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees an unmanaged string pointer that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method first zeros out and then frees unmanaged memory that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method to marshal and decrypt the contents of a <xref href=\"System.Security.SecureString\" data-throw-if-not-resolved=\"false\"></xref> object to a block of unmanaged memory. It then uses the <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to zero out and dispose the unmanaged block.</p>Runtime.InteropServices.Marshal.SecureStringToCoTaskMemAnsi#1"
  syntax:
    content: public static void ZeroFreeCoTaskMemAnsi(IntPtr s)
    content.vb: Public Shared Sub ZeroFreeCoTaskMemAnsi(s As IntPtr)
    parameters:
    - id: s
      type: System.IntPtr
      description: "\n<p>The address of the unmanaged string to free.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)
  id: ZeroFreeCoTaskMemUnicode(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ZeroFreeCoTaskMemUnicode(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ZeroFreeCoTaskMemUnicode
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 648
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees an unmanaged string pointer that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method first zeros out and then frees unmanaged memory that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - 
  syntax:
    content: public static void ZeroFreeCoTaskMemUnicode(IntPtr s)
    content.vb: Public Shared Sub ZeroFreeCoTaskMemUnicode(s As IntPtr)
    parameters:
    - id: s
      type: System.IntPtr
      description: "\n<p>The address of the unmanaged string to free.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)
  id: ZeroFreeGlobalAllocAnsi(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ZeroFreeGlobalAllocAnsi(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ZeroFreeGlobalAllocAnsi
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 650
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees an unmanaged string pointer that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method first zeros out and then frees unmanaged memory that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocAnsi(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method to marshal and decrypt the contents of a <xref href=\"System.Security.SecureString\" data-throw-if-not-resolved=\"false\"></xref> object to a block of unmanaged memory. It then uses the <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocAnsi(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to zero out and dispose the unmanaged block.</p>Runtime.InteropServices.Marshal.SecureStringToHGlobalAnsi#1"
  syntax:
    content: public static void ZeroFreeGlobalAllocAnsi(IntPtr s)
    content.vb: Public Shared Sub ZeroFreeGlobalAllocAnsi(s As IntPtr)
    parameters:
    - id: s
      type: System.IntPtr
      description: "\n<p>The address of the unmanaged string to free.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)
  commentId: M:System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)
  id: ZeroFreeGlobalAllocUnicode(System.IntPtr)
  parent: System.Runtime.InteropServices.Marshal
  langs:
  - csharp
  - vb
  name: ZeroFreeGlobalAllocUnicode(IntPtr)
  fullName: System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)
  type: Method
  source:
    remote:
      path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ZeroFreeGlobalAllocUnicode
    path: src/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
    startLine: 652
  assemblies:
  - System.Runtime.InteropServices
  namespace: System.Runtime.InteropServices
  summary: "\n<p>Frees an unmanaged string pointer that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method first zeros out and then frees unmanaged memory that was allocated using the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to use the <xref href=\"System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(System.Security.SecureString)\" data-throw-if-not-resolved=\"false\"></xref> method with the unmanaged <strong>LogonUser</strong> function to perform impersonation with the <xref href=\"System.Security.SecureString\" data-throw-if-not-resolved=\"false\"></xref> class. The example then uses the <xref href=\"System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to zero out and free the unmanaged string reference.</p>Runtime.InteropServices.Marshal.SecureStringToHGlobalUni#1"
  syntax:
    content: public static void ZeroFreeGlobalAllocUnicode(IntPtr s)
    content.vb: Public Shared Sub ZeroFreeGlobalAllocUnicode(s As IntPtr)
    parameters:
    - id: s
      type: System.IntPtr
      description: "\n<p>The address of the unmanaged string to free.</p>\n"
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
references:
- uid: System.Runtime.InteropServices
  isExternal: false
  name: System.Runtime.InteropServices
  fullName: System.Runtime.InteropServices
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Byte[]
  isExternal: false
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: ()
    fullName: ()
- uid: System.Char[]
  isExternal: false
  name: Char[]
  fullName: System.Char[]
  fullname.vb: System.Char()
  name.vb: Char()
  spec.csharp:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Char
    name: Char
    fullName: System.Char
  - name: ()
    fullName: ()
- uid: System.Double[]
  isExternal: true
  name: Double[]
  fullName: System.Double[]
  fullname.vb: System.Double()
  name.vb: Double()
  spec.csharp:
  - uid: System.Double
    name: Double
    fullName: System.Double
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Double
    name: Double
    fullName: System.Double
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Int16[]
  isExternal: true
  name: Int16[]
  fullName: System.Int16[]
  fullname.vb: System.Int16()
  name.vb: Int16()
  spec.csharp:
  - uid: System.Int16
    name: Int16
    fullName: System.Int16
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Int16
    name: Int16
    fullName: System.Int16
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Int32[]
  isExternal: false
  name: Int32[]
  fullName: System.Int32[]
  fullname.vb: System.Int32()
  name.vb: Int32()
  spec.csharp:
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Int32
    name: Int32
    fullName: System.Int32
  - name: ()
    fullName: ()
- uid: System.Int64[]
  isExternal: true
  name: Int64[]
  fullName: System.Int64[]
  fullname.vb: System.Int64()
  name.vb: Int64()
  spec.csharp:
  - uid: System.Int64
    name: Int64
    fullName: System.Int64
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Int64
    name: Int64
    fullName: System.Int64
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.IntPtr[]
  isExternal: true
  name: IntPtr[]
  fullName: System.IntPtr[]
  fullname.vb: System.IntPtr()
  name.vb: IntPtr()
  spec.csharp:
  - uid: System.IntPtr
    name: IntPtr
    fullName: System.IntPtr
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.IntPtr
    name: IntPtr
    fullName: System.IntPtr
    isExternal: true
  - name: ()
    fullName: ()
- uid: System.Single[]
  isExternal: true
  name: Single[]
  fullName: System.Single[]
  fullname.vb: System.Single()
  name.vb: Single()
  spec.csharp:
  - uid: System.Single
    name: Single
    fullName: System.Single
    isExternal: true
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Single
    name: Single
    fullName: System.Single
    isExternal: true
  - name: ()
    fullName: ()
- uid: '{T}'
  isExternal: false
  name: T
  fullName: T
- uid: System.Type
  parent: System
  isExternal: false
  name: Type
  fullName: System.Type
- uid: '{TWrapper}'
  isExternal: false
  name: TWrapper
  fullName: TWrapper
- uid: System.Runtime.InteropServices.CustomQueryInterfaceMode
  parent: System.Runtime.InteropServices
  isExternal: false
  name: CustomQueryInterfaceMode
  fullName: System.Runtime.InteropServices.CustomQueryInterfaceMode
- uid: System.Delegate
  parent: System
  isExternal: false
  name: Delegate
  fullName: System.Delegate
- uid: '{TDelegate}'
  isExternal: false
  name: TDelegate
  fullName: TDelegate
- uid: System.Exception
  parent: System
  isExternal: false
  name: Exception
  fullName: System.Exception
- uid: System.Object[]
  isExternal: false
  name: Object[]
  fullName: System.Object[]
  fullname.vb: System.Object()
  name.vb: Object()
  spec.csharp:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Object
    name: Object
    fullName: System.Object
  - name: ()
    fullName: ()
- uid: '{T}[]'
  isExternal: false
  name: T[]
  fullName: T[]
  fullname.vb: T()
  name.vb: T()
  spec.csharp:
  - name: T
    fullName: T
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - name: T
    fullName: T
  - name: ()
    fullName: ()
- uid: System.Guid
  parent: System
  isExternal: false
  name: Guid
  fullName: System.Guid
- uid: System.Runtime.InteropServices.ComTypes.ITypeInfo
  parent: System.Runtime.InteropServices.ComTypes
  isExternal: false
  name: ITypeInfo
  fullName: System.Runtime.InteropServices.ComTypes.ITypeInfo
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Runtime.InteropServices.ComTypes
  isExternal: false
  name: System.Runtime.InteropServices.ComTypes
  fullName: System.Runtime.InteropServices.ComTypes
- uid: System.Byte
  parent: System
  isExternal: false
  name: Byte
  fullName: System.Byte
- uid: System.Int16
  parent: System
  isExternal: false
  name: Int16
  fullName: System.Int16
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Array
  parent: System
  isExternal: false
  name: Array
  fullName: System.Array
- uid: System.Char
  parent: System
  isExternal: false
  name: Char
  fullName: System.Char
- uid: System.OutOfMemoryException
  isExternal: false
  name: OutOfMemoryException
  fullName: System.OutOfMemoryException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.InvalidCastException
  isExternal: false
  name: InvalidCastException
  fullName: System.InvalidCastException
- uid: System.Runtime.InteropServices.InvalidOleVariantTypeException
  isExternal: false
  name: InvalidOleVariantTypeException
  fullName: System.Runtime.InteropServices.InvalidOleVariantTypeException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.MissingMethodException
  isExternal: false
  name: MissingMethodException
  fullName: System.MissingMethodException
- uid: System.AccessViolationException
- uid: System.NullReferenceException
  isExternal: false
  name: NullReferenceException
  fullName: System.NullReferenceException
