items:
- uid: System.Threading.SemaphoreSlim
  commentId: T:System.Threading.SemaphoreSlim
  id: SemaphoreSlim
  parent: System.Threading
  children:
  - System.Threading.SemaphoreSlim.#ctor(System.Int32)
  - System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)
  - System.Threading.SemaphoreSlim.AvailableWaitHandle
  - System.Threading.SemaphoreSlim.CurrentCount
  - System.Threading.SemaphoreSlim.Dispose
  - System.Threading.SemaphoreSlim.Dispose(System.Boolean)
  - System.Threading.SemaphoreSlim.Release
  - System.Threading.SemaphoreSlim.Release(System.Int32)
  - System.Threading.SemaphoreSlim.Wait
  - System.Threading.SemaphoreSlim.Wait(System.Int32)
  - System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)
  - System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)
  - System.Threading.SemaphoreSlim.Wait(System.TimeSpan)
  - System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)
  - System.Threading.SemaphoreSlim.WaitAsync
  - System.Threading.SemaphoreSlim.WaitAsync(System.Int32)
  - System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)
  - System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)
  - System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)
  - System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)
  langs:
  - csharp
  - vb
  name: SemaphoreSlim
  fullName: System.Threading.SemaphoreSlim
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: SemaphoreSlim
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 41
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Represents a lightweight alternative to <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> that limits the number of threads that can access a resource or pool of resources concurrently.</p>\n"
  remarks: "\n<p>Semaphores are of two types: local semaphores and named system semaphores. The former is local to an app. The latter is visible throughout the operating system and is suitable for inter-process synchronization. The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> is a lightweight alternative to the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class that doesn't use Windows kernel semaphores. Unlike the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class, the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class doesn’t support named system semaphores. You can use it as a local semaphore only. The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class is the recommended semaphore for synchronization within a single app. </p>\n<p>A lightweight semaphore controls access to a pool of resources that is local to your application. When you instantiate a semaphore, you can specify the maximum number of threads that can enter the semaphore concurrently. You also specify the initial number of threads that can enter the semaphore concurrently. This defines the semaphore's count. </p>\n<p>The count is decremented each time a thread enters the semaphore, and incremented each time a thread releases the semaphore. To enter the semaphore, a thread calls one of the <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> overloads. To release the semaphore, it calls one of the <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> overloads. When the count reaches zero, subsequent calls to one of the <strong>Wait</strong> methods block until other threads release the semaphore. If multiple threads are blocked, there is no guaranteed order, such as FIFO or LIFO, that controls when threads enter the semaphore. </p>\n<p>The basic structure for code that uses a semaphore to protect resources is:</p>\n<pre><code>' Enter semaphore by calling one of the Wait or WaitAsync methods.\nSemaphoreSlim.Wait()\n' \n' Execute code protected by the semaphore. \n'\nSemaphoreSlim.Release()</code></pre>\n<p>When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created. The semaphore's count is available from the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property. </p>\n<p>The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class doesn’t enforce thread or task identity on calls to the <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref>, and <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> methods. In addition, if the <xref href=\"System.Threading.SemaphoreSlim.#ctor(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> constructor is used to instantiate the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object, the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property can increase beyond the value set by the constructor. It is the programmer's responsibility to ensure that calls to <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> methods are appropriately paired with calls to <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> methods. </p>\n"
  example:
  - "\n<p>The following example creates a semaphore with a maximum count of three threads and an initial count of zero threads. The example starts five tasks, all of which block waiting for the semaphore. The main thread calls the <xref href=\"System.Threading.SemaphoreSlim.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> overload to increase the semaphore count to its maximum, which allows three tasks to enter the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread to make the output easier to read. </p>System.Threading.SemaphoreSlim#1"
  syntax:
    content: >-
      [ComVisible(false)]

      [HostProtection(Synchronization = true, ExternalThreading = true)]

      [DebuggerDisplay("Current Count = {m_currentCount}")]

      public class SemaphoreSlim : IDisposable
    content.vb: >-
      <ComVisible(False)>

      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      <DebuggerDisplay("Current Count = {m_currentCount}")>

      Public Class SemaphoreSlim
          Implements IDisposable
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32)
  commentId: M:System.Threading.SemaphoreSlim.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: SemaphoreSlim(Int32)
  fullName: System.Threading.SemaphoreSlim.SemaphoreSlim(System.Int32)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 159
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the initial number of requests that can be granted concurrently.</p>\n"
  remarks: "\n<p>The <em>initialCount</em> parameter defines the number of concurrent requests to enter the semaphore that can be granted. However, it doesn’t define the maximum number of requests that can be granted concurrently. A   <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object instantiated by calling this constructor doesn’t throw a <xref href=\"System.Threading.SemaphoreFullException\" data-throw-if-not-resolved=\"false\"></xref> exception if a call to the <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> method increases the value of the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property beyond <em>initialCount</em>. This occurs if there are more calls to <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> methods than there are to <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> methods. To set the maximum number of concurrent requests to enter the semaphore that can be granted, call the <xref href=\"System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> constructor. </p>\n"
  example:
  - 
  syntax:
    content: public SemaphoreSlim(int initialCount)
    content.vb: Public Sub New(initialCount As Integer)
    parameters:
    - id: initialCount
      type: System.Int32
      description: >-
        The initial number of requests for the semaphore that can be granted

        concurrently.
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>initialCount</em> is less than 0.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)
  commentId: M:System.Threading.SemaphoreSlim.#ctor(System.Int32,System.Int32)
  id: '#ctor(System.Int32,System.Int32)'
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: SemaphoreSlim(Int32, Int32)
  fullName: System.Threading.SemaphoreSlim.SemaphoreSlim(System.Int32, System.Int32)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 176
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the initial and maximum number of requests that can be granted concurrently.</p>\n"
  example:
  - 
  syntax:
    content: public SemaphoreSlim(int initialCount, int maxCount)
    content.vb: Public Sub New(initialCount As Integer, maxCount As Integer)
    parameters:
    - id: initialCount
      type: System.Int32
      description: >-
        The initial number of requests for the semaphore that can be granted

        concurrently.
    - id: maxCount
      type: System.Int32
      description: >-
        The maximum number of requests for the semaphore that can be granted

        concurrently.
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>initialCount</em> is less than 0, or <em>initialCount</em> is greater than <em>maxCount</em>, or <em>maxCount</em> is equal to or less than 0.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.AvailableWaitHandle
  commentId: P:System.Threading.SemaphoreSlim.AvailableWaitHandle
  id: AvailableWaitHandle
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: AvailableWaitHandle
  fullName: System.Threading.SemaphoreSlim.AvailableWaitHandle
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: AvailableWaitHandle
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 124
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Returns a <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> that can be used to wait on the semaphore.</p>\n"
  remarks: "\n<p>Use this property only when you must wait on a SemaphoreSlim together with other kernel-based synchronization objects with the same wait handle. A successful wait on the <xref href=\"System.Threading.SemaphoreSlim.AvailableWaitHandle\" data-throw-if-not-resolved=\"false\"></xref> does not imply a successful wait on the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> itself, nor does it decrement the semaphore's count. After the available wait handle is signaled, you should wait on the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> specifically.</p>\n"
  example:
  - 
  syntax:
    content: public WaitHandle AvailableWaitHandle { get; }
    content.vb: Public ReadOnly Property AvailableWaitHandle As WaitHandle
    parameters: []
    return:
      type: System.Threading.WaitHandle
      description: >-
        A <xref href="System.Threading.WaitHandle" data-throw-if-not-resolved="false"></xref> that can be used to wait on the

        semaphore.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.SemaphoreSlim.CurrentCount
  commentId: P:System.Threading.SemaphoreSlim.CurrentCount
  id: CurrentCount
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: CurrentCount
  fullName: System.Threading.SemaphoreSlim.CurrentCount
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: CurrentCount
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 106
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the number of remaining threads that can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n"
  remarks: "\n<p>The initial value of the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property is set by the call to the <see cref=\"Overload:System.Threading.SemaphoreSlim.#ctor\"></see> class constructor. It is decremented by each call to the <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> method, and incremented by each call to the <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n"
  example:
  - 
  syntax:
    content: public int CurrentCount { get; }
    content.vb: Public ReadOnly Property CurrentCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: The current count of the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>.
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.SemaphoreSlim.Dispose
  commentId: M:System.Threading.SemaphoreSlim.Dispose
  id: Dispose
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Dispose()
  fullName: System.Threading.SemaphoreSlim.Dispose()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 845
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases all resources used by the current instance of the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Call <strong>Dispose</strong> when you are finished using the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>. The <strong>Dispose</strong> method leaves the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> in an unusable state. After calling <strong>Dispose</strong>, you must release all references to the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> so the garbage collector can reclaim the memory that the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> was occupying.</p>\n<p>For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>\n<p>Always call <strong>Dispose</strong> before you release your last reference to the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object's <strong>Finalize</strong> method.</p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Dispose(System.Boolean)
  commentId: M:System.Threading.SemaphoreSlim.Dispose(System.Boolean)
  id: Dispose(System.Boolean)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Dispose(Boolean)
  fullName: System.Threading.SemaphoreSlim.Dispose(System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Dispose
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 861
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the unmanaged resources used by the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, and optionally releases the managed resources.</p>\n"
  remarks: "\n<p>Unlike most of the members of <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.SemaphoreSlim.Dispose(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> is not thread-safe and may not be used concurrently with other members of this instance.</p>\n"
  example:
  - 
  syntax:
    content: protected virtual void Dispose(bool disposing)
    content.vb: Protected Overridable Sub Dispose(disposing As Boolean)
    parameters:
    - id: disposing
      type: System.Boolean
      description: >-
        true to release both managed and unmanaged resources;

        false to release only unmanaged resources.
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Threading.SemaphoreSlim.Release
  commentId: M:System.Threading.SemaphoreSlim.Release
  id: Release
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Release()
  fullName: System.Threading.SemaphoreSlim.Release()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Release
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 739
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object once.</p>\n"
  remarks: "\n<p>A call to the <xref href=\"System.Threading.SemaphoreSlim.Release\" data-throw-if-not-resolved=\"false\"></xref> method increments the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. If the value of the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property is zero before this method is called, the method also allows one thread or task blocked by a call to the <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> method to enter the semaphore. </p>\n"
  example:
  - 
  syntax:
    content: public int Release()
    content.vb: Public Function Release As Integer
    return:
      type: System.Int32
      description: The previous count of the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  - type: System.Threading.SemaphoreFullException
    commentId: T:System.Threading.SemaphoreFullException
    description: "\n<p>The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> has already reached its maximum size.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Release(System.Int32)
  commentId: M:System.Threading.SemaphoreSlim.Release(System.Int32)
  id: Release(System.Int32)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Release(Int32)
  fullName: System.Threading.SemaphoreSlim.Release(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Release
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 755
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> object a specified number of times.</p>\n"
  remarks: "\n<p>A call to the <xref href=\"System.Threading.SemaphoreSlim.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method increments the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by <em>releaseCount</em>. If the value of the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property is zero before this method is called, the method also allows <em>releaseCount</em> threads or tasks blocked by a call to the <xref href=\"System.Threading.SemaphoreSlim.Wait\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.SemaphoreSlim.WaitAsync\" data-throw-if-not-resolved=\"false\"></xref> method to enter the semaphore. </p>\n"
  example:
  - 
  syntax:
    content: public int Release(int releaseCount)
    content.vb: Public Function Release(releaseCount As Integer) As Integer
    parameters:
    - id: releaseCount
      type: System.Int32
      description: The number of times to exit the semaphore.
    return:
      type: System.Int32
      description: The previous count of the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>releaseCount</em> is less than 1.</p>\n"
  - type: System.Threading.SemaphoreFullException
    commentId: T:System.Threading.SemaphoreFullException
    description: "\n<p>The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> has already reached its maximum size.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait
  commentId: M:System.Threading.SemaphoreSlim.Wait
  id: Wait
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait()
  fullName: System.Threading.SemaphoreSlim.Wait()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 203
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n"
  example:
  - 
  syntax:
    content: public void Wait()
    content.vb: Public Sub Wait
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait(System.Int32)
  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Int32)
  id: Wait(System.Int32)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait(Int32)
  fullName: System.Threading.SemaphoreSlim.Wait(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 291
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a 32-bit signed integer that specifies the timeout.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n<p>If a thread or task is blocked when calling <xref href=\"System.Threading.SemaphoreSlim.Wait(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref>, and the time-out interval specified by <em>millisecondsTimeout</em> expires, the thread or task doesn’t enter the semaphore, and the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property isn’t decremented.</p>\n"
  example:
  - 
  syntax:
    content: public bool Wait(int millisecondsTimeout)
    content.vb: Public Function Wait(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: The number of milliseconds to wait, or <xref href="System.Threading.Timeout.Infinite" data-throw-if-not-resolved="false"></xref>(-1) to wait indefinitely.
    return:
      type: System.Boolean
      description: >-
        true if the current thread successfully entered the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>;

        otherwise, false.
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)
  id: Wait(System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait(Int32, CancellationToken)
  fullName: System.Threading.SemaphoreSlim.Wait(System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 309
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a 32-bit signed integer that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n<p>If <em>cancellationToken</em> is cancelled, or if a thread or task is blocked when calling <xref href=\"System.Threading.SemaphoreSlim.Wait(System.Int32,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> and the time-out interval specified by <em>millisecondsTimeout</em> expires, the thread or task doesn’t enter the semaphore, and the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property isn’t decremented. If <em>cancellationToken</em> is cancelled, the method throws an   <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception. </p>\n"
  example:
  - 
  syntax:
    content: public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken)
    content.vb: Public Function Wait(millisecondsTimeout As Integer, cancellationToken As CancellationToken) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: >-
        The number of milliseconds to wait, or <xref href="System.Threading.Timeout.Infinite" data-throw-if-not-resolved="false"></xref>(-1) to

        wait indefinitely.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> to observe.
    return:
      type: System.Boolean
      description: true if the current thread successfully entered the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>; otherwise, false.
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref> instance has been disposed, or the <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created <em>cancellationToken</em> has been disposed.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)
  id: Wait(System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait(CancellationToken)
  fullName: System.Threading.SemaphoreSlim.Wait(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 219
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n<p>If <em>cancellationToken</em> is cancelled, the thread or task doesn’t enter the semaphore, and the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property isn’t decremented. Instead, the method throws an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception. </p>\n"
  example:
  - 
  syntax:
    content: public void Wait(CancellationToken cancellationToken)
    content.vb: Public Sub Wait(cancellationToken As CancellationToken)
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: >-
        The <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> token to

        observe.
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n<p>-or-</p>\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created<em> cancellationToken</em> has already been disposed.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan)
  commentId: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan)
  id: Wait(System.TimeSpan)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait(TimeSpan)
  fullName: System.Threading.SemaphoreSlim.Wait(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 237
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> to specify the timeout.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n<p>If a thread or task is blocked when calling <xref href=\"System.Threading.SemaphoreSlim.Wait(System.TimeSpan)\" data-throw-if-not-resolved=\"false\"></xref> and the time-out interval specified by <em>timeout</em> expires, the thread or task doesn’t enter the semaphore, and the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property isn’t decremented. </p>\n"
  example:
  - 
  syntax:
    content: public bool Wait(TimeSpan timeout)
    content.vb: Public Function Wait(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: >
        A <xref href="System.TimeSpan" data-throw-if-not-resolved="false"></xref> that represents the number of milliseconds

        to wait, or a <xref href="System.TimeSpan" data-throw-if-not-resolved="false"></xref> that represents -1 milliseconds to wait indefinitely.
    return:
      type: System.Boolean
      description: >-
        true if the current thread successfully entered the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>;

        otherwise, false.
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The semaphoreSlim instance has been disposed<em>.</em></p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)
  id: Wait(System.TimeSpan,System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: Wait(TimeSpan, CancellationToken)
  fullName: System.Threading.SemaphoreSlim.Wait(System.TimeSpan, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 267
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Blocks the current thread until it can enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that specifies the timeout, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>If a thread or task is able to enter the semaphore, it decrements the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property by one. </p>\n<p>If <em>cancellationToken</em> is cancelled, or if a thread or task is blocked when calling <xref href=\"System.Threading.SemaphoreSlim.Wait(System.TimeSpan,System.Threading.CancellationToken)\" data-throw-if-not-resolved=\"false\"></xref> and the timeout interval specified by <em>timeout</em> expires, the thread or task doesn’t enter the semaphore, and the <xref href=\"System.Threading.SemaphoreSlim.CurrentCount\" data-throw-if-not-resolved=\"false\"></xref> property isn’t decremented. If <em>cancellationToken</em> is cancelled, the method throws an <xref href=\"System.OperationCanceledException\" data-throw-if-not-resolved=\"false\"></xref> exception. </p>\n"
  example:
  - 
  syntax:
    content: public bool Wait(TimeSpan timeout, CancellationToken cancellationToken)
    content.vb: Public Function Wait(timeout As TimeSpan, cancellationToken As CancellationToken) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: >
        A <xref href="System.TimeSpan" data-throw-if-not-resolved="false"></xref> that represents the number of milliseconds

        to wait, or a <xref href="System.TimeSpan" data-throw-if-not-resolved="false"></xref> that represents -1 milliseconds to wait indefinitely.
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: >-
        The <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> to

        observe.
    return:
      type: System.Boolean
      description: >-
        true if the current thread successfully entered the <xref href="System.Threading.SemaphoreSlim" data-throw-if-not-resolved="false"></xref>;

        otherwise, false.
  exceptions:
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>timeout</em> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The semaphoreSlim instance has been disposed<em>.</em></p>\n<p>\n<em>-or-</em>\n</p>\n<p>The <xref href=\"System.Threading.CancellationTokenSource\" data-throw-if-not-resolved=\"false\"></xref> that created <em>cancellationToken</em> has already been disposed.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync
  id: WaitAsync
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync()
  fullName: System.Threading.SemaphoreSlim.WaitAsync()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 478
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  syntax:
    content: public Task WaitAsync()
    content.vb: Public Function WaitAsync As Task
    return:
      type: System.Threading.Tasks.Task
      description: A task that will complete when the semaphore has been entered.
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32)
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32)
  id: WaitAsync(System.Int32)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync(Int32)
  fullName: System.Threading.SemaphoreSlim.WaitAsync(System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 515
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a 32-bit signed integer to measure the time interval. </p>\n"
  syntax:
    content: public Task<bool> WaitAsync(int millisecondsTimeout)
    content.vb: Public Function WaitAsync(millisecondsTimeout As Integer) As Task(Of Boolean)
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\nThe number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>(-1) to wait indefinitely.\n"
    return:
      type: System.Threading.Tasks.Task{System.Boolean}
      description: "\nA task that will complete with a result of true if the current thread successfully entered \nthe <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, otherwise with a result of false.\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Int32,System.Threading.CancellationToken)
  id: WaitAsync(System.Int32,System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync(Int32, CancellationToken)
  fullName: System.Threading.SemaphoreSlim.WaitAsync(System.Int32, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 596
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a 32-bit signed integer to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  syntax:
    content: public Task<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken)
    content.vb: Public Function WaitAsync(millisecondsTimeout As Integer, cancellationToken As CancellationToken) As Task(Of Boolean)
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\nThe number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>(-1) to wait indefinitely.\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: The <xref href="System.Threading.CancellationToken" data-throw-if-not-resolved="false"></xref> to observe.
    return:
      type: System.Threading.Tasks.Task{System.Boolean}
      description: "\nA task that will complete with a result of true if the current thread successfully entered \nthe <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, otherwise with a result of false.\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed. </p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)
  id: WaitAsync(System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync(CancellationToken)
  fullName: System.Threading.SemaphoreSlim.WaitAsync(System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 494
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  syntax:
    content: public Task WaitAsync(CancellationToken cancellationToken)
    content.vb: Public Function WaitAsync(cancellationToken As CancellationToken) As Task
    parameters:
    - id: cancellationToken
      type: System.Threading.CancellationToken
      description: "\nThe <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref> token to observe.\n"
    return:
      type: System.Threading.Tasks.Task
      description: A task that will complete when the semaphore has been entered.
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)
  id: WaitAsync(System.TimeSpan)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync(TimeSpan)
  fullName: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 543
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> to measure the time interval.</p>\n"
  syntax:
    content: public Task<bool> WaitAsync(TimeSpan timeout)
    content.vb: Public Function WaitAsync(timeout As TimeSpan) As Task(Of Boolean)
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\nA <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds\nto wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely.\n"
    return:
      type: System.Threading.Tasks.Task{System.Boolean}
      description: "\nA task that will complete with a result of true if the current thread successfully entered \nthe <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, otherwise with a result of false.\n"
  exceptions:
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The current instance has already been disposed.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out </p>\n<p>-or- </p>\n<p>timeout is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)
  commentId: M:System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan,System.Threading.CancellationToken)
  id: WaitAsync(System.TimeSpan,System.Threading.CancellationToken)
  parent: System.Threading.SemaphoreSlim
  langs:
  - csharp
  - vb
  name: WaitAsync(TimeSpan, CancellationToken)
  fullName: System.Threading.SemaphoreSlim.WaitAsync(System.TimeSpan, System.Threading.CancellationToken)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: WaitAsync
    path: src/mscorlib/src/System/Threading/SemaphoreSlim.cs
    startLine: 564
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Asynchronously waits to enter the <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, using a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> to measure the time interval, while observing a <xref href=\"System.Threading.CancellationToken\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public Task<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken)
    content.vb: Public Function WaitAsync(timeout As TimeSpan, cancellationToken As CancellationToken) As Task(Of Boolean)
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\nA <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents the number of milliseconds\nto wait, or a <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> that represents -1 milliseconds to wait indefinitely.\n"
    - id: cancellationToken
      type: System.Threading.CancellationToken
    return:
      type: System.Threading.Tasks.Task{System.Boolean}
      description: "\nA task that will complete with a result of true if the current thread successfully entered \nthe <xref href=\"System.Threading.SemaphoreSlim\" data-throw-if-not-resolved=\"false\"></xref>, otherwise with a result of false.\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is a negative number other than -1, which represents an infinite time-out</p>\n<p>-or-</p>\n<p>timeout is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.OperationCanceledException
    commentId: T:System.OperationCanceledException
    description: "\n<p>\n<em>cancellationToken</em> was canceled. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  fullName: System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Threading.WaitHandle
  parent: System.Threading
  isExternal: false
  name: WaitHandle
  fullName: System.Threading.WaitHandle
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Threading.CancellationToken
  parent: System.Threading
  isExternal: false
  name: CancellationToken
  fullName: System.Threading.CancellationToken
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Threading.Tasks.Task{System.Boolean}
  parent: System.Threading.Tasks
  definition: System.Threading.Tasks.Task`1
  name: Task<Boolean>
  fullName: System.Threading.Tasks.Task<System.Boolean>
  fullname.vb: System.Threading.Tasks.Task(Of System.Boolean)
  name.vb: Task(Of Boolean)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
- uid: System.Threading.Tasks.Task`1
  parent: System.Threading.Tasks
  isExternal: false
  name: Task<TResult>
  fullName: System.Threading.Tasks.Task<TResult>
  fullname.vb: System.Threading.Tasks.Task(Of TResult)
  name.vb: Task(Of TResult)
  spec.csharp:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: <
    fullName: <
  - name: TResult
    fullName: TResult
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Threading.Tasks.Task`1
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: '(Of '
    fullName: '(Of '
  - name: TResult
    fullName: TResult
  - name: )
    fullName: )
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.Threading.SemaphoreFullException
  isExternal: false
  name: SemaphoreFullException
  fullName: System.Threading.SemaphoreFullException
- uid: System.OperationCanceledException
  parent: System
  isExternal: false
  name: OperationCanceledException
  fullName: System.OperationCanceledException
