items:
- uid: System.IntPtr
  commentId: T:System.IntPtr
  id: IntPtr
  parent: System
  children:
  - System.IntPtr.#ctor(System.Int32)
  - System.IntPtr.#ctor(System.Int64)
  - System.IntPtr.#ctor(System.Void*)
  - System.IntPtr.Add(System.IntPtr,System.Int32)
  - System.IntPtr.Equals(System.Object)
  - System.IntPtr.GetHashCode
  - System.IntPtr.op_Addition(System.IntPtr,System.Int32)
  - System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)
  - System.IntPtr.op_Explicit(System.Int32)~System.IntPtr
  - System.IntPtr.op_Explicit(System.Int64)~System.IntPtr
  - System.IntPtr.op_Explicit(System.IntPtr)~System.Int32
  - System.IntPtr.op_Explicit(System.IntPtr)~System.Int64
  - System.IntPtr.op_Explicit(System.IntPtr)~System.Void*
  - System.IntPtr.op_Explicit(System.Void*)~System.IntPtr
  - System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)
  - System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)
  - System.IntPtr.Size
  - System.IntPtr.Subtract(System.IntPtr,System.Int32)
  - System.IntPtr.ToInt32
  - System.IntPtr.ToInt64
  - System.IntPtr.ToPointer
  - System.IntPtr.ToString
  - System.IntPtr.ToString(System.String)
  - System.IntPtr.Zero
  langs:
  - csharp
  - vb
  name: IntPtr
  fullName: System.IntPtr
  type: Struct
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IntPtr
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 24
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>A platform-specific type that is used to represent a pointer or a handle.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type is designed to be an integer whose size is platform-specific. That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</p>\n<p>The <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</p>\n<p>\n<xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> objects can also be used to hold handles. For example, instances of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> are used extensively in the <xref href=\"System.IO.FileStream\" data-throw-if-not-resolved=\"false\"></xref> class to hold file handles.</p>\n<p>The <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type is CLS-compliant, while the <xref href=\"System.UIntPtr\" data-throw-if-not-resolved=\"false\"></xref> type is not. Only the <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type is used in the common language runtime. The <xref href=\"System.UIntPtr\" data-throw-if-not-resolved=\"false\"></xref> type is provided mostly to maintain architectural symmetry with the <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> type.</p>\n<p>This type implements the <xref href=\"System.Runtime.Serialization.ISerializable\" data-throw-if-not-resolved=\"false\"></xref> interface.</p>\n"
  example:
  - "\n<p>The following example uses managed pointers to reverse the characters in an array. After it initializes a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> object and gets its length, it does the following: </p>\n<ol><li>\n<p>Calls the <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character. The method returns an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the beginning of the unmanaged string. The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte. </p>\n</li><li>\n<p>Calls the <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to allocate the same number of bytes as the unmanaged string occupies. The method returns an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the beginning of the unmanaged block of memory. The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte. </p>\n</li><li>\n<p>The Visual Basic example defines a variable named <code>offset</code> that is equal to the length of the ANSI string. It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied. Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block. </p>\n<p>The C# and C++ examples call the <xref href=\"System.IntPtr.ToPointer\" data-throw-if-not-resolved=\"false\"></xref> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string. Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block. </p>\n</li><li>\n<p>Uses a loop to copy each character from the string to the unmanaged block of memory. </p>\n<p>The Visual Basic example calls the <xref href=\"System.Runtime.InteropServices.Marshal.ReadByte(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string. The offset is incremented with each iteration of the loop. It then calls the <xref href=\"System.Runtime.InteropServices.Marshal.WriteByte(System.IntPtr,System.Int32,System.Byte)\" data-throw-if-not-resolved=\"false\"></xref> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus <code>offset</code>. It then decrements <code>offset</code>. </p>\n<p>The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.  </p>\n</li><li>\n<p>All examples call the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n</li><li>\n<p>After displaying the original and reversed strings, all examples call the <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory. </p>\n</li></ol>System.IntPtr#1"
  syntax:
    content: >-
      [Serializable]

      [ComVisible(true)]

      public struct IntPtr : ISerializable
    content.vb: >-
      <Serializable>

      <ComVisible(True)>

      Public Structure IntPtr
          Implements ISerializable
  seealso:
  - type: System.UIntPtr
    commentId: T:System.UIntPtr
  inheritedMembers:
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetType
  attributes:
  - type: System.Runtime.InteropServices.StructLayoutAttribute
    ctor: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)
    arguments:
    - type: System.Runtime.InteropServices.LayoutKind
      value: 0
  modifiers.csharp:
  - public
  - struct
  modifiers.vb:
  - Public
  - Structure
- uid: System.IntPtr.Zero
  commentId: F:System.IntPtr.Zero
  id: Zero
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Zero
  fullName: System.IntPtr.Zero
  type: Field
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Zero
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 31
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>A read-only field that represents a pointer or handle that has been initialized to zero.</p>\n"
  remarks: "\n<p>The value of this field is not equivalent to <strong>null</strong>. Use this field to efficiently determine whether an instance of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> has been set to a value other than zero.</p>\n<p>For example, assume the variable, ip, is an instance of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>. You can determine if it has been set by comparing it to the value returned by a constructor, for example: \" <code>if ip != new IntPtr(0)...</code> \". However, invoking a constructor to get an unintialized pointer is inefficient. It is better to code either \" <code>if ip != IntPtr.Zero...</code> \", or \" <code>if !IntPtr.Zero.Equals(ip)...</code> \".</p>\n<p>When calling the Windows API from managed code, you can pass <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref> instead of <code>null</code> if an argument is expected to be either a pointer or a <code>null</code>. For example, the following call to the Windows <strong>CreateFile</strong> function supplies <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref> for the <em>pSecurityAttributes</em> and <em>hTemplateFile</em> argument values. </p>System.IntPtr.Zero#2<p>Although <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref> is equivalent to <code>null</code> for Windows API functions with parameters or return values that can be either pointers or <code>null</code>, <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref> is not equivalent to <strong>null</strong>. Passing <strong>null</strong> to the <strong>IntPtr.Zero.Equals</strong> method always returns <strong>false</strong>. </p><p>You can also test for a <code>null</code> return value from Windows API function calls that return either a pointer or a <code>null</code> by comparing the returned value with <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref>. For example, the call to the <strong>GetWindow</strong> function in the following example tries to retrieve the handle of a non-existent window. If it were called from unmanaged code, the function would return <code>null</code>, but when it is called from managed code, it returns <xref href=\"System.IntPtr.Zero\" data-throw-if-not-resolved=\"false\"></xref>. </p>System.IntPtr.Zero#1"
  syntax:
    content: public static readonly IntPtr Zero
    content.vb: Public Shared ReadOnly Zero As IntPtr
    return:
      type: System.IntPtr
  modifiers.csharp:
  - public
  - static
  - readonly
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.IntPtr.#ctor(System.Int32)
  commentId: M:System.IntPtr.#ctor(System.Int32)
  id: '#ctor(System.Int32)'
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: IntPtr(Int32)
  fullName: System.IntPtr.IntPtr(System.Int32)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 42
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> using the specified 32-bit pointer or handle.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public IntPtr(int value)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Sub New(value As Integer)
    parameters:
    - id: value
      type: System.Int32
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.#ctor(System.Int64)
  commentId: M:System.IntPtr.#ctor(System.Int64)
  id: '#ctor(System.Int64)'
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: IntPtr(Int64)
  fullName: System.IntPtr.IntPtr(System.Int64)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 54
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> using the specified 64-bit pointer.</p>\n"
  remarks: "\n<p>An exception is only thrown if the value of <em>value</em> requires more bits than the current platform supports.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public IntPtr(long value)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Sub New(value As Long)
    parameters:
    - id: value
      type: System.Int64
  exceptions:
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: "\n<p>On a 32-bit platform, <em>value</em> is too large or too small to represent as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.#ctor(System.Void*)
  commentId: M:System.IntPtr.#ctor(System.Void*)
  id: '#ctor(System.Void*)'
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: IntPtr(Void*)
  fullName: System.IntPtr.IntPtr(System.Void*)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 66
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> using the specified pointer to an unspecified type.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [CLSCompliant(false)]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public IntPtr(void *value)
    content.vb: >-
      <SecurityCritical>

      <CLSCompliant(False)>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Sub New(value As  *)
    parameters:
    - id: value
      type: System.Void*
  seealso:
  - type: System.Void
    commentId: T:System.Void
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.Size
  commentId: P:System.IntPtr.Size
  id: Size
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Size
  fullName: System.IntPtr.Size
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Size
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 271
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the size of this instance.</p>\n"
  syntax:
    content: >-
      public static int Size

      {
          [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
          [NonVersionable]
          get;
      }
    content.vb: Public Shared ReadOnly Property Size As Integer
    parameters: []
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.IntPtr.Add(System.IntPtr,System.Int32)
  commentId: M:System.IntPtr.Add(System.IntPtr,System.Int32)
  id: Add(System.IntPtr,System.Int32)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Add(IntPtr, Int32)
  fullName: System.IntPtr.Add(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Add
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 237
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Adds an offset to the value of a pointer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IntPtr.Add(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method does not throw an exception if the result is too large to represent as a pointer on the specified platform. Instead, the addition operation is performed in an unchecked context.</p>\n<p>Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</p>\n"
  example:
  - "\n<p>The following example instantiates an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the beginning of a ten-element array, and then calls the <xref href=\"System.IntPtr.Add(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to iterate the elements in the array.</p>System.IntPtr.Add#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static IntPtr Add(IntPtr pointer, int offset)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Function Add(pointer As IntPtr, offset As Integer) As IntPtr
    parameters:
    - id: pointer
      type: System.IntPtr
    - id: offset
      type: System.Int32
    return:
      type: System.IntPtr
  seealso:
  - type: System.IntPtr.op_Addition(System.IntPtr,System.Int32)
    commentId: M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.Equals(System.Object)
  commentId: M:System.IntPtr.Equals(System.Object)
  id: Equals(System.Object)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Equals(Object)
  fullName: System.IntPtr.Equals(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Equals
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 101
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns a value indicating whether this instance is equal to a specified object.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public override bool Equals(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      Public Overrides Function Equals(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
    return:
      type: System.Boolean
  overridden: System.ValueType.Equals(System.Object)
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.IntPtr.GetHashCode
  commentId: M:System.IntPtr.GetHashCode
  id: GetHashCode
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: GetHashCode()
  fullName: System.IntPtr.GetHashCode()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetHashCode
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 109
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Returns the hash code for this instance.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public override int GetHashCode()
    content.vb: >-
      <SecuritySafeCritical>

      Public Overrides Function GetHashCode As Integer
    return:
      type: System.Int32
  overridden: System.ValueType.GetHashCode
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.IntPtr.op_Addition(System.IntPtr,System.Int32)
  commentId: M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)
  id: op_Addition(System.IntPtr,System.Int32)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Addition(IntPtr, Int32)
  fullName: System.IntPtr.Addition(System.IntPtr, System.Int32)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Addition
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 244
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Adds an offset to the value of a pointer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IntPtr.op_Addition(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method defines the addition operation for <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> objects. It enables code such as the following.</p>System.IntPtr.op_Addition#1<p>Languages that do not support custom operators can call the <xref href=\"System.IntPtr.Add(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method instead.</p><p>The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform. Instead, it is performed in an unchecked context.</p>"
  example:
  - 
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static IntPtr operator +(IntPtr pointer, int offset)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Operator +(pointer As IntPtr, offset As Integer) As IntPtr
    parameters:
    - id: pointer
      type: System.IntPtr
    - id: offset
      type: System.Int32
    return:
      type: System.IntPtr
  seealso:
  - type: System.IntPtr.Add(System.IntPtr,System.Int32)
    commentId: M:System.IntPtr.Add(System.IntPtr,System.Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)
  commentId: M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)
  id: op_Equality(System.IntPtr,System.IntPtr)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Equality(IntPtr, IntPtr)
  fullName: System.IntPtr.Equality(System.IntPtr, System.IntPtr)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Equality
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 221
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether two specified instances of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> are equal.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [NonVersionable]

      public static bool operator ==(IntPtr value1, IntPtr value2)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <NonVersionable>

      Public Shared Operator =(value1 As IntPtr, value2 As IntPtr) As Boolean
    parameters:
    - id: value1
      type: System.IntPtr
    - id: value2
      type: System.IntPtr
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.op_Explicit(System.Int32)~System.IntPtr
  commentId: M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr
  id: op_Explicit(System.Int32)~System.IntPtr
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(Int32 to IntPtr)
  fullName: System.IntPtr.Explicit(System.Int32 to System.IntPtr)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 168
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of a 32-bit signed integer to an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static explicit operator IntPtr(int value)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Narrowing Operator CType(value As Integer) As IntPtr
    parameters:
    - id: value
      type: System.Int32
    return:
      type: System.IntPtr
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.Int32 to System.IntPtr)
  name.vb: Narrowing(Int32 to IntPtr)
- uid: System.IntPtr.op_Explicit(System.Int64)~System.IntPtr
  commentId: M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr
  id: op_Explicit(System.Int64)~System.IntPtr
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(Int64 to IntPtr)
  fullName: System.IntPtr.Explicit(System.Int64 to System.IntPtr)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 175
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of a 64-bit signed integer to an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static explicit operator IntPtr(long value)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Narrowing Operator CType(value As Long) As IntPtr
    parameters:
    - id: value
      type: System.Int64
    return:
      type: System.IntPtr
  exceptions:
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: "\n<p>On a 32-bit platform, <em>value</em> is too large to represent as an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.Int64 to System.IntPtr)
  name.vb: Narrowing(Int64 to IntPtr)
- uid: System.IntPtr.op_Explicit(System.IntPtr)~System.Int32
  commentId: M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32
  id: op_Explicit(System.IntPtr)~System.Int32
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(IntPtr to Int32)
  fullName: System.IntPtr.Explicit(System.IntPtr to System.Int32)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 198
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of the specified <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> to a 32-bit signed integer.</p>\n"
  remarks: "\n<p>An exception is only thrown if the value of <em>value</em> requires more bits than the current platform supports.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [NonVersionable]

      public static explicit operator int (IntPtr value)
    content.vb: >-
      <SecuritySafeCritical>

      <NonVersionable>

      Public Shared Narrowing Operator CType(value As IntPtr) As Integer
    parameters:
    - id: value
      type: System.IntPtr
    return:
      type: System.Int32
  exceptions:
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: "\n<p>On a 64-bit platform, the value of <em>value</em> is too large to represent as a 32-bit signed integer. </p>\n"
  seealso:
  - type: System.IntPtr.ToInt32
    commentId: M:System.IntPtr.ToInt32
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.IntPtr to System.Int32)
  name.vb: Narrowing(IntPtr to Int32)
- uid: System.IntPtr.op_Explicit(System.IntPtr)~System.Int64
  commentId: M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64
  id: op_Explicit(System.IntPtr)~System.Int64
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(IntPtr to Int64)
  fullName: System.IntPtr.Explicit(System.IntPtr to System.Int64)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 210
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of the specified <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> to a 64-bit signed integer.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [NonVersionable]

      public static explicit operator long (IntPtr value)
    content.vb: >-
      <SecuritySafeCritical>

      <NonVersionable>

      Public Shared Narrowing Operator CType(value As IntPtr) As Long
    parameters:
    - id: value
      type: System.IntPtr
    return:
      type: System.Int64
  seealso:
  - type: System.IntPtr.ToInt64
    commentId: M:System.IntPtr.ToInt64
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.IntPtr to System.Int64)
  name.vb: Narrowing(IntPtr to Int64)
- uid: System.IntPtr.op_Explicit(System.IntPtr)~System.Void*
  commentId: M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*
  id: op_Explicit(System.IntPtr)~System.Void*
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(IntPtr to Void*)
  fullName: System.IntPtr.Explicit(System.IntPtr to System.Void*)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 190
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of the specified <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> to a pointer to an unspecified type.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [CLSCompliant(false)]

      [NonVersionable]

      public static explicit operator void *(IntPtr value)
    content.vb: "<SecuritySafeCritical>\n<CLSCompliant(False)>\n<NonVersionable>\nPublic Shared Narrowing Operator CType(value As IntPtr) As "
    parameters:
    - id: value
      type: System.IntPtr
    return:
      type: System.Void*
  seealso:
  - type: System.IntPtr.ToPointer
    commentId: M:System.IntPtr.ToPointer
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.IntPtr to System.Void*)
  name.vb: Narrowing(IntPtr to Void*)
- uid: System.IntPtr.op_Explicit(System.Void*)~System.IntPtr
  commentId: M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr
  id: op_Explicit(System.Void*)~System.IntPtr
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Explicit(Void* to IntPtr)
  fullName: System.IntPtr.Explicit(System.Void* to System.IntPtr)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Explicit
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 182
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the specified pointer to an unspecified type to an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: >-
      [SecurityCritical]

      [CLSCompliant(false)]

      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static explicit operator IntPtr(void *value)
    content.vb: >-
      <SecurityCritical>

      <CLSCompliant(False)>

      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Narrowing Operator CType(value As  *) As IntPtr
    parameters:
    - id: value
      type: System.Void*
    return:
      type: System.IntPtr
  see:
  - type: System.Security.SecurityCriticalAttribute
    commentId: T:System.Security.SecurityCriticalAttribute
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.IntPtr.Narrowing(System.Void* to System.IntPtr)
  name.vb: Narrowing(Void* to IntPtr)
- uid: System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)
  commentId: M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)
  id: op_Inequality(System.IntPtr,System.IntPtr)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Inequality(IntPtr, IntPtr)
  fullName: System.IntPtr.Inequality(System.IntPtr, System.IntPtr)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Inequality
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 229
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Determines whether two specified instances of <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> are not equal.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [NonVersionable]

      public static bool operator !=(IntPtr value1, IntPtr value2)
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <NonVersionable>

      Public Shared Operator <>(value1 As IntPtr, value2 As IntPtr) As Boolean
    parameters:
    - id: value1
      type: System.IntPtr
    - id: value2
      type: System.IntPtr
    return:
      type: System.Boolean
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)
  commentId: M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)
  id: op_Subtraction(System.IntPtr,System.Int32)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Subtraction(IntPtr, Int32)
  fullName: System.IntPtr.Subtraction(System.IntPtr, System.Int32)
  type: Operator
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: op_Subtraction
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 261
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Subtracts an offset from the value of a pointer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method defines the subtraction operation for <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> objects. It enables code such as the following.</p>System.IntPtr.op_Addition#2<p>Languages that do not support custom operators can call the <xref href=\"System.IntPtr.Subtract(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method instead.</p><p>The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform. Instead, it is performed in an unchecked context.</p>"
  example:
  - 
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static IntPtr operator -(IntPtr pointer, int offset)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Operator -(pointer As IntPtr, offset As Integer) As IntPtr
    parameters:
    - id: pointer
      type: System.IntPtr
    - id: offset
      type: System.Int32
    return:
      type: System.IntPtr
  seealso:
  - type: System.IntPtr.Subtract(System.IntPtr,System.Int32)
    commentId: M:System.IntPtr.Subtract(System.IntPtr,System.Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.Subtract(System.IntPtr,System.Int32)
  commentId: M:System.IntPtr.Subtract(System.IntPtr,System.Int32)
  id: Subtract(System.IntPtr,System.Int32)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: Subtract(IntPtr, Int32)
  fullName: System.IntPtr.Subtract(System.IntPtr, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Subtract
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 255
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Subtracts an offset from the value of a pointer.</p>\n"
  remarks: "\n<p>The <xref href=\"System.IntPtr.Subtract(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method does not throw an exception if the result is too small to represent as a pointer on the specified platform. Instead, the subtraction operation is performed in an unchecked context.</p>\n<p>Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</p>\n"
  example:
  - "\n<p>The following example instantiates an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the end of a ten-element array, and then calls the <xref href=\"System.IntPtr.Subtract(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to iterate the elements in the array in reverse order. </p>System.IntPtr.Subtract#1"
  syntax:
    content: >-
      [ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)]

      [NonVersionable]

      public static IntPtr Subtract(IntPtr pointer, int offset)
    content.vb: >-
      <ReliabilityContract(Consistency.MayCorruptInstance, Cer.MayFail)>

      <NonVersionable>

      Public Shared Function Subtract(pointer As IntPtr, offset As Integer) As IntPtr
    parameters:
    - id: pointer
      type: System.IntPtr
    - id: offset
      type: System.Int32
    return:
      type: System.IntPtr
  seealso:
  - type: System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)
    commentId: M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.IntPtr.ToInt32
  commentId: M:System.IntPtr.ToInt32
  id: ToInt32
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: ToInt32()
  fullName: System.IntPtr.ToInt32()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToInt32
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 123
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of this instance to a 32-bit signed integer.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [NonVersionable]

      public int ToInt32()
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <NonVersionable>

      Public Function ToInt32 As Integer
    return:
      type: System.Int32
  exceptions:
  - type: System.OverflowException
    commentId: T:System.OverflowException
    description: "\n<p>On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.ToInt64
  commentId: M:System.IntPtr.ToInt64
  id: ToInt64
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: ToInt64()
  fullName: System.IntPtr.ToInt64()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToInt64
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 135
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of this instance to a 64-bit signed integer.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [NonVersionable]

      public long ToInt64()
    content.vb: >-
      <SecuritySafeCritical>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      <NonVersionable>

      Public Function ToInt64 As Long
    return:
      type: System.Int64
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.ToPointer
  commentId: M:System.IntPtr.ToPointer
  id: ToPointer
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: ToPointer()
  fullName: System.IntPtr.ToPointer()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToPointer
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 287
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the value of this instance to a pointer to an unspecified type.</p>\n"
  example:
  - "\n<p>The following example uses managed pointers to reverse the characters in an array. After it initializes a <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> object and gets its length, it does the following: </p>\n<ul><li>\n<p>Calls the <xref href=\"System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters. The method returns an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the beginning of the unmanaged string. </p>\n</li><li>\n<p>Calls the <xref href=\"System.Runtime.InteropServices.Marshal.AllocHGlobal(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to allocate the same number of bytes as the unmanaged string occupies. The method returns an <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object that points to the beginning of the unmanaged block of memory. </p>\n</li><li>\n<p>Calls the <xref href=\"System.IntPtr.ToPointer\" data-throw-if-not-resolved=\"false\"></xref> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string. Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block. </p>\n</li><li>\n<p>Uses a loop to copy each character from the string to the unmanaged block of memory. After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</p>\n</li><li>\n<p>Calls the <xref href=\"System.Runtime.InteropServices.Marshal.PtrToStringAnsi(System.IntPtr,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref href=\"System.String\" data-throw-if-not-resolved=\"false\"></xref> object. </p>\n</li><li>\n<p>After displaying the original and reversed strings, calls the <xref href=\"System.Runtime.InteropServices.Marshal.FreeHGlobal(System.IntPtr)\" data-throw-if-not-resolved=\"false\"></xref> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory. </p>\n</li></ul>System.IntPtr.ToPointer#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [CLSCompliant(false)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      [NonVersionable]

      public void *ToPointer()
    content.vb: "<SecuritySafeCritical>\n<CLSCompliant(False)>\n<ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>\n<NonVersionable>\nPublic Function ToPointer As "
    return:
      type: System.Void*
  attributes:
  - type: System.CLSCompliantAttribute
    ctor: System.CLSCompliantAttribute.#ctor(System.Boolean)
    arguments:
    - type: System.Boolean
      value: false
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.IntPtr.ToString
  commentId: M:System.IntPtr.ToString
  id: ToString
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: ToString()
  fullName: System.IntPtr.ToString()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToString
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 146
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the numeric value of the current <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object to its equivalent string representation.</p>\n"
  remarks: "\n<p>If the value of the <xref href=\"System.IntPtr.Size\" data-throw-if-not-resolved=\"false\"></xref> property for this instance is 4, then this method is equivalent to <xref href=\"System.Int32.ToString\" data-throw-if-not-resolved=\"false\"></xref>; otherwise, this method is equivalent to <xref href=\"System.Int64.ToString\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public override string ToString()
    content.vb: >-
      <SecuritySafeCritical>

      Public Overrides Function ToString As String
    return:
      type: System.String
  overridden: System.ValueType.ToString
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.IntPtr.ToString(System.String)
  commentId: M:System.IntPtr.ToString(System.String)
  id: ToString(System.String)
  parent: System.IntPtr
  langs:
  - csharp
  - vb
  name: ToString(String)
  fullName: System.IntPtr.ToString(System.String)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/IntPtr.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToString
    path: src/mscorlib/src/System/IntPtr.cs
    startLine: 155
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Converts the numeric value of the current <xref href=\"System.IntPtr\" data-throw-if-not-resolved=\"false\"></xref> object to its equivalent string representation.</p>\n"
  remarks: "\n<p>If the <em>format</em> parameter is <strong>null</strong> or an empty string (\"\"), the return value is formatted with the general format specifier (\"G\"). For more information about numeric format specifiers, see the Standard Numeric Format Strings topic. </p>\n<p>The return value is formatted using the invariant culture. </p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public string ToString(string format)
    content.vb: >-
      <SecuritySafeCritical>

      Public Function ToString(format As String) As String
    parameters:
    - id: format
      type: System.String
    return:
      type: System.String
  seealso:
  - type: System.Globalization.CultureInfo.InvariantCulture
    commentId: P:System.Globalization.CultureInfo.InvariantCulture
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.IntPtr
  parent: System
  isExternal: false
  name: IntPtr
  fullName: System.IntPtr
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Void*
  isExternal: true
  name: Void*
  fullName: System.Void*
  spec.csharp:
  - uid: System.Void
    name: Void
    fullName: System.Void
    isExternal: true
  - name: '*'
    fullName: '*'
  spec.vb:
  - uid: System.Void
    name: Void
    fullName: System.Void
    isExternal: true
  - name: '*'
    fullName: '*'
- uid: System.ValueType.Equals(System.Object)
  parent: System.ValueType
  isExternal: true
  name: Equals(Object)
  fullName: System.ValueType.Equals(System.Object)
  spec.csharp:
  - uid: System.ValueType.Equals(System.Object)
    name: Equals
    fullName: System.ValueType.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.Equals(System.Object)
    name: Equals
    fullName: System.ValueType.Equals
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.ValueType
  parent: System
  isExternal: false
  name: ValueType
  fullName: System.ValueType
- uid: System.ValueType.GetHashCode
  parent: System.ValueType
  isExternal: false
  name: GetHashCode()
  fullName: System.ValueType.GetHashCode()
  spec.csharp:
  - uid: System.ValueType.GetHashCode
    name: GetHashCode
    fullName: System.ValueType.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.GetHashCode
    name: GetHashCode
    fullName: System.ValueType.GetHashCode
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.ValueType.ToString
  parent: System.ValueType
  isExternal: false
  name: ToString()
  fullName: System.ValueType.ToString()
  spec.csharp:
  - uid: System.ValueType.ToString
    name: ToString
    fullName: System.ValueType.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.ValueType.ToString
    name: ToString
    fullName: System.ValueType.ToString
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.OverflowException
  isExternal: false
  name: OverflowException
  fullName: System.OverflowException
