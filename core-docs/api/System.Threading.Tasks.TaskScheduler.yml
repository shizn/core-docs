items:
- uid: System.Threading.Tasks.TaskScheduler
  commentId: T:System.Threading.Tasks.TaskScheduler
  id: TaskScheduler
  parent: System.Threading.Tasks
  children:
  - System.Threading.Tasks.TaskScheduler.#ctor
  - System.Threading.Tasks.TaskScheduler.Current
  - System.Threading.Tasks.TaskScheduler.Default
  - System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  - System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  - System.Threading.Tasks.TaskScheduler.Id
  - System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  - System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  - System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  langs:
  - csharp
  - vb
  name: TaskScheduler
  fullName: System.Threading.Tasks.TaskScheduler
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TaskScheduler
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 41
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Represents an object that handles the low-level work of queuing tasks onto threads.</p>\n"
  remarks: "\n<p>An instance of the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed. </p>\n<p> The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios. </p>\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</p>\n<p>In this topic:The default task scheduler and the thread pool            The global queue vs. local queues      Work stealing      Long-running tasks      Task inliningSpecifying a synchronization context</p>\n"
  example:
  - '<p>The following example is taken from the <see href="http://go.microsoft.com/fwlink/?LinkID=165717">Samples for Parallel Programming with the .NET Framework 4</see> on the MSDN Code Gallery Web site.  It creates a custom task scheduler that limits the number of threads used by the app. It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</p>TPL_Schedulers#02<p>In addition, several sample task schedulers are available on Code Gallery: <see href="http://go.microsoft.com/fwlink/?LinkID=165717">Samples for Parallel Programming with the .NET Framework 4</see>.</p>'
  syntax:
    content: >-
      [DebuggerDisplay("Id={Id}")]

      [DebuggerTypeProxy(typeof (TaskScheduler.SystemThreadingTasks_TaskSchedulerDebugView))]

      [HostProtection(Synchronization = true, ExternalThreading = true)]

      [PermissionSet(SecurityAction.InheritanceDemand, Unrestricted = true)]

      public abstract class TaskScheduler
    content.vb: >-
      <DebuggerDisplay("Id={Id}")>

      <DebuggerTypeProxy(GetType(TaskScheduler.SystemThreadingTasks_TaskSchedulerDebugView))>

      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      <PermissionSet(SecurityAction.InheritanceDemand, Unrestricted:=True)>

      Public MustInherit Class TaskScheduler
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Threading.Tasks.TaskScheduler.#ctor
  commentId: M:System.Threading.Tasks.TaskScheduler.#ctor
  id: '#ctor'
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TaskScheduler()
  fullName: System.Threading.Tasks.TaskScheduler.TaskScheduler()
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 302
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: protected TaskScheduler()
    content.vb: Protected Sub New
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Threading.Tasks.TaskScheduler.Current
  commentId: P:System.Threading.Tasks.TaskScheduler.Current
  id: Current
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Current
  fullName: System.Threading.Tasks.TaskScheduler.Current
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Current
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 344
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the currently executing task.</p>\n"
  remarks: "\n<p>When not called from within a task, <xref href=\"System.Threading.Tasks.TaskScheduler.Current\" data-throw-if-not-resolved=\"false\"></xref> will return the <xref href=\"System.Threading.Tasks.TaskScheduler.Default\" data-throw-if-not-resolved=\"false\"></xref> scheduler.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler Current { get; }
    content.vb: Public Shared ReadOnly Property Current As TaskScheduler
    parameters: []
    return:
      type: System.Threading.Tasks.TaskScheduler
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.Default
  commentId: P:System.Threading.Tasks.TaskScheduler.Default
  id: Default
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Default
  fullName: System.Threading.Tasks.TaskScheduler.Default
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Default
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 329
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the default <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> instance that is provided by the .NET Framework.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler Default { get; }
    content.vb: Public Shared ReadOnly Property Default As TaskScheduler
    parameters: []
    return:
      type: System.Threading.Tasks.TaskScheduler
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.Id
  commentId: P:System.Threading.Tasks.TaskScheduler.Id
  id: Id
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Id
  fullName: System.Threading.Tasks.TaskScheduler.Id
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Id
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 397
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public int Id { get; }
    content.vb: Public ReadOnly Property Id As Integer
    parameters: []
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  commentId: P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  id: MaximumConcurrencyLevel
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: MaximumConcurrencyLevel
  fullName: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: MaximumConcurrencyLevel
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 166
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Indicates the maximum concurrency level this <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> is able to support.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public virtual int MaximumConcurrencyLevel { get; }
    content.vb: Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer
    parameters: []
    return:
      type: System.Int32
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  commentId: E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  id: UnobservedTaskException
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: UnobservedTaskException
  fullName: System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  type: Event
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: UnobservedTaskException
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 475
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</p>\n"
  remarks: "\n<p>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering. </p>\n<p>To make it easier for developers to write asynchronous code based on tasks, the .NET Framework 4.5 changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the <xref href=\"System.Threading.Tasks.TaskScheduler.UnobservedTaskException\" data-throw-if-not-resolved=\"false\"></xref> exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the .NET Framework 4.5, you can use the  configuration element to revert to the behavior of the .NET Framework 4 and terminate the process:</p>\n<pre><code class=\"xml\"><configuration> \n<runtime> \n<ThrowUnobservedTaskExceptions enabled=\"true\"/> \n</runtime> \n</configuration></code></pre>\n"
  example:
  - 
  syntax:
    content: public static event EventHandler<UnobservedTaskExceptionEventArgs> UnobservedTaskException
    content.vb: Public Shared Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs)
    return:
      type: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  commentId: M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  id: FromCurrentSynchronizationContext
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: FromCurrentSynchronizationContext()
  fullName: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: FromCurrentSynchronizationContext
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 389
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>All <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances queued to the returned scheduler will be executed through a call to the <xref href=\"System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method on that context.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler FromCurrentSynchronizationContext()
    content.vb: Public Shared Function FromCurrentSynchronizationContext As TaskScheduler
    return:
      type: System.Threading.Tasks.TaskScheduler
      description: "\nA <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with \nthe current <xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref>, as\ndetermined by <xref href=\"System.Threading.SynchronizationContext.Current\" data-throw-if-not-resolved=\"false\"></xref>.\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current SynchronizationContext may not be used as a TaskScheduler.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  commentId: M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  id: GetScheduledTasks
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: GetScheduledTasks()
  fullName: System.Threading.Tasks.TaskScheduler.GetScheduledTasks()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: GetScheduledTasks
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 159
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>For debugger support only, generates an enumerable of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances currently queued to the scheduler waiting to be executed.</p>\n"
  remarks: "\n<p>A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</p>\n<p>It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:</p>\n<pre><code>protected override IEnumerable<Task> GetScheduledTasks()\n{\nbool lockTaken = false;\ntry\n{\nMonitor.TryEnter(_syncObj, ref lockTaken);\nif (lockTaken)\n{\n    return _tasks.ToArray();\n}\nelse throw new NotSupportedException();\n}\nfinally\n{\nif (lockTaken) Monitor.Exit(_syncObj);\n}}</code></pre>\n<p>Additionally, this method and the enumerable returned must not modify any globally visible state.</p>\n<p>The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.</p>\n<p>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <strong>GetScheduledTasksForDebugger</strong> instead: <code>internal Task[] GetScheduledTasksForDebugger()</code>. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method <code>internal static TaskScheduler[] GetTaskSchedulersForDebugger()</code>. This static method returns an array of all active <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> instances. You can then use <code>GetScheduledTasksForDebugger</code> on each scheduler instance to retrieve its list of scheduled tasks.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecurityCritical]

      protected abstract IEnumerable<Task> GetScheduledTasks()
    content.vb: >-
      <SecurityCritical>

      Protected MustOverride Function GetScheduledTasks As IEnumerable(Of Task)
    return:
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
      description: >
        An enumerable that allows traversal of tasks currently queued to this scheduler.
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This scheduler is unable to generate a list of queued tasks at this time.</p>\n"
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
- uid: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  id: QueueTask(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: QueueTask(Task)
  fullName: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: QueueTask
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 72
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to the scheduler. </p>\n"
  remarks: "\n<p> A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this method to accept tasks being scheduled on the scheduler.</p>\n<p> A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</p>\n<p>  This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecurityCritical]

      protected abstract void QueueTask(Task task)
    content.vb: >-
      <SecurityCritical>

      Protected MustOverride Sub QueueTask(task As Task)
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: The <xref href="System.Threading.Tasks.Task" data-throw-if-not-resolved="false"></xref> to be queued.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
- uid: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  id: TryDequeue(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryDequeue(Task)
  fullName: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryDequeue
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 239
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Attempts to dequeue a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> that was previously queued to this scheduler.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n<p>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> objects can be disposed of in a timely manner.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecurityCritical]

      protected virtual bool TryDequeue(Task task)
    content.vb: >-
      <SecurityCritical>

      Protected Overridable Function TryDequeue(task As Task) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: The <xref href="System.Threading.Tasks.Task" data-throw-if-not-resolved="false"></xref> to be dequeued.
    return:
      type: System.Boolean
      description: A Boolean denoting whether the <em>task</em> argument was successfully dequeued.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  id: TryExecuteTask(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryExecuteTask(Task)
  fullName: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryExecuteTask
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 446
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Attempts to execute the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> on this scheduler.</p>\n"
  remarks: "\n<p> Scheduler implementations are provided with <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances to be executed through either the <xref href=\"System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method. When the scheduler deems it appropriate to run the provided task, <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</p>\n<p>\n<xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecurityCritical]

      protected bool TryExecuteTask(Task task)
    content.vb: >-
      <SecurityCritical>

      Protected Function TryExecuteTask(task As Task) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: "\nA <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object to be executed."
    return:
      type: System.Boolean
      description: >-
        A Boolean that is true if <em>task</em> was successfully executed, false if it

        was not. A common reason for execution failure is that the task had previously been executed or

        is in the process of being executed by another thread.
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>task</em> is not associated with this scheduler.</p>\n"
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  id: TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryExecuteTaskInline(Task, Boolean)
  fullName: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryExecuteTaskInline
    path: src/mscorlib/src/System/Threading/Tasks/TaskScheduler.cs
    startLine: 115
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Determines whether the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> can be executed synchronously in this call, and if it can, executes it.</p>\n"
  remarks: "\n<p>A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</p>\n<p>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref href=\"System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [SecurityCritical]

      protected abstract bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
    content.vb: >-
      <SecurityCritical>

      Protected MustOverride Function TryExecuteTaskInline(task As Task, taskWasPreviouslyQueued As Boolean) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: >-
        The <xref href="System.Threading.Tasks.Task" data-throw-if-not-resolved="false"></xref> to be

        executed.
    - id: taskWasPreviouslyQueued
      type: System.Boolean
      description: >-
        A Boolean denoting whether or not task has previously been

        queued. If this parameter is True, then the task may have been previously queued (scheduled); if

        False, then the task is known not to have been queued, and this call is being made in order to

        execute the task inline without queueing it.
    return:
      type: System.Boolean
      description: A Boolean value indicating whether the task was executed inline.
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>task</em> was already executed.</p>\n"
  attributes:
  - type: System.Security.SecurityCriticalAttribute
    ctor: System.Security.SecurityCriticalAttribute.#ctor
    arguments: []
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
references:
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Threading.Tasks.TaskScheduler
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskScheduler
  fullName: System.Threading.Tasks.TaskScheduler
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}
  parent: System
  definition: System.EventHandler`1
  name: EventHandler<UnobservedTaskExceptionEventArgs>
  fullName: System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs>
  fullname.vb: System.EventHandler(Of System.Threading.Tasks.UnobservedTaskExceptionEventArgs)
  name.vb: EventHandler(Of UnobservedTaskExceptionEventArgs)
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
    name: UnobservedTaskExceptionEventArgs
    fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
    name: UnobservedTaskExceptionEventArgs
    fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
  - name: )
    fullName: )
- uid: System.EventHandler`1
  parent: System
  isExternal: false
  name: EventHandler<TEventArgs>
  fullName: System.EventHandler<TEventArgs>
  fullname.vb: System.EventHandler(Of TEventArgs)
  name.vb: EventHandler(Of TEventArgs)
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
  - name: <
    fullName: <
  - name: TEventArgs
    fullName: TEventArgs
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
  - name: '(Of '
    fullName: '(Of '
  - name: TEventArgs
    fullName: TEventArgs
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
  parent: System.Collections.Generic
  definition: System.Collections.Generic.IEnumerable`1
  name: IEnumerable<Task>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task)
  name.vb: IEnumerable(Of Task)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: IEnumerable<T>
  fullName: System.Collections.Generic.IEnumerable<T>
  fullname.vb: System.Collections.Generic.IEnumerable(Of T)
  name.vb: IEnumerable(Of T)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Task
  fullName: System.Threading.Tasks.Task
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
