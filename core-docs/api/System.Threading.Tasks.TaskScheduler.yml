items:
- uid: System.Threading.Tasks.TaskScheduler
  commentId: T:System.Threading.Tasks.TaskScheduler
  id: TaskScheduler
  parent: System.Threading.Tasks
  children:
  - System.Threading.Tasks.TaskScheduler.#ctor
  - System.Threading.Tasks.TaskScheduler.Current
  - System.Threading.Tasks.TaskScheduler.Default
  - System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  - System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  - System.Threading.Tasks.TaskScheduler.Id
  - System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  - System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  - System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  - System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  langs:
  - csharp
  - vb
  name: TaskScheduler
  fullName: System.Threading.Tasks.TaskScheduler
  type: Class
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TaskScheduler
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 524
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Represents an object that handles the low-level work of queuing tasks onto threads.</p>\n"
  remarks: "\n<p>An instance of the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed. </p>\n<p> The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios. </p>\n<p>The <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</p>\n<p>In this topic:The default task scheduler and the thread pool            The global queue vs. local queues      Work stealing      Long-running tasks      Task inliningSpecifying a synchronization context</p>\n"
  example:
  - '<p>The following example is taken from the <see href="http://go.microsoft.com/fwlink/?LinkID=165717">Samples for Parallel Programming with the .NET Framework 4</see> on the MSDN Code Gallery Web site.  It creates a custom task scheduler that limits the number of threads used by the app. It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</p>TPL_Schedulers#02<p>In addition, several sample task schedulers are available on Code Gallery: <see href="http://go.microsoft.com/fwlink/?LinkID=165717">Samples for Parallel Programming with the .NET Framework 4</see>.</p>'
  syntax:
    content: 'public abstract class TaskScheduler : object'
    content.vb: >-
      Public MustInherit Class TaskScheduler
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - abstract
  - class
  modifiers.vb:
  - Public
  - MustInherit
  - Class
- uid: System.Threading.Tasks.TaskScheduler.#ctor
  commentId: M:System.Threading.Tasks.TaskScheduler.#ctor
  id: '#ctor'
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TaskScheduler()
  fullName: System.Threading.Tasks.TaskScheduler.TaskScheduler()
  type: Constructor
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 526
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Initializes the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - 
  syntax:
    content: protected TaskScheduler()
    content.vb: Protected Sub New
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Threading.Tasks.TaskScheduler.Current
  commentId: P:System.Threading.Tasks.TaskScheduler.Current
  id: Current
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Current
  fullName: System.Threading.Tasks.TaskScheduler.Current
  type: Property
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Current
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 527
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the currently executing task.</p>\n"
  remarks: "\n<p>When not called from within a task, <xref href=\"System.Threading.Tasks.TaskScheduler.Current\" data-throw-if-not-resolved=\"false\"></xref> will return the <xref href=\"System.Threading.Tasks.TaskScheduler.Default\" data-throw-if-not-resolved=\"false\"></xref> scheduler.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler Current { get; }
    content.vb: Public Shared ReadOnly Property Current As TaskScheduler
    parameters: []
    return:
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>Returns the <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the currently executing task.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.Default
  commentId: P:System.Threading.Tasks.TaskScheduler.Default
  id: Default
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Default
  fullName: System.Threading.Tasks.TaskScheduler.Default
  type: Property
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Default
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 528
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the default <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> instance that is provided by the .NET Framework.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler Default { get; }
    content.vb: Public Shared ReadOnly Property Default As TaskScheduler
    parameters: []
    return:
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>Returns the default <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.Id
  commentId: P:System.Threading.Tasks.TaskScheduler.Id
  id: Id
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: Id
  fullName: System.Threading.Tasks.TaskScheduler.Id
  type: Property
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Id
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 529
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Gets the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public int Id { get; }
    content.vb: Public ReadOnly Property Id As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>Returns the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  commentId: P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  id: MaximumConcurrencyLevel
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: MaximumConcurrencyLevel
  fullName: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel
  type: Property
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: MaximumConcurrencyLevel
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 530
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Indicates the maximum concurrency level this <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> is able to support.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public virtual int MaximumConcurrencyLevel { get; }
    content.vb: Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>Returns an integer that represents the maximum concurrency level. The default scheduler returns <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  commentId: E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  id: UnobservedTaskException
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: UnobservedTaskException
  fullName: System.Threading.Tasks.TaskScheduler.UnobservedTaskException
  type: Event
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: UnobservedTaskException
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 531
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</p>\n"
  remarks: "\n<p>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering. </p>\n<p>To make it easier for developers to write asynchronous code based on tasks, the .NET Framework 4.5 changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the <xref href=\"System.Threading.Tasks.TaskScheduler.UnobservedTaskException\" data-throw-if-not-resolved=\"false\"></xref> exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the .NET Framework 4.5, you can use the  configuration element to revert to the behavior of the .NET Framework 4 and terminate the process:</p>\n<pre><code class=\"xml\"><configuration> \n<runtime> \n<ThrowUnobservedTaskExceptions enabled=\"true\"/> \n</runtime> \n</configuration></code></pre>\n"
  example:
  - 
  syntax:
    content: public static event EventHandler<UnobservedTaskExceptionEventArgs> UnobservedTaskException
    content.vb: Public Shared Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs)
    return:
      type: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  commentId: M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext
  id: FromCurrentSynchronizationContext
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: FromCurrentSynchronizationContext()
  fullName: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext()
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: FromCurrentSynchronizationContext
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 532
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Creates a <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>All <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances queued to the returned scheduler will be executed through a call to the <xref href=\"System.Threading.SynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method on that context.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: public static TaskScheduler FromCurrentSynchronizationContext()
    content.vb: Public Shared Function FromCurrentSynchronizationContext As TaskScheduler
    return:
      type: System.Threading.Tasks.TaskScheduler
      description: "\n<p>A <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\" data-throw-if-not-resolved=\"false\"></xref>, as determined by <xref href=\"System.Threading.SynchronizationContext.Current\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The current SynchronizationContext may not be used as a TaskScheduler.</p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  commentId: M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks
  id: GetScheduledTasks
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: GetScheduledTasks()
  fullName: System.Threading.Tasks.TaskScheduler.GetScheduledTasks()
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: GetScheduledTasks
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 533
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>For debugger support only, generates an enumerable of <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances currently queued to the scheduler waiting to be executed.</p>\n"
  remarks: "\n<p>A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</p>\n<p>It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:</p>\n<pre><code>protected override IEnumerable<Task> GetScheduledTasks()\n{\nbool lockTaken = false;\ntry\n{\nMonitor.TryEnter(_syncObj, ref lockTaken);\nif (lockTaken)\n{\n    return _tasks.ToArray();\n}\nelse throw new NotSupportedException();\n}\nfinally\n{\nif (lockTaken) Monitor.Exit(_syncObj);\n}}</code></pre>\n<p>Additionally, this method and the enumerable returned must not modify any globally visible state.</p>\n<p>The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.</p>\n<p>Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <strong>GetScheduledTasksForDebugger</strong> instead: <code>internal Task[] GetScheduledTasksForDebugger()</code>. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method <code>internal static TaskScheduler[] GetTaskSchedulersForDebugger()</code>. This static method returns an array of all active <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> instances. You can then use <code>GetScheduledTasksForDebugger</code> on each scheduler instance to retrieve its list of scheduled tasks.</p>\n"
  example:
  - 
  syntax:
    content: protected abstract Collections.Generic.IEnumerable<Task> GetScheduledTasks()
    content.vb: Protected MustOverride Function GetScheduledTasks As Collections.Generic.IEnumerable(Of Task)
    return:
      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
      description: "\n<p>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>This scheduler is unable to generate a list of queued tasks at this time.</p>\n"
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
- uid: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  id: QueueTask(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: QueueTask(Task)
  fullName: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: QueueTask
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 535
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Queues a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to the scheduler. </p>\n"
  remarks: "\n<p> A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this method to accept tasks being scheduled on the scheduler.</p>\n<p> A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</p>\n<p>  This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: protected abstract void QueueTask(Task task)
    content.vb: Protected MustOverride Sub QueueTask(task As Task)
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to be queued.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
- uid: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  id: TryDequeue(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryDequeue(Task)
  fullName: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryDequeue
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 537
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Attempts to dequeue a <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> that was previously queued to this scheduler.</p>\n"
  remarks: "\n<p>For more information, see Task Schedulers.</p>\n<p>This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref href=\"System.Threading.CancellationTokenRegistration\" data-throw-if-not-resolved=\"false\"></xref> objects can be disposed of in a timely manner.</p>\n"
  example:
  - 
  syntax:
    content: protected virtual bool TryDequeue(Task task)
    content.vb: Protected Overridable Function TryDequeue(task As Task) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to be dequeued.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>A Boolean denoting whether the <em>task</em> argument was successfully dequeued.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  modifiers.csharp:
  - protected
  - virtual
  modifiers.vb:
  - Protected
  - Overridable
- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  id: TryExecuteTask(System.Threading.Tasks.Task)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryExecuteTask(Task)
  fullName: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryExecuteTask
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 539
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Attempts to execute the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> on this scheduler.</p>\n"
  remarks: "\n<p> Scheduler implementations are provided with <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> instances to be executed through either the <xref href=\"System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method or the <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> method. When the scheduler deems it appropriate to run the provided task, <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</p>\n<p>\n<xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.</p>\n<p></p>\n"
  example:
  - 
  syntax:
    content: protected bool TryExecuteTask(Task task)
    content.vb: Protected Function TryExecuteTask(task As Task) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: "\n<p>A <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> object to be executed.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>A Boolean that is true if <em>task</em> was successfully executed, false if it was not. A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>task</em> is not associated with this scheduler.</p>\n"
  modifiers.csharp:
  - protected
  modifiers.vb:
  - Protected
- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  id: TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)
  parent: System.Threading.Tasks.TaskScheduler
  langs:
  - csharp
  - vb
  name: TryExecuteTaskInline(Task, Boolean)
  fullName: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task, System.Boolean)
  type: Method
  source:
    remote:
      path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryExecuteTaskInline
    path: src/System.Threading.Tasks/ref/System.Threading.Tasks.cs
    startLine: 541
  assemblies:
  - System.Threading.Tasks
  namespace: System.Threading.Tasks
  summary: "\n<p>Determines whether the provided <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> can be executed synchronously in this call, and if it can, executes it.</p>\n"
  remarks: "\n<p>A class derived from <xref href=\"System.Threading.Tasks.TaskScheduler\" data-throw-if-not-resolved=\"false\"></xref> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</p>\n<p>If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref href=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref href=\"System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</p>\n<p>For more information, see Task Schedulers.</p>\n"
  example:
  - 
  syntax:
    content: protected abstract bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued)
    content.vb: Protected MustOverride Function TryExecuteTaskInline(task As Task, taskWasPreviouslyQueued As Boolean) As Boolean
    parameters:
    - id: task
      type: System.Threading.Tasks.Task
      description: "\n<p>The <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref> to be executed.</p>\n"
    - id: taskWasPreviouslyQueued
      type: System.Boolean
      description: "\n<p>A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>A Boolean value indicating whether the task was executed inline.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>task</em> argument is null.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The <em>task</em> was already executed.</p>\n"
  modifiers.csharp:
  - protected
  - abstract
  modifiers.vb:
  - Protected
  - MustOverride
references:
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Threading.Tasks.TaskScheduler
  parent: System.Threading.Tasks
  isExternal: false
  name: TaskScheduler
  fullName: System.Threading.Tasks.TaskScheduler
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}
  definition: System.EventHandler`1
  name: EventHandler<UnobservedTaskExceptionEventArgs>
  fullName: System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs>
  fullname.vb: System.EventHandler(Of System.Threading.Tasks.UnobservedTaskExceptionEventArgs)
  name.vb: EventHandler(Of UnobservedTaskExceptionEventArgs)
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
    name: UnobservedTaskExceptionEventArgs
    fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
    name: UnobservedTaskExceptionEventArgs
    fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs
  - name: )
    fullName: )
- uid: System.EventHandler`1
  isExternal: false
  name: EventHandler<>
  fullName: System.EventHandler<>
  fullname.vb: System.EventHandler(Of )
  name.vb: EventHandler(Of )
  spec.csharp:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
  - name: <
    fullName: <
  - {}
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.EventHandler`1
    name: EventHandler
    fullName: System.EventHandler
  - name: '(Of '
    fullName: '(Of '
  - {}
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}
  definition: System.Collections.Generic.IEnumerable`1
  name: Collections.Generic.IEnumerable<Task>
  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>
  fullname.vb: System.Collections.Generic.IEnumerable(Of System.Threading.Tasks.Task)
  name.vb: Collections.Generic.IEnumerable(Of Task)
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: Collections.Generic.IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: <
    fullName: <
  - uid: System.Threading.Tasks.Task
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: Collections.Generic.IEnumerable
    fullName: System.Collections.Generic.IEnumerable
    isExternal: true
  - name: '(Of '
    fullName: '(Of '
  - uid: System.Threading.Tasks.Task
    name: Task
    fullName: System.Threading.Tasks.Task
  - name: )
    fullName: )
- uid: System.Collections.Generic.IEnumerable`1
  parent: System.Collections.Generic
  isExternal: false
  name: Collections.Generic.IEnumerable<>
  fullName: System.Collections.Generic.IEnumerable<>
  fullname.vb: System.Collections.Generic.IEnumerable(Of )
  name.vb: Collections.Generic.IEnumerable(Of )
  spec.csharp:
  - uid: System.Collections.Generic.IEnumerable`1
    name: Collections.Generic.IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: <
    fullName: <
  - {}
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Collections.Generic.IEnumerable`1
    name: Collections.Generic.IEnumerable
    fullName: System.Collections.Generic.IEnumerable
  - name: '(Of '
    fullName: '(Of '
  - {}
  - name: )
    fullName: )
- uid: System.Collections.Generic
  isExternal: false
  name: System.Collections.Generic
  fullName: System.Collections.Generic
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Threading.Tasks.Task
  fullName: System.Threading.Tasks.Task
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
