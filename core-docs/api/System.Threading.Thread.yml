items:
- uid: System.Threading.Thread
  commentId: T:System.Threading.Thread
  id: Thread
  parent: System.Threading
  children:
  - System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  - System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  - System.Threading.Thread.CurrentThread
  - System.Threading.Thread.IsAlive
  - System.Threading.Thread.IsBackground
  - System.Threading.Thread.Join
  - System.Threading.Thread.Join(System.Int32)
  - System.Threading.Thread.ManagedThreadId
  - System.Threading.Thread.Name
  - System.Threading.Thread.Sleep(System.Int32)
  - System.Threading.Thread.Sleep(System.TimeSpan)
  - System.Threading.Thread.Start
  - System.Threading.Thread.Start(System.Object)
  - System.Threading.Thread.ThreadState
  langs:
  - csharp
  - vb
  name: Thread
  fullName: System.Threading.Thread
  type: Class
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Thread
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 11
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Creates and controls a thread, sets its priority, and gets its status.</p>\n"
  remarks: "\n<p>When a process starts, the common language runtime automatically creates a single foreground thread to execute application code. Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process. These threads can execute either in the foreground or in the background. In addition, you can use the <xref href=\"System.Threading.ThreadPool\" data-throw-if-not-resolved=\"false\"></xref> class to execute code on worker threads that are managed by the common language runtime. </p>\n<p>In this section</p>\n<p>Starting a threadRetrieving Thread objectsForeground and background threadsCulture and threadsGetting information about and controlling threadsAccessing the source code for the Thread class</p>\n"
  example:
  - >-
    <p>The following example demonstrates simple threading functionality.</p>Classic Thread Example#1<p>This code produces output similar to the following: </p><pre><code> [VB, C++, C#]
     Main thread: Start a second thread.
     Main thread: Do some work.
     ThreadProc: 0
     Main thread: Do some work.
     ThreadProc: 1
     Main thread: Do some work.
     ThreadProc: 2
     Main thread: Do some work.
     ThreadProc: 3
     Main thread: Call Join(), to wait until ThreadProc ends.
     ThreadProc: 4
     ThreadProc: 5
     ThreadProc: 6
     ThreadProc: 7
     ThreadProc: 8
     ThreadProc: 9
     Main thread: ThreadProc.Join has returned.  Press Enter to end program.</code></pre>
  syntax:
    content: 'public sealed class Thread : object'
    content.vb: >-
      Public NotInheritable Class Thread
          Inherits Object
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - sealed
  - class
  modifiers.vb:
  - Public
  - NotInheritable
  - Class
- uid: System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  commentId: M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)
  id: '#ctor(System.Threading.ParameterizedThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Thread(ParameterizedThreadStart)
  fullName: System.Threading.Thread.Thread(System.Threading.ParameterizedThreadStart)
  type: Constructor
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 14
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</p>\n"
  remarks: "\n<p>A thread does not begin executing when it is created. To schedule the thread for execution, call the <xref href=\"System.Threading.Thread.Start\" data-throw-if-not-resolved=\"false\"></xref> method. To pass a data object to the thread, use the <xref href=\"System.Threading.Thread.Start(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method overload.</p>\n<p>Visual Basic users can omit the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> constructor when creating a thread. Use the <strong>AddressOf</strong> operator when passing your method, for example <code>Dim t As New Thread(AddressOf ThreadProc)</code>. Visual Basic automatically calls the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> constructor.</p>\n"
  example:
  - "\n<p>The following example shows the syntax for creating and using a <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate with a static method and an instance method.</p>System.Threading.ParameterizedThreadStart#1"
  syntax:
    content: public Thread(ParameterizedThreadStart start)
    content.vb: Public Sub New(start As ParameterizedThreadStart)
    parameters:
    - id: start
      type: System.Threading.ParameterizedThreadStart
      description: "\n<p>A delegate that represents the methods to be invoked when this thread begins executing. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>start</em> is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Threading.ParameterizedThreadStart
    commentId: T:System.Threading.ParameterizedThreadStart
  - type: System.AppDomain
    commentId: T:System.AppDomain
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  commentId: M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)
  id: '#ctor(System.Threading.ThreadStart)'
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Thread(ThreadStart)
  fullName: System.Threading.Thread.Thread(System.Threading.ThreadStart)
  type: Constructor
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 15
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>A thread does not begin executing when it is created. To schedule the thread for execution, call the <xref href=\"System.Threading.Thread.Start\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>Visual Basic users can omit the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> constructor when creating a thread. Use the <strong>AddressOf</strong> operator when passing your method for example <code>Dim t As New Thread(AddressOf ThreadProc)</code>. Visual Basic automatically calls the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> constructor.</p>\n"
  example:
  - "\n<p>The following code example shows how to create a thread that executes a static method.</p>System.Threading.Thread.ctor#1<p>The following code example shows how to create a thread that executes an instance method.</p>System.Threading.Thread.ctor2#1"
  syntax:
    content: public Thread(ThreadStart start)
    content.vb: Public Sub New(start As ThreadStart)
    parameters:
    - id: start
      type: System.Threading.ThreadStart
      description: "\n<p>A <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate that represents the methods to be invoked when this thread begins executing. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>start</em> parameter is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Threading.ThreadStart
    commentId: T:System.Threading.ThreadStart
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.CurrentThread
  commentId: P:System.Threading.Thread.CurrentThread
  id: CurrentThread
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: CurrentThread
  fullName: System.Threading.Thread.CurrentThread
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CurrentThread
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 16
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets the currently running thread.</p>\n"
  example:
  - "\n<p>The following example creates a task that in turn creates 20 child tasks. The application itself, as well as each task, calls the <code>ShowThreadInformation</code> method, which uses the <xref href=\"System.Threading.Thread.CurrentThread\" data-throw-if-not-resolved=\"false\"></xref> property  to display information about the thread on which it is running. </p>System.Threading.Thread.CurrentThread#1<p>Each child task generates 1 million random numbers between 1 and 1 million and returns their mean. The parent task calls the <xref href=\"System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])\" data-throw-if-not-resolved=\"false\"></xref> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means. </p><p>Note that while the application runs on a foreground thread, each task runs on a thread pool thread. </p>"
  syntax:
    content: public static Thread CurrentThread { get; }
    content.vb: Public Shared ReadOnly Property CurrentThread As Thread
    parameters: []
    return:
      type: System.Threading.Thread
      description: "\n<p>A <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> that is the representation of the currently running thread.</p>\n"
  modifiers.csharp:
  - public
  - static
  - get
  modifiers.vb:
  - Public
  - Shared
  - ReadOnly
- uid: System.Threading.Thread.IsAlive
  commentId: P:System.Threading.Thread.IsAlive
  id: IsAlive
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: IsAlive
  fullName: System.Threading.Thread.IsAlive
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAlive
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 17
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets a value indicating the execution status of the current thread.</p>\n"
  syntax:
    content: public bool IsAlive { get; }
    content.vb: Public ReadOnly Property IsAlive As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this thread has been started and has not terminated normally or aborted; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Thread.IsBackground
  commentId: P:System.Threading.Thread.IsBackground
  id: IsBackground
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: IsBackground
  fullName: System.Threading.Thread.IsBackground
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsBackground
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 18
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets or sets a value indicating whether or not a thread is a background thread.</p>\n"
  remarks: "\n<p>A thread is either a background thread or a foreground thread. Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating. Once all foreground threads belonging to a process have terminated, the common language runtime ends the process. Any remaining background threads are stopped and do not complete.</p>\n<p>By default, the following threads execute in the foreground (that is, their <xref href=\"System.Threading.Thread.IsBackground\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>false</strong>): </p>\n<ul><li>\n<p>The primary thread (or main application thread).</p>\n</li><li>\n<p>All threads created by calling a <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> class constructor. </p>\n</li></ul>\n<p>By default, the following threads execute in the background  (that is, their <xref href=\"System.Threading.Thread.IsBackground\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>): </p>\n<ul><li>\n<p>Thread pool threads, which are a pool of worker threads maintained by the runtime. You can configure the thread pool and schedule work on thread pool threads by using the <xref href=\"System.Threading.ThreadPool\" data-throw-if-not-resolved=\"false\"></xref> class. </p>\n<p>Task-based asynchronous operations automatically execute on thread pool threads. </p>\n</li><li>\n<p>All threads that enter the managed execution environment from unmanaged code. </p>\n</li></ul>\n"
  example:
  - "\n<p>The following example contrasts the behavior of foreground and background threads. It creates a foreground thread and a background thread. The foreground thread keeps the process running until completes its <strong>for</strong> loop and terminates. However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</p>System.Threading.Thread.IsBackground#1"
  syntax:
    content: public bool IsBackground { get; set; }
    content.vb: Public Property IsBackground As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if this thread is or is to become a background thread; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "\n<p>The thread is dead. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.ManagedThreadId
  commentId: P:System.Threading.Thread.ManagedThreadId
  id: ManagedThreadId
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: ManagedThreadId
  fullName: System.Threading.Thread.ManagedThreadId
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ManagedThreadId
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 19
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets a unique identifier for the current managed thread. </p>\n"
  remarks: "\n<p>A thread's <xref href=\"System.Threading.Thread.ManagedThreadId\" data-throw-if-not-resolved=\"false\"></xref> property value serves to uniquely identify that thread within its process. </p>\n<p>The value of the <xref href=\"System.Threading.Thread.ManagedThreadId\" data-throw-if-not-resolved=\"false\"></xref> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber. </p>\n"
  syntax:
    content: public int ManagedThreadId { get; }
    content.vb: Public ReadOnly Property ManagedThreadId As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>An integer that represents a unique identifier for this managed thread.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Thread.Name
  commentId: P:System.Threading.Thread.Name
  id: Name
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Name
  fullName: System.Threading.Thread.Name
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Name
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 20
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets or sets the name of the thread.</p>\n"
  remarks: "\n<p>This property is write-once. Because the default value of a thread's <xref href=\"System.Threading.Thread.Name\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>null</strong>, you can determine whether a name has already been explicitly assigned to the thread by comparing it with <strong>null</strong>. </p>\n<p>The string assigned to the <xref href=\"System.Threading.Thread.Name\" data-throw-if-not-resolved=\"false\"></xref> property can include any Unicode character.</p>\n"
  example:
  - "\n<p>The following example shows how to name a thread.</p>System.Threading.Thread.Name#1"
  syntax:
    content: public string Name { get; set; }
    content.vb: Public Property Name As String
    parameters: []
    return:
      type: System.String
      description: "\n<p>A string containing the name of the thread, or <strong>null</strong> if no name was set.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>A set operation was requested, but the <strong>Name</strong> property has already been set. </p>\n"
  modifiers.csharp:
  - public
  - get
  - set
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.ThreadState
  commentId: P:System.Threading.Thread.ThreadState
  id: ThreadState
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: ThreadState
  fullName: System.Threading.Thread.ThreadState
  type: Property
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ThreadState
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 21
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Gets a value containing the states of the current thread.</p>\n"
  remarks: "\n<p>The <xref href=\"System.Threading.Thread.ThreadState\" data-throw-if-not-resolved=\"false\"></xref> property provides more specific information than the <xref href=\"System.Threading.Thread.IsAlive\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>Thread state is only of interest in debugging scenarios. Your code should never use thread state to synchronize the activities of threads.</p>\n"
  example:
  - "\n<p>The following code example demonstrates accessing the <strong>ThreadState</strong> of a thread.</p>System.Threading.Thread.ThreadState#1"
  syntax:
    content: public ThreadState ThreadState { get; }
    content.vb: Public ReadOnly Property ThreadState As ThreadState
    parameters: []
    return:
      type: System.Threading.ThreadState
      description: "\n<p>One of the <xref href=\"System.Threading.ThreadState\" data-throw-if-not-resolved=\"false\"></xref> values indicating the state of the current thread. The initial value is <strong>Unstarted</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.Thread.Join
  commentId: M:System.Threading.Thread.Join
  id: Join
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Join()
  fullName: System.Threading.Thread.Join()
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Join
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 22
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <strong>SendMessage</strong> pumping.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method is called has completed. Use this method to ensure that a thread has been terminated. The caller will block indefinitely if the thread does not terminate. In the following example, the <code>Thread1</code> thread calls the <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method of <code>Thread2</code>, which causes <code>Thread1</code>  to block until <code>Thread2</code>  has completed. </p>System.Threading.Thread.Join#1<p>If the thread has already terminated when <see cref=\"Overload:System.Threading.Thread.Join\"></see> is called, the method returns immediately.</p><p>You should never call the <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method of the <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> object that represents the current thread from the current thread. This causes your app to hang because the current thread waits upon itself indefinitely, </p><p>This method changes the state of the calling thread to include <xref href=\"System.Threading.ThreadState.WaitSleepJoin\" data-throw-if-not-resolved=\"false\"></xref>. You cannot invoke <strong>Join</strong> on a thread that is in the <xref href=\"System.Threading.ThreadState.Unstarted\" data-throw-if-not-resolved=\"false\"></xref> state.</p>"
  syntax:
    content: public void Join()
    content.vb: Public Sub Join
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "\n<p>The caller attempted to join a thread that is in the <xref href=\"System.Threading.ThreadState.Unstarted\" data-throw-if-not-resolved=\"false\"></xref> state. </p>\n"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "\n<p>The thread is interrupted while waiting. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.Join(System.Int32)
  commentId: M:System.Threading.Thread.Join(System.Int32)
  id: Join(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Join(Int32)
  fullName: System.Threading.Thread.Join(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Join
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 23
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</p>\n"
  remarks: "\n<p>\n<xref href=\"System.Threading.Thread.Join(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method is called has completed or the time-out interval has elapsed. In the following example, the <code>Thread1</code> thread calls the <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method of <code>Thread2</code>, which causes <code>Thread1</code> to block either until <code>Thread2</code> has completed or 2 seconds have elapsed. </p>System.Threading.Thread.Join#2<p>If <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> is specified for the <em>millisecondsTimeout</em> parameter, this method behaves identically to the <xref href=\"System.Threading.Thread.Join\" data-throw-if-not-resolved=\"false\"></xref> method overload, except for the return value.</p><p>If the thread has already terminated when <see cref=\"Overload:System.Threading.Thread.Join\"></see> is called, the method returns immediately.</p><p>This method changes the state of the calling thread to include <xref href=\"System.Threading.ThreadState.WaitSleepJoin\" data-throw-if-not-resolved=\"false\"></xref>. You cannot invoke <strong>Join</strong> on a thread that is in the <xref href=\"System.Threading.ThreadState.Unstarted\" data-throw-if-not-resolved=\"false\"></xref> state.</p>"
  syntax:
    content: public bool Join(int millisecondsTimeout)
    content.vb: Public Function Join(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait for the thread to terminate. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the thread has terminated; <strong>false</strong> if the thread has not terminated after the amount of time specified by the <em>millisecondsTimeout</em> parameter has elapsed.</p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>millisecondsTimeout</em> is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> in milliseconds. </p>\n"
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "\n<p>The thread has not been started. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.Sleep(System.Int32)
  commentId: M:System.Threading.Thread.Sleep(System.Int32)
  id: Sleep(System.Int32)
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Sleep(Int32)
  fullName: System.Threading.Thread.Sleep(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sleep
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 24
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Suspends the current thread for the specified number of milliseconds.</p>\n"
  remarks: "\n<p>The thread will not be scheduled for execution by the operating system for the amount of time specified. This method changes the state of the thread to include <xref href=\"System.Threading.ThreadState.WaitSleepJoin\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You can specify <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> for the <em>millisecondsTimeout</em> parameter to suspend the thread indefinitely. However, we recommend that you use other <xref href=\"System.Threading\" data-throw-if-not-resolved=\"false\"></xref> classes such as <xref href=\"System.Threading.Mutex\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.Monitor\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> instead to sychronize threads or manage resources.</p>\n<p>The system clock ticks at a specific rate called the clock resolution. The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks. For more information on clock resolution and the waiting time, see the <see href=\"http://msdn.microsoft.com/library/windows/desktop/ms686298.aspx\">Sleep function</see> topic. This method calls the <see href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms686298.aspx\">Sleep function</see> from the Windows system APIs.</p>\n<p>This method does not perform standard COM and SendMessage pumping.</p>\n<p>If you need to sleep on a thread that has <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <see cref=\"Overload:System.Threading.Thread.Join\"></see> method that specifies a timeout interval.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Threading.Thread.Sleep(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to block the application's main thread.</p>Thread.Sleep#1"
  syntax:
    content: public static void Sleep(int millisecondsTimeout)
    content.vb: Public Shared Sub Sleep(millisecondsTimeout As Integer)
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds for which the thread is suspended. If the value of the <em>millisecondsTimeout</em> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run. If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The time-out value is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Thread.Sleep(System.TimeSpan)
  commentId: M:System.Threading.Thread.Sleep(System.TimeSpan)
  id: Sleep(System.TimeSpan)
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Sleep(TimeSpan)
  fullName: System.Threading.Thread.Sleep(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Sleep
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 25
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Suspends the current thread for the specified amount of time.</p>\n"
  remarks: "\n<p>The thread will not be scheduled for execution by the operating system for the amount of time specified. This method changes the state of the thread to include <xref href=\"System.Threading.ThreadState.WaitSleepJoin\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>You can specify <xref href=\"System.Threading.Timeout.InfiniteTimeSpan\" data-throw-if-not-resolved=\"false\"></xref> for the <em>timeout</em> parameter to suspend the thread indefinitely. However, we recommend that you use other <xref href=\"System.Threading\" data-throw-if-not-resolved=\"false\"></xref> classes such as <xref href=\"System.Threading.Mutex\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.Monitor\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Threading.EventWaitHandle\" data-throw-if-not-resolved=\"false\"></xref>, or <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> instead to sychronize threads or manage resources.</p>\n<p>This overload of <see cref=\"Overload:System.Threading.Thread.Sleep\"></see> uses the total number of whole milliseconds in <em>timeout</em>. Fractional milliseconds are discarded.</p>\n<p>This method does not perform standard COM and SendMessage pumping.</p>\n<p>If you need to sleep on a thread that has <xref href=\"System.STAThreadAttribute\" data-throw-if-not-resolved=\"false\"></xref>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <see cref=\"Overload:System.Threading.Thread.Join\"></see> method that specifies a timeout interval.</p>\n"
  example:
  - "\n<p>The following example uses the <xref href=\"System.Threading.Thread.Sleep(System.TimeSpan)\" data-throw-if-not-resolved=\"false\"></xref> method overload to block the application's main thread five times, for two seconds each time.</p>Thread.Sleep_TimeSpan#1"
  syntax:
    content: public static void Sleep(TimeSpan timeout)
    content.vb: Public Shared Sub Sleep(timeout As TimeSpan)
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>The amount of time for which the thread is suspended. If the value of the <em>millisecondsTimeout</em> argument is <xref href=\"System.TimeSpan.Zero\" data-throw-if-not-resolved=\"false\"></xref>, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run. If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> in milliseconds, or is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Thread.Start
  commentId: M:System.Threading.Thread.Start
  id: Start
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Start()
  fullName: System.Threading.Thread.Start()
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 26
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Causes the operating system to change the state of the current instance to <xref href=\"System.Threading.ThreadState.Running\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Once a thread is in the <xref href=\"System.Threading.ThreadState.Running\" data-throw-if-not-resolved=\"false\"></xref> state, the operating system can schedule it for execution. The thread begins executing at the first line of the method represented by the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate supplied to the thread constructor. Note that the call to <xref href=\"System.Threading.Thread.Start\" data-throw-if-not-resolved=\"false\"></xref> does not block the calling thread. </p>\n<p>If this overload is used with a thread created using a <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate, <strong>null</strong> is passed to the method executed by the thread.</p>\n<p>Once the thread terminates, it cannot be restarted with another call to <strong>Start</strong>.</p>\n"
  example:
  - "\n<p>The following example creates and starts a thread.</p>ThreadStart#1"
  syntax:
    content: public void Start()
    content.vb: Public Sub Start
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "\n<p>The thread has already been started. </p>\n"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is not enough memory available to start this thread. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Thread.Start(System.Object)
  commentId: M:System.Threading.Thread.Start(System.Object)
  id: Start(System.Object)
  parent: System.Threading.Thread
  langs:
  - csharp
  - vb
  name: Start(Object)
  fullName: System.Threading.Thread.Start(System.Object)
  type: Method
  source:
    remote:
      path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Start
    path: src/System.Threading.Thread/ref/System.Threading.Thread.cs
    startLine: 27
  assemblies:
  - System.Threading.Thread
  namespace: System.Threading
  summary: "\n<p>Causes the operating system to change the state of the current instance to <xref href=\"System.Threading.ThreadState.Running\" data-throw-if-not-resolved=\"false\"></xref>, and optionally supplies an object containing data to be used by the method the thread executes.</p>\n"
  remarks: "\n<p>Once a thread is in the <xref href=\"System.Threading.ThreadState.Running\" data-throw-if-not-resolved=\"false\"></xref> state, the operating system can schedule it for execution. The thread begins executing at the first line of the method represented by the <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate supplied to the thread constructor. Note that the call to <xref href=\"System.Threading.Thread.Start(System.Object)\" data-throw-if-not-resolved=\"false\"></xref> does not block the calling thread.</p>\n<p>Once the thread terminates, it cannot be restarted with another call to <strong>Start</strong>.</p>\n<p>This overload and the <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload. A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object. For more information, see Creating Threads and Passing Data at Start Time.</p>\n"
  example:
  - "\n<p>The following example creates a <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate with a static method and an instance method. </p>System.Threading.ParameterizedThreadStart#1"
  syntax:
    content: public void Start(object parameter)
    content.vb: Public Sub Start(parameter As Object)
    parameters:
    - id: parameter
      type: System.Object
      description: "\n<p>An object that contains data to be used by the method the thread executes.</p>\n"
  exceptions:
  - type: System.Threading.ThreadStateException
    commentId: T:System.Threading.ThreadStateException
    description: "\n<p>The thread has already been started. </p>\n"
  - type: System.OutOfMemoryException
    commentId: T:System.OutOfMemoryException
    description: "\n<p>There is not enough memory available to start this thread. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>This thread was created using a <xref href=\"System.Threading.ThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate instead of a <xref href=\"System.Threading.ParameterizedThreadStart\" data-throw-if-not-resolved=\"false\"></xref> delegate.</p>\n"
  seealso:
  - type: System.Threading.ParameterizedThreadStart
    commentId: T:System.Threading.ParameterizedThreadStart
  - type: System.AppDomain
    commentId: T:System.AppDomain
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Threading.ParameterizedThreadStart
  parent: System.Threading
  isExternal: false
  name: ParameterizedThreadStart
  fullName: System.Threading.ParameterizedThreadStart
- uid: System.Threading.ThreadStart
  parent: System.Threading
  isExternal: false
  name: ThreadStart
  fullName: System.Threading.ThreadStart
- uid: System.Threading.Thread
  parent: System.Threading
  isExternal: false
  name: Thread
  fullName: System.Threading.Thread
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Threading.ThreadState
  parent: System.Threading
  isExternal: false
  name: ThreadState
  fullName: System.Threading.ThreadState
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.Threading.ThreadStateException
  isExternal: false
  name: ThreadStateException
  fullName: System.Threading.ThreadStateException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.Threading.ThreadInterruptedException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.OutOfMemoryException
  isExternal: false
  name: OutOfMemoryException
  fullName: System.OutOfMemoryException
